var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, {get: all2[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// build/_snowpack/pkg/moment.js
var require_moment = __commonJS((exports2, module2) => {
  __markAsModule(exports2);
  __export(exports2, {
    default: () => moment_default
  });
  //! moment.js
  //! version : 2.29.1
  //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
  //! license : MIT
  //! momentjs.com
  var hookCallback;
  function hooks() {
    return hookCallback.apply(null, arguments);
  }
  function setHookCallback(callback) {
    hookCallback = callback;
  }
  function isArray4(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
  }
  function isObject4(input) {
    return input != null && Object.prototype.toString.call(input) === "[object Object]";
  }
  function hasOwnProp(a2, b3) {
    return Object.prototype.hasOwnProperty.call(a2, b3);
  }
  function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
      return Object.getOwnPropertyNames(obj).length === 0;
    } else {
      var k3;
      for (k3 in obj) {
        if (hasOwnProp(obj, k3)) {
          return false;
        }
      }
      return true;
    }
  }
  function isUndefined4(input) {
    return input === void 0;
  }
  function isNumber2(input) {
    return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
  }
  function isDate3(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
  }
  function map3(arr, fn) {
    var res = [], i3;
    for (i3 = 0; i3 < arr.length; ++i3) {
      res.push(fn(arr[i3], i3));
    }
    return res;
  }
  function extend3(a2, b3) {
    for (var i3 in b3) {
      if (hasOwnProp(b3, i3)) {
        a2[i3] = b3[i3];
      }
    }
    if (hasOwnProp(b3, "toString")) {
      a2.toString = b3.toString;
    }
    if (hasOwnProp(b3, "valueOf")) {
      a2.valueOf = b3.valueOf;
    }
    return a2;
  }
  function createUTC(input, format2, locale2, strict) {
    return createLocalOrUTC(input, format2, locale2, strict, true).utc();
  }
  function defaultParsingFlags() {
    return {
      empty: false,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: false,
      invalidEra: null,
      invalidMonth: null,
      invalidFormat: false,
      userInvalidated: false,
      iso: false,
      parsedDateParts: [],
      era: null,
      meridiem: null,
      rfc2822: false,
      weekdayMismatch: false
    };
  }
  function getParsingFlags(m3) {
    if (m3._pf == null) {
      m3._pf = defaultParsingFlags();
    }
    return m3._pf;
  }
  var some;
  if (Array.prototype.some) {
    some = Array.prototype.some;
  } else {
    some = function(fun) {
      var t4 = Object(this), len2 = t4.length >>> 0, i3;
      for (i3 = 0; i3 < len2; i3++) {
        if (i3 in t4 && fun.call(this, t4[i3], i3, t4)) {
          return true;
        }
      }
      return false;
    };
  }
  function isValid(m3) {
    if (m3._isValid == null) {
      var flags2 = getParsingFlags(m3), parsedParts = some.call(flags2.parsedDateParts, function(i3) {
        return i3 != null;
      }), isNowValid = !isNaN(m3._d.getTime()) && flags2.overflow < 0 && !flags2.empty && !flags2.invalidEra && !flags2.invalidMonth && !flags2.invalidWeekday && !flags2.weekdayMismatch && !flags2.nullInput && !flags2.invalidFormat && !flags2.userInvalidated && (!flags2.meridiem || flags2.meridiem && parsedParts);
      if (m3._strict) {
        isNowValid = isNowValid && flags2.charsLeftOver === 0 && flags2.unusedTokens.length === 0 && flags2.bigHour === void 0;
      }
      if (Object.isFrozen == null || !Object.isFrozen(m3)) {
        m3._isValid = isNowValid;
      } else {
        return isNowValid;
      }
    }
    return m3._isValid;
  }
  function createInvalid(flags2) {
    var m3 = createUTC(NaN);
    if (flags2 != null) {
      extend3(getParsingFlags(m3), flags2);
    } else {
      getParsingFlags(m3).userInvalidated = true;
    }
    return m3;
  }
  var momentProperties = hooks.momentProperties = [];
  var updateInProgress = false;
  function copyConfig(to2, from2) {
    var i3, prop, val;
    if (!isUndefined4(from2._isAMomentObject)) {
      to2._isAMomentObject = from2._isAMomentObject;
    }
    if (!isUndefined4(from2._i)) {
      to2._i = from2._i;
    }
    if (!isUndefined4(from2._f)) {
      to2._f = from2._f;
    }
    if (!isUndefined4(from2._l)) {
      to2._l = from2._l;
    }
    if (!isUndefined4(from2._strict)) {
      to2._strict = from2._strict;
    }
    if (!isUndefined4(from2._tzm)) {
      to2._tzm = from2._tzm;
    }
    if (!isUndefined4(from2._isUTC)) {
      to2._isUTC = from2._isUTC;
    }
    if (!isUndefined4(from2._offset)) {
      to2._offset = from2._offset;
    }
    if (!isUndefined4(from2._pf)) {
      to2._pf = getParsingFlags(from2);
    }
    if (!isUndefined4(from2._locale)) {
      to2._locale = from2._locale;
    }
    if (momentProperties.length > 0) {
      for (i3 = 0; i3 < momentProperties.length; i3++) {
        prop = momentProperties[i3];
        val = from2[prop];
        if (!isUndefined4(val)) {
          to2[prop] = val;
        }
      }
    }
    return to2;
  }
  function Moment(config2) {
    copyConfig(this, config2);
    this._d = new Date(config2._d != null ? config2._d.getTime() : NaN);
    if (!this.isValid()) {
      this._d = new Date(NaN);
    }
    if (updateInProgress === false) {
      updateInProgress = true;
      hooks.updateOffset(this);
      updateInProgress = false;
    }
  }
  function isMoment(obj) {
    return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
  }
  function warn3(msg) {
    if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
      console.warn("Deprecation warning: " + msg);
    }
  }
  function deprecate(msg, fn) {
    var firstTime = true;
    return extend3(function() {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(null, msg);
      }
      if (firstTime) {
        var args = [], arg, i3, key;
        for (i3 = 0; i3 < arguments.length; i3++) {
          arg = "";
          if (typeof arguments[i3] === "object") {
            arg += "\n[" + i3 + "] ";
            for (key in arguments[0]) {
              if (hasOwnProp(arguments[0], key)) {
                arg += key + ": " + arguments[0][key] + ", ";
              }
            }
            arg = arg.slice(0, -2);
          } else {
            arg = arguments[i3];
          }
          args.push(arg);
        }
        warn3(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
        firstTime = false;
      }
      return fn.apply(this, arguments);
    }, fn);
  }
  var deprecations = {};
  function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
      warn3(msg);
      deprecations[name] = true;
    }
  }
  hooks.suppressDeprecationWarnings = false;
  hooks.deprecationHandler = null;
  function isFunction5(input) {
    return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
  }
  function set3(config2) {
    var prop, i3;
    for (i3 in config2) {
      if (hasOwnProp(config2, i3)) {
        prop = config2[i3];
        if (isFunction5(prop)) {
          this[i3] = prop;
        } else {
          this["_" + i3] = prop;
        }
      }
    }
    this._config = config2;
    this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
  }
  function mergeConfigs(parentConfig, childConfig) {
    var res = extend3({}, parentConfig), prop;
    for (prop in childConfig) {
      if (hasOwnProp(childConfig, prop)) {
        if (isObject4(parentConfig[prop]) && isObject4(childConfig[prop])) {
          res[prop] = {};
          extend3(res[prop], parentConfig[prop]);
          extend3(res[prop], childConfig[prop]);
        } else if (childConfig[prop] != null) {
          res[prop] = childConfig[prop];
        } else {
          delete res[prop];
        }
      }
    }
    for (prop in parentConfig) {
      if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject4(parentConfig[prop])) {
        res[prop] = extend3({}, res[prop]);
      }
    }
    return res;
  }
  function Locale(config2) {
    if (config2 != null) {
      this.set(config2);
    }
  }
  var keys2;
  if (Object.keys) {
    keys2 = Object.keys;
  } else {
    keys2 = function(obj) {
      var i3, res = [];
      for (i3 in obj) {
        if (hasOwnProp(obj, i3)) {
          res.push(i3);
        }
      }
      return res;
    };
  }
  var defaultCalendar = {
    sameDay: "[Today at] LT",
    nextDay: "[Tomorrow at] LT",
    nextWeek: "dddd [at] LT",
    lastDay: "[Yesterday at] LT",
    lastWeek: "[Last] dddd [at] LT",
    sameElse: "L"
  };
  function calendar(key, mom, now4) {
    var output2 = this._calendar[key] || this._calendar["sameElse"];
    return isFunction5(output2) ? output2.call(mom, now4) : output2;
  }
  function zeroFill(number, targetLength, forceSign) {
    var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
    return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
  }
  var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
  var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
  var formatFunctions = {};
  var formatTokenFunctions = {};
  function addFormatToken(token3, padded, ordinal2, callback) {
    var func = callback;
    if (typeof callback === "string") {
      func = function() {
        return this[callback]();
      };
    }
    if (token3) {
      formatTokenFunctions[token3] = func;
    }
    if (padded) {
      formatTokenFunctions[padded[0]] = function() {
        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
      };
    }
    if (ordinal2) {
      formatTokenFunctions[ordinal2] = function() {
        return this.localeData().ordinal(func.apply(this, arguments), token3);
      };
    }
  }
  function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
      return input.replace(/^\[|\]$/g, "");
    }
    return input.replace(/\\/g, "");
  }
  function makeFormatFunction(format2) {
    var array2 = format2.match(formattingTokens), i3, length;
    for (i3 = 0, length = array2.length; i3 < length; i3++) {
      if (formatTokenFunctions[array2[i3]]) {
        array2[i3] = formatTokenFunctions[array2[i3]];
      } else {
        array2[i3] = removeFormattingTokens(array2[i3]);
      }
    }
    return function(mom) {
      var output2 = "", i4;
      for (i4 = 0; i4 < length; i4++) {
        output2 += isFunction5(array2[i4]) ? array2[i4].call(mom, format2) : array2[i4];
      }
      return output2;
    };
  }
  function formatMoment(m3, format2) {
    if (!m3.isValid()) {
      return m3.localeData().invalidDate();
    }
    format2 = expandFormat(format2, m3.localeData());
    formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
    return formatFunctions[format2](m3);
  }
  function expandFormat(format2, locale2) {
    var i3 = 5;
    function replaceLongDateFormatTokens(input) {
      return locale2.longDateFormat(input) || input;
    }
    localFormattingTokens.lastIndex = 0;
    while (i3 >= 0 && localFormattingTokens.test(format2)) {
      format2 = format2.replace(localFormattingTokens, replaceLongDateFormatTokens);
      localFormattingTokens.lastIndex = 0;
      i3 -= 1;
    }
    return format2;
  }
  var defaultLongDateFormat = {
    LTS: "h:mm:ss A",
    LT: "h:mm A",
    L: "MM/DD/YYYY",
    LL: "MMMM D, YYYY",
    LLL: "MMMM D, YYYY h:mm A",
    LLLL: "dddd, MMMM D, YYYY h:mm A"
  };
  function longDateFormat(key) {
    var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
    if (format2 || !formatUpper) {
      return format2;
    }
    this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
      if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
        return tok.slice(1);
      }
      return tok;
    }).join("");
    return this._longDateFormat[key];
  }
  var defaultInvalidDate = "Invalid date";
  function invalidDate() {
    return this._invalidDate;
  }
  var defaultOrdinal = "%d";
  var defaultDayOfMonthOrdinalParse = /\d{1,2}/;
  function ordinal(number) {
    return this._ordinal.replace("%d", number);
  }
  var defaultRelativeTime = {
    future: "in %s",
    past: "%s ago",
    s: "a few seconds",
    ss: "%d seconds",
    m: "a minute",
    mm: "%d minutes",
    h: "an hour",
    hh: "%d hours",
    d: "a day",
    dd: "%d days",
    w: "a week",
    ww: "%d weeks",
    M: "a month",
    MM: "%d months",
    y: "a year",
    yy: "%d years"
  };
  function relativeTime(number, withoutSuffix, string, isFuture) {
    var output2 = this._relativeTime[string];
    return isFunction5(output2) ? output2(number, withoutSuffix, string, isFuture) : output2.replace(/%d/i, number);
  }
  function pastFuture(diff2, output2) {
    var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
    return isFunction5(format2) ? format2(output2) : format2.replace(/%s/i, output2);
  }
  var aliases = {};
  function addUnitAlias(unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
  }
  function normalizeUnits(units) {
    return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
  }
  function normalizeObjectUnits(inputObject) {
    var normalizedInput = {}, normalizedProp, prop;
    for (prop in inputObject) {
      if (hasOwnProp(inputObject, prop)) {
        normalizedProp = normalizeUnits(prop);
        if (normalizedProp) {
          normalizedInput[normalizedProp] = inputObject[prop];
        }
      }
    }
    return normalizedInput;
  }
  var priorities = {};
  function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
  }
  function getPrioritizedUnits(unitsObj) {
    var units = [], u;
    for (u in unitsObj) {
      if (hasOwnProp(unitsObj, u)) {
        units.push({unit: u, priority: priorities[u]});
      }
    }
    units.sort(function(a2, b3) {
      return a2.priority - b3.priority;
    });
    return units;
  }
  function isLeapYear(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  }
  function absFloor(number) {
    if (number < 0) {
      return Math.ceil(number) || 0;
    } else {
      return Math.floor(number);
    }
  }
  function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion, value = 0;
    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
      value = absFloor(coercedNumber);
    }
    return value;
  }
  function makeGetSet(unit, keepTime) {
    return function(value) {
      if (value != null) {
        set$12(this, unit, value);
        hooks.updateOffset(this, keepTime);
        return this;
      } else {
        return get5(this, unit);
      }
    };
  }
  function get5(mom, unit) {
    return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
  }
  function set$12(mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
      if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
        value = toInt(value);
        mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
      } else {
        mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
      }
    }
  }
  function stringGet(units) {
    units = normalizeUnits(units);
    if (isFunction5(this[units])) {
      return this[units]();
    }
    return this;
  }
  function stringSet(units, value) {
    if (typeof units === "object") {
      units = normalizeObjectUnits(units);
      var prioritized = getPrioritizedUnits(units), i3;
      for (i3 = 0; i3 < prioritized.length; i3++) {
        this[prioritized[i3].unit](units[prioritized[i3].unit]);
      }
    } else {
      units = normalizeUnits(units);
      if (isFunction5(this[units])) {
        return this[units](value);
      }
    }
    return this;
  }
  var match1 = /\d/;
  var match2 = /\d\d/;
  var match3 = /\d{3}/;
  var match4 = /\d{4}/;
  var match6 = /[+-]?\d{6}/;
  var match1to2 = /\d\d?/;
  var match3to4 = /\d\d\d\d?/;
  var match5to6 = /\d\d\d\d\d\d?/;
  var match1to3 = /\d{1,3}/;
  var match1to4 = /\d{1,4}/;
  var match1to6 = /[+-]?\d{1,6}/;
  var matchUnsigned = /\d+/;
  var matchSigned = /[+-]?\d+/;
  var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
  var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
  var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
  var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
  var regexes;
  regexes = {};
  function addRegexToken(token3, regex, strictRegex) {
    regexes[token3] = isFunction5(regex) ? regex : function(isStrict, localeData2) {
      return isStrict && strictRegex ? strictRegex : regex;
    };
  }
  function getParseRegexForToken(token3, config2) {
    if (!hasOwnProp(regexes, token3)) {
      return new RegExp(unescapeFormat(token3));
    }
    return regexes[token3](config2._strict, config2._locale);
  }
  function unescapeFormat(s2) {
    return regexEscape2(s2.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p22, p3, p4) {
      return p1 || p22 || p3 || p4;
    }));
  }
  function regexEscape2(s2) {
    return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  var tokens = {};
  function addParseToken(token3, callback) {
    var i3, func = callback;
    if (typeof token3 === "string") {
      token3 = [token3];
    }
    if (isNumber2(callback)) {
      func = function(input, array2) {
        array2[callback] = toInt(input);
      };
    }
    for (i3 = 0; i3 < token3.length; i3++) {
      tokens[token3[i3]] = func;
    }
  }
  function addWeekParseToken(token3, callback) {
    addParseToken(token3, function(input, array2, config2, token4) {
      config2._w = config2._w || {};
      callback(input, config2._w, config2, token4);
    });
  }
  function addTimeToArrayFromToken(token3, input, config2) {
    if (input != null && hasOwnProp(tokens, token3)) {
      tokens[token3](input, config2._a, config2, token3);
    }
  }
  var YEAR = 0;
  var MONTH = 1;
  var DATE = 2;
  var HOUR = 3;
  var MINUTE = 4;
  var SECOND = 5;
  var MILLISECOND = 6;
  var WEEK = 7;
  var WEEKDAY = 8;
  function mod(n4, x3) {
    return (n4 % x3 + x3) % x3;
  }
  var indexOf;
  if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
  } else {
    indexOf = function(o) {
      var i3;
      for (i3 = 0; i3 < this.length; ++i3) {
        if (this[i3] === o) {
          return i3;
        }
      }
      return -1;
    };
  }
  function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
      return NaN;
    }
    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
  }
  addFormatToken("M", ["MM", 2], "Mo", function() {
    return this.month() + 1;
  });
  addFormatToken("MMM", 0, 0, function(format2) {
    return this.localeData().monthsShort(this, format2);
  });
  addFormatToken("MMMM", 0, 0, function(format2) {
    return this.localeData().months(this, format2);
  });
  addUnitAlias("month", "M");
  addUnitPriority("month", 8);
  addRegexToken("M", match1to2);
  addRegexToken("MM", match1to2, match2);
  addRegexToken("MMM", function(isStrict, locale2) {
    return locale2.monthsShortRegex(isStrict);
  });
  addRegexToken("MMMM", function(isStrict, locale2) {
    return locale2.monthsRegex(isStrict);
  });
  addParseToken(["M", "MM"], function(input, array2) {
    array2[MONTH] = toInt(input) - 1;
  });
  addParseToken(["MMM", "MMMM"], function(input, array2, config2, token3) {
    var month = config2._locale.monthsParse(input, token3, config2._strict);
    if (month != null) {
      array2[MONTH] = month;
    } else {
      getParsingFlags(config2).invalidMonth = input;
    }
  });
  var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_");
  var defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
  var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
  var defaultMonthsShortRegex = matchWord;
  var defaultMonthsRegex = matchWord;
  function localeMonths(m3, format2) {
    if (!m3) {
      return isArray4(this._months) ? this._months : this._months["standalone"];
    }
    return isArray4(this._months) ? this._months[m3.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m3.month()];
  }
  function localeMonthsShort(m3, format2) {
    if (!m3) {
      return isArray4(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
    }
    return isArray4(this._monthsShort) ? this._monthsShort[m3.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m3.month()];
  }
  function handleStrictParse(monthName, format2, strict) {
    var i3, ii2, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
      for (i3 = 0; i3 < 12; ++i3) {
        mom = createUTC([2e3, i3]);
        this._shortMonthsParse[i3] = this.monthsShort(mom, "").toLocaleLowerCase();
        this._longMonthsParse[i3] = this.months(mom, "").toLocaleLowerCase();
      }
    }
    if (strict) {
      if (format2 === "MMM") {
        ii2 = indexOf.call(this._shortMonthsParse, llc);
        return ii2 !== -1 ? ii2 : null;
      } else {
        ii2 = indexOf.call(this._longMonthsParse, llc);
        return ii2 !== -1 ? ii2 : null;
      }
    } else {
      if (format2 === "MMM") {
        ii2 = indexOf.call(this._shortMonthsParse, llc);
        if (ii2 !== -1) {
          return ii2;
        }
        ii2 = indexOf.call(this._longMonthsParse, llc);
        return ii2 !== -1 ? ii2 : null;
      } else {
        ii2 = indexOf.call(this._longMonthsParse, llc);
        if (ii2 !== -1) {
          return ii2;
        }
        ii2 = indexOf.call(this._shortMonthsParse, llc);
        return ii2 !== -1 ? ii2 : null;
      }
    }
  }
  function localeMonthsParse(monthName, format2, strict) {
    var i3, mom, regex;
    if (this._monthsParseExact) {
      return handleStrictParse.call(this, monthName, format2, strict);
    }
    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
    }
    for (i3 = 0; i3 < 12; i3++) {
      mom = createUTC([2e3, i3]);
      if (strict && !this._longMonthsParse[i3]) {
        this._longMonthsParse[i3] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
        this._shortMonthsParse[i3] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
      }
      if (!strict && !this._monthsParse[i3]) {
        regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
        this._monthsParse[i3] = new RegExp(regex.replace(".", ""), "i");
      }
      if (strict && format2 === "MMMM" && this._longMonthsParse[i3].test(monthName)) {
        return i3;
      } else if (strict && format2 === "MMM" && this._shortMonthsParse[i3].test(monthName)) {
        return i3;
      } else if (!strict && this._monthsParse[i3].test(monthName)) {
        return i3;
      }
    }
  }
  function setMonth(mom, value) {
    var dayOfMonth;
    if (!mom.isValid()) {
      return mom;
    }
    if (typeof value === "string") {
      if (/^\d+$/.test(value)) {
        value = toInt(value);
      } else {
        value = mom.localeData().monthsParse(value);
        if (!isNumber2(value)) {
          return mom;
        }
      }
    }
    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
    return mom;
  }
  function getSetMonth(value) {
    if (value != null) {
      setMonth(this, value);
      hooks.updateOffset(this, true);
      return this;
    } else {
      return get5(this, "Month");
    }
  }
  function getDaysInMonth() {
    return daysInMonth(this.year(), this.month());
  }
  function monthsShortRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, "_monthsRegex")) {
        computeMonthsParse.call(this);
      }
      if (isStrict) {
        return this._monthsShortStrictRegex;
      } else {
        return this._monthsShortRegex;
      }
    } else {
      if (!hasOwnProp(this, "_monthsShortRegex")) {
        this._monthsShortRegex = defaultMonthsShortRegex;
      }
      return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
    }
  }
  function monthsRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, "_monthsRegex")) {
        computeMonthsParse.call(this);
      }
      if (isStrict) {
        return this._monthsStrictRegex;
      } else {
        return this._monthsRegex;
      }
    } else {
      if (!hasOwnProp(this, "_monthsRegex")) {
        this._monthsRegex = defaultMonthsRegex;
      }
      return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
    }
  }
  function computeMonthsParse() {
    function cmpLenRev(a2, b3) {
      return b3.length - a2.length;
    }
    var shortPieces = [], longPieces = [], mixedPieces = [], i3, mom;
    for (i3 = 0; i3 < 12; i3++) {
      mom = createUTC([2e3, i3]);
      shortPieces.push(this.monthsShort(mom, ""));
      longPieces.push(this.months(mom, ""));
      mixedPieces.push(this.months(mom, ""));
      mixedPieces.push(this.monthsShort(mom, ""));
    }
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i3 = 0; i3 < 12; i3++) {
      shortPieces[i3] = regexEscape2(shortPieces[i3]);
      longPieces[i3] = regexEscape2(longPieces[i3]);
    }
    for (i3 = 0; i3 < 24; i3++) {
      mixedPieces[i3] = regexEscape2(mixedPieces[i3]);
    }
    this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
    this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
  }
  addFormatToken("Y", 0, 0, function() {
    var y4 = this.year();
    return y4 <= 9999 ? zeroFill(y4, 4) : "+" + y4;
  });
  addFormatToken(0, ["YY", 2], 0, function() {
    return this.year() % 100;
  });
  addFormatToken(0, ["YYYY", 4], 0, "year");
  addFormatToken(0, ["YYYYY", 5], 0, "year");
  addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
  addUnitAlias("year", "y");
  addUnitPriority("year", 1);
  addRegexToken("Y", matchSigned);
  addRegexToken("YY", match1to2, match2);
  addRegexToken("YYYY", match1to4, match4);
  addRegexToken("YYYYY", match1to6, match6);
  addRegexToken("YYYYYY", match1to6, match6);
  addParseToken(["YYYYY", "YYYYYY"], YEAR);
  addParseToken("YYYY", function(input, array2) {
    array2[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
  });
  addParseToken("YY", function(input, array2) {
    array2[YEAR] = hooks.parseTwoDigitYear(input);
  });
  addParseToken("Y", function(input, array2) {
    array2[YEAR] = parseInt(input, 10);
  });
  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  }
  hooks.parseTwoDigitYear = function(input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
  };
  var getSetYear = makeGetSet("FullYear", true);
  function getIsLeapYear() {
    return isLeapYear(this.year());
  }
  function createDate(y4, m3, d3, h3, M2, s2, ms) {
    var date;
    if (y4 < 100 && y4 >= 0) {
      date = new Date(y4 + 400, m3, d3, h3, M2, s2, ms);
      if (isFinite(date.getFullYear())) {
        date.setFullYear(y4);
      }
    } else {
      date = new Date(y4, m3, d3, h3, M2, s2, ms);
    }
    return date;
  }
  function createUTCDate(y4) {
    var date, args;
    if (y4 < 100 && y4 >= 0) {
      args = Array.prototype.slice.call(arguments);
      args[0] = y4 + 400;
      date = new Date(Date.UTC.apply(null, args));
      if (isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y4);
      }
    } else {
      date = new Date(Date.UTC.apply(null, arguments));
    }
    return date;
  }
  function firstWeekOffset(year, dow, doy) {
    var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
    return -fwdlw + fwd - 1;
  }
  function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
    if (dayOfYear <= 0) {
      resYear = year - 1;
      resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
      resYear = year + 1;
      resDayOfYear = dayOfYear - daysInYear(year);
    } else {
      resYear = year;
      resDayOfYear = dayOfYear;
    }
    return {
      year: resYear,
      dayOfYear: resDayOfYear
    };
  }
  function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
    if (week < 1) {
      resYear = mom.year() - 1;
      resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
      resWeek = week - weeksInYear(mom.year(), dow, doy);
      resYear = mom.year() + 1;
    } else {
      resYear = mom.year();
      resWeek = week;
    }
    return {
      week: resWeek,
      year: resYear
    };
  }
  function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
  }
  addFormatToken("w", ["ww", 2], "wo", "week");
  addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
  addUnitAlias("week", "w");
  addUnitAlias("isoWeek", "W");
  addUnitPriority("week", 5);
  addUnitPriority("isoWeek", 5);
  addRegexToken("w", match1to2);
  addRegexToken("ww", match1to2, match2);
  addRegexToken("W", match1to2);
  addRegexToken("WW", match1to2, match2);
  addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config2, token3) {
    week[token3.substr(0, 1)] = toInt(input);
  });
  function localeWeek(mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
  }
  var defaultLocaleWeek = {
    dow: 0,
    doy: 6
  };
  function localeFirstDayOfWeek() {
    return this._week.dow;
  }
  function localeFirstDayOfYear() {
    return this._week.doy;
  }
  function getSetWeek(input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, "d");
  }
  function getSetISOWeek(input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, "d");
  }
  addFormatToken("d", 0, "do", "day");
  addFormatToken("dd", 0, 0, function(format2) {
    return this.localeData().weekdaysMin(this, format2);
  });
  addFormatToken("ddd", 0, 0, function(format2) {
    return this.localeData().weekdaysShort(this, format2);
  });
  addFormatToken("dddd", 0, 0, function(format2) {
    return this.localeData().weekdays(this, format2);
  });
  addFormatToken("e", 0, 0, "weekday");
  addFormatToken("E", 0, 0, "isoWeekday");
  addUnitAlias("day", "d");
  addUnitAlias("weekday", "e");
  addUnitAlias("isoWeekday", "E");
  addUnitPriority("day", 11);
  addUnitPriority("weekday", 11);
  addUnitPriority("isoWeekday", 11);
  addRegexToken("d", match1to2);
  addRegexToken("e", match1to2);
  addRegexToken("E", match1to2);
  addRegexToken("dd", function(isStrict, locale2) {
    return locale2.weekdaysMinRegex(isStrict);
  });
  addRegexToken("ddd", function(isStrict, locale2) {
    return locale2.weekdaysShortRegex(isStrict);
  });
  addRegexToken("dddd", function(isStrict, locale2) {
    return locale2.weekdaysRegex(isStrict);
  });
  addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config2, token3) {
    var weekday = config2._locale.weekdaysParse(input, token3, config2._strict);
    if (weekday != null) {
      week.d = weekday;
    } else {
      getParsingFlags(config2).invalidWeekday = input;
    }
  });
  addWeekParseToken(["d", "e", "E"], function(input, week, config2, token3) {
    week[token3] = toInt(input);
  });
  function parseWeekday(input, locale2) {
    if (typeof input !== "string") {
      return input;
    }
    if (!isNaN(input)) {
      return parseInt(input, 10);
    }
    input = locale2.weekdaysParse(input);
    if (typeof input === "number") {
      return input;
    }
    return null;
  }
  function parseIsoWeekday(input, locale2) {
    if (typeof input === "string") {
      return locale2.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
  }
  function shiftWeekdays(ws, n4) {
    return ws.slice(n4, 7).concat(ws.slice(0, n4));
  }
  var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
  var defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
  var defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
  var defaultWeekdaysRegex = matchWord;
  var defaultWeekdaysShortRegex = matchWord;
  var defaultWeekdaysMinRegex = matchWord;
  function localeWeekdays(m3, format2) {
    var weekdays = isArray4(this._weekdays) ? this._weekdays : this._weekdays[m3 && m3 !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
    return m3 === true ? shiftWeekdays(weekdays, this._week.dow) : m3 ? weekdays[m3.day()] : weekdays;
  }
  function localeWeekdaysShort(m3) {
    return m3 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m3 ? this._weekdaysShort[m3.day()] : this._weekdaysShort;
  }
  function localeWeekdaysMin(m3) {
    return m3 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m3 ? this._weekdaysMin[m3.day()] : this._weekdaysMin;
  }
  function handleStrictParse$1(weekdayName, format2, strict) {
    var i3, ii2, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._minWeekdaysParse = [];
      for (i3 = 0; i3 < 7; ++i3) {
        mom = createUTC([2e3, 1]).day(i3);
        this._minWeekdaysParse[i3] = this.weekdaysMin(mom, "").toLocaleLowerCase();
        this._shortWeekdaysParse[i3] = this.weekdaysShort(mom, "").toLocaleLowerCase();
        this._weekdaysParse[i3] = this.weekdays(mom, "").toLocaleLowerCase();
      }
    }
    if (strict) {
      if (format2 === "dddd") {
        ii2 = indexOf.call(this._weekdaysParse, llc);
        return ii2 !== -1 ? ii2 : null;
      } else if (format2 === "ddd") {
        ii2 = indexOf.call(this._shortWeekdaysParse, llc);
        return ii2 !== -1 ? ii2 : null;
      } else {
        ii2 = indexOf.call(this._minWeekdaysParse, llc);
        return ii2 !== -1 ? ii2 : null;
      }
    } else {
      if (format2 === "dddd") {
        ii2 = indexOf.call(this._weekdaysParse, llc);
        if (ii2 !== -1) {
          return ii2;
        }
        ii2 = indexOf.call(this._shortWeekdaysParse, llc);
        if (ii2 !== -1) {
          return ii2;
        }
        ii2 = indexOf.call(this._minWeekdaysParse, llc);
        return ii2 !== -1 ? ii2 : null;
      } else if (format2 === "ddd") {
        ii2 = indexOf.call(this._shortWeekdaysParse, llc);
        if (ii2 !== -1) {
          return ii2;
        }
        ii2 = indexOf.call(this._weekdaysParse, llc);
        if (ii2 !== -1) {
          return ii2;
        }
        ii2 = indexOf.call(this._minWeekdaysParse, llc);
        return ii2 !== -1 ? ii2 : null;
      } else {
        ii2 = indexOf.call(this._minWeekdaysParse, llc);
        if (ii2 !== -1) {
          return ii2;
        }
        ii2 = indexOf.call(this._weekdaysParse, llc);
        if (ii2 !== -1) {
          return ii2;
        }
        ii2 = indexOf.call(this._shortWeekdaysParse, llc);
        return ii2 !== -1 ? ii2 : null;
      }
    }
  }
  function localeWeekdaysParse(weekdayName, format2, strict) {
    var i3, mom, regex;
    if (this._weekdaysParseExact) {
      return handleStrictParse$1.call(this, weekdayName, format2, strict);
    }
    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._minWeekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._fullWeekdaysParse = [];
    }
    for (i3 = 0; i3 < 7; i3++) {
      mom = createUTC([2e3, 1]).day(i3);
      if (strict && !this._fullWeekdaysParse[i3]) {
        this._fullWeekdaysParse[i3] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
        this._shortWeekdaysParse[i3] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
        this._minWeekdaysParse[i3] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
      }
      if (!this._weekdaysParse[i3]) {
        regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
        this._weekdaysParse[i3] = new RegExp(regex.replace(".", ""), "i");
      }
      if (strict && format2 === "dddd" && this._fullWeekdaysParse[i3].test(weekdayName)) {
        return i3;
      } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i3].test(weekdayName)) {
        return i3;
      } else if (strict && format2 === "dd" && this._minWeekdaysParse[i3].test(weekdayName)) {
        return i3;
      } else if (!strict && this._weekdaysParse[i3].test(weekdayName)) {
        return i3;
      }
    }
  }
  function getSetDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
      input = parseWeekday(input, this.localeData());
      return this.add(input - day, "d");
    } else {
      return day;
    }
  }
  function getSetLocaleDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, "d");
  }
  function getSetISODayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    if (input != null) {
      var weekday = parseIsoWeekday(input, this.localeData());
      return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
      return this.day() || 7;
    }
  }
  function weekdaysRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, "_weekdaysRegex")) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysStrictRegex;
      } else {
        return this._weekdaysRegex;
      }
    } else {
      if (!hasOwnProp(this, "_weekdaysRegex")) {
        this._weekdaysRegex = defaultWeekdaysRegex;
      }
      return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
    }
  }
  function weekdaysShortRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, "_weekdaysRegex")) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysShortStrictRegex;
      } else {
        return this._weekdaysShortRegex;
      }
    } else {
      if (!hasOwnProp(this, "_weekdaysShortRegex")) {
        this._weekdaysShortRegex = defaultWeekdaysShortRegex;
      }
      return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
  }
  function weekdaysMinRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, "_weekdaysRegex")) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysMinStrictRegex;
      } else {
        return this._weekdaysMinRegex;
      }
    } else {
      if (!hasOwnProp(this, "_weekdaysMinRegex")) {
        this._weekdaysMinRegex = defaultWeekdaysMinRegex;
      }
      return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
  }
  function computeWeekdaysParse() {
    function cmpLenRev(a2, b3) {
      return b3.length - a2.length;
    }
    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i3, mom, minp, shortp, longp;
    for (i3 = 0; i3 < 7; i3++) {
      mom = createUTC([2e3, 1]).day(i3);
      minp = regexEscape2(this.weekdaysMin(mom, ""));
      shortp = regexEscape2(this.weekdaysShort(mom, ""));
      longp = regexEscape2(this.weekdays(mom, ""));
      minPieces.push(minp);
      shortPieces.push(shortp);
      longPieces.push(longp);
      mixedPieces.push(minp);
      mixedPieces.push(shortp);
      mixedPieces.push(longp);
    }
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;
    this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
    this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
    this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
  }
  function hFormat() {
    return this.hours() % 12 || 12;
  }
  function kFormat() {
    return this.hours() || 24;
  }
  addFormatToken("H", ["HH", 2], 0, "hour");
  addFormatToken("h", ["hh", 2], 0, hFormat);
  addFormatToken("k", ["kk", 2], 0, kFormat);
  addFormatToken("hmm", 0, 0, function() {
    return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
  });
  addFormatToken("hmmss", 0, 0, function() {
    return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  addFormatToken("Hmm", 0, 0, function() {
    return "" + this.hours() + zeroFill(this.minutes(), 2);
  });
  addFormatToken("Hmmss", 0, 0, function() {
    return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  function meridiem(token3, lowercase) {
    addFormatToken(token3, 0, 0, function() {
      return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
  }
  meridiem("a", true);
  meridiem("A", false);
  addUnitAlias("hour", "h");
  addUnitPriority("hour", 13);
  function matchMeridiem(isStrict, locale2) {
    return locale2._meridiemParse;
  }
  addRegexToken("a", matchMeridiem);
  addRegexToken("A", matchMeridiem);
  addRegexToken("H", match1to2);
  addRegexToken("h", match1to2);
  addRegexToken("k", match1to2);
  addRegexToken("HH", match1to2, match2);
  addRegexToken("hh", match1to2, match2);
  addRegexToken("kk", match1to2, match2);
  addRegexToken("hmm", match3to4);
  addRegexToken("hmmss", match5to6);
  addRegexToken("Hmm", match3to4);
  addRegexToken("Hmmss", match5to6);
  addParseToken(["H", "HH"], HOUR);
  addParseToken(["k", "kk"], function(input, array2, config2) {
    var kInput = toInt(input);
    array2[HOUR] = kInput === 24 ? 0 : kInput;
  });
  addParseToken(["a", "A"], function(input, array2, config2) {
    config2._isPm = config2._locale.isPM(input);
    config2._meridiem = input;
  });
  addParseToken(["h", "hh"], function(input, array2, config2) {
    array2[HOUR] = toInt(input);
    getParsingFlags(config2).bigHour = true;
  });
  addParseToken("hmm", function(input, array2, config2) {
    var pos = input.length - 2;
    array2[HOUR] = toInt(input.substr(0, pos));
    array2[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config2).bigHour = true;
  });
  addParseToken("hmmss", function(input, array2, config2) {
    var pos1 = input.length - 4, pos2 = input.length - 2;
    array2[HOUR] = toInt(input.substr(0, pos1));
    array2[MINUTE] = toInt(input.substr(pos1, 2));
    array2[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config2).bigHour = true;
  });
  addParseToken("Hmm", function(input, array2, config2) {
    var pos = input.length - 2;
    array2[HOUR] = toInt(input.substr(0, pos));
    array2[MINUTE] = toInt(input.substr(pos));
  });
  addParseToken("Hmmss", function(input, array2, config2) {
    var pos1 = input.length - 4, pos2 = input.length - 2;
    array2[HOUR] = toInt(input.substr(0, pos1));
    array2[MINUTE] = toInt(input.substr(pos1, 2));
    array2[SECOND] = toInt(input.substr(pos2));
  });
  function localeIsPM(input) {
    return (input + "").toLowerCase().charAt(0) === "p";
  }
  var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
  var getSetHour = makeGetSet("Hours", true);
  function localeMeridiem(hours2, minutes2, isLower) {
    if (hours2 > 11) {
      return isLower ? "pm" : "PM";
    } else {
      return isLower ? "am" : "AM";
    }
  }
  var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,
    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,
    week: defaultLocaleWeek,
    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,
    meridiemParse: defaultLocaleMeridiemParse
  };
  var locales = {};
  var localeFamilies = {};
  var globalLocale;
  function commonPrefix(arr1, arr2) {
    var i3, minl = Math.min(arr1.length, arr2.length);
    for (i3 = 0; i3 < minl; i3 += 1) {
      if (arr1[i3] !== arr2[i3]) {
        return i3;
      }
    }
    return minl;
  }
  function normalizeLocale(key) {
    return key ? key.toLowerCase().replace("_", "-") : key;
  }
  function chooseLocale(names) {
    var i3 = 0, j, next, locale2, split2;
    while (i3 < names.length) {
      split2 = normalizeLocale(names[i3]).split("-");
      j = split2.length;
      next = normalizeLocale(names[i3 + 1]);
      next = next ? next.split("-") : null;
      while (j > 0) {
        locale2 = loadLocale(split2.slice(0, j).join("-"));
        if (locale2) {
          return locale2;
        }
        if (next && next.length >= j && commonPrefix(split2, next) >= j - 1) {
          break;
        }
        j--;
      }
      i3++;
    }
    return globalLocale;
  }
  function loadLocale(name) {
    var oldLocale = null, aliasedRequire;
    if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports) {
      try {
        oldLocale = globalLocale._abbr;
        aliasedRequire = require;
        aliasedRequire("./locale/" + name);
        getSetGlobalLocale(oldLocale);
      } catch (e3) {
        locales[name] = null;
      }
    }
    return locales[name];
  }
  function getSetGlobalLocale(key, values2) {
    var data;
    if (key) {
      if (isUndefined4(values2)) {
        data = getLocale(key);
      } else {
        data = defineLocale(key, values2);
      }
      if (data) {
        globalLocale = data;
      } else {
        if (typeof console !== "undefined" && console.warn) {
          console.warn("Locale " + key + " not found. Did you forget to load it?");
        }
      }
    }
    return globalLocale._abbr;
  }
  function defineLocale(name, config2) {
    if (config2 !== null) {
      var locale2, parentConfig = baseConfig;
      config2.abbr = name;
      if (locales[name] != null) {
        deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
        parentConfig = locales[name]._config;
      } else if (config2.parentLocale != null) {
        if (locales[config2.parentLocale] != null) {
          parentConfig = locales[config2.parentLocale]._config;
        } else {
          locale2 = loadLocale(config2.parentLocale);
          if (locale2 != null) {
            parentConfig = locale2._config;
          } else {
            if (!localeFamilies[config2.parentLocale]) {
              localeFamilies[config2.parentLocale] = [];
            }
            localeFamilies[config2.parentLocale].push({
              name,
              config: config2
            });
            return null;
          }
        }
      }
      locales[name] = new Locale(mergeConfigs(parentConfig, config2));
      if (localeFamilies[name]) {
        localeFamilies[name].forEach(function(x3) {
          defineLocale(x3.name, x3.config);
        });
      }
      getSetGlobalLocale(name);
      return locales[name];
    } else {
      delete locales[name];
      return null;
    }
  }
  function updateLocale(name, config2) {
    if (config2 != null) {
      var locale2, tmpLocale, parentConfig = baseConfig;
      if (locales[name] != null && locales[name].parentLocale != null) {
        locales[name].set(mergeConfigs(locales[name]._config, config2));
      } else {
        tmpLocale = loadLocale(name);
        if (tmpLocale != null) {
          parentConfig = tmpLocale._config;
        }
        config2 = mergeConfigs(parentConfig, config2);
        if (tmpLocale == null) {
          config2.abbr = name;
        }
        locale2 = new Locale(config2);
        locale2.parentLocale = locales[name];
        locales[name] = locale2;
      }
      getSetGlobalLocale(name);
    } else {
      if (locales[name] != null) {
        if (locales[name].parentLocale != null) {
          locales[name] = locales[name].parentLocale;
          if (name === getSetGlobalLocale()) {
            getSetGlobalLocale(name);
          }
        } else if (locales[name] != null) {
          delete locales[name];
        }
      }
    }
    return locales[name];
  }
  function getLocale(key) {
    var locale2;
    if (key && key._locale && key._locale._abbr) {
      key = key._locale._abbr;
    }
    if (!key) {
      return globalLocale;
    }
    if (!isArray4(key)) {
      locale2 = loadLocale(key);
      if (locale2) {
        return locale2;
      }
      key = [key];
    }
    return chooseLocale(key);
  }
  function listLocales() {
    return keys2(locales);
  }
  function checkOverflow(m3) {
    var overflow, a2 = m3._a;
    if (a2 && getParsingFlags(m3).overflow === -2) {
      overflow = a2[MONTH] < 0 || a2[MONTH] > 11 ? MONTH : a2[DATE] < 1 || a2[DATE] > daysInMonth(a2[YEAR], a2[MONTH]) ? DATE : a2[HOUR] < 0 || a2[HOUR] > 24 || a2[HOUR] === 24 && (a2[MINUTE] !== 0 || a2[SECOND] !== 0 || a2[MILLISECOND] !== 0) ? HOUR : a2[MINUTE] < 0 || a2[MINUTE] > 59 ? MINUTE : a2[SECOND] < 0 || a2[SECOND] > 59 ? SECOND : a2[MILLISECOND] < 0 || a2[MILLISECOND] > 999 ? MILLISECOND : -1;
      if (getParsingFlags(m3)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
        overflow = DATE;
      }
      if (getParsingFlags(m3)._overflowWeeks && overflow === -1) {
        overflow = WEEK;
      }
      if (getParsingFlags(m3)._overflowWeekday && overflow === -1) {
        overflow = WEEKDAY;
      }
      getParsingFlags(m3).overflow = overflow;
    }
    return m3;
  }
  var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
  var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
  var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
  var isoDates = [
    ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
    ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
    ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
    ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
    ["YYYY-DDD", /\d{4}-\d{3}/],
    ["YYYY-MM", /\d{4}-\d\d/, false],
    ["YYYYYYMMDD", /[+-]\d{10}/],
    ["YYYYMMDD", /\d{8}/],
    ["GGGG[W]WWE", /\d{4}W\d{3}/],
    ["GGGG[W]WW", /\d{4}W\d{2}/, false],
    ["YYYYDDD", /\d{7}/],
    ["YYYYMM", /\d{6}/, false],
    ["YYYY", /\d{4}/, false]
  ];
  var isoTimes = [
    ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
    ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
    ["HH:mm:ss", /\d\d:\d\d:\d\d/],
    ["HH:mm", /\d\d:\d\d/],
    ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
    ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
    ["HHmmss", /\d\d\d\d\d\d/],
    ["HHmm", /\d\d\d\d/],
    ["HH", /\d\d/]
  ];
  var aspNetJsonRegex = /^\/?Date\((-?\d+)/i;
  var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
  var obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
  };
  function configFromISO(config2) {
    var i3, l3, string = config2._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat;
    if (match) {
      getParsingFlags(config2).iso = true;
      for (i3 = 0, l3 = isoDates.length; i3 < l3; i3++) {
        if (isoDates[i3][1].exec(match[1])) {
          dateFormat = isoDates[i3][0];
          allowTime = isoDates[i3][2] !== false;
          break;
        }
      }
      if (dateFormat == null) {
        config2._isValid = false;
        return;
      }
      if (match[3]) {
        for (i3 = 0, l3 = isoTimes.length; i3 < l3; i3++) {
          if (isoTimes[i3][1].exec(match[3])) {
            timeFormat = (match[2] || " ") + isoTimes[i3][0];
            break;
          }
        }
        if (timeFormat == null) {
          config2._isValid = false;
          return;
        }
      }
      if (!allowTime && timeFormat != null) {
        config2._isValid = false;
        return;
      }
      if (match[4]) {
        if (tzRegex.exec(match[4])) {
          tzFormat = "Z";
        } else {
          config2._isValid = false;
          return;
        }
      }
      config2._f = dateFormat + (timeFormat || "") + (tzFormat || "");
      configFromStringAndFormat(config2);
    } else {
      config2._isValid = false;
    }
  }
  function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = [
      untruncateYear(yearStr),
      defaultLocaleMonthsShort.indexOf(monthStr),
      parseInt(dayStr, 10),
      parseInt(hourStr, 10),
      parseInt(minuteStr, 10)
    ];
    if (secondStr) {
      result.push(parseInt(secondStr, 10));
    }
    return result;
  }
  function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);
    if (year <= 49) {
      return 2e3 + year;
    } else if (year <= 999) {
      return 1900 + year;
    }
    return year;
  }
  function preprocessRFC2822(s2) {
    return s2.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
  }
  function checkWeekday(weekdayStr, parsedInput, config2) {
    if (weekdayStr) {
      var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
      if (weekdayProvided !== weekdayActual) {
        getParsingFlags(config2).weekdayMismatch = true;
        config2._isValid = false;
        return false;
      }
    }
    return true;
  }
  function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
      return obsOffsets[obsOffset];
    } else if (militaryOffset) {
      return 0;
    } else {
      var hm = parseInt(numOffset, 10), m3 = hm % 100, h3 = (hm - m3) / 100;
      return h3 * 60 + m3;
    }
  }
  function configFromRFC2822(config2) {
    var match = rfc2822.exec(preprocessRFC2822(config2._i)), parsedArray;
    if (match) {
      parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
      if (!checkWeekday(match[1], parsedArray, config2)) {
        return;
      }
      config2._a = parsedArray;
      config2._tzm = calculateOffset(match[8], match[9], match[10]);
      config2._d = createUTCDate.apply(null, config2._a);
      config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
      getParsingFlags(config2).rfc2822 = true;
    } else {
      config2._isValid = false;
    }
  }
  function configFromString(config2) {
    var matched = aspNetJsonRegex.exec(config2._i);
    if (matched !== null) {
      config2._d = new Date(+matched[1]);
      return;
    }
    configFromISO(config2);
    if (config2._isValid === false) {
      delete config2._isValid;
    } else {
      return;
    }
    configFromRFC2822(config2);
    if (config2._isValid === false) {
      delete config2._isValid;
    } else {
      return;
    }
    if (config2._strict) {
      config2._isValid = false;
    } else {
      hooks.createFromInputFallback(config2);
    }
  }
  hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config2) {
    config2._d = new Date(config2._i + (config2._useUTC ? " UTC" : ""));
  });
  function defaults3(a2, b3, c4) {
    if (a2 != null) {
      return a2;
    }
    if (b3 != null) {
      return b3;
    }
    return c4;
  }
  function currentDateArray(config2) {
    var nowValue = new Date(hooks.now());
    if (config2._useUTC) {
      return [
        nowValue.getUTCFullYear(),
        nowValue.getUTCMonth(),
        nowValue.getUTCDate()
      ];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
  }
  function configFromArray(config2) {
    var i3, date, input = [], currentDate, expectedWeekday, yearToUse;
    if (config2._d) {
      return;
    }
    currentDate = currentDateArray(config2);
    if (config2._w && config2._a[DATE] == null && config2._a[MONTH] == null) {
      dayOfYearFromWeekInfo(config2);
    }
    if (config2._dayOfYear != null) {
      yearToUse = defaults3(config2._a[YEAR], currentDate[YEAR]);
      if (config2._dayOfYear > daysInYear(yearToUse) || config2._dayOfYear === 0) {
        getParsingFlags(config2)._overflowDayOfYear = true;
      }
      date = createUTCDate(yearToUse, 0, config2._dayOfYear);
      config2._a[MONTH] = date.getUTCMonth();
      config2._a[DATE] = date.getUTCDate();
    }
    for (i3 = 0; i3 < 3 && config2._a[i3] == null; ++i3) {
      config2._a[i3] = input[i3] = currentDate[i3];
    }
    for (; i3 < 7; i3++) {
      config2._a[i3] = input[i3] = config2._a[i3] == null ? i3 === 2 ? 1 : 0 : config2._a[i3];
    }
    if (config2._a[HOUR] === 24 && config2._a[MINUTE] === 0 && config2._a[SECOND] === 0 && config2._a[MILLISECOND] === 0) {
      config2._nextDay = true;
      config2._a[HOUR] = 0;
    }
    config2._d = (config2._useUTC ? createUTCDate : createDate).apply(null, input);
    expectedWeekday = config2._useUTC ? config2._d.getUTCDay() : config2._d.getDay();
    if (config2._tzm != null) {
      config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
    }
    if (config2._nextDay) {
      config2._a[HOUR] = 24;
    }
    if (config2._w && typeof config2._w.d !== "undefined" && config2._w.d !== expectedWeekday) {
      getParsingFlags(config2).weekdayMismatch = true;
    }
  }
  function dayOfYearFromWeekInfo(config2) {
    var w3, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
    w3 = config2._w;
    if (w3.GG != null || w3.W != null || w3.E != null) {
      dow = 1;
      doy = 4;
      weekYear = defaults3(w3.GG, config2._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
      week = defaults3(w3.W, 1);
      weekday = defaults3(w3.E, 1);
      if (weekday < 1 || weekday > 7) {
        weekdayOverflow = true;
      }
    } else {
      dow = config2._locale._week.dow;
      doy = config2._locale._week.doy;
      curWeek = weekOfYear(createLocal(), dow, doy);
      weekYear = defaults3(w3.gg, config2._a[YEAR], curWeek.year);
      week = defaults3(w3.w, curWeek.week);
      if (w3.d != null) {
        weekday = w3.d;
        if (weekday < 0 || weekday > 6) {
          weekdayOverflow = true;
        }
      } else if (w3.e != null) {
        weekday = w3.e + dow;
        if (w3.e < 0 || w3.e > 6) {
          weekdayOverflow = true;
        }
      } else {
        weekday = dow;
      }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
      getParsingFlags(config2)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
      getParsingFlags(config2)._overflowWeekday = true;
    } else {
      temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
      config2._a[YEAR] = temp.year;
      config2._dayOfYear = temp.dayOfYear;
    }
  }
  hooks.ISO_8601 = function() {
  };
  hooks.RFC_2822 = function() {
  };
  function configFromStringAndFormat(config2) {
    if (config2._f === hooks.ISO_8601) {
      configFromISO(config2);
      return;
    }
    if (config2._f === hooks.RFC_2822) {
      configFromRFC2822(config2);
      return;
    }
    config2._a = [];
    getParsingFlags(config2).empty = true;
    var string = "" + config2._i, i3, parsedInput, tokens2, token3, skipped, stringLength = string.length, totalParsedInputLength = 0, era;
    tokens2 = expandFormat(config2._f, config2._locale).match(formattingTokens) || [];
    for (i3 = 0; i3 < tokens2.length; i3++) {
      token3 = tokens2[i3];
      parsedInput = (string.match(getParseRegexForToken(token3, config2)) || [])[0];
      if (parsedInput) {
        skipped = string.substr(0, string.indexOf(parsedInput));
        if (skipped.length > 0) {
          getParsingFlags(config2).unusedInput.push(skipped);
        }
        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
        totalParsedInputLength += parsedInput.length;
      }
      if (formatTokenFunctions[token3]) {
        if (parsedInput) {
          getParsingFlags(config2).empty = false;
        } else {
          getParsingFlags(config2).unusedTokens.push(token3);
        }
        addTimeToArrayFromToken(token3, parsedInput, config2);
      } else if (config2._strict && !parsedInput) {
        getParsingFlags(config2).unusedTokens.push(token3);
      }
    }
    getParsingFlags(config2).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
      getParsingFlags(config2).unusedInput.push(string);
    }
    if (config2._a[HOUR] <= 12 && getParsingFlags(config2).bigHour === true && config2._a[HOUR] > 0) {
      getParsingFlags(config2).bigHour = void 0;
    }
    getParsingFlags(config2).parsedDateParts = config2._a.slice(0);
    getParsingFlags(config2).meridiem = config2._meridiem;
    config2._a[HOUR] = meridiemFixWrap(config2._locale, config2._a[HOUR], config2._meridiem);
    era = getParsingFlags(config2).era;
    if (era !== null) {
      config2._a[YEAR] = config2._locale.erasConvertYear(era, config2._a[YEAR]);
    }
    configFromArray(config2);
    checkOverflow(config2);
  }
  function meridiemFixWrap(locale2, hour, meridiem2) {
    var isPm;
    if (meridiem2 == null) {
      return hour;
    }
    if (locale2.meridiemHour != null) {
      return locale2.meridiemHour(hour, meridiem2);
    } else if (locale2.isPM != null) {
      isPm = locale2.isPM(meridiem2);
      if (isPm && hour < 12) {
        hour += 12;
      }
      if (!isPm && hour === 12) {
        hour = 0;
      }
      return hour;
    } else {
      return hour;
    }
  }
  function configFromStringAndArray(config2) {
    var tempConfig, bestMoment, scoreToBeat, i3, currentScore, validFormatFound, bestFormatIsValid = false;
    if (config2._f.length === 0) {
      getParsingFlags(config2).invalidFormat = true;
      config2._d = new Date(NaN);
      return;
    }
    for (i3 = 0; i3 < config2._f.length; i3++) {
      currentScore = 0;
      validFormatFound = false;
      tempConfig = copyConfig({}, config2);
      if (config2._useUTC != null) {
        tempConfig._useUTC = config2._useUTC;
      }
      tempConfig._f = config2._f[i3];
      configFromStringAndFormat(tempConfig);
      if (isValid(tempConfig)) {
        validFormatFound = true;
      }
      currentScore += getParsingFlags(tempConfig).charsLeftOver;
      currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
      getParsingFlags(tempConfig).score = currentScore;
      if (!bestFormatIsValid) {
        if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
          if (validFormatFound) {
            bestFormatIsValid = true;
          }
        }
      } else {
        if (currentScore < scoreToBeat) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
        }
      }
    }
    extend3(config2, bestMoment || tempConfig);
  }
  function configFromObject(config2) {
    if (config2._d) {
      return;
    }
    var i3 = normalizeObjectUnits(config2._i), dayOrDate = i3.day === void 0 ? i3.date : i3.day;
    config2._a = map3([i3.year, i3.month, dayOrDate, i3.hour, i3.minute, i3.second, i3.millisecond], function(obj) {
      return obj && parseInt(obj, 10);
    });
    configFromArray(config2);
  }
  function createFromConfig(config2) {
    var res = new Moment(checkOverflow(prepareConfig(config2)));
    if (res._nextDay) {
      res.add(1, "d");
      res._nextDay = void 0;
    }
    return res;
  }
  function prepareConfig(config2) {
    var input = config2._i, format2 = config2._f;
    config2._locale = config2._locale || getLocale(config2._l);
    if (input === null || format2 === void 0 && input === "") {
      return createInvalid({nullInput: true});
    }
    if (typeof input === "string") {
      config2._i = input = config2._locale.preparse(input);
    }
    if (isMoment(input)) {
      return new Moment(checkOverflow(input));
    } else if (isDate3(input)) {
      config2._d = input;
    } else if (isArray4(format2)) {
      configFromStringAndArray(config2);
    } else if (format2) {
      configFromStringAndFormat(config2);
    } else {
      configFromInput(config2);
    }
    if (!isValid(config2)) {
      config2._d = null;
    }
    return config2;
  }
  function configFromInput(config2) {
    var input = config2._i;
    if (isUndefined4(input)) {
      config2._d = new Date(hooks.now());
    } else if (isDate3(input)) {
      config2._d = new Date(input.valueOf());
    } else if (typeof input === "string") {
      configFromString(config2);
    } else if (isArray4(input)) {
      config2._a = map3(input.slice(0), function(obj) {
        return parseInt(obj, 10);
      });
      configFromArray(config2);
    } else if (isObject4(input)) {
      configFromObject(config2);
    } else if (isNumber2(input)) {
      config2._d = new Date(input);
    } else {
      hooks.createFromInputFallback(config2);
    }
  }
  function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
    var c4 = {};
    if (format2 === true || format2 === false) {
      strict = format2;
      format2 = void 0;
    }
    if (locale2 === true || locale2 === false) {
      strict = locale2;
      locale2 = void 0;
    }
    if (isObject4(input) && isObjectEmpty(input) || isArray4(input) && input.length === 0) {
      input = void 0;
    }
    c4._isAMomentObject = true;
    c4._useUTC = c4._isUTC = isUTC;
    c4._l = locale2;
    c4._i = input;
    c4._f = format2;
    c4._strict = strict;
    return createFromConfig(c4);
  }
  function createLocal(input, format2, locale2, strict) {
    return createLocalOrUTC(input, format2, locale2, strict, false);
  }
  var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return createInvalid();
    }
  });
  var prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return createInvalid();
    }
  });
  function pickBy(fn, moments) {
    var res, i3;
    if (moments.length === 1 && isArray4(moments[0])) {
      moments = moments[0];
    }
    if (!moments.length) {
      return createLocal();
    }
    res = moments[0];
    for (i3 = 1; i3 < moments.length; ++i3) {
      if (!moments[i3].isValid() || moments[i3][fn](res)) {
        res = moments[i3];
      }
    }
    return res;
  }
  function min2() {
    var args = [].slice.call(arguments, 0);
    return pickBy("isBefore", args);
  }
  function max2() {
    var args = [].slice.call(arguments, 0);
    return pickBy("isAfter", args);
  }
  var now3 = function() {
    return Date.now ? Date.now() : +new Date();
  };
  var ordering = [
    "year",
    "quarter",
    "month",
    "week",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond"
  ];
  function isDurationValid(m3) {
    var key, unitHasDecimal = false, i3;
    for (key in m3) {
      if (hasOwnProp(m3, key) && !(indexOf.call(ordering, key) !== -1 && (m3[key] == null || !isNaN(m3[key])))) {
        return false;
      }
    }
    for (i3 = 0; i3 < ordering.length; ++i3) {
      if (m3[ordering[i3]]) {
        if (unitHasDecimal) {
          return false;
        }
        if (parseFloat(m3[ordering[i3]]) !== toInt(m3[ordering[i3]])) {
          unitHasDecimal = true;
        }
      }
    }
    return true;
  }
  function isValid$1() {
    return this._isValid;
  }
  function createInvalid$1() {
    return createDuration(NaN);
  }
  function Duration(duration) {
    var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
    this._isValid = isDurationValid(normalizedInput);
    this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
    this._days = +days2 + weeks2 * 7;
    this._months = +months2 + quarters * 3 + years2 * 12;
    this._data = {};
    this._locale = getLocale();
    this._bubble();
  }
  function isDuration(obj) {
    return obj instanceof Duration;
  }
  function absRound(number) {
    if (number < 0) {
      return Math.round(-1 * number) * -1;
    } else {
      return Math.round(number);
    }
  }
  function compareArrays(array1, array2, dontConvert) {
    var len2 = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i3;
    for (i3 = 0; i3 < len2; i3++) {
      if (dontConvert && array1[i3] !== array2[i3] || !dontConvert && toInt(array1[i3]) !== toInt(array2[i3])) {
        diffs++;
      }
    }
    return diffs + lengthDiff;
  }
  function offset2(token3, separator) {
    addFormatToken(token3, 0, 0, function() {
      var offset3 = this.utcOffset(), sign2 = "+";
      if (offset3 < 0) {
        offset3 = -offset3;
        sign2 = "-";
      }
      return sign2 + zeroFill(~~(offset3 / 60), 2) + separator + zeroFill(~~offset3 % 60, 2);
    });
  }
  offset2("Z", ":");
  offset2("ZZ", "");
  addRegexToken("Z", matchShortOffset);
  addRegexToken("ZZ", matchShortOffset);
  addParseToken(["Z", "ZZ"], function(input, array2, config2) {
    config2._useUTC = true;
    config2._tzm = offsetFromString(matchShortOffset, input);
  });
  var chunkOffset = /([\+\-]|\d\d)/gi;
  function offsetFromString(matcher2, string) {
    var matches2 = (string || "").match(matcher2), chunk, parts, minutes2;
    if (matches2 === null) {
      return null;
    }
    chunk = matches2[matches2.length - 1] || [];
    parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
    minutes2 = +(parts[1] * 60) + toInt(parts[2]);
    return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
  }
  function cloneWithOffset(input, model) {
    var res, diff2;
    if (model._isUTC) {
      res = model.clone();
      diff2 = (isMoment(input) || isDate3(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
      res._d.setTime(res._d.valueOf() + diff2);
      hooks.updateOffset(res, false);
      return res;
    } else {
      return createLocal(input).local();
    }
  }
  function getDateOffset(m3) {
    return -Math.round(m3._d.getTimezoneOffset());
  }
  hooks.updateOffset = function() {
  };
  function getSetOffset(input, keepLocalTime, keepMinutes) {
    var offset3 = this._offset || 0, localAdjust;
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    if (input != null) {
      if (typeof input === "string") {
        input = offsetFromString(matchShortOffset, input);
        if (input === null) {
          return this;
        }
      } else if (Math.abs(input) < 16 && !keepMinutes) {
        input = input * 60;
      }
      if (!this._isUTC && keepLocalTime) {
        localAdjust = getDateOffset(this);
      }
      this._offset = input;
      this._isUTC = true;
      if (localAdjust != null) {
        this.add(localAdjust, "m");
      }
      if (offset3 !== input) {
        if (!keepLocalTime || this._changeInProgress) {
          addSubtract(this, createDuration(input - offset3, "m"), 1, false);
        } else if (!this._changeInProgress) {
          this._changeInProgress = true;
          hooks.updateOffset(this, true);
          this._changeInProgress = null;
        }
      }
      return this;
    } else {
      return this._isUTC ? offset3 : getDateOffset(this);
    }
  }
  function getSetZone(input, keepLocalTime) {
    if (input != null) {
      if (typeof input !== "string") {
        input = -input;
      }
      this.utcOffset(input, keepLocalTime);
      return this;
    } else {
      return -this.utcOffset();
    }
  }
  function setOffsetToUTC(keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
  }
  function setOffsetToLocal(keepLocalTime) {
    if (this._isUTC) {
      this.utcOffset(0, keepLocalTime);
      this._isUTC = false;
      if (keepLocalTime) {
        this.subtract(getDateOffset(this), "m");
      }
    }
    return this;
  }
  function setOffsetToParsedOffset() {
    if (this._tzm != null) {
      this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === "string") {
      var tZone = offsetFromString(matchOffset, this._i);
      if (tZone != null) {
        this.utcOffset(tZone);
      } else {
        this.utcOffset(0, true);
      }
    }
    return this;
  }
  function hasAlignedHourOffset(input) {
    if (!this.isValid()) {
      return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;
    return (this.utcOffset() - input) % 60 === 0;
  }
  function isDaylightSavingTime() {
    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
  }
  function isDaylightSavingTimeShifted() {
    if (!isUndefined4(this._isDSTShifted)) {
      return this._isDSTShifted;
    }
    var c4 = {}, other;
    copyConfig(c4, this);
    c4 = prepareConfig(c4);
    if (c4._a) {
      other = c4._isUTC ? createUTC(c4._a) : createLocal(c4._a);
      this._isDSTShifted = this.isValid() && compareArrays(c4._a, other.toArray()) > 0;
    } else {
      this._isDSTShifted = false;
    }
    return this._isDSTShifted;
  }
  function isLocal() {
    return this.isValid() ? !this._isUTC : false;
  }
  function isUtcOffset() {
    return this.isValid() ? this._isUTC : false;
  }
  function isUtc() {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
  }
  var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/;
  var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  function createDuration(input, key) {
    var duration = input, match = null, sign2, ret, diffRes;
    if (isDuration(input)) {
      duration = {
        ms: input._milliseconds,
        d: input._days,
        M: input._months
      };
    } else if (isNumber2(input) || !isNaN(+input)) {
      duration = {};
      if (key) {
        duration[key] = +input;
      } else {
        duration.milliseconds = +input;
      }
    } else if (match = aspNetRegex.exec(input)) {
      sign2 = match[1] === "-" ? -1 : 1;
      duration = {
        y: 0,
        d: toInt(match[DATE]) * sign2,
        h: toInt(match[HOUR]) * sign2,
        m: toInt(match[MINUTE]) * sign2,
        s: toInt(match[SECOND]) * sign2,
        ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
      };
    } else if (match = isoRegex.exec(input)) {
      sign2 = match[1] === "-" ? -1 : 1;
      duration = {
        y: parseIso(match[2], sign2),
        M: parseIso(match[3], sign2),
        w: parseIso(match[4], sign2),
        d: parseIso(match[5], sign2),
        h: parseIso(match[6], sign2),
        m: parseIso(match[7], sign2),
        s: parseIso(match[8], sign2)
      };
    } else if (duration == null) {
      duration = {};
    } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
      diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
      duration = {};
      duration.ms = diffRes.milliseconds;
      duration.M = diffRes.months;
    }
    ret = new Duration(duration);
    if (isDuration(input) && hasOwnProp(input, "_locale")) {
      ret._locale = input._locale;
    }
    if (isDuration(input) && hasOwnProp(input, "_isValid")) {
      ret._isValid = input._isValid;
    }
    return ret;
  }
  createDuration.fn = Duration.prototype;
  createDuration.invalid = createInvalid$1;
  function parseIso(inp, sign2) {
    var res = inp && parseFloat(inp.replace(",", "."));
    return (isNaN(res) ? 0 : res) * sign2;
  }
  function positiveMomentsDifference(base, other) {
    var res = {};
    res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, "M").isAfter(other)) {
      --res.months;
    }
    res.milliseconds = +other - +base.clone().add(res.months, "M");
    return res;
  }
  function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
      return {milliseconds: 0, months: 0};
    }
    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
      res = positiveMomentsDifference(base, other);
    } else {
      res = positiveMomentsDifference(other, base);
      res.milliseconds = -res.milliseconds;
      res.months = -res.months;
    }
    return res;
  }
  function createAdder(direction, name) {
    return function(val, period) {
      var dur, tmp;
      if (period !== null && !isNaN(+period)) {
        deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
        tmp = val;
        val = period;
        period = tmp;
      }
      dur = createDuration(val, period);
      addSubtract(this, dur, direction);
      return this;
    };
  }
  function addSubtract(mom, duration, isAdding, updateOffset) {
    var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
    if (!mom.isValid()) {
      return;
    }
    updateOffset = updateOffset == null ? true : updateOffset;
    if (months2) {
      setMonth(mom, get5(mom, "Month") + months2 * isAdding);
    }
    if (days2) {
      set$12(mom, "Date", get5(mom, "Date") + days2 * isAdding);
    }
    if (milliseconds2) {
      mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
    }
    if (updateOffset) {
      hooks.updateOffset(mom, days2 || months2);
    }
  }
  var add = createAdder(1, "add");
  var subtract = createAdder(-1, "subtract");
  function isString4(input) {
    return typeof input === "string" || input instanceof String;
  }
  function isMomentInput(input) {
    return isMoment(input) || isDate3(input) || isString4(input) || isNumber2(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
  }
  function isMomentInputObject(input) {
    var objectTest = isObject4(input) && !isObjectEmpty(input), propertyTest = false, properties = [
      "years",
      "year",
      "y",
      "months",
      "month",
      "M",
      "days",
      "day",
      "d",
      "dates",
      "date",
      "D",
      "hours",
      "hour",
      "h",
      "minutes",
      "minute",
      "m",
      "seconds",
      "second",
      "s",
      "milliseconds",
      "millisecond",
      "ms"
    ], i3, property2;
    for (i3 = 0; i3 < properties.length; i3 += 1) {
      property2 = properties[i3];
      propertyTest = propertyTest || hasOwnProp(input, property2);
    }
    return objectTest && propertyTest;
  }
  function isNumberOrStringArray(input) {
    var arrayTest = isArray4(input), dataTypeTest = false;
    if (arrayTest) {
      dataTypeTest = input.filter(function(item) {
        return !isNumber2(item) && isString4(input);
      }).length === 0;
    }
    return arrayTest && dataTypeTest;
  }
  function isCalendarSpec(input) {
    var objectTest = isObject4(input) && !isObjectEmpty(input), propertyTest = false, properties = [
      "sameDay",
      "nextDay",
      "lastDay",
      "nextWeek",
      "lastWeek",
      "sameElse"
    ], i3, property2;
    for (i3 = 0; i3 < properties.length; i3 += 1) {
      property2 = properties[i3];
      propertyTest = propertyTest || hasOwnProp(input, property2);
    }
    return objectTest && propertyTest;
  }
  function getCalendarFormat(myMoment, now4) {
    var diff2 = myMoment.diff(now4, "days", true);
    return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
  }
  function calendar$1(time2, formats2) {
    if (arguments.length === 1) {
      if (!arguments[0]) {
        time2 = void 0;
        formats2 = void 0;
      } else if (isMomentInput(arguments[0])) {
        time2 = arguments[0];
        formats2 = void 0;
      } else if (isCalendarSpec(arguments[0])) {
        formats2 = arguments[0];
        time2 = void 0;
      }
    }
    var now4 = time2 || createLocal(), sod = cloneWithOffset(now4, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output2 = formats2 && (isFunction5(formats2[format2]) ? formats2[format2].call(this, now4) : formats2[format2]);
    return this.format(output2 || this.localeData().calendar(format2, this, createLocal(now4)));
  }
  function clone2() {
    return new Moment(this);
  }
  function isAfter(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(units) || "millisecond";
    if (units === "millisecond") {
      return this.valueOf() > localInput.valueOf();
    } else {
      return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
  }
  function isBefore(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(units) || "millisecond";
    if (units === "millisecond") {
      return this.valueOf() < localInput.valueOf();
    } else {
      return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
  }
  function isBetween(from2, to2, units, inclusivity) {
    var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
    if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
      return false;
    }
    inclusivity = inclusivity || "()";
    return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
  }
  function isSame(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input), inputMs;
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(units) || "millisecond";
    if (units === "millisecond") {
      return this.valueOf() === localInput.valueOf();
    } else {
      inputMs = localInput.valueOf();
      return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
  }
  function isSameOrAfter(input, units) {
    return this.isSame(input, units) || this.isAfter(input, units);
  }
  function isSameOrBefore(input, units) {
    return this.isSame(input, units) || this.isBefore(input, units);
  }
  function diff(input, units, asFloat) {
    var that, zoneDelta, output2;
    if (!this.isValid()) {
      return NaN;
    }
    that = cloneWithOffset(input, this);
    if (!that.isValid()) {
      return NaN;
    }
    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
    units = normalizeUnits(units);
    switch (units) {
      case "year":
        output2 = monthDiff(this, that) / 12;
        break;
      case "month":
        output2 = monthDiff(this, that);
        break;
      case "quarter":
        output2 = monthDiff(this, that) / 3;
        break;
      case "second":
        output2 = (this - that) / 1e3;
        break;
      case "minute":
        output2 = (this - that) / 6e4;
        break;
      case "hour":
        output2 = (this - that) / 36e5;
        break;
      case "day":
        output2 = (this - that - zoneDelta) / 864e5;
        break;
      case "week":
        output2 = (this - that - zoneDelta) / 6048e5;
        break;
      default:
        output2 = this - that;
    }
    return asFloat ? output2 : absFloor(output2);
  }
  function monthDiff(a2, b3) {
    if (a2.date() < b3.date()) {
      return -monthDiff(b3, a2);
    }
    var wholeMonthDiff = (b3.year() - a2.year()) * 12 + (b3.month() - a2.month()), anchor = a2.clone().add(wholeMonthDiff, "months"), anchor2, adjust2;
    if (b3 - anchor < 0) {
      anchor2 = a2.clone().add(wholeMonthDiff - 1, "months");
      adjust2 = (b3 - anchor) / (anchor - anchor2);
    } else {
      anchor2 = a2.clone().add(wholeMonthDiff + 1, "months");
      adjust2 = (b3 - anchor) / (anchor2 - anchor);
    }
    return -(wholeMonthDiff + adjust2) || 0;
  }
  hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
  hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
  function toString4() {
    return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
  }
  function toISOString(keepOffset) {
    if (!this.isValid()) {
      return null;
    }
    var utc = keepOffset !== true, m3 = utc ? this.clone().utc() : this;
    if (m3.year() < 0 || m3.year() > 9999) {
      return formatMoment(m3, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
    }
    if (isFunction5(Date.prototype.toISOString)) {
      if (utc) {
        return this.toDate().toISOString();
      } else {
        return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m3, "Z"));
      }
    }
    return formatMoment(m3, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
  }
  function inspect() {
    if (!this.isValid()) {
      return "moment.invalid(/* " + this._i + " */)";
    }
    var func = "moment", zone = "", prefix2, year, datetime, suffix;
    if (!this.isLocal()) {
      func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
      zone = "Z";
    }
    prefix2 = "[" + func + '("]';
    year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
    datetime = "-MM-DD[T]HH:mm:ss.SSS";
    suffix = zone + '[")]';
    return this.format(prefix2 + year + datetime + suffix);
  }
  function format(inputString) {
    if (!inputString) {
      inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output2 = formatMoment(this, inputString);
    return this.localeData().postformat(output2);
  }
  function from(time2, withoutSuffix) {
    if (this.isValid() && (isMoment(time2) && time2.isValid() || createLocal(time2).isValid())) {
      return createDuration({to: this, from: time2}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }
  function fromNow(withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
  }
  function to(time2, withoutSuffix) {
    if (this.isValid() && (isMoment(time2) && time2.isValid() || createLocal(time2).isValid())) {
      return createDuration({from: this, to: time2}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }
  function toNow(withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
  }
  function locale(key) {
    var newLocaleData;
    if (key === void 0) {
      return this._locale._abbr;
    } else {
      newLocaleData = getLocale(key);
      if (newLocaleData != null) {
        this._locale = newLocaleData;
      }
      return this;
    }
  }
  var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
    if (key === void 0) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  });
  function localeData() {
    return this._locale;
  }
  var MS_PER_SECOND = 1e3;
  var MS_PER_MINUTE = 60 * MS_PER_SECOND;
  var MS_PER_HOUR = 60 * MS_PER_MINUTE;
  var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
  function mod$1(dividend, divisor) {
    return (dividend % divisor + divisor) % divisor;
  }
  function localStartOfDate(y4, m3, d3) {
    if (y4 < 100 && y4 >= 0) {
      return new Date(y4 + 400, m3, d3) - MS_PER_400_YEARS;
    } else {
      return new Date(y4, m3, d3).valueOf();
    }
  }
  function utcStartOfDate(y4, m3, d3) {
    if (y4 < 100 && y4 >= 0) {
      return Date.UTC(y4 + 400, m3, d3) - MS_PER_400_YEARS;
    } else {
      return Date.UTC(y4, m3, d3);
    }
  }
  function startOf(units) {
    var time2, startOfDate;
    units = normalizeUnits(units);
    if (units === void 0 || units === "millisecond" || !this.isValid()) {
      return this;
    }
    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
    switch (units) {
      case "year":
        time2 = startOfDate(this.year(), 0, 1);
        break;
      case "quarter":
        time2 = startOfDate(this.year(), this.month() - this.month() % 3, 1);
        break;
      case "month":
        time2 = startOfDate(this.year(), this.month(), 1);
        break;
      case "week":
        time2 = startOfDate(this.year(), this.month(), this.date() - this.weekday());
        break;
      case "isoWeek":
        time2 = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
        break;
      case "day":
      case "date":
        time2 = startOfDate(this.year(), this.month(), this.date());
        break;
      case "hour":
        time2 = this._d.valueOf();
        time2 -= mod$1(time2 + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
        break;
      case "minute":
        time2 = this._d.valueOf();
        time2 -= mod$1(time2, MS_PER_MINUTE);
        break;
      case "second":
        time2 = this._d.valueOf();
        time2 -= mod$1(time2, MS_PER_SECOND);
        break;
    }
    this._d.setTime(time2);
    hooks.updateOffset(this, true);
    return this;
  }
  function endOf(units) {
    var time2, startOfDate;
    units = normalizeUnits(units);
    if (units === void 0 || units === "millisecond" || !this.isValid()) {
      return this;
    }
    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
    switch (units) {
      case "year":
        time2 = startOfDate(this.year() + 1, 0, 1) - 1;
        break;
      case "quarter":
        time2 = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
        break;
      case "month":
        time2 = startOfDate(this.year(), this.month() + 1, 1) - 1;
        break;
      case "week":
        time2 = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
        break;
      case "isoWeek":
        time2 = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
        break;
      case "day":
      case "date":
        time2 = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
        break;
      case "hour":
        time2 = this._d.valueOf();
        time2 += MS_PER_HOUR - mod$1(time2 + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
        break;
      case "minute":
        time2 = this._d.valueOf();
        time2 += MS_PER_MINUTE - mod$1(time2, MS_PER_MINUTE) - 1;
        break;
      case "second":
        time2 = this._d.valueOf();
        time2 += MS_PER_SECOND - mod$1(time2, MS_PER_SECOND) - 1;
        break;
    }
    this._d.setTime(time2);
    hooks.updateOffset(this, true);
    return this;
  }
  function valueOf() {
    return this._d.valueOf() - (this._offset || 0) * 6e4;
  }
  function unix() {
    return Math.floor(this.valueOf() / 1e3);
  }
  function toDate() {
    return new Date(this.valueOf());
  }
  function toArray() {
    var m3 = this;
    return [
      m3.year(),
      m3.month(),
      m3.date(),
      m3.hour(),
      m3.minute(),
      m3.second(),
      m3.millisecond()
    ];
  }
  function toObject3() {
    var m3 = this;
    return {
      years: m3.year(),
      months: m3.month(),
      date: m3.date(),
      hours: m3.hours(),
      minutes: m3.minutes(),
      seconds: m3.seconds(),
      milliseconds: m3.milliseconds()
    };
  }
  function toJSON() {
    return this.isValid() ? this.toISOString() : null;
  }
  function isValid$2() {
    return isValid(this);
  }
  function parsingFlags() {
    return extend3({}, getParsingFlags(this));
  }
  function invalidAt() {
    return getParsingFlags(this).overflow;
  }
  function creationData() {
    return {
      input: this._i,
      format: this._f,
      locale: this._locale,
      isUTC: this._isUTC,
      strict: this._strict
    };
  }
  addFormatToken("N", 0, 0, "eraAbbr");
  addFormatToken("NN", 0, 0, "eraAbbr");
  addFormatToken("NNN", 0, 0, "eraAbbr");
  addFormatToken("NNNN", 0, 0, "eraName");
  addFormatToken("NNNNN", 0, 0, "eraNarrow");
  addFormatToken("y", ["y", 1], "yo", "eraYear");
  addFormatToken("y", ["yy", 2], 0, "eraYear");
  addFormatToken("y", ["yyy", 3], 0, "eraYear");
  addFormatToken("y", ["yyyy", 4], 0, "eraYear");
  addRegexToken("N", matchEraAbbr);
  addRegexToken("NN", matchEraAbbr);
  addRegexToken("NNN", matchEraAbbr);
  addRegexToken("NNNN", matchEraName);
  addRegexToken("NNNNN", matchEraNarrow);
  addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array2, config2, token3) {
    var era = config2._locale.erasParse(input, token3, config2._strict);
    if (era) {
      getParsingFlags(config2).era = era;
    } else {
      getParsingFlags(config2).invalidEra = input;
    }
  });
  addRegexToken("y", matchUnsigned);
  addRegexToken("yy", matchUnsigned);
  addRegexToken("yyy", matchUnsigned);
  addRegexToken("yyyy", matchUnsigned);
  addRegexToken("yo", matchEraYearOrdinal);
  addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
  addParseToken(["yo"], function(input, array2, config2, token3) {
    var match;
    if (config2._locale._eraYearOrdinalRegex) {
      match = input.match(config2._locale._eraYearOrdinalRegex);
    }
    if (config2._locale.eraYearOrdinalParse) {
      array2[YEAR] = config2._locale.eraYearOrdinalParse(input, match);
    } else {
      array2[YEAR] = parseInt(input, 10);
    }
  });
  function localeEras(m3, format2) {
    var i3, l3, date, eras = this._eras || getLocale("en")._eras;
    for (i3 = 0, l3 = eras.length; i3 < l3; ++i3) {
      switch (typeof eras[i3].since) {
        case "string":
          date = hooks(eras[i3].since).startOf("day");
          eras[i3].since = date.valueOf();
          break;
      }
      switch (typeof eras[i3].until) {
        case "undefined":
          eras[i3].until = Infinity;
          break;
        case "string":
          date = hooks(eras[i3].until).startOf("day").valueOf();
          eras[i3].until = date.valueOf();
          break;
      }
    }
    return eras;
  }
  function localeErasParse(eraName, format2, strict) {
    var i3, l3, eras = this.eras(), name, abbr, narrow;
    eraName = eraName.toUpperCase();
    for (i3 = 0, l3 = eras.length; i3 < l3; ++i3) {
      name = eras[i3].name.toUpperCase();
      abbr = eras[i3].abbr.toUpperCase();
      narrow = eras[i3].narrow.toUpperCase();
      if (strict) {
        switch (format2) {
          case "N":
          case "NN":
          case "NNN":
            if (abbr === eraName) {
              return eras[i3];
            }
            break;
          case "NNNN":
            if (name === eraName) {
              return eras[i3];
            }
            break;
          case "NNNNN":
            if (narrow === eraName) {
              return eras[i3];
            }
            break;
        }
      } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
        return eras[i3];
      }
    }
  }
  function localeErasConvertYear(era, year) {
    var dir = era.since <= era.until ? 1 : -1;
    if (year === void 0) {
      return hooks(era.since).year();
    } else {
      return hooks(era.since).year() + (year - era.offset) * dir;
    }
  }
  function getEraName() {
    var i3, l3, val, eras = this.localeData().eras();
    for (i3 = 0, l3 = eras.length; i3 < l3; ++i3) {
      val = this.clone().startOf("day").valueOf();
      if (eras[i3].since <= val && val <= eras[i3].until) {
        return eras[i3].name;
      }
      if (eras[i3].until <= val && val <= eras[i3].since) {
        return eras[i3].name;
      }
    }
    return "";
  }
  function getEraNarrow() {
    var i3, l3, val, eras = this.localeData().eras();
    for (i3 = 0, l3 = eras.length; i3 < l3; ++i3) {
      val = this.clone().startOf("day").valueOf();
      if (eras[i3].since <= val && val <= eras[i3].until) {
        return eras[i3].narrow;
      }
      if (eras[i3].until <= val && val <= eras[i3].since) {
        return eras[i3].narrow;
      }
    }
    return "";
  }
  function getEraAbbr() {
    var i3, l3, val, eras = this.localeData().eras();
    for (i3 = 0, l3 = eras.length; i3 < l3; ++i3) {
      val = this.clone().startOf("day").valueOf();
      if (eras[i3].since <= val && val <= eras[i3].until) {
        return eras[i3].abbr;
      }
      if (eras[i3].until <= val && val <= eras[i3].since) {
        return eras[i3].abbr;
      }
    }
    return "";
  }
  function getEraYear() {
    var i3, l3, dir, val, eras = this.localeData().eras();
    for (i3 = 0, l3 = eras.length; i3 < l3; ++i3) {
      dir = eras[i3].since <= eras[i3].until ? 1 : -1;
      val = this.clone().startOf("day").valueOf();
      if (eras[i3].since <= val && val <= eras[i3].until || eras[i3].until <= val && val <= eras[i3].since) {
        return (this.year() - hooks(eras[i3].since).year()) * dir + eras[i3].offset;
      }
    }
    return this.year();
  }
  function erasNameRegex(isStrict) {
    if (!hasOwnProp(this, "_erasNameRegex")) {
      computeErasParse.call(this);
    }
    return isStrict ? this._erasNameRegex : this._erasRegex;
  }
  function erasAbbrRegex(isStrict) {
    if (!hasOwnProp(this, "_erasAbbrRegex")) {
      computeErasParse.call(this);
    }
    return isStrict ? this._erasAbbrRegex : this._erasRegex;
  }
  function erasNarrowRegex(isStrict) {
    if (!hasOwnProp(this, "_erasNarrowRegex")) {
      computeErasParse.call(this);
    }
    return isStrict ? this._erasNarrowRegex : this._erasRegex;
  }
  function matchEraAbbr(isStrict, locale2) {
    return locale2.erasAbbrRegex(isStrict);
  }
  function matchEraName(isStrict, locale2) {
    return locale2.erasNameRegex(isStrict);
  }
  function matchEraNarrow(isStrict, locale2) {
    return locale2.erasNarrowRegex(isStrict);
  }
  function matchEraYearOrdinal(isStrict, locale2) {
    return locale2._eraYearOrdinalRegex || matchUnsigned;
  }
  function computeErasParse() {
    var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i3, l3, eras = this.eras();
    for (i3 = 0, l3 = eras.length; i3 < l3; ++i3) {
      namePieces.push(regexEscape2(eras[i3].name));
      abbrPieces.push(regexEscape2(eras[i3].abbr));
      narrowPieces.push(regexEscape2(eras[i3].narrow));
      mixedPieces.push(regexEscape2(eras[i3].name));
      mixedPieces.push(regexEscape2(eras[i3].abbr));
      mixedPieces.push(regexEscape2(eras[i3].narrow));
    }
    this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
    this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
    this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
    this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
  }
  addFormatToken(0, ["gg", 2], 0, function() {
    return this.weekYear() % 100;
  });
  addFormatToken(0, ["GG", 2], 0, function() {
    return this.isoWeekYear() % 100;
  });
  function addWeekYearFormatToken(token3, getter) {
    addFormatToken(0, [token3, token3.length], 0, getter);
  }
  addWeekYearFormatToken("gggg", "weekYear");
  addWeekYearFormatToken("ggggg", "weekYear");
  addWeekYearFormatToken("GGGG", "isoWeekYear");
  addWeekYearFormatToken("GGGGG", "isoWeekYear");
  addUnitAlias("weekYear", "gg");
  addUnitAlias("isoWeekYear", "GG");
  addUnitPriority("weekYear", 1);
  addUnitPriority("isoWeekYear", 1);
  addRegexToken("G", matchSigned);
  addRegexToken("g", matchSigned);
  addRegexToken("GG", match1to2, match2);
  addRegexToken("gg", match1to2, match2);
  addRegexToken("GGGG", match1to4, match4);
  addRegexToken("gggg", match1to4, match4);
  addRegexToken("GGGGG", match1to6, match6);
  addRegexToken("ggggg", match1to6, match6);
  addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config2, token3) {
    week[token3.substr(0, 2)] = toInt(input);
  });
  addWeekParseToken(["gg", "GG"], function(input, week, config2, token3) {
    week[token3] = hooks.parseTwoDigitYear(input);
  });
  function getSetWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
  }
  function getSetISOWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
  }
  function getISOWeeksInYear() {
    return weeksInYear(this.year(), 1, 4);
  }
  function getISOWeeksInISOWeekYear() {
    return weeksInYear(this.isoWeekYear(), 1, 4);
  }
  function getWeeksInYear() {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
  }
  function getWeeksInWeekYear() {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
  }
  function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
      return weekOfYear(this, dow, doy).year;
    } else {
      weeksTarget = weeksInYear(input, dow, doy);
      if (week > weeksTarget) {
        week = weeksTarget;
      }
      return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
  }
  function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
  }
  addFormatToken("Q", 0, "Qo", "quarter");
  addUnitAlias("quarter", "Q");
  addUnitPriority("quarter", 7);
  addRegexToken("Q", match1);
  addParseToken("Q", function(input, array2) {
    array2[MONTH] = (toInt(input) - 1) * 3;
  });
  function getSetQuarter(input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
  }
  addFormatToken("D", ["DD", 2], "Do", "date");
  addUnitAlias("date", "D");
  addUnitPriority("date", 9);
  addRegexToken("D", match1to2);
  addRegexToken("DD", match1to2, match2);
  addRegexToken("Do", function(isStrict, locale2) {
    return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
  });
  addParseToken(["D", "DD"], DATE);
  addParseToken("Do", function(input, array2) {
    array2[DATE] = toInt(input.match(match1to2)[0]);
  });
  var getSetDayOfMonth = makeGetSet("Date", true);
  addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
  addUnitAlias("dayOfYear", "DDD");
  addUnitPriority("dayOfYear", 4);
  addRegexToken("DDD", match1to3);
  addRegexToken("DDDD", match3);
  addParseToken(["DDD", "DDDD"], function(input, array2, config2) {
    config2._dayOfYear = toInt(input);
  });
  function getSetDayOfYear(input) {
    var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
    return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
  }
  addFormatToken("m", ["mm", 2], 0, "minute");
  addUnitAlias("minute", "m");
  addUnitPriority("minute", 14);
  addRegexToken("m", match1to2);
  addRegexToken("mm", match1to2, match2);
  addParseToken(["m", "mm"], MINUTE);
  var getSetMinute = makeGetSet("Minutes", false);
  addFormatToken("s", ["ss", 2], 0, "second");
  addUnitAlias("second", "s");
  addUnitPriority("second", 15);
  addRegexToken("s", match1to2);
  addRegexToken("ss", match1to2, match2);
  addParseToken(["s", "ss"], SECOND);
  var getSetSecond = makeGetSet("Seconds", false);
  addFormatToken("S", 0, 0, function() {
    return ~~(this.millisecond() / 100);
  });
  addFormatToken(0, ["SS", 2], 0, function() {
    return ~~(this.millisecond() / 10);
  });
  addFormatToken(0, ["SSS", 3], 0, "millisecond");
  addFormatToken(0, ["SSSS", 4], 0, function() {
    return this.millisecond() * 10;
  });
  addFormatToken(0, ["SSSSS", 5], 0, function() {
    return this.millisecond() * 100;
  });
  addFormatToken(0, ["SSSSSS", 6], 0, function() {
    return this.millisecond() * 1e3;
  });
  addFormatToken(0, ["SSSSSSS", 7], 0, function() {
    return this.millisecond() * 1e4;
  });
  addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
    return this.millisecond() * 1e5;
  });
  addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
    return this.millisecond() * 1e6;
  });
  addUnitAlias("millisecond", "ms");
  addUnitPriority("millisecond", 16);
  addRegexToken("S", match1to3, match1);
  addRegexToken("SS", match1to3, match2);
  addRegexToken("SSS", match1to3, match3);
  var token2;
  var getSetMillisecond;
  for (token2 = "SSSS"; token2.length <= 9; token2 += "S") {
    addRegexToken(token2, matchUnsigned);
  }
  function parseMs(input, array2) {
    array2[MILLISECOND] = toInt(("0." + input) * 1e3);
  }
  for (token2 = "S"; token2.length <= 9; token2 += "S") {
    addParseToken(token2, parseMs);
  }
  getSetMillisecond = makeGetSet("Milliseconds", false);
  addFormatToken("z", 0, 0, "zoneAbbr");
  addFormatToken("zz", 0, 0, "zoneName");
  function getZoneAbbr() {
    return this._isUTC ? "UTC" : "";
  }
  function getZoneName() {
    return this._isUTC ? "Coordinated Universal Time" : "";
  }
  var proto = Moment.prototype;
  proto.add = add;
  proto.calendar = calendar$1;
  proto.clone = clone2;
  proto.diff = diff;
  proto.endOf = endOf;
  proto.format = format;
  proto.from = from;
  proto.fromNow = fromNow;
  proto.to = to;
  proto.toNow = toNow;
  proto.get = stringGet;
  proto.invalidAt = invalidAt;
  proto.isAfter = isAfter;
  proto.isBefore = isBefore;
  proto.isBetween = isBetween;
  proto.isSame = isSame;
  proto.isSameOrAfter = isSameOrAfter;
  proto.isSameOrBefore = isSameOrBefore;
  proto.isValid = isValid$2;
  proto.lang = lang;
  proto.locale = locale;
  proto.localeData = localeData;
  proto.max = prototypeMax;
  proto.min = prototypeMin;
  proto.parsingFlags = parsingFlags;
  proto.set = stringSet;
  proto.startOf = startOf;
  proto.subtract = subtract;
  proto.toArray = toArray;
  proto.toObject = toObject3;
  proto.toDate = toDate;
  proto.toISOString = toISOString;
  proto.inspect = inspect;
  if (typeof Symbol !== "undefined" && Symbol.for != null) {
    proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return "Moment<" + this.format() + ">";
    };
  }
  proto.toJSON = toJSON;
  proto.toString = toString4;
  proto.unix = unix;
  proto.valueOf = valueOf;
  proto.creationData = creationData;
  proto.eraName = getEraName;
  proto.eraNarrow = getEraNarrow;
  proto.eraAbbr = getEraAbbr;
  proto.eraYear = getEraYear;
  proto.year = getSetYear;
  proto.isLeapYear = getIsLeapYear;
  proto.weekYear = getSetWeekYear;
  proto.isoWeekYear = getSetISOWeekYear;
  proto.quarter = proto.quarters = getSetQuarter;
  proto.month = getSetMonth;
  proto.daysInMonth = getDaysInMonth;
  proto.week = proto.weeks = getSetWeek;
  proto.isoWeek = proto.isoWeeks = getSetISOWeek;
  proto.weeksInYear = getWeeksInYear;
  proto.weeksInWeekYear = getWeeksInWeekYear;
  proto.isoWeeksInYear = getISOWeeksInYear;
  proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
  proto.date = getSetDayOfMonth;
  proto.day = proto.days = getSetDayOfWeek;
  proto.weekday = getSetLocaleDayOfWeek;
  proto.isoWeekday = getSetISODayOfWeek;
  proto.dayOfYear = getSetDayOfYear;
  proto.hour = proto.hours = getSetHour;
  proto.minute = proto.minutes = getSetMinute;
  proto.second = proto.seconds = getSetSecond;
  proto.millisecond = proto.milliseconds = getSetMillisecond;
  proto.utcOffset = getSetOffset;
  proto.utc = setOffsetToUTC;
  proto.local = setOffsetToLocal;
  proto.parseZone = setOffsetToParsedOffset;
  proto.hasAlignedHourOffset = hasAlignedHourOffset;
  proto.isDST = isDaylightSavingTime;
  proto.isLocal = isLocal;
  proto.isUtcOffset = isUtcOffset;
  proto.isUtc = isUtc;
  proto.isUTC = isUtc;
  proto.zoneAbbr = getZoneAbbr;
  proto.zoneName = getZoneName;
  proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
  proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
  proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
  proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
  proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
  function createUnix(input) {
    return createLocal(input * 1e3);
  }
  function createInZone() {
    return createLocal.apply(null, arguments).parseZone();
  }
  function preParsePostFormat(string) {
    return string;
  }
  var proto$1 = Locale.prototype;
  proto$1.calendar = calendar;
  proto$1.longDateFormat = longDateFormat;
  proto$1.invalidDate = invalidDate;
  proto$1.ordinal = ordinal;
  proto$1.preparse = preParsePostFormat;
  proto$1.postformat = preParsePostFormat;
  proto$1.relativeTime = relativeTime;
  proto$1.pastFuture = pastFuture;
  proto$1.set = set3;
  proto$1.eras = localeEras;
  proto$1.erasParse = localeErasParse;
  proto$1.erasConvertYear = localeErasConvertYear;
  proto$1.erasAbbrRegex = erasAbbrRegex;
  proto$1.erasNameRegex = erasNameRegex;
  proto$1.erasNarrowRegex = erasNarrowRegex;
  proto$1.months = localeMonths;
  proto$1.monthsShort = localeMonthsShort;
  proto$1.monthsParse = localeMonthsParse;
  proto$1.monthsRegex = monthsRegex;
  proto$1.monthsShortRegex = monthsShortRegex;
  proto$1.week = localeWeek;
  proto$1.firstDayOfYear = localeFirstDayOfYear;
  proto$1.firstDayOfWeek = localeFirstDayOfWeek;
  proto$1.weekdays = localeWeekdays;
  proto$1.weekdaysMin = localeWeekdaysMin;
  proto$1.weekdaysShort = localeWeekdaysShort;
  proto$1.weekdaysParse = localeWeekdaysParse;
  proto$1.weekdaysRegex = weekdaysRegex;
  proto$1.weekdaysShortRegex = weekdaysShortRegex;
  proto$1.weekdaysMinRegex = weekdaysMinRegex;
  proto$1.isPM = localeIsPM;
  proto$1.meridiem = localeMeridiem;
  function get$12(format2, index3, field, setter) {
    var locale2 = getLocale(), utc = createUTC().set(setter, index3);
    return locale2[field](utc, format2);
  }
  function listMonthsImpl(format2, index3, field) {
    if (isNumber2(format2)) {
      index3 = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
    if (index3 != null) {
      return get$12(format2, index3, field, "month");
    }
    var i3, out = [];
    for (i3 = 0; i3 < 12; i3++) {
      out[i3] = get$12(format2, i3, field, "month");
    }
    return out;
  }
  function listWeekdaysImpl(localeSorted, format2, index3, field) {
    if (typeof localeSorted === "boolean") {
      if (isNumber2(format2)) {
        index3 = format2;
        format2 = void 0;
      }
      format2 = format2 || "";
    } else {
      format2 = localeSorted;
      index3 = format2;
      localeSorted = false;
      if (isNumber2(format2)) {
        index3 = format2;
        format2 = void 0;
      }
      format2 = format2 || "";
    }
    var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i3, out = [];
    if (index3 != null) {
      return get$12(format2, (index3 + shift) % 7, field, "day");
    }
    for (i3 = 0; i3 < 7; i3++) {
      out[i3] = get$12(format2, (i3 + shift) % 7, field, "day");
    }
    return out;
  }
  function listMonths(format2, index3) {
    return listMonthsImpl(format2, index3, "months");
  }
  function listMonthsShort(format2, index3) {
    return listMonthsImpl(format2, index3, "monthsShort");
  }
  function listWeekdays(localeSorted, format2, index3) {
    return listWeekdaysImpl(localeSorted, format2, index3, "weekdays");
  }
  function listWeekdaysShort(localeSorted, format2, index3) {
    return listWeekdaysImpl(localeSorted, format2, index3, "weekdaysShort");
  }
  function listWeekdaysMin(localeSorted, format2, index3) {
    return listWeekdaysImpl(localeSorted, format2, index3, "weekdaysMin");
  }
  getSetGlobalLocale("en", {
    eras: [
      {
        since: "0001-01-01",
        until: Infinity,
        offset: 1,
        name: "Anno Domini",
        narrow: "AD",
        abbr: "AD"
      },
      {
        since: "0000-12-31",
        until: -Infinity,
        offset: 1,
        name: "Before Christ",
        narrow: "BC",
        abbr: "BC"
      }
    ],
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function(number) {
      var b3 = number % 10, output2 = toInt(number % 100 / 10) === 1 ? "th" : b3 === 1 ? "st" : b3 === 2 ? "nd" : b3 === 3 ? "rd" : "th";
      return number + output2;
    }
  });
  hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
  hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
  var mathAbs = Math.abs;
  function abs() {
    var data = this._data;
    this._milliseconds = mathAbs(this._milliseconds);
    this._days = mathAbs(this._days);
    this._months = mathAbs(this._months);
    data.milliseconds = mathAbs(data.milliseconds);
    data.seconds = mathAbs(data.seconds);
    data.minutes = mathAbs(data.minutes);
    data.hours = mathAbs(data.hours);
    data.months = mathAbs(data.months);
    data.years = mathAbs(data.years);
    return this;
  }
  function addSubtract$1(duration, input, value, direction) {
    var other = createDuration(input, value);
    duration._milliseconds += direction * other._milliseconds;
    duration._days += direction * other._days;
    duration._months += direction * other._months;
    return duration._bubble();
  }
  function add$1(input, value) {
    return addSubtract$1(this, input, value, 1);
  }
  function subtract$1(input, value) {
    return addSubtract$1(this, input, value, -1);
  }
  function absCeil(number) {
    if (number < 0) {
      return Math.floor(number);
    } else {
      return Math.ceil(number);
    }
  }
  function bubble() {
    var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
    if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
      milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
      days2 = 0;
      months2 = 0;
    }
    data.milliseconds = milliseconds2 % 1e3;
    seconds2 = absFloor(milliseconds2 / 1e3);
    data.seconds = seconds2 % 60;
    minutes2 = absFloor(seconds2 / 60);
    data.minutes = minutes2 % 60;
    hours2 = absFloor(minutes2 / 60);
    data.hours = hours2 % 24;
    days2 += absFloor(hours2 / 24);
    monthsFromDays = absFloor(daysToMonths(days2));
    months2 += monthsFromDays;
    days2 -= absCeil(monthsToDays(monthsFromDays));
    years2 = absFloor(months2 / 12);
    months2 %= 12;
    data.days = days2;
    data.months = months2;
    data.years = years2;
    return this;
  }
  function daysToMonths(days2) {
    return days2 * 4800 / 146097;
  }
  function monthsToDays(months2) {
    return months2 * 146097 / 4800;
  }
  function as(units) {
    if (!this.isValid()) {
      return NaN;
    }
    var days2, months2, milliseconds2 = this._milliseconds;
    units = normalizeUnits(units);
    if (units === "month" || units === "quarter" || units === "year") {
      days2 = this._days + milliseconds2 / 864e5;
      months2 = this._months + daysToMonths(days2);
      switch (units) {
        case "month":
          return months2;
        case "quarter":
          return months2 / 3;
        case "year":
          return months2 / 12;
      }
    } else {
      days2 = this._days + Math.round(monthsToDays(this._months));
      switch (units) {
        case "week":
          return days2 / 7 + milliseconds2 / 6048e5;
        case "day":
          return days2 + milliseconds2 / 864e5;
        case "hour":
          return days2 * 24 + milliseconds2 / 36e5;
        case "minute":
          return days2 * 1440 + milliseconds2 / 6e4;
        case "second":
          return days2 * 86400 + milliseconds2 / 1e3;
        case "millisecond":
          return Math.floor(days2 * 864e5) + milliseconds2;
        default:
          throw new Error("Unknown unit " + units);
      }
    }
  }
  function valueOf$1() {
    if (!this.isValid()) {
      return NaN;
    }
    return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
  }
  function makeAs(alias) {
    return function() {
      return this.as(alias);
    };
  }
  var asMilliseconds = makeAs("ms");
  var asSeconds = makeAs("s");
  var asMinutes = makeAs("m");
  var asHours = makeAs("h");
  var asDays = makeAs("d");
  var asWeeks = makeAs("w");
  var asMonths = makeAs("M");
  var asQuarters = makeAs("Q");
  var asYears = makeAs("y");
  function clone$1() {
    return createDuration(this);
  }
  function get$2(units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + "s"]() : NaN;
  }
  function makeGetter(name) {
    return function() {
      return this.isValid() ? this._data[name] : NaN;
    };
  }
  var milliseconds = makeGetter("milliseconds");
  var seconds = makeGetter("seconds");
  var minutes = makeGetter("minutes");
  var hours = makeGetter("hours");
  var days = makeGetter("days");
  var months = makeGetter("months");
  var years = makeGetter("years");
  function weeks() {
    return absFloor(this.days() / 7);
  }
  var round = Math.round;
  var thresholds = {
    ss: 44,
    s: 45,
    m: 45,
    h: 22,
    d: 26,
    w: null,
    M: 11
  };
  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
    return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
  }
  function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
    var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a2 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
    if (thresholds2.w != null) {
      a2 = a2 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
    }
    a2 = a2 || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
    a2[2] = withoutSuffix;
    a2[3] = +posNegDuration > 0;
    a2[4] = locale2;
    return substituteTimeAgo.apply(null, a2);
  }
  function getSetRelativeTimeRounding(roundingFunction) {
    if (roundingFunction === void 0) {
      return round;
    }
    if (typeof roundingFunction === "function") {
      round = roundingFunction;
      return true;
    }
    return false;
  }
  function getSetRelativeTimeThreshold(threshold, limit) {
    if (thresholds[threshold] === void 0) {
      return false;
    }
    if (limit === void 0) {
      return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === "s") {
      thresholds.ss = limit - 1;
    }
    return true;
  }
  function humanize3(argWithSuffix, argThresholds) {
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }
    var withSuffix = false, th2 = thresholds, locale2, output2;
    if (typeof argWithSuffix === "object") {
      argThresholds = argWithSuffix;
      argWithSuffix = false;
    }
    if (typeof argWithSuffix === "boolean") {
      withSuffix = argWithSuffix;
    }
    if (typeof argThresholds === "object") {
      th2 = Object.assign({}, thresholds, argThresholds);
      if (argThresholds.s != null && argThresholds.ss == null) {
        th2.ss = argThresholds.s - 1;
      }
    }
    locale2 = this.localeData();
    output2 = relativeTime$1(this, !withSuffix, th2, locale2);
    if (withSuffix) {
      output2 = locale2.pastFuture(+this, output2);
    }
    return locale2.postformat(output2);
  }
  var abs$1 = Math.abs;
  function sign(x3) {
    return (x3 > 0) - (x3 < 0) || +x3;
  }
  function toISOString$1() {
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }
    var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
    if (!total) {
      return "P0D";
    }
    minutes2 = absFloor(seconds2 / 60);
    hours2 = absFloor(minutes2 / 60);
    seconds2 %= 60;
    minutes2 %= 60;
    years2 = absFloor(months2 / 12);
    months2 %= 12;
    s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
    totalSign = total < 0 ? "-" : "";
    ymSign = sign(this._months) !== sign(total) ? "-" : "";
    daysSign = sign(this._days) !== sign(total) ? "-" : "";
    hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
    return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
  }
  var proto$2 = Duration.prototype;
  proto$2.isValid = isValid$1;
  proto$2.abs = abs;
  proto$2.add = add$1;
  proto$2.subtract = subtract$1;
  proto$2.as = as;
  proto$2.asMilliseconds = asMilliseconds;
  proto$2.asSeconds = asSeconds;
  proto$2.asMinutes = asMinutes;
  proto$2.asHours = asHours;
  proto$2.asDays = asDays;
  proto$2.asWeeks = asWeeks;
  proto$2.asMonths = asMonths;
  proto$2.asQuarters = asQuarters;
  proto$2.asYears = asYears;
  proto$2.valueOf = valueOf$1;
  proto$2._bubble = bubble;
  proto$2.clone = clone$1;
  proto$2.get = get$2;
  proto$2.milliseconds = milliseconds;
  proto$2.seconds = seconds;
  proto$2.minutes = minutes;
  proto$2.hours = hours;
  proto$2.days = days;
  proto$2.weeks = weeks;
  proto$2.months = months;
  proto$2.years = years;
  proto$2.humanize = humanize3;
  proto$2.toISOString = toISOString$1;
  proto$2.toString = toISOString$1;
  proto$2.toJSON = toISOString$1;
  proto$2.locale = locale;
  proto$2.localeData = localeData;
  proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
  proto$2.lang = lang;
  addFormatToken("X", 0, 0, "unix");
  addFormatToken("x", 0, 0, "valueOf");
  addRegexToken("x", matchSigned);
  addRegexToken("X", matchTimestamp);
  addParseToken("X", function(input, array2, config2) {
    config2._d = new Date(parseFloat(input) * 1e3);
  });
  addParseToken("x", function(input, array2, config2) {
    config2._d = new Date(toInt(input));
  });
  //! moment.js
  hooks.version = "2.29.1";
  setHookCallback(createLocal);
  hooks.fn = proto;
  hooks.min = min2;
  hooks.max = max2;
  hooks.now = now3;
  hooks.utc = createUTC;
  hooks.unix = createUnix;
  hooks.months = listMonths;
  hooks.isDate = isDate3;
  hooks.locale = getSetGlobalLocale;
  hooks.invalid = createInvalid;
  hooks.duration = createDuration;
  hooks.isMoment = isMoment;
  hooks.weekdays = listWeekdays;
  hooks.parseZone = createInZone;
  hooks.localeData = getLocale;
  hooks.isDuration = isDuration;
  hooks.monthsShort = listMonthsShort;
  hooks.weekdaysMin = listWeekdaysMin;
  hooks.defineLocale = defineLocale;
  hooks.updateLocale = updateLocale;
  hooks.locales = listLocales;
  hooks.weekdaysShort = listWeekdaysShort;
  hooks.normalizeUnits = normalizeUnits;
  hooks.relativeTimeRounding = getSetRelativeTimeRounding;
  hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
  hooks.calendarFormat = getCalendarFormat;
  hooks.prototype = proto;
  hooks.HTML5_FMT = {
    DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
    DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
    DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
    DATE: "YYYY-MM-DD",
    TIME: "HH:mm",
    TIME_SECONDS: "HH:mm:ss",
    TIME_MS: "HH:mm:ss.SSS",
    WEEK: "GGGG-[W]WW",
    MONTH: "YYYY-MM"
  };
  var moment_default = hooks;
});

// build/_snowpack/pkg/keycloak-admin.js
var require_keycloak_admin = __commonJS((exports) => {
  __markAsModule(exports);
  __export(exports, {
    default: () => keycloak_admin_default
  });
  var requiredActionProviderRepresentation = createCommonjsModule(function(module2, exports2) {
    exports2.__esModule = true;
    exports2.RequiredActionAlias = void 0;
    (function(RequiredActionAlias) {
      RequiredActionAlias["VERIFY_EMAIL"] = "VERIFY_EMAIL";
      RequiredActionAlias["UPDATE_PROFILE"] = "UPDATE_PROFILE";
      RequiredActionAlias["CONFIGURE_TOTP"] = "CONFIGURE_TOTP";
      RequiredActionAlias["UPDATE_PASSWORD"] = "UPDATE_PASSWORD";
      RequiredActionAlias["terms_and_conditions"] = "terms_and_conditions";
    })(exports2.RequiredActionAlias || (exports2.RequiredActionAlias = {}));
  });
  var camelize = function(obj) {
    if (typeof obj === "string")
      return camelCase(obj);
    return walk(obj);
  };
  function walk(obj) {
    if (!obj || typeof obj !== "object")
      return obj;
    if (isDate(obj) || isRegex(obj))
      return obj;
    if (isArray(obj))
      return map(obj, walk);
    return reduce(objectKeys(obj), function(acc, key) {
      var camel = camelCase(key);
      acc[camel] = walk(obj[key]);
      return acc;
    }, {});
  }
  function camelCase(str) {
    return str.replace(/[_.-](\w|$)/g, function(_23, x3) {
      return x3.toUpperCase();
    });
  }
  var isArray = Array.isArray || function(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };
  var isDate = function(obj) {
    return Object.prototype.toString.call(obj) === "[object Date]";
  };
  var isRegex = function(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var has = Object.prototype.hasOwnProperty;
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      if (has.call(obj, key))
        keys2.push(key);
    }
    return keys2;
  };
  function map(xs, f3) {
    if (xs.map)
      return xs.map(f3);
    var res = [];
    for (var i3 = 0; i3 < xs.length; i3++) {
      res.push(f3(xs[i3], i3));
    }
    return res;
  }
  function reduce(xs, f3, acc) {
    if (xs.reduce)
      return xs.reduce(f3, acc);
    for (var i3 = 0; i3 < xs.length; i3++) {
      acc = f3(acc, xs[i3], i3);
    }
    return acc;
  }
  var strictUriEncode = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x3) => `%${x3.charCodeAt(0).toString(16).toUpperCase()}`);
  var token = "%[a-f0-9]{2}";
  var singleMatcher = new RegExp(token, "gi");
  var multiMatcher = new RegExp("(" + token + ")+", "gi");
  function decodeComponents(components3, split2) {
    try {
      return decodeURIComponent(components3.join(""));
    } catch (err) {
    }
    if (components3.length === 1) {
      return components3;
    }
    split2 = split2 || 1;
    var left2 = components3.slice(0, split2);
    var right2 = components3.slice(split2);
    return Array.prototype.concat.call([], decodeComponents(left2), decodeComponents(right2));
  }
  function decode(input) {
    try {
      return decodeURIComponent(input);
    } catch (err) {
      var tokens = input.match(singleMatcher);
      for (var i3 = 1; i3 < tokens.length; i3++) {
        input = decodeComponents(tokens, i3).join("");
        tokens = input.match(singleMatcher);
      }
      return input;
    }
  }
  function customDecodeURIComponent(input) {
    var replaceMap = {
      "%FE%FF": "",
      "%FF%FE": ""
    };
    var match = multiMatcher.exec(input);
    while (match) {
      try {
        replaceMap[match[0]] = decodeURIComponent(match[0]);
      } catch (err) {
        var result = decode(match[0]);
        if (result !== match[0]) {
          replaceMap[match[0]] = result;
        }
      }
      match = multiMatcher.exec(input);
    }
    replaceMap["%C2"] = "";
    var entries = Object.keys(replaceMap);
    for (var i3 = 0; i3 < entries.length; i3++) {
      var key = entries[i3];
      input = input.replace(new RegExp(key, "g"), replaceMap[key]);
    }
    return input;
  }
  var decodeUriComponent = function(encodedURI) {
    if (typeof encodedURI !== "string") {
      throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
    }
    try {
      encodedURI = encodedURI.replace(/\+/g, " ");
      return decodeURIComponent(encodedURI);
    } catch (err) {
      return customDecodeURIComponent(encodedURI);
    }
  };
  var splitOnFirst = (string, separator) => {
    if (!(typeof string === "string" && typeof separator === "string")) {
      throw new TypeError("Expected the arguments to be of type `string`");
    }
    if (separator === "") {
      return [string];
    }
    const separatorIndex = string.indexOf(separator);
    if (separatorIndex === -1) {
      return [string];
    }
    return [
      string.slice(0, separatorIndex),
      string.slice(separatorIndex + separator.length)
    ];
  };
  var filterObj = function(obj, predicate) {
    var ret = {};
    var keys2 = Object.keys(obj);
    var isArr = Array.isArray(predicate);
    for (var i3 = 0; i3 < keys2.length; i3++) {
      var key = keys2[i3];
      var val = obj[key];
      if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
        ret[key] = val;
      }
    }
    return ret;
  };
  var queryString = createCommonjsModule(function(module2, exports2) {
    const isNullOrUndefined2 = (value) => value === null || value === void 0;
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index3 = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[", index3, "]"].join("")];
            }
            return [
              ...result,
              [encode2(key, options), "[", encode2(index3, options), "]=", encode2(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[]"].join("")];
            }
            return [...result, [encode2(key, options), "[]=", encode2(value, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key) => (result, value) => {
            if (value === null || value === void 0 || value.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode2(key, options), "=", encode2(value, options)].join("")];
            }
            return [[result, encode2(value, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode2(key, options)];
            }
            return [...result, [encode2(key, options), "=", encode2(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray4 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray4 && decode2(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode2(value, options) : value;
            const newValue = isArray4 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
            accumulator[key] = newValue;
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode2(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode2(value, options) {
      if (options.decode) {
        return decodeUriComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a2, b3) => Number(a2) - Number(b3)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash2 = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash2 = url.slice(hashStart);
      }
      return hash2;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse2(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode2(value, options);
        formatter(decode2(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k3 of Object.keys(value)) {
            value[k3] = parseValue(value[k3], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, Object.create(null));
    }
    exports2.extract = extract;
    exports2.parse = parse2;
    exports2.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined2(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys2 = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys2.sort(options.sort);
      }
      return keys2.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode2(key, options);
        }
        if (Array.isArray(value)) {
          return value.reduce(formatter(key), []).join("&");
        }
        return encode2(key, options) + "=" + encode2(value, options);
      }).filter((x3) => x3.length > 0).join("&");
    };
    exports2.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash2] = splitOnFirst(url, "#");
      return Object.assign({
        url: url_.split("?")[0] || "",
        query: parse2(extract(url), options)
      }, options && options.parseFragmentIdentifier && hash2 ? {fragmentIdentifier: decode2(hash2, options)} : {});
    };
    exports2.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports2.extract(object.url);
      const parsedQueryFromUrl = exports2.parse(queryFromUrl, {sort: false});
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString2 = exports2.stringify(query, options);
      if (queryString2) {
        queryString2 = `?${queryString2}`;
      }
      let hash2 = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash2 = `#${encode2(object.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString2}${hash2}`;
    };
    exports2.pick = (input, filter3, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true
      }, options);
      const {url, query, fragmentIdentifier} = exports2.parseUrl(input, options);
      return exports2.stringifyUrl({
        url,
        query: filterObj(query, filter3),
        fragmentIdentifier
      }, options);
    };
    exports2.exclude = (input, filter3, options) => {
      const exclusionFilter = Array.isArray(filter3) ? (key) => !filter3.includes(key) : (key, value) => !filter3(key, value);
      return exports2.pick(input, exclusionFilter, options);
    };
  });
  var constants = createCommonjsModule(function(module2, exports2) {
    exports2.__esModule = true;
    exports2.defaultRealm = exports2.defaultBaseUrl = void 0;
    exports2.defaultBaseUrl = "http://127.0.0.1:8080/auth";
    exports2.defaultRealm = "master";
  });
  var auth = createCommonjsModule(function(module2, exports2) {
    var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
      __assign = Object.assign || function(t4) {
        for (var s2, i3 = 1, n4 = arguments.length; i3 < n4; i3++) {
          s2 = arguments[i3];
          for (var p3 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p3))
              t4[p3] = s2[p3];
        }
        return t4;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
      var _23 = {label: 0, sent: function() {
        if (t4[0] & 1)
          throw t4[1];
        return t4[1];
      }, trys: [], ops: []}, f3, y4, t4, g3;
      return g3 = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
        return this;
      }), g3;
      function verb(n4) {
        return function(v3) {
          return step([n4, v3]);
        };
      }
      function step(op) {
        if (f3)
          throw new TypeError("Generator is already executing.");
        while (_23)
          try {
            if (f3 = 1, y4 && (t4 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t4 = y4["return"]) && t4.call(y4), 0) : y4.next) && !(t4 = t4.call(y4, op[1])).done)
              return t4;
            if (y4 = 0, t4)
              op = [op[0] & 2, t4.value];
            switch (op[0]) {
              case 0:
              case 1:
                t4 = op;
                break;
              case 4:
                _23.label++;
                return {value: op[1], done: false};
              case 5:
                _23.label++;
                y4 = op[1];
                op = [0];
                continue;
              case 7:
                op = _23.ops.pop();
                _23.trys.pop();
                continue;
              default:
                if (!(t4 = _23.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _23 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t4 || op[1] > t4[0] && op[1] < t4[3])) {
                  _23.label = op[1];
                  break;
                }
                if (op[0] === 6 && _23.label < t4[1]) {
                  _23.label = t4[1];
                  t4 = op;
                  break;
                }
                if (t4 && _23.label < t4[2]) {
                  _23.label = t4[2];
                  _23.ops.push(op);
                  break;
                }
                if (t4[2])
                  _23.ops.pop();
                _23.trys.pop();
                continue;
            }
            op = body.call(thisArg, _23);
          } catch (e3) {
            op = [6, e3];
            y4 = 0;
          } finally {
            f3 = t4 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {value: op[0] ? op[1] : void 0, done: true};
      }
    };
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    exports2.__esModule = true;
    exports2.getToken = void 0;
    var axios_12 = __importDefault(axios$1);
    var camelize_1 = __importDefault(camelize);
    var query_string_1 = __importDefault(queryString);
    exports2.getToken = function(settings) {
      return __awaiter2(void 0, void 0, void 0, function() {
        var baseUrl, realmName, url, credentials, payload, config2, data;
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              baseUrl = settings.baseUrl || constants.defaultBaseUrl;
              realmName = settings.realmName || constants.defaultRealm;
              url = baseUrl + "/realms/" + realmName + "/protocol/openid-connect/token";
              credentials = settings.credentials || {};
              payload = query_string_1["default"].stringify(__assign(__assign({username: credentials.username, password: credentials.password, grant_type: credentials.grantType, client_id: credentials.clientId, totp: credentials.totp}, credentials.offlineToken ? {scope: "offline_access"} : {}), credentials.refreshToken ? {
                refresh_token: credentials.refreshToken,
                client_secret: credentials.clientSecret
              } : {}));
              config2 = __assign({}, settings.requestConfig);
              if (credentials.clientSecret) {
                config2.auth = {
                  username: credentials.clientId,
                  password: credentials.clientSecret
                };
              }
              return [4, axios_12["default"].post(url, payload, config2)];
            case 1:
              data = _a.sent().data;
              return [2, camelize_1["default"](data)];
          }
        });
      });
    };
  });
  var urlJoin = createCommonjsModule(function(module2) {
    (function(name, context2, definition) {
      if (module2.exports)
        module2.exports = definition();
      else
        context2[name] = definition();
    })("urljoin", commonjsGlobal, function() {
      function normalize2(strArray) {
        var resultArray = [];
        if (strArray.length === 0) {
          return "";
        }
        if (typeof strArray[0] !== "string") {
          throw new TypeError("Url must be a string. Received " + strArray[0]);
        }
        if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
          var first = strArray.shift();
          strArray[0] = first + strArray[0];
        }
        if (strArray[0].match(/^file:\/\/\//)) {
          strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1:///");
        } else {
          strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1://");
        }
        for (var i3 = 0; i3 < strArray.length; i3++) {
          var component = strArray[i3];
          if (typeof component !== "string") {
            throw new TypeError("Url must be a string. Received " + component);
          }
          if (component === "") {
            continue;
          }
          if (i3 > 0) {
            component = component.replace(/^[\/]+/, "");
          }
          if (i3 < strArray.length - 1) {
            component = component.replace(/[\/]+$/, "");
          } else {
            component = component.replace(/[\/]+$/, "/");
          }
          resultArray.push(component);
        }
        var str = resultArray.join("/");
        str = str.replace(/\/(\?|&|#[^!])/g, "$1");
        var parts = str.split("?");
        str = parts.shift() + (parts.length > 0 ? "?" : "") + parts.join("&");
        return str;
      }
      return function() {
        var input;
        if (typeof arguments[0] === "object") {
          input = arguments[0];
        } else {
          input = [].slice.call(arguments);
        }
        return normalize2(input);
      };
    });
  });
  var urlTemplate = createCommonjsModule(function(module2, exports2) {
    (function(root3, factory) {
      {
        module2.exports = factory();
      }
    })(commonjsGlobal, function() {
      function UrlTemplate() {
      }
      UrlTemplate.prototype.encodeReserved = function(str) {
        return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
          if (!/%[0-9A-Fa-f]/.test(part)) {
            part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
          }
          return part;
        }).join("");
      };
      UrlTemplate.prototype.encodeUnreserved = function(str) {
        return encodeURIComponent(str).replace(/[!'()*]/g, function(c4) {
          return "%" + c4.charCodeAt(0).toString(16).toUpperCase();
        });
      };
      UrlTemplate.prototype.encodeValue = function(operator, value, key) {
        value = operator === "+" || operator === "#" ? this.encodeReserved(value) : this.encodeUnreserved(value);
        if (key) {
          return this.encodeUnreserved(key) + "=" + value;
        } else {
          return value;
        }
      };
      UrlTemplate.prototype.isDefined = function(value) {
        return value !== void 0 && value !== null;
      };
      UrlTemplate.prototype.isKeyOperator = function(operator) {
        return operator === ";" || operator === "&" || operator === "?";
      };
      UrlTemplate.prototype.getValues = function(context2, operator, key, modifier) {
        var value = context2[key], result = [];
        if (this.isDefined(value) && value !== "") {
          if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
            value = value.toString();
            if (modifier && modifier !== "*") {
              value = value.substring(0, parseInt(modifier, 10));
            }
            result.push(this.encodeValue(operator, value, this.isKeyOperator(operator) ? key : null));
          } else {
            if (modifier === "*") {
              if (Array.isArray(value)) {
                value.filter(this.isDefined).forEach(function(value2) {
                  result.push(this.encodeValue(operator, value2, this.isKeyOperator(operator) ? key : null));
                }, this);
              } else {
                Object.keys(value).forEach(function(k3) {
                  if (this.isDefined(value[k3])) {
                    result.push(this.encodeValue(operator, value[k3], k3));
                  }
                }, this);
              }
            } else {
              var tmp = [];
              if (Array.isArray(value)) {
                value.filter(this.isDefined).forEach(function(value2) {
                  tmp.push(this.encodeValue(operator, value2));
                }, this);
              } else {
                Object.keys(value).forEach(function(k3) {
                  if (this.isDefined(value[k3])) {
                    tmp.push(this.encodeUnreserved(k3));
                    tmp.push(this.encodeValue(operator, value[k3].toString()));
                  }
                }, this);
              }
              if (this.isKeyOperator(operator)) {
                result.push(this.encodeUnreserved(key) + "=" + tmp.join(","));
              } else if (tmp.length !== 0) {
                result.push(tmp.join(","));
              }
            }
          }
        } else {
          if (operator === ";") {
            if (this.isDefined(value)) {
              result.push(this.encodeUnreserved(key));
            }
          } else if (value === "" && (operator === "&" || operator === "?")) {
            result.push(this.encodeUnreserved(key) + "=");
          } else if (value === "") {
            result.push("");
          }
        }
        return result;
      };
      UrlTemplate.prototype.parse = function(template) {
        var that = this;
        var operators = ["+", "#", ".", "/", ";", "?", "&"];
        return {
          expand: function(context2) {
            return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_23, expression, literal) {
              if (expression) {
                var operator = null, values2 = [];
                if (operators.indexOf(expression.charAt(0)) !== -1) {
                  operator = expression.charAt(0);
                  expression = expression.substr(1);
                }
                expression.split(/,/g).forEach(function(variable) {
                  var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
                  values2.push.apply(values2, that.getValues(context2, operator, tmp[1], tmp[2] || tmp[3]));
                });
                if (operator && operator !== "+") {
                  var separator = ",";
                  if (operator === "?") {
                    separator = "&";
                  } else if (operator !== "#") {
                    separator = operator;
                  }
                  return (values2.length !== 0 ? operator : "") + values2.join(separator);
                } else {
                  return values2.join(",");
                }
              } else {
                return that.encodeReserved(literal);
              }
            });
          }
        };
      };
      return new UrlTemplate();
    });
  });
  var agent = createCommonjsModule(function(module2, exports2) {
    var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
      __assign = Object.assign || function(t4) {
        for (var s2, i3 = 1, n4 = arguments.length; i3 < n4; i3++) {
          s2 = arguments[i3];
          for (var p3 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p3))
              t4[p3] = s2[p3];
        }
        return t4;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
      var _23 = {label: 0, sent: function() {
        if (t4[0] & 1)
          throw t4[1];
        return t4[1];
      }, trys: [], ops: []}, f3, y4, t4, g3;
      return g3 = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
        return this;
      }), g3;
      function verb(n4) {
        return function(v3) {
          return step([n4, v3]);
        };
      }
      function step(op) {
        if (f3)
          throw new TypeError("Generator is already executing.");
        while (_23)
          try {
            if (f3 = 1, y4 && (t4 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t4 = y4["return"]) && t4.call(y4), 0) : y4.next) && !(t4 = t4.call(y4, op[1])).done)
              return t4;
            if (y4 = 0, t4)
              op = [op[0] & 2, t4.value];
            switch (op[0]) {
              case 0:
              case 1:
                t4 = op;
                break;
              case 4:
                _23.label++;
                return {value: op[1], done: false};
              case 5:
                _23.label++;
                y4 = op[1];
                op = [0];
                continue;
              case 7:
                op = _23.ops.pop();
                _23.trys.pop();
                continue;
              default:
                if (!(t4 = _23.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _23 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t4 || op[1] > t4[0] && op[1] < t4[3])) {
                  _23.label = op[1];
                  break;
                }
                if (op[0] === 6 && _23.label < t4[1]) {
                  _23.label = t4[1];
                  t4 = op;
                  break;
                }
                if (t4 && _23.label < t4[2]) {
                  _23.label = t4[2];
                  _23.ops.push(op);
                  break;
                }
                if (t4[2])
                  _23.ops.pop();
                _23.trys.pop();
                continue;
            }
            op = body.call(thisArg, _23);
          } catch (e3) {
            op = [6, e3];
            y4 = 0;
          } finally {
            f3 = t4 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {value: op[0] ? op[1] : void 0, done: true};
      }
    };
    var __spreadArrays = commonjsGlobal && commonjsGlobal.__spreadArrays || function() {
      for (var s2 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
        s2 += arguments[i3].length;
      for (var r4 = Array(s2), k3 = 0, i3 = 0; i3 < il; i3++)
        for (var a2 = arguments[i3], j = 0, jl = a2.length; j < jl; j++, k3++)
          r4[k3] = a2[j];
      return r4;
    };
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    exports2.__esModule = true;
    exports2.Agent = void 0;
    var url_join_1 = __importDefault(urlJoin);
    var url_template_1 = __importDefault(urlTemplate);
    var axios_12 = __importDefault(axios$1);
    var query_string_1 = __importDefault(queryString);
    var SLASH = "/";
    var Agent = function() {
      function Agent2(_a) {
        var client2 = _a.client, _b = _a.path, path = _b === void 0 ? "/" : _b, _c = _a.getUrlParams, getUrlParams = _c === void 0 ? function() {
          return {};
        } : _c, _d = _a.getBaseUrl, getBaseUrl2 = _d === void 0 ? function() {
          return client2.baseUrl;
        } : _d;
        this.client = client2;
        this.getBaseParams = getUrlParams;
        this.getBaseUrl = getBaseUrl2;
        this.basePath = path;
      }
      Agent2.prototype.request = function(_a) {
        var _this = this;
        var method = _a.method, _b = _a.path, path = _b === void 0 ? "" : _b, _c = _a.urlParamKeys, urlParamKeys = _c === void 0 ? [] : _c, _d = _a.queryParamKeys, queryParamKeys = _d === void 0 ? [] : _d, _e = _a.catchNotFound, catchNotFound = _e === void 0 ? false : _e, keyTransform = _a.keyTransform, payloadKey = _a.payloadKey, returnResourceIdInLocationHeader = _a.returnResourceIdInLocationHeader;
        return function(payload) {
          if (payload === void 0) {
            payload = {};
          }
          return __awaiter2(_this, void 0, void 0, function() {
            var baseParams, queryParams, allUrlParamKeys, urlParams;
            return __generator2(this, function(_a2) {
              baseParams = this.getBaseParams();
              queryParams = queryParamKeys ? lodash.pick(payload, queryParamKeys) : null;
              allUrlParamKeys = __spreadArrays(Object.keys(baseParams), urlParamKeys);
              urlParams = __assign(__assign({}, baseParams), lodash.pick(payload, allUrlParamKeys));
              payload = lodash.omit(payload, __spreadArrays(allUrlParamKeys, queryParamKeys));
              if (keyTransform) {
                this.transformKey(payload, keyTransform);
                this.transformKey(queryParams, keyTransform);
              }
              return [2, this.requestWithParams({
                method,
                path,
                payload,
                urlParams,
                queryParams,
                catchNotFound,
                payloadKey,
                returnResourceIdInLocationHeader
              })];
            });
          });
        };
      };
      Agent2.prototype.updateRequest = function(_a) {
        var _this = this;
        var method = _a.method, _b = _a.path, path = _b === void 0 ? "" : _b, _c = _a.urlParamKeys, urlParamKeys = _c === void 0 ? [] : _c, _d = _a.queryParamKeys, queryParamKeys = _d === void 0 ? [] : _d, _e = _a.catchNotFound, catchNotFound = _e === void 0 ? false : _e, keyTransform = _a.keyTransform, payloadKey = _a.payloadKey, returnResourceIdInLocationHeader = _a.returnResourceIdInLocationHeader;
        return function(query, payload) {
          if (query === void 0) {
            query = {};
          }
          if (payload === void 0) {
            payload = {};
          }
          return __awaiter2(_this, void 0, void 0, function() {
            var baseParams, queryParams, allUrlParamKeys, urlParams;
            return __generator2(this, function(_a2) {
              baseParams = this.getBaseParams();
              queryParams = queryParamKeys ? lodash.pick(query, queryParamKeys) : null;
              allUrlParamKeys = __spreadArrays(Object.keys(baseParams), urlParamKeys);
              urlParams = __assign(__assign({}, baseParams), lodash.pick(query, allUrlParamKeys));
              if (keyTransform) {
                this.transformKey(queryParams, keyTransform);
              }
              return [2, this.requestWithParams({
                method,
                path,
                payload,
                urlParams,
                queryParams,
                catchNotFound,
                payloadKey,
                returnResourceIdInLocationHeader
              })];
            });
          });
        };
      };
      Agent2.prototype.requestWithParams = function(_a) {
        var method = _a.method, path = _a.path, payload = _a.payload, urlParams = _a.urlParams, queryParams = _a.queryParams, catchNotFound = _a.catchNotFound, payloadKey = _a.payloadKey, returnResourceIdInLocationHeader = _a.returnResourceIdInLocationHeader;
        return __awaiter2(this, void 0, void 0, function() {
          var newPath, pathTemplate, parsedPath, url, requestConfig, _b, _c, _d, res, locationHeader, resourceId, field, err_1;
          var _e, _f;
          return __generator2(this, function(_g) {
            switch (_g.label) {
              case 0:
                newPath = url_join_1["default"](this.basePath, path);
                pathTemplate = url_template_1["default"].parse(newPath);
                parsedPath = pathTemplate.expand(urlParams);
                url = "" + this.getBaseUrl() + parsedPath;
                requestConfig = __assign(__assign({paramsSerializer: function(params) {
                  return query_string_1["default"].stringify(params);
                }}, this.client.getRequestConfig() || {}), {
                  method,
                  url
                });
                _b = requestConfig;
                _c = [__assign({}, requestConfig.headers)];
                _e = {};
                _d = "bearer ";
                return [4, this.client.getAccessToken()];
              case 1:
                _b.headers = __assign.apply(void 0, _c.concat([(_e.Authorization = _d + _g.sent(), _e)]));
                if (method === "GET") {
                  requestConfig.params = payload;
                } else {
                  requestConfig.data = payloadKey ? payload[payloadKey] : payload;
                }
                if (queryParams) {
                  requestConfig.params = requestConfig.params ? __assign(__assign({}, requestConfig.params), queryParams) : queryParams;
                }
                _g.label = 2;
              case 2:
                _g.trys.push([2, 4, , 5]);
                return [4, axios_12["default"](requestConfig)];
              case 3:
                res = _g.sent();
                if (returnResourceIdInLocationHeader) {
                  locationHeader = res.headers.location;
                  if (!locationHeader) {
                    throw new Error("location header is not found in request: " + res.config.url);
                  }
                  resourceId = lodash.last(locationHeader.split(SLASH));
                  if (!resourceId) {
                    throw new Error("resourceId is not found in Location header from request: " + res.config.url);
                  }
                  field = returnResourceIdInLocationHeader.field;
                  return [2, (_f = {}, _f[field] = resourceId, _f)];
                }
                return [2, res.data];
              case 4:
                err_1 = _g.sent();
                if (err_1.response && err_1.response.status === 404 && catchNotFound) {
                  return [2, null];
                }
                throw err_1;
              case 5:
                return [2];
            }
          });
        });
      };
      Agent2.prototype.transformKey = function(payload, keyMapping) {
        if (!payload) {
          return;
        }
        Object.keys(keyMapping).some(function(key) {
          if (lodash.isUndefined(payload[key])) {
            return false;
          }
          var newKey = keyMapping[key];
          payload[newKey] = payload[key];
          delete payload[key];
        });
      };
      return Agent2;
    }();
    exports2.Agent = Agent;
  });
  var resource = createCommonjsModule(function(module2, exports2) {
    var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
      __assign = Object.assign || function(t4) {
        for (var s2, i3 = 1, n4 = arguments.length; i3 < n4; i3++) {
          s2 = arguments[i3];
          for (var p3 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p3))
              t4[p3] = s2[p3];
        }
        return t4;
      };
      return __assign.apply(this, arguments);
    };
    exports2.__esModule = true;
    var Resource = function() {
      function Resource2(client2, settings) {
        var _this = this;
        if (settings === void 0) {
          settings = {};
        }
        this.makeRequest = function(args) {
          return _this.agent.request(args);
        };
        this.makeUpdateRequest = function(args) {
          return _this.agent.updateRequest(args);
        };
        this.agent = new agent.Agent(__assign({client: client2}, settings));
      }
      return Resource2;
    }();
    exports2["default"] = Resource;
  });
  var cache = createCommonjsModule(function(module2, exports2) {
    var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
      var extendStatics = function(d3, b3) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p3 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p3))
              d4[p3] = b4[p3];
        };
        return extendStatics(d3, b3);
      };
      return function(d3, b3) {
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    exports2.__esModule = true;
    exports2.Cache = void 0;
    var resource_1 = __importDefault(resource);
    var Cache = function(_super) {
      __extends(Cache2, _super);
      function Cache2(client2) {
        var _this = _super.call(this, client2, {
          path: "/admin/realms/{realm}",
          getUrlParams: function() {
            return {
              realm: client2.realmName
            };
          },
          getBaseUrl: function() {
            return client2.baseUrl;
          }
        }) || this;
        _this.clearUserCache = _this.makeRequest({
          method: "POST",
          path: "/clear-user-cache"
        });
        return _this;
      }
      return Cache2;
    }(resource_1["default"]);
    exports2.Cache = Cache;
  });
  var users = createCommonjsModule(function(module2, exports2) {
    var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
      var extendStatics = function(d3, b3) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p3 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p3))
              d4[p3] = b4[p3];
        };
        return extendStatics(d3, b3);
      };
      return function(d3, b3) {
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    exports2.__esModule = true;
    exports2.Users = void 0;
    var resource_1 = __importDefault(resource);
    var Users = function(_super) {
      __extends(Users2, _super);
      function Users2(client2) {
        var _this = _super.call(this, client2, {
          path: "/admin/realms/{realm}/users",
          getUrlParams: function() {
            return {
              realm: client2.realmName
            };
          },
          getBaseUrl: function() {
            return client2.baseUrl;
          }
        }) || this;
        _this.find = _this.makeRequest({
          method: "GET"
        });
        _this.create = _this.makeRequest({
          method: "POST",
          returnResourceIdInLocationHeader: {field: "id"}
        });
        _this.findOne = _this.makeRequest({
          method: "GET",
          path: "/{id}",
          urlParamKeys: ["id"],
          catchNotFound: true
        });
        _this.update = _this.makeUpdateRequest({
          method: "PUT",
          path: "/{id}",
          urlParamKeys: ["id"]
        });
        _this.del = _this.makeRequest({
          method: "DELETE",
          path: "/{id}",
          urlParamKeys: ["id"]
        });
        _this.count = _this.makeRequest({
          method: "GET",
          path: "/count"
        });
        _this.listRoleMappings = _this.makeRequest({
          method: "GET",
          path: "/{id}/role-mappings",
          urlParamKeys: ["id"]
        });
        _this.addRealmRoleMappings = _this.makeRequest({
          method: "POST",
          path: "/{id}/role-mappings/realm",
          urlParamKeys: ["id"],
          payloadKey: "roles"
        });
        _this.listRealmRoleMappings = _this.makeRequest({
          method: "GET",
          path: "/{id}/role-mappings/realm",
          urlParamKeys: ["id"]
        });
        _this.delRealmRoleMappings = _this.makeRequest({
          method: "DELETE",
          path: "/{id}/role-mappings/realm",
          urlParamKeys: ["id"],
          payloadKey: "roles"
        });
        _this.listAvailableRealmRoleMappings = _this.makeRequest({
          method: "GET",
          path: "/{id}/role-mappings/realm/available",
          urlParamKeys: ["id"]
        });
        _this.listCompositeRealmRoleMappings = _this.makeRequest({
          method: "GET",
          path: "/{id}/role-mappings/realm/composite",
          urlParamKeys: ["id"]
        });
        _this.listClientRoleMappings = _this.makeRequest({
          method: "GET",
          path: "/{id}/role-mappings/clients/{clientUniqueId}",
          urlParamKeys: ["id", "clientUniqueId"]
        });
        _this.addClientRoleMappings = _this.makeRequest({
          method: "POST",
          path: "/{id}/role-mappings/clients/{clientUniqueId}",
          urlParamKeys: ["id", "clientUniqueId"],
          payloadKey: "roles"
        });
        _this.delClientRoleMappings = _this.makeRequest({
          method: "DELETE",
          path: "/{id}/role-mappings/clients/{clientUniqueId}",
          urlParamKeys: ["id", "clientUniqueId"],
          payloadKey: "roles"
        });
        _this.listAvailableClientRoleMappings = _this.makeRequest({
          method: "GET",
          path: "/{id}/role-mappings/clients/{clientUniqueId}/available",
          urlParamKeys: ["id", "clientUniqueId"]
        });
        _this.listCompositeClientRoleMappings = _this.makeRequest({
          method: "GET",
          path: "/{id}/role-mappings/clients/{clientUniqueId}/composite",
          urlParamKeys: ["id", "clientUniqueId"]
        });
        _this.executeActionsEmail = _this.makeRequest({
          method: "PUT",
          path: "/{id}/execute-actions-email",
          urlParamKeys: ["id"],
          payloadKey: "actions",
          queryParamKeys: ["lifespan", "redirectUri", "clientId"],
          keyTransform: {
            clientId: "client_id",
            redirectUri: "redirect_uri"
          }
        });
        _this.listGroups = _this.makeRequest({
          method: "GET",
          path: "/{id}/groups",
          urlParamKeys: ["id"]
        });
        _this.addToGroup = _this.makeRequest({
          method: "PUT",
          path: "/{id}/groups/{groupId}",
          urlParamKeys: ["id", "groupId"]
        });
        _this.delFromGroup = _this.makeRequest({
          method: "DELETE",
          path: "/{id}/groups/{groupId}",
          urlParamKeys: ["id", "groupId"]
        });
        _this.countGroups = _this.makeRequest({
          method: "GET",
          path: "/{id}/groups/count",
          urlParamKeys: ["id"]
        });
        _this.listFederatedIdentities = _this.makeRequest({
          method: "GET",
          path: "/{id}/federated-identity",
          urlParamKeys: ["id"]
        });
        _this.addToFederatedIdentity = _this.makeRequest({
          method: "POST",
          path: "/{id}/federated-identity/{federatedIdentityId}",
          urlParamKeys: ["id", "federatedIdentityId"],
          payloadKey: "federatedIdentity"
        });
        _this.delFromFederatedIdentity = _this.makeRequest({
          method: "DELETE",
          path: "/{id}/federated-identity/{federatedIdentityId}",
          urlParamKeys: ["id", "federatedIdentityId"]
        });
        _this.removeTotp = _this.makeRequest({
          method: "PUT",
          path: "/{id}/remove-totp",
          urlParamKeys: ["id"]
        });
        _this.resetPassword = _this.makeRequest({
          method: "PUT",
          path: "/{id}/reset-password",
          urlParamKeys: ["id"],
          payloadKey: "credential"
        });
        _this.sendVerifyEmail = _this.makeRequest({
          method: "PUT",
          path: "/{id}/send-verify-email",
          urlParamKeys: ["id"],
          queryParamKeys: ["clientId", "redirectUri"],
          keyTransform: {
            clientId: "client_id",
            redirectUri: "redirect_uri"
          }
        });
        _this.listSessions = _this.makeRequest({
          method: "GET",
          path: "/{id}/sessions",
          urlParamKeys: ["id"]
        });
        _this.listOfflineSessions = _this.makeRequest({
          method: "GET",
          path: "/{id}/offline-sessions/{clientId}",
          urlParamKeys: ["id", "clientId"]
        });
        _this.logout = _this.makeRequest({
          method: "POST",
          path: "/{id}/logout",
          urlParamKeys: ["id"]
        });
        _this.listConsents = _this.makeRequest({
          method: "GET",
          path: "/{id}/consents",
          urlParamKeys: ["id"]
        });
        _this.revokeConsent = _this.makeRequest({
          method: "DELETE",
          path: "/{id}/consents/{clientId}",
          urlParamKeys: ["id", "clientId"]
        });
        return _this;
      }
      return Users2;
    }(resource_1["default"]);
    exports2.Users = Users;
  });
  var groups = createCommonjsModule(function(module2, exports2) {
    var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
      var extendStatics = function(d3, b3) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p3 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p3))
              d4[p3] = b4[p3];
        };
        return extendStatics(d3, b3);
      };
      return function(d3, b3) {
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    exports2.__esModule = true;
    exports2.Groups = void 0;
    var resource_1 = __importDefault(resource);
    var Groups = function(_super) {
      __extends(Groups2, _super);
      function Groups2(client2) {
        var _this = _super.call(this, client2, {
          path: "/admin/realms/{realm}/groups",
          getUrlParams: function() {
            return {
              realm: client2.realmName
            };
          },
          getBaseUrl: function() {
            return client2.baseUrl;
          }
        }) || this;
        _this.find = _this.makeRequest({
          method: "GET"
        });
        _this.create = _this.makeRequest({
          method: "POST",
          returnResourceIdInLocationHeader: {field: "id"}
        });
        _this.findOne = _this.makeRequest({
          method: "GET",
          path: "/{id}",
          urlParamKeys: ["id"],
          catchNotFound: true
        });
        _this.update = _this.makeUpdateRequest({
          method: "PUT",
          path: "/{id}",
          urlParamKeys: ["id"]
        });
        _this.del = _this.makeRequest({
          method: "DELETE",
          path: "/{id}",
          urlParamKeys: ["id"]
        });
        _this.count = _this.makeRequest({
          method: "GET",
          path: "/count"
        });
        _this.setOrCreateChild = _this.makeUpdateRequest({
          method: "POST",
          path: "/{id}/children",
          urlParamKeys: ["id"],
          returnResourceIdInLocationHeader: {field: "id"}
        });
        _this.listMembers = _this.makeRequest({
          method: "GET",
          path: "/{id}/members",
          urlParamKeys: ["id"],
          catchNotFound: true
        });
        _this.listRoleMappings = _this.makeRequest({
          method: "GET",
          path: "/{id}/role-mappings",
          urlParamKeys: ["id"]
        });
        _this.addRealmRoleMappings = _this.makeRequest({
          method: "POST",
          path: "/{id}/role-mappings/realm",
          urlParamKeys: ["id"],
          payloadKey: "roles"
        });
        _this.listRealmRoleMappings = _this.makeRequest({
          method: "GET",
          path: "/{id}/role-mappings/realm",
          urlParamKeys: ["id"]
        });
        _this.delRealmRoleMappings = _this.makeRequest({
          method: "DELETE",
          path: "/{id}/role-mappings/realm",
          urlParamKeys: ["id"],
          payloadKey: "roles"
        });
        _this.listAvailableRealmRoleMappings = _this.makeRequest({
          method: "GET",
          path: "/{id}/role-mappings/realm/available",
          urlParamKeys: ["id"]
        });
        _this.listClientRoleMappings = _this.makeRequest({
          method: "GET",
          path: "/{id}/role-mappings/clients/{clientUniqueId}",
          urlParamKeys: ["id", "clientUniqueId"]
        });
        _this.addClientRoleMappings = _this.makeRequest({
          method: "POST",
          path: "/{id}/role-mappings/clients/{clientUniqueId}",
          urlParamKeys: ["id", "clientUniqueId"],
          payloadKey: "roles"
        });
        _this.delClientRoleMappings = _this.makeRequest({
          method: "DELETE",
          path: "/{id}/role-mappings/clients/{clientUniqueId}",
          urlParamKeys: ["id", "clientUniqueId"],
          payloadKey: "roles"
        });
        _this.listAvailableClientRoleMappings = _this.makeRequest({
          method: "GET",
          path: "/{id}/role-mappings/clients/{clientUniqueId}/available",
          urlParamKeys: ["id", "clientUniqueId"]
        });
        _this.updatePermission = _this.makeUpdateRequest({
          method: "PUT",
          path: "/{id}/management/permissions",
          urlParamKeys: ["id"]
        });
        _this.listPermissions = _this.makeRequest({
          method: "GET",
          path: "/{id}/management/permissions",
          urlParamKeys: ["id"]
        });
        return _this;
      }
      return Groups2;
    }(resource_1["default"]);
    exports2.Groups = Groups;
  });
  var roles = createCommonjsModule(function(module2, exports2) {
    var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
      var extendStatics = function(d3, b3) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p3 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p3))
              d4[p3] = b4[p3];
        };
        return extendStatics(d3, b3);
      };
      return function(d3, b3) {
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    exports2.__esModule = true;
    exports2.Roles = void 0;
    var resource_1 = __importDefault(resource);
    var Roles = function(_super) {
      __extends(Roles2, _super);
      function Roles2(client2) {
        var _this = _super.call(this, client2, {
          path: "/admin/realms/{realm}",
          getUrlParams: function() {
            return {
              realm: client2.realmName
            };
          },
          getBaseUrl: function() {
            return client2.baseUrl;
          }
        }) || this;
        _this.find = _this.makeRequest({
          method: "GET",
          path: "/roles"
        });
        _this.create = _this.makeRequest({
          method: "POST",
          path: "/roles",
          returnResourceIdInLocationHeader: {field: "roleName"}
        });
        _this.findOneByName = _this.makeRequest({
          method: "GET",
          path: "/roles/{name}",
          urlParamKeys: ["name"],
          catchNotFound: true
        });
        _this.updateByName = _this.makeUpdateRequest({
          method: "PUT",
          path: "/roles/{name}",
          urlParamKeys: ["name"]
        });
        _this.delByName = _this.makeRequest({
          method: "DELETE",
          path: "/roles/{name}",
          urlParamKeys: ["name"]
        });
        _this.findUsersWithRole = _this.makeRequest({
          method: "GET",
          path: "/roles/{name}/users",
          urlParamKeys: ["name"],
          catchNotFound: true
        });
        _this.findOneById = _this.makeRequest({
          method: "GET",
          path: "/roles-by-id/{id}",
          urlParamKeys: ["id"],
          catchNotFound: true
        });
        _this.createComposite = _this.makeUpdateRequest({
          method: "POST",
          path: "/roles-by-id/{roleId}/composites",
          urlParamKeys: ["roleId"]
        });
        _this.getCompositeRoles = _this.makeRequest({
          method: "GET",
          path: "/roles-by-id/{id}/composites",
          urlParamKeys: ["id"]
        });
        _this.getCompositeRolesForRealm = _this.makeRequest({
          method: "GET",
          path: "/roles-by-id/{id}/composites/realm",
          urlParamKeys: ["id"]
        });
        _this.getCompositeRolesForClient = _this.makeRequest({
          method: "GET",
          path: "/roles-by-id/{id}/composites/clients/{clientId}",
          urlParamKeys: ["id", "clientId"]
        });
        _this.delCompositeRoles = _this.makeUpdateRequest({
          method: "DELETE",
          path: "/roles-by-id/{id}/composites",
          urlParamKeys: ["id"]
        });
        _this.updateById = _this.makeUpdateRequest({
          method: "PUT",
          path: "/roles-by-id/{id}",
          urlParamKeys: ["id"]
        });
        _this.delById = _this.makeRequest({
          method: "DELETE",
          path: "/roles-by-id/{id}",
          urlParamKeys: ["id"]
        });
        return _this;
      }
      return Roles2;
    }(resource_1["default"]);
    exports2.Roles = Roles;
  });
  var clients = createCommonjsModule(function(module2, exports2) {
    var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
      var extendStatics = function(d3, b3) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p3 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p3))
              d4[p3] = b4[p3];
        };
        return extendStatics(d3, b3);
      };
      return function(d3, b3) {
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
      __assign = Object.assign || function(t4) {
        for (var s2, i3 = 1, n4 = arguments.length; i3 < n4; i3++) {
          s2 = arguments[i3];
          for (var p3 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p3))
              t4[p3] = s2[p3];
        }
        return t4;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
      var _23 = {label: 0, sent: function() {
        if (t4[0] & 1)
          throw t4[1];
        return t4[1];
      }, trys: [], ops: []}, f3, y4, t4, g3;
      return g3 = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
        return this;
      }), g3;
      function verb(n4) {
        return function(v3) {
          return step([n4, v3]);
        };
      }
      function step(op) {
        if (f3)
          throw new TypeError("Generator is already executing.");
        while (_23)
          try {
            if (f3 = 1, y4 && (t4 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t4 = y4["return"]) && t4.call(y4), 0) : y4.next) && !(t4 = t4.call(y4, op[1])).done)
              return t4;
            if (y4 = 0, t4)
              op = [op[0] & 2, t4.value];
            switch (op[0]) {
              case 0:
              case 1:
                t4 = op;
                break;
              case 4:
                _23.label++;
                return {value: op[1], done: false};
              case 5:
                _23.label++;
                y4 = op[1];
                op = [0];
                continue;
              case 7:
                op = _23.ops.pop();
                _23.trys.pop();
                continue;
              default:
                if (!(t4 = _23.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _23 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t4 || op[1] > t4[0] && op[1] < t4[3])) {
                  _23.label = op[1];
                  break;
                }
                if (op[0] === 6 && _23.label < t4[1]) {
                  _23.label = t4[1];
                  t4 = op;
                  break;
                }
                if (t4 && _23.label < t4[2]) {
                  _23.label = t4[2];
                  _23.ops.push(op);
                  break;
                }
                if (t4[2])
                  _23.ops.pop();
                _23.trys.pop();
                continue;
            }
            op = body.call(thisArg, _23);
          } catch (e3) {
            op = [6, e3];
            y4 = 0;
          } finally {
            f3 = t4 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {value: op[0] ? op[1] : void 0, done: true};
      }
    };
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    exports2.__esModule = true;
    exports2.Clients = void 0;
    var resource_1 = __importDefault(resource);
    var Clients2 = function(_super) {
      __extends(Clients3, _super);
      function Clients3(client2) {
        var _this = _super.call(this, client2, {
          path: "/admin/realms/{realm}/clients",
          getUrlParams: function() {
            return {
              realm: client2.realmName
            };
          },
          getBaseUrl: function() {
            return client2.baseUrl;
          }
        }) || this;
        _this.find = _this.makeRequest({
          method: "GET"
        });
        _this.create = _this.makeRequest({
          method: "POST",
          returnResourceIdInLocationHeader: {field: "id"}
        });
        _this.findOne = _this.makeRequest({
          method: "GET",
          path: "/{id}",
          urlParamKeys: ["id"],
          catchNotFound: true
        });
        _this.update = _this.makeUpdateRequest({
          method: "PUT",
          path: "/{id}",
          urlParamKeys: ["id"]
        });
        _this.del = _this.makeRequest({
          method: "DELETE",
          path: "/{id}",
          urlParamKeys: ["id"]
        });
        _this.createRole = _this.makeRequest({
          method: "POST",
          path: "/{id}/roles",
          urlParamKeys: ["id"],
          returnResourceIdInLocationHeader: {field: "roleName"}
        });
        _this.listRoles = _this.makeRequest({
          method: "GET",
          path: "/{id}/roles",
          urlParamKeys: ["id"]
        });
        _this.findRole = _this.makeRequest({
          method: "GET",
          path: "/{id}/roles/{roleName}",
          urlParamKeys: ["id", "roleName"],
          catchNotFound: true
        });
        _this.updateRole = _this.makeUpdateRequest({
          method: "PUT",
          path: "/{id}/roles/{roleName}",
          urlParamKeys: ["id", "roleName"]
        });
        _this.delRole = _this.makeRequest({
          method: "DELETE",
          path: "/{id}/roles/{roleName}",
          urlParamKeys: ["id", "roleName"]
        });
        _this.findUsersWithRole = _this.makeRequest({
          method: "GET",
          path: "/{id}/roles/{roleName}/users",
          urlParamKeys: ["id", "roleName"]
        });
        _this.getServiceAccountUser = _this.makeRequest({
          method: "GET",
          path: "/{id}/service-account-user",
          urlParamKeys: ["id"]
        });
        _this.generateNewClientSecret = _this.makeRequest({
          method: "POST",
          path: "/{id}/client-secret",
          urlParamKeys: ["id"]
        });
        _this.generateRegistrationAccessToken = _this.makeRequest({
          method: "POST",
          path: "/{id}/registration-access-token",
          urlParamKeys: ["id"]
        });
        _this.getClientSecret = _this.makeRequest({
          method: "GET",
          path: "/{id}/client-secret",
          urlParamKeys: ["id"]
        });
        _this.listDefaultClientScopes = _this.makeRequest({
          method: "GET",
          path: "/{id}/default-client-scopes",
          urlParamKeys: ["id"]
        });
        _this.addDefaultClientScope = _this.makeRequest({
          method: "PUT",
          path: "/{id}/default-client-scopes/{clientScopeId}",
          urlParamKeys: ["id", "clientScopeId"]
        });
        _this.delDefaultClientScope = _this.makeRequest({
          method: "DELETE",
          path: "/{id}/default-client-scopes/{clientScopeId}",
          urlParamKeys: ["id", "clientScopeId"]
        });
        _this.listOptionalClientScopes = _this.makeRequest({
          method: "GET",
          path: "/{id}/optional-client-scopes",
          urlParamKeys: ["id"]
        });
        _this.addOptionalClientScope = _this.makeRequest({
          method: "PUT",
          path: "/{id}/optional-client-scopes/{clientScopeId}",
          urlParamKeys: ["id", "clientScopeId"]
        });
        _this.delOptionalClientScope = _this.makeRequest({
          method: "DELETE",
          path: "/{id}/optional-client-scopes/{clientScopeId}",
          urlParamKeys: ["id", "clientScopeId"]
        });
        _this.addMultipleProtocolMappers = _this.makeUpdateRequest({
          method: "POST",
          path: "/{id}/protocol-mappers/add-models",
          urlParamKeys: ["id"]
        });
        _this.addProtocolMapper = _this.makeUpdateRequest({
          method: "POST",
          path: "/{id}/protocol-mappers/models",
          urlParamKeys: ["id"]
        });
        _this.listProtocolMappers = _this.makeRequest({
          method: "GET",
          path: "/{id}/protocol-mappers/models",
          urlParamKeys: ["id"]
        });
        _this.findProtocolMapperById = _this.makeRequest({
          method: "GET",
          path: "/{id}/protocol-mappers/models/{mapperId}",
          urlParamKeys: ["id", "mapperId"],
          catchNotFound: true
        });
        _this.findProtocolMappersByProtocol = _this.makeRequest({
          method: "GET",
          path: "/{id}/protocol-mappers/protocol/{protocol}",
          urlParamKeys: ["id", "protocol"],
          catchNotFound: true
        });
        _this.updateProtocolMapper = _this.makeUpdateRequest({
          method: "PUT",
          path: "/{id}/protocol-mappers/models/{mapperId}",
          urlParamKeys: ["id", "mapperId"]
        });
        _this.delProtocolMapper = _this.makeRequest({
          method: "DELETE",
          path: "/{id}/protocol-mappers/models/{mapperId}",
          urlParamKeys: ["id", "mapperId"]
        });
        _this.listScopeMappings = _this.makeRequest({
          method: "GET",
          path: "/{id}/scope-mappings",
          urlParamKeys: ["id"]
        });
        _this.addClientScopeMappings = _this.makeUpdateRequest({
          method: "POST",
          path: "/{id}/scope-mappings/clients/{client}",
          urlParamKeys: ["id", "client"]
        });
        _this.listClientScopeMappings = _this.makeRequest({
          method: "GET",
          path: "/{id}/scope-mappings/clients/{client}",
          urlParamKeys: ["id", "client"]
        });
        _this.listAvailableClientScopeMappings = _this.makeRequest({
          method: "GET",
          path: "/{id}/scope-mappings/clients/{client}/available",
          urlParamKeys: ["id", "client"]
        });
        _this.listCompositeClientScopeMappings = _this.makeRequest({
          method: "GET",
          path: "/{id}/scope-mappings/clients/{client}/available",
          urlParamKeys: ["id", "client"]
        });
        _this.delClientScopeMappings = _this.makeUpdateRequest({
          method: "DELETE",
          path: "/{id}/scope-mappings/clients/{client}",
          urlParamKeys: ["id", "client"]
        });
        _this.evaluatePermission = _this.makeRequest({
          method: "GET",
          path: "/{id}/evaluate-scopes/scope-mappings/{roleContainer}/{type}",
          urlParamKeys: ["id", "roleContainer", "type"],
          queryParamKeys: ["scope"]
        });
        _this.evaluateListProtocolMapper = _this.makeRequest({
          method: "GET",
          path: "/{id}/evaluate-scopes/protocol-mappers",
          urlParamKeys: ["id"],
          queryParamKeys: ["scope"]
        });
        _this.evaluateGenerateAccessToken = _this.makeRequest({
          method: "GET",
          path: "/{id}/evaluate-scopes/generate-example-access-token",
          urlParamKeys: ["id"],
          queryParamKeys: ["scope", "userId"]
        });
        _this.addRealmScopeMappings = _this.makeUpdateRequest({
          method: "POST",
          path: "/{id}/scope-mappings/realm",
          urlParamKeys: ["id", "client"]
        });
        _this.listRealmScopeMappings = _this.makeRequest({
          method: "GET",
          path: "/{id}/scope-mappings/realm",
          urlParamKeys: ["id"]
        });
        _this.listAvailableRealmScopeMappings = _this.makeRequest({
          method: "GET",
          path: "/{id}/scope-mappings/realm/available",
          urlParamKeys: ["id"]
        });
        _this.listCompositeRealmScopeMappings = _this.makeRequest({
          method: "GET",
          path: "/{id}/scope-mappings/realm/available",
          urlParamKeys: ["id"]
        });
        _this.delRealmScopeMappings = _this.makeUpdateRequest({
          method: "DELETE",
          path: "/{id}/scope-mappings/realm",
          urlParamKeys: ["id"]
        });
        _this.listSessions = _this.makeRequest({
          method: "GET",
          path: "/{id}/user-sessions",
          urlParamKeys: ["id"]
        });
        _this.listOfflineSessions = _this.makeRequest({
          method: "GET",
          path: "/{id}/offline-sessions",
          urlParamKeys: ["id"]
        });
        _this.getSessionCount = _this.makeRequest({
          method: "GET",
          path: "/{id}/session-count",
          urlParamKeys: ["id"]
        });
        _this.listResources = _this.makeRequest({
          method: "GET",
          path: "{id}/authz/resource-server/resource",
          urlParamKeys: ["id"]
        });
        _this.createResource = _this.makeUpdateRequest({
          method: "POST",
          path: "{id}/authz/resource-server/resource",
          urlParamKeys: ["id"]
        });
        _this.updateResource = _this.makeUpdateRequest({
          method: "PUT",
          path: "/{id}/authz/resource-server/resource/{resourceId}",
          urlParamKeys: ["id", "resourceId"]
        });
        _this.delResource = _this.makeRequest({
          method: "DELETE",
          path: "/{id}/authz/resource-server/resource/{resourceId}",
          urlParamKeys: ["id", "resourceId"]
        });
        _this.evaluateResource = _this.makeUpdateRequest({
          method: "POST",
          path: "{id}/authz/resource-server/policy/evaluate",
          urlParamKeys: ["id"]
        });
        _this.listPolicies = _this.makeRequest({
          method: "GET",
          path: "{id}/authz/resource-server/policy",
          urlParamKeys: ["id"]
        });
        _this.findPolicyByName = _this.makeRequest({
          method: "GET",
          path: "{id}/authz/resource-server/policy/search",
          urlParamKeys: ["id"]
        });
        _this.updatePolicy = _this.makeUpdateRequest({
          method: "PUT",
          path: "/{id}/authz/resource-server/policy/{type}/{policyId}",
          urlParamKeys: ["id", "type", "policyId"]
        });
        _this.createPolicy = _this.makeUpdateRequest({
          method: "POST",
          path: "/{id}/authz/resource-server/policy/{type}",
          urlParamKeys: ["id", "type"]
        });
        _this.findOnePolicy = _this.makeRequest({
          method: "GET",
          path: "/{id}/authz/resource-server/policy/{type}/{policyId}",
          urlParamKeys: ["id", "type", "policyId"],
          catchNotFound: true
        });
        _this.delPolicy = _this.makeRequest({
          method: "DELETE",
          path: "{id}/authz/resource-server/policy/{policyId}",
          urlParamKeys: ["id", "policyId"]
        });
        _this.listAllScopes = _this.makeRequest({
          method: "GET",
          path: "/{id}/authz/resource-server/scope",
          urlParamKeys: ["id"]
        });
        _this.listScopesByResource = _this.makeRequest({
          method: "GET",
          path: "/{id}/authz/resource-server/resource/{resourceName}/scopes",
          urlParamKeys: ["id", "resourceName"]
        });
        _this.createAuthorizationScope = _this.makeUpdateRequest({
          method: "POST",
          path: "{id}/authz/resource-server/scope",
          urlParamKeys: ["id"]
        });
        _this.findPermissions = _this.makeRequest({
          method: "GET",
          path: "{id}/authz/resource-server/permission",
          urlParamKeys: ["id"]
        });
        _this.createPermission = _this.makeUpdateRequest({
          method: "POST",
          path: "/{id}/authz/resource-server/permission/{type}",
          urlParamKeys: ["id", "type"]
        });
        _this.updatePermission = _this.makeUpdateRequest({
          method: "PUT",
          path: "/{id}/authz/resource-server/permission/{type}/{permissionId}",
          urlParamKeys: ["id", "type", "permissionId"]
        });
        _this.delPermission = _this.makeRequest({
          method: "DELETE",
          path: "/{id}/authz/resource-server/permission/{type}/{permissionId}",
          urlParamKeys: ["id", "type", "permissionId"]
        });
        _this.findOnePermission = _this.makeRequest({
          method: "GET",
          path: "/{id}/authz/resource-server/permission/{type}/{permissionId}",
          urlParamKeys: ["id", "type", "permissionId"]
        });
        _this.getOfflineSessionCount = _this.makeRequest({
          method: "GET",
          path: "/{id}/offline-session-count",
          urlParamKeys: ["id"]
        });
        _this.getInstallationProviders = _this.makeRequest({
          method: "GET",
          path: "/{id}/installation/providers/{providerId}",
          urlParamKeys: ["id", "providerId"]
        });
        _this.pushRevocation = _this.makeRequest({
          method: "POST",
          path: "/{id}/push-revocation",
          urlParamKeys: ["id"]
        });
        _this.addClusterNode = _this.makeRequest({
          method: "POST",
          path: "/{id}/nodes",
          urlParamKeys: ["id"]
        });
        _this.deleteClusterNode = _this.makeRequest({
          method: "DELETE",
          path: "/{id}/nodes/{node}",
          urlParamKeys: ["id", "node"]
        });
        _this.testNodesAvailable = _this.makeRequest({
          method: "GET",
          path: "/{id}/test-nodes-available",
          urlParamKeys: ["id"]
        });
        _this.getKeyInfo = _this.makeRequest({
          method: "GET",
          path: "/{id}/certificates/{attr}",
          urlParamKeys: ["id", "attr"]
        });
        _this.generateKey = _this.makeRequest({
          method: "POST",
          path: "/{id}/certificates/{attr}/generate",
          urlParamKeys: ["id", "attr"]
        });
        _this.downloadKey = _this.makeUpdateRequest({
          method: "POST",
          path: "/{id}/certificates/{attr}/download",
          urlParamKeys: ["id", "attr"]
        });
        _this.generateAndDownloadKey = _this.makeUpdateRequest({
          method: "POST",
          path: "/{id}/certificates/{attr}/generate-and-download",
          urlParamKeys: ["id", "attr"]
        });
        _this.uploadKey = _this.makeUpdateRequest({
          method: "POST",
          path: "/{id}/certificates/{attr}/upload",
          urlParamKeys: ["id", "attr"]
        });
        _this.uploadCertificate = _this.makeUpdateRequest({
          method: "POST",
          path: "/{id}/certificates/{attr}/upload-certificate",
          urlParamKeys: ["id", "attr"]
        });
        return _this;
      }
      Clients3.prototype.createOrUpdatePolicy = function(payload) {
        return __awaiter2(this, void 0, void 0, function() {
          var policyFound;
          return __generator2(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.findPolicyByName({
                  id: payload.id,
                  name: payload.policyName
                })];
              case 1:
                policyFound = _a.sent();
                if (!policyFound)
                  return [3, 3];
                return [4, this.updatePolicy({id: payload.id, policyId: policyFound.id, type: payload.policy.type}, payload.policy)];
              case 2:
                _a.sent();
                return [2, this.findPolicyByName({id: payload.id, name: payload.policyName})];
              case 3:
                return [2, this.createPolicy({id: payload.id, type: payload.policy.type}, payload.policy)];
            }
          });
        });
      };
      Clients3.prototype.findProtocolMapperByName = function(payload) {
        return __awaiter2(this, void 0, void 0, function() {
          var allProtocolMappers, protocolMapper;
          return __generator2(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.listProtocolMappers(__assign({id: payload.id}, payload.realm ? {realm: payload.realm} : {}))];
              case 1:
                allProtocolMappers = _a.sent();
                protocolMapper = allProtocolMappers.find(function(mapper) {
                  return mapper.name === payload.name;
                });
                return [2, protocolMapper ? protocolMapper : null];
            }
          });
        });
      };
      return Clients3;
    }(resource_1["default"]);
    exports2.Clients = Clients2;
  });
  var realms = createCommonjsModule(function(module2, exports2) {
    var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
      var extendStatics = function(d3, b3) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p3 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p3))
              d4[p3] = b4[p3];
        };
        return extendStatics(d3, b3);
      };
      return function(d3, b3) {
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    exports2.__esModule = true;
    exports2.Realms = void 0;
    var resource_1 = __importDefault(resource);
    var Realms = function(_super) {
      __extends(Realms2, _super);
      function Realms2(client2) {
        var _this = _super.call(this, client2, {
          path: "/admin/realms",
          getBaseUrl: function() {
            return client2.baseUrl;
          }
        }) || this;
        _this.find = _this.makeRequest({
          method: "GET"
        });
        _this.create = _this.makeRequest({
          method: "POST",
          returnResourceIdInLocationHeader: {field: "realmName"}
        });
        _this.findOne = _this.makeRequest({
          method: "GET",
          path: "/{realm}",
          urlParamKeys: ["realm"],
          catchNotFound: true
        });
        _this.update = _this.makeUpdateRequest({
          method: "PUT",
          path: "/{realm}",
          urlParamKeys: ["realm"]
        });
        _this.del = _this.makeRequest({
          method: "DELETE",
          path: "/{realm}",
          urlParamKeys: ["realm"]
        });
        _this["export"] = _this.makeRequest({
          method: "POST",
          path: "/{realm}/partial-export",
          urlParamKeys: ["realm"],
          queryParamKeys: ["exportClients", "exportGroupsAndRoles"]
        });
        _this.findEvents = _this.makeRequest({
          method: "GET",
          path: "/{realm}/events",
          urlParamKeys: ["realm"],
          queryParamKeys: [
            "client",
            "dateFrom",
            "dateTo",
            "first",
            "ipAddress",
            "max",
            "type",
            "user"
          ]
        });
        _this.getConfigEvents = _this.makeRequest({
          method: "GET",
          path: "/{realm}/events/config",
          urlParamKeys: ["realm"]
        });
        _this.updateConfigEvents = _this.makeUpdateRequest({
          method: "PUT",
          path: "/{realm}/events/config",
          urlParamKeys: ["realm"]
        });
        _this.clearEvents = _this.makeRequest({
          method: "DELETE",
          path: "/{realm}/events",
          urlParamKeys: ["realm"]
        });
        _this.clearAdminEvents = _this.makeRequest({
          method: "DELETE",
          path: "/{realm}/admin-events",
          urlParamKeys: ["realm"]
        });
        _this.getClientsInitialAccess = _this.makeRequest({
          method: "GET",
          path: "/{realm}/clients-initial-access",
          urlParamKeys: ["realm"]
        });
        _this.createClientsInitialAccess = _this.makeUpdateRequest({
          method: "POST",
          path: "/{realm}/clients-initial-access",
          urlParamKeys: ["realm"]
        });
        _this.delClientsInitialAccess = _this.makeRequest({
          method: "DELETE",
          path: "/{realm}/clients-initial-access/{id}",
          urlParamKeys: ["realm", "id"]
        });
        _this.removeSession = _this.makeRequest({
          method: "DELETE",
          path: "/{realm}/sessions/{session}",
          urlParamKeys: ["realm", "session"],
          catchNotFound: true
        });
        _this.findAdminEvents = _this.makeRequest({
          method: "GET",
          path: "/{realm}/admin-events",
          urlParamKeys: ["realm"],
          queryParamKeys: [
            "authClient",
            "authIpAddress",
            "authRealm",
            "authUser",
            "dateFrom",
            "dateTo",
            "max",
            "first",
            "operationTypes",
            "resourcePath",
            "resourceTypes"
          ]
        });
        _this.getUsersManagementPermissions = _this.makeRequest({
          method: "GET",
          path: "/{realm}/users-management-permissions",
          urlParamKeys: ["realm"]
        });
        _this.updateUsersManagementPermissions = _this.makeRequest({
          method: "PUT",
          path: "/{realm}/users-management-permissions",
          urlParamKeys: ["realm"]
        });
        _this.logoutAll = _this.makeRequest({
          method: "POST",
          path: "/{realm}/logout-all",
          urlParamKeys: ["realm"]
        });
        _this.deleteSession = _this.makeRequest({
          method: "DELETE",
          path: "/{realm}/sessions/{session}",
          urlParamKeys: ["realm", "session"]
        });
        _this.pushRevocation = _this.makeRequest({
          method: "POST",
          path: "/{realm}/push-revocation",
          urlParamKeys: ["realm"]
        });
        _this.getKeys = _this.makeRequest({
          method: "GET",
          path: "/{realm}/keys",
          urlParamKeys: ["realm"]
        });
        _this.testLDAPConnection = _this.makeUpdateRequest({
          method: "POST",
          path: "/{realm}/testLDAPConnection",
          urlParamKeys: ["realm"]
        });
        _this.testSMTPConnection = _this.makeUpdateRequest({
          method: "POST",
          path: "/{realm}/testSMTPConnection",
          urlParamKeys: ["realm"]
        });
        _this.getRealmSpecificLocales = _this.makeRequest({
          method: "GET",
          path: "/{realm}/localization",
          urlParamKeys: ["realm"]
        });
        _this.getRealmLocalizationTexts = _this.makeRequest({
          method: "GET",
          path: "/{realm}/localization/{selectedLocale}",
          urlParamKeys: ["realm", "selectedLocale"]
        });
        _this.addLocalization = _this.makeUpdateRequest({
          method: "PUT",
          path: "/{realm}/localization/{selectedLocale}/{key}",
          urlParamKeys: ["realm", "selectedLocale", "key"]
        });
        _this.deleteRealmLocalizationTexts = _this.makeRequest({
          method: "DELETE",
          path: "/{realm}/localization/{selectedLocale}/{key}",
          urlParamKeys: ["realm", "selectedLocale", "key"]
        });
        return _this;
      }
      return Realms2;
    }(resource_1["default"]);
    exports2.Realms = Realms;
  });
  var clientScopes = createCommonjsModule(function(module2, exports2) {
    var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
      var extendStatics = function(d3, b3) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p3 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p3))
              d4[p3] = b4[p3];
        };
        return extendStatics(d3, b3);
      };
      return function(d3, b3) {
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
      __assign = Object.assign || function(t4) {
        for (var s2, i3 = 1, n4 = arguments.length; i3 < n4; i3++) {
          s2 = arguments[i3];
          for (var p3 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p3))
              t4[p3] = s2[p3];
        }
        return t4;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
      var _23 = {label: 0, sent: function() {
        if (t4[0] & 1)
          throw t4[1];
        return t4[1];
      }, trys: [], ops: []}, f3, y4, t4, g3;
      return g3 = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
        return this;
      }), g3;
      function verb(n4) {
        return function(v3) {
          return step([n4, v3]);
        };
      }
      function step(op) {
        if (f3)
          throw new TypeError("Generator is already executing.");
        while (_23)
          try {
            if (f3 = 1, y4 && (t4 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t4 = y4["return"]) && t4.call(y4), 0) : y4.next) && !(t4 = t4.call(y4, op[1])).done)
              return t4;
            if (y4 = 0, t4)
              op = [op[0] & 2, t4.value];
            switch (op[0]) {
              case 0:
              case 1:
                t4 = op;
                break;
              case 4:
                _23.label++;
                return {value: op[1], done: false};
              case 5:
                _23.label++;
                y4 = op[1];
                op = [0];
                continue;
              case 7:
                op = _23.ops.pop();
                _23.trys.pop();
                continue;
              default:
                if (!(t4 = _23.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _23 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t4 || op[1] > t4[0] && op[1] < t4[3])) {
                  _23.label = op[1];
                  break;
                }
                if (op[0] === 6 && _23.label < t4[1]) {
                  _23.label = t4[1];
                  t4 = op;
                  break;
                }
                if (t4 && _23.label < t4[2]) {
                  _23.label = t4[2];
                  _23.ops.push(op);
                  break;
                }
                if (t4[2])
                  _23.ops.pop();
                _23.trys.pop();
                continue;
            }
            op = body.call(thisArg, _23);
          } catch (e3) {
            op = [6, e3];
            y4 = 0;
          } finally {
            f3 = t4 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {value: op[0] ? op[1] : void 0, done: true};
      }
    };
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    exports2.__esModule = true;
    exports2.ClientScopes = void 0;
    var resource_1 = __importDefault(resource);
    var ClientScopes2 = function(_super) {
      __extends(ClientScopes3, _super);
      function ClientScopes3(client2) {
        var _this = _super.call(this, client2, {
          path: "/admin/realms/{realm}",
          getUrlParams: function() {
            return {
              realm: client2.realmName
            };
          },
          getBaseUrl: function() {
            return client2.baseUrl;
          }
        }) || this;
        _this.find = _this.makeRequest({
          method: "GET",
          path: "/client-scopes"
        });
        _this.create = _this.makeRequest({
          method: "POST",
          path: "/client-scopes"
        });
        _this.findOne = _this.makeRequest({
          method: "GET",
          path: "/client-scopes/{id}",
          urlParamKeys: ["id"],
          catchNotFound: true
        });
        _this.update = _this.makeUpdateRequest({
          method: "PUT",
          path: "/client-scopes/{id}",
          urlParamKeys: ["id"]
        });
        _this.del = _this.makeRequest({
          method: "DELETE",
          path: "/client-scopes/{id}",
          urlParamKeys: ["id"]
        });
        _this.listDefaultClientScopes = _this.makeRequest({
          method: "GET",
          path: "/default-default-client-scopes"
        });
        _this.addDefaultClientScope = _this.makeRequest({
          method: "PUT",
          path: "/default-default-client-scopes/{id}",
          urlParamKeys: ["id"]
        });
        _this.delDefaultClientScope = _this.makeRequest({
          method: "DELETE",
          path: "/default-default-client-scopes/{id}",
          urlParamKeys: ["id"]
        });
        _this.listDefaultOptionalClientScopes = _this.makeRequest({
          method: "GET",
          path: "/default-optional-client-scopes"
        });
        _this.addDefaultOptionalClientScope = _this.makeRequest({
          method: "PUT",
          path: "/default-optional-client-scopes/{id}",
          urlParamKeys: ["id"]
        });
        _this.delDefaultOptionalClientScope = _this.makeRequest({
          method: "DELETE",
          path: "/default-optional-client-scopes/{id}",
          urlParamKeys: ["id"]
        });
        _this.addMultipleProtocolMappers = _this.makeUpdateRequest({
          method: "POST",
          path: "/client-scopes/{id}/protocol-mappers/add-models",
          urlParamKeys: ["id"]
        });
        _this.addProtocolMapper = _this.makeUpdateRequest({
          method: "POST",
          path: "/client-scopes/{id}/protocol-mappers/models",
          urlParamKeys: ["id"]
        });
        _this.listProtocolMappers = _this.makeRequest({
          method: "GET",
          path: "/client-scopes/{id}/protocol-mappers/models",
          urlParamKeys: ["id"]
        });
        _this.findProtocolMapper = _this.makeRequest({
          method: "GET",
          path: "/client-scopes/{id}/protocol-mappers/models/{mapperId}",
          urlParamKeys: ["id", "mapperId"],
          catchNotFound: true
        });
        _this.findProtocolMappersByProtocol = _this.makeRequest({
          method: "GET",
          path: "/client-scopes/{id}/protocol-mappers/protocol/{protocol}",
          urlParamKeys: ["id", "protocol"],
          catchNotFound: true
        });
        _this.updateProtocolMapper = _this.makeUpdateRequest({
          method: "PUT",
          path: "/client-scopes/{id}/protocol-mappers/models/{mapperId}",
          urlParamKeys: ["id", "mapperId"]
        });
        _this.delProtocolMapper = _this.makeRequest({
          method: "DELETE",
          path: "/client-scopes/{id}/protocol-mappers/models/{mapperId}",
          urlParamKeys: ["id", "mapperId"]
        });
        _this.listScopeMappings = _this.makeRequest({
          method: "GET",
          path: "/client-scopes/{id}/scope-mappings",
          urlParamKeys: ["id"]
        });
        _this.addClientScopeMappings = _this.makeUpdateRequest({
          method: "POST",
          path: "/client-scopes/{id}/scope-mappings/clients/{client}",
          urlParamKeys: ["id", "client"]
        });
        _this.listClientScopeMappings = _this.makeRequest({
          method: "GET",
          path: "/client-scopes/{id}/scope-mappings/clients/{client}",
          urlParamKeys: ["id", "client"]
        });
        _this.listAvailableClientScopeMappings = _this.makeRequest({
          method: "GET",
          path: "/client-scopes/{id}/scope-mappings/clients/{client}/available",
          urlParamKeys: ["id", "client"]
        });
        _this.listCompositeClientScopeMappings = _this.makeRequest({
          method: "GET",
          path: "/client-scopes/{id}/scope-mappings/clients/{client}/composite",
          urlParamKeys: ["id", "client"]
        });
        _this.delClientScopeMappings = _this.makeUpdateRequest({
          method: "DELETE",
          path: "/client-scopes/{id}/scope-mappings/clients/{client}",
          urlParamKeys: ["id", "client"]
        });
        _this.addRealmScopeMappings = _this.makeUpdateRequest({
          method: "POST",
          path: "/client-scopes/{id}/scope-mappings/realm",
          urlParamKeys: ["id"]
        });
        _this.listRealmScopeMappings = _this.makeRequest({
          method: "GET",
          path: "/client-scopes/{id}/scope-mappings/realm",
          urlParamKeys: ["id"]
        });
        _this.listAvailableRealmScopeMappings = _this.makeRequest({
          method: "GET",
          path: "/client-scopes/{id}/scope-mappings/realm/available",
          urlParamKeys: ["id"]
        });
        _this.listCompositeRealmScopeMappings = _this.makeRequest({
          method: "GET",
          path: "/client-scopes/{id}/scope-mappings/realm/composite",
          urlParamKeys: ["id"]
        });
        _this.delRealmScopeMappings = _this.makeUpdateRequest({
          method: "DELETE",
          path: "/client-scopes/{id}/scope-mappings/realm",
          urlParamKeys: ["id"]
        });
        return _this;
      }
      ClientScopes3.prototype.findOneByName = function(payload) {
        return __awaiter2(this, void 0, void 0, function() {
          var allScopes, scope;
          return __generator2(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.find(__assign({}, payload.realm ? {realm: payload.realm} : {}))];
              case 1:
                allScopes = _a.sent();
                scope = allScopes.find(function(item) {
                  return item.name === payload.name;
                });
                return [2, scope ? scope : null];
            }
          });
        });
      };
      ClientScopes3.prototype.delByName = function(payload) {
        return __awaiter2(this, void 0, void 0, function() {
          var scope;
          return __generator2(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.findOneByName(payload)];
              case 1:
                scope = _a.sent();
                if (!scope) {
                  throw new Error("Scope not found.");
                }
                return [4, this.del(__assign(__assign({}, payload.realm ? {realm: payload.realm} : {}), {id: scope.id}))];
              case 2:
                _a.sent();
                return [2];
            }
          });
        });
      };
      ClientScopes3.prototype.findProtocolMapperByName = function(payload) {
        return __awaiter2(this, void 0, void 0, function() {
          var allProtocolMappers, protocolMapper;
          return __generator2(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.listProtocolMappers(__assign({id: payload.id}, payload.realm ? {realm: payload.realm} : {}))];
              case 1:
                allProtocolMappers = _a.sent();
                protocolMapper = allProtocolMappers.find(function(mapper) {
                  return mapper.name === payload.name;
                });
                return [2, protocolMapper ? protocolMapper : null];
            }
          });
        });
      };
      return ClientScopes3;
    }(resource_1["default"]);
    exports2.ClientScopes = ClientScopes2;
  });
  var identityProviders = createCommonjsModule(function(module2, exports2) {
    var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
      var extendStatics = function(d3, b3) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p3 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p3))
              d4[p3] = b4[p3];
        };
        return extendStatics(d3, b3);
      };
      return function(d3, b3) {
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    exports2.__esModule = true;
    exports2.IdentityProviders = void 0;
    var resource_1 = __importDefault(resource);
    var IdentityProviders = function(_super) {
      __extends(IdentityProviders2, _super);
      function IdentityProviders2(client2) {
        var _this = _super.call(this, client2, {
          path: "/admin/realms/{realm}/identity-provider",
          getUrlParams: function() {
            return {
              realm: client2.realmName
            };
          },
          getBaseUrl: function() {
            return client2.baseUrl;
          }
        }) || this;
        _this.find = _this.makeRequest({
          method: "GET",
          path: "/instances"
        });
        _this.create = _this.makeRequest({
          method: "POST",
          path: "/instances",
          returnResourceIdInLocationHeader: {field: "id"}
        });
        _this.findOne = _this.makeRequest({
          method: "GET",
          path: "/instances/{alias}",
          urlParamKeys: ["alias"],
          catchNotFound: true
        });
        _this.update = _this.makeUpdateRequest({
          method: "PUT",
          path: "/instances/{alias}",
          urlParamKeys: ["alias"]
        });
        _this.del = _this.makeRequest({
          method: "DELETE",
          path: "/instances/{alias}",
          urlParamKeys: ["alias"]
        });
        _this.findFactory = _this.makeRequest({
          method: "GET",
          path: "/providers/{providerId}",
          urlParamKeys: ["providerId"]
        });
        _this.findMappers = _this.makeRequest({
          method: "GET",
          path: "/instances/{alias}/mappers",
          urlParamKeys: ["alias"]
        });
        _this.findOneMapper = _this.makeRequest({
          method: "GET",
          path: "/instances/{alias}/mappers/{id}",
          urlParamKeys: ["alias", "id"],
          catchNotFound: true
        });
        _this.createMapper = _this.makeRequest({
          method: "POST",
          path: "/instances/{alias}/mappers",
          urlParamKeys: ["alias"],
          payloadKey: "identityProviderMapper",
          returnResourceIdInLocationHeader: {field: "id"}
        });
        _this.updateMapper = _this.makeUpdateRequest({
          method: "PUT",
          path: "/instances/{alias}/mappers/{id}",
          urlParamKeys: ["alias", "id"]
        });
        _this.delMapper = _this.makeRequest({
          method: "DELETE",
          path: "/instances/{alias}/mappers/{id}",
          urlParamKeys: ["alias", "id"]
        });
        _this.findMapperTypes = _this.makeRequest({
          method: "GET",
          path: "/instances/{alias}/mapper-types",
          urlParamKeys: ["alias"]
        });
        _this.importFromUrl = _this.makeRequest({
          method: "POST",
          path: "/import-config"
        });
        return _this;
      }
      return IdentityProviders2;
    }(resource_1["default"]);
    exports2.IdentityProviders = IdentityProviders;
  });
  var components = createCommonjsModule(function(module2, exports2) {
    var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
      var extendStatics = function(d3, b3) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p3 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p3))
              d4[p3] = b4[p3];
        };
        return extendStatics(d3, b3);
      };
      return function(d3, b3) {
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    exports2.__esModule = true;
    exports2.Components = void 0;
    var resource_1 = __importDefault(resource);
    var Components = function(_super) {
      __extends(Components2, _super);
      function Components2(client2) {
        var _this = _super.call(this, client2, {
          path: "/admin/realms/{realm}/components",
          getUrlParams: function() {
            return {
              realm: client2.realmName
            };
          },
          getBaseUrl: function() {
            return client2.baseUrl;
          }
        }) || this;
        _this.find = _this.makeRequest({
          method: "GET"
        });
        _this.create = _this.makeRequest({
          method: "POST",
          returnResourceIdInLocationHeader: {field: "id"}
        });
        _this.findOne = _this.makeRequest({
          method: "GET",
          path: "/{id}",
          urlParamKeys: ["id"],
          catchNotFound: true
        });
        _this.update = _this.makeUpdateRequest({
          method: "PUT",
          path: "/{id}",
          urlParamKeys: ["id"]
        });
        _this.del = _this.makeRequest({
          method: "DELETE",
          path: "/{id}",
          urlParamKeys: ["id"]
        });
        return _this;
      }
      return Components2;
    }(resource_1["default"]);
    exports2.Components = Components;
  });
  var authenticationManagement = createCommonjsModule(function(module2, exports2) {
    var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
      var extendStatics = function(d3, b3) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p3 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p3))
              d4[p3] = b4[p3];
        };
        return extendStatics(d3, b3);
      };
      return function(d3, b3) {
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    exports2.__esModule = true;
    exports2.AuthenticationManagement = void 0;
    var resource_1 = __importDefault(resource);
    var AuthenticationManagement = function(_super) {
      __extends(AuthenticationManagement2, _super);
      function AuthenticationManagement2(client2) {
        var _this = _super.call(this, client2, {
          path: "/admin/realms/{realm}/authentication",
          getUrlParams: function() {
            return {
              realm: client2.realmName
            };
          },
          getBaseUrl: function() {
            return client2.baseUrl;
          }
        }) || this;
        _this.registerRequiredAction = _this.makeRequest({
          method: "POST",
          path: "/register-required-action"
        });
        _this.getRequiredActions = _this.makeRequest({
          method: "GET",
          path: "/required-actions"
        });
        _this.getRequiredActionForAlias = _this.makeRequest({
          method: "GET",
          path: "/required-actions/{alias}",
          urlParamKeys: ["alias"],
          catchNotFound: true
        });
        _this.getClientAuthenticatorProviders = _this.makeRequest({
          method: "GET",
          path: "/client-authenticator-providers"
        });
        _this.updateRequiredAction = _this.makeUpdateRequest({
          method: "PUT",
          path: "/required-actions/{alias}",
          urlParamKeys: ["alias"]
        });
        _this.deleteRequiredAction = _this.makeRequest({
          method: "DELETE",
          path: "/required-actions/{alias}",
          urlParamKeys: ["alias"]
        });
        _this.lowerRequiredActionPriority = _this.makeRequest({
          method: "POST",
          path: "/required-actions/{alias}/lower-priority",
          urlParamKeys: ["alias"]
        });
        _this.raiseRequiredActionPriority = _this.makeRequest({
          method: "POST",
          path: "/required-actions/{alias}/raise-priority",
          urlParamKeys: ["alias"]
        });
        _this.getUnregisteredRequiredActions = _this.makeRequest({
          method: "GET",
          path: "/unregistered-required-actions"
        });
        _this.getFlows = _this.makeRequest({
          method: "GET",
          path: "/flows"
        });
        _this.getFormProviders = _this.makeRequest({
          method: "GET",
          path: "/form-providers"
        });
        _this.createFlow = _this.makeRequest({
          method: "POST",
          path: "/flows",
          returnResourceIdInLocationHeader: {field: "id"}
        });
        _this.copyFlow = _this.makeRequest({
          method: "POST",
          path: "/flows/{flow}/copy",
          urlParamKeys: ["flow"]
        });
        _this.deleteFlow = _this.makeRequest({
          method: "DELETE",
          path: "/flows/{flowId}",
          urlParamKeys: ["flowId"]
        });
        _this.updateFlow = _this.makeUpdateRequest({
          method: "PUT",
          path: "/flows/{flowId}",
          urlParamKeys: ["flowId"]
        });
        _this.getExecutions = _this.makeRequest({
          method: "GET",
          path: "/flows/{flow}/executions",
          urlParamKeys: ["flow"]
        });
        _this.addExecution = _this.makeUpdateRequest({
          method: "POST",
          path: "/flows/{flow}/executions",
          urlParamKeys: ["flow"]
        });
        _this.addExecutionToFlow = _this.makeRequest({
          method: "POST",
          path: "/flows/{flow}/executions/execution",
          urlParamKeys: ["flow"],
          returnResourceIdInLocationHeader: {field: "id"}
        });
        _this.addFlowToFlow = _this.makeRequest({
          method: "POST",
          path: "/flows/{flow}/executions/flow",
          urlParamKeys: ["flow"],
          returnResourceIdInLocationHeader: {field: "id"}
        });
        _this.updateExecution = _this.makeUpdateRequest({
          method: "PUT",
          path: "/flows/{flow}/executions",
          urlParamKeys: ["flow"]
        });
        _this.delExecution = _this.makeRequest({
          method: "DELETE",
          path: "/executions/{id}",
          urlParamKeys: ["id"]
        });
        _this.lowerPriorityExecution = _this.makeRequest({
          method: "POST",
          path: "/executions/{id}/lower-priority",
          urlParamKeys: ["id"]
        });
        _this.raisePriorityExecution = _this.makeRequest({
          method: "POST",
          path: "/executions/{id}/raise-priority",
          urlParamKeys: ["id"]
        });
        _this.getConfigDescription = _this.makeRequest({
          method: "GET",
          path: "config-description/{providerId}",
          urlParamKeys: ["providerId"]
        });
        _this.createConfig = _this.makeRequest({
          method: "POST",
          path: "/executions/{id}/config",
          urlParamKeys: ["id"],
          returnResourceIdInLocationHeader: {field: "id"}
        });
        _this.updateConfig = _this.makeRequest({
          method: "PUT",
          path: "/config/{id}",
          urlParamKeys: ["id"]
        });
        _this.getConfig = _this.makeRequest({
          method: "GET",
          path: "/config/{id}",
          urlParamKeys: ["id"]
        });
        _this.delConfig = _this.makeRequest({
          method: "DELETE",
          path: "/config/{id}",
          urlParamKeys: ["id"]
        });
        return _this;
      }
      return AuthenticationManagement2;
    }(resource_1["default"]);
    exports2.AuthenticationManagement = AuthenticationManagement;
  });
  var serverInfo = createCommonjsModule(function(module2, exports2) {
    var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
      var extendStatics = function(d3, b3) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p3 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p3))
              d4[p3] = b4[p3];
        };
        return extendStatics(d3, b3);
      };
      return function(d3, b3) {
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    exports2.__esModule = true;
    exports2.ServerInfo = void 0;
    var resource_1 = __importDefault(resource);
    var ServerInfo = function(_super) {
      __extends(ServerInfo2, _super);
      function ServerInfo2(client2) {
        var _this = _super.call(this, client2, {
          path: "/admin/serverinfo",
          getBaseUrl: function() {
            return client2.baseUrl;
          }
        }) || this;
        _this.find = _this.makeRequest({
          method: "GET",
          path: "/"
        });
        return _this;
      }
      return ServerInfo2;
    }(resource_1["default"]);
    exports2.ServerInfo = ServerInfo;
  });
  var whoAmI = createCommonjsModule(function(module2, exports2) {
    var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
      var extendStatics = function(d3, b3) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p3 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p3))
              d4[p3] = b4[p3];
        };
        return extendStatics(d3, b3);
      };
      return function(d3, b3) {
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    exports2.__esModule = true;
    exports2.WhoAmI = void 0;
    var resource_1 = __importDefault(resource);
    var WhoAmI2 = function(_super) {
      __extends(WhoAmI3, _super);
      function WhoAmI3(client2) {
        var _this = _super.call(this, client2, {
          path: "/admin/{realm}/console",
          getUrlParams: function() {
            return {
              realm: client2.realmName
            };
          },
          getBaseUrl: function() {
            return client2.baseUrl;
          }
        }) || this;
        _this.find = _this.makeRequest({
          method: "GET",
          path: "/whoami"
        });
        return _this;
      }
      return WhoAmI3;
    }(resource_1["default"]);
    exports2.WhoAmI = WhoAmI2;
  });
  var attackDetection = createCommonjsModule(function(module2, exports2) {
    var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
      var extendStatics = function(d3, b3) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p3 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p3))
              d4[p3] = b4[p3];
        };
        return extendStatics(d3, b3);
      };
      return function(d3, b3) {
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    exports2.__esModule = true;
    exports2.AttackDetection = void 0;
    var resource_1 = __importDefault(resource);
    var AttackDetection = function(_super) {
      __extends(AttackDetection2, _super);
      function AttackDetection2(client2) {
        var _this = _super.call(this, client2, {
          path: "/admin/realms/{realm}/attack-detection/brute-force",
          getUrlParams: function() {
            return {
              realm: client2.realmName
            };
          },
          getBaseUrl: function() {
            return client2.baseUrl;
          }
        }) || this;
        _this.findOne = _this.makeRequest({
          method: "GET",
          path: "/users/{id}",
          urlParamKeys: ["id"],
          catchNotFound: true
        });
        _this.del = _this.makeRequest({
          method: "DELETE",
          path: "/users/{id}",
          urlParamKeys: ["id"]
        });
        _this.delAll = _this.makeRequest({
          method: "DELETE",
          path: "/users"
        });
        return _this;
      }
      return AttackDetection2;
    }(resource_1["default"]);
    exports2.AttackDetection = AttackDetection;
  });
  var sessions = createCommonjsModule(function(module2, exports2) {
    var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
      var extendStatics = function(d3, b3) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p3 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p3))
              d4[p3] = b4[p3];
        };
        return extendStatics(d3, b3);
      };
      return function(d3, b3) {
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    exports2.__esModule = true;
    exports2.Sessions = void 0;
    var resource_1 = __importDefault(resource);
    var Sessions = function(_super) {
      __extends(Sessions2, _super);
      function Sessions2(client2) {
        var _this = _super.call(this, client2, {
          path: "/admin/realms/{realm}/client-session-stats",
          getUrlParams: function() {
            return {
              realm: client2.realmName
            };
          },
          getBaseUrl: function() {
            return client2.baseUrl;
          }
        }) || this;
        _this.find = _this.makeRequest({
          method: "GET"
        });
        return _this;
      }
      return Sessions2;
    }(resource_1["default"]);
    exports2.Sessions = Sessions;
  });
  var userStorageProvider = createCommonjsModule(function(module2, exports2) {
    var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
      var extendStatics = function(d3, b3) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p3 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p3))
              d4[p3] = b4[p3];
        };
        return extendStatics(d3, b3);
      };
      return function(d3, b3) {
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    exports2.__esModule = true;
    exports2.UserStorageProvider = void 0;
    var resource_1 = __importDefault(resource);
    var UserStorageProvider = function(_super) {
      __extends(UserStorageProvider2, _super);
      function UserStorageProvider2(client2) {
        var _this = _super.call(this, client2, {
          path: "/admin/realms/{realm}/user-storage",
          getUrlParams: function() {
            return {
              realm: client2.realmName
            };
          },
          getBaseUrl: function() {
            return client2.baseUrl;
          }
        }) || this;
        _this.name = _this.makeRequest({
          method: "GET",
          path: "/{id}/name",
          urlParamKeys: ["id"]
        });
        _this.removeImportedUsers = _this.makeRequest({
          method: "POST",
          path: "/{id}/remove-imported-users",
          urlParamKeys: ["id"]
        });
        _this.sync = _this.makeRequest({
          method: "POST",
          path: "/{id}/sync",
          urlParamKeys: ["id"],
          queryParamKeys: ["action"]
        });
        _this.unlinkUsers = _this.makeRequest({
          method: "POST",
          path: "/{id}/unlink-users",
          urlParamKeys: ["id"]
        });
        _this.mappersSync = _this.makeRequest({
          method: "POST",
          path: "/{parentId}/mappers/{id}/sync",
          urlParamKeys: ["id", "parentId"],
          queryParamKeys: ["direction"]
        });
        return _this;
      }
      return UserStorageProvider2;
    }(resource_1["default"]);
    exports2.UserStorageProvider = UserStorageProvider;
  });
  var sha256 = createCommonjsModule(function(module) {
    /**
     * [js-sha256]{@link https://github.com/emn178/js-sha256}
     *
     * @version 0.9.0
     * @author Chen, Yi-Cyuan [emn178@gmail.com]
     * @copyright Chen, Yi-Cyuan 2014-2017
     * @license MIT
     */
    (function() {
      var ERROR = "input is invalid type";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA256_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = commonjsGlobal;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && true && module.exports;
      var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
      var blocks = [];
      if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(outputType, is224) {
        return function(message) {
          return new Sha256(is224, true).update(message)[outputType]();
        };
      };
      var createMethod = function(is224) {
        var method = createOutputMethod("hex", is224);
        if (NODE_JS) {
          method = nodeWrap(method, is224);
        }
        method.create = function() {
          return new Sha256(is224);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i3 = 0; i3 < OUTPUT_TYPES.length; ++i3) {
          var type = OUTPUT_TYPES[i3];
          method[type] = createOutputMethod(type, is224);
        }
        return method;
      };
      var nodeWrap = function(method, is224) {
        var crypto = eval("require('crypto')");
        var Buffer = eval("require('buffer').Buffer");
        var algorithm = is224 ? "sha224" : "sha256";
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
          } else {
            if (message === null || message === void 0) {
              throw new Error(ERROR);
            } else if (message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            }
          }
          if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
            return crypto.createHash(algorithm).update(new Buffer(message)).digest("hex");
          } else {
            return method(message);
          }
        };
        return nodeMethod;
      };
      var createHmacOutputMethod = function(outputType, is224) {
        return function(key, message) {
          return new HmacSha256(key, is224, true).update(message)[outputType]();
        };
      };
      var createHmacMethod = function(is224) {
        var method = createHmacOutputMethod("hex", is224);
        method.create = function(key) {
          return new HmacSha256(key, is224);
        };
        method.update = function(key, message) {
          return method.create(key).update(message);
        };
        for (var i3 = 0; i3 < OUTPUT_TYPES.length; ++i3) {
          var type = OUTPUT_TYPES[i3];
          method[type] = createHmacOutputMethod(type, is224);
        }
        return method;
      };
      function Sha256(is224, sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (is224) {
          this.h0 = 3238371032;
          this.h1 = 914150663;
          this.h2 = 812702999;
          this.h3 = 4144912697;
          this.h4 = 4290775857;
          this.h5 = 1750603025;
          this.h6 = 1694076839;
          this.h7 = 3204075428;
        } else {
          this.h0 = 1779033703;
          this.h1 = 3144134277;
          this.h2 = 1013904242;
          this.h3 = 2773480762;
          this.h4 = 1359893119;
          this.h5 = 2600822924;
          this.h6 = 528734635;
          this.h7 = 1541459225;
        }
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
        this.is224 = is224;
      }
      Sha256.prototype.update = function(message) {
        if (this.finalized) {
          return;
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
          notString = true;
        }
        var code2, index3 = 0, i3, length = message.length, blocks = this.blocks;
        while (index3 < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks[0] = this.block;
            blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          }
          if (notString) {
            for (i3 = this.start; index3 < length && i3 < 64; ++index3) {
              blocks[i3 >> 2] |= message[index3] << SHIFT[i3++ & 3];
            }
          } else {
            for (i3 = this.start; index3 < length && i3 < 64; ++index3) {
              code2 = message.charCodeAt(index3);
              if (code2 < 128) {
                blocks[i3 >> 2] |= code2 << SHIFT[i3++ & 3];
              } else if (code2 < 2048) {
                blocks[i3 >> 2] |= (192 | code2 >> 6) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code2 & 63) << SHIFT[i3++ & 3];
              } else if (code2 < 55296 || code2 >= 57344) {
                blocks[i3 >> 2] |= (224 | code2 >> 12) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code2 & 63) << SHIFT[i3++ & 3];
              } else {
                code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index3) & 1023);
                blocks[i3 >> 2] |= (240 | code2 >> 18) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code2 & 63) << SHIFT[i3++ & 3];
              }
            }
          }
          this.lastByteIndex = i3;
          this.bytes += i3 - this.start;
          if (i3 >= 64) {
            this.block = blocks[16];
            this.start = i3 - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i3;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha256.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i3 = this.lastByteIndex;
        blocks[16] = this.block;
        blocks[i3 >> 2] |= EXTRA[i3 & 3];
        this.block = blocks[16];
        if (i3 >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks[0] = this.block;
          blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
        }
        blocks[14] = this.hBytes << 3 | this.bytes >>> 29;
        blocks[15] = this.bytes << 3;
        this.hash();
      };
      Sha256.prototype.hash = function() {
        var a2 = this.h0, b3 = this.h1, c4 = this.h2, d3 = this.h3, e3 = this.h4, f3 = this.h5, g3 = this.h6, h3 = this.h7, blocks = this.blocks, j, s0, s1, maj, t1, t22, ch2, ab2, da2, cd2, bc2;
        for (j = 16; j < 64; ++j) {
          t1 = blocks[j - 15];
          s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
          t1 = blocks[j - 2];
          s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          blocks[j] = blocks[j - 16] + s0 + blocks[j - 7] + s1 << 0;
        }
        bc2 = b3 & c4;
        for (j = 0; j < 64; j += 4) {
          if (this.first) {
            if (this.is224) {
              ab2 = 300032;
              t1 = blocks[0] - 1413257819;
              h3 = t1 - 150054599 << 0;
              d3 = t1 + 24177077 << 0;
            } else {
              ab2 = 704751109;
              t1 = blocks[0] - 210244248;
              h3 = t1 - 1521486534 << 0;
              d3 = t1 + 143694565 << 0;
            }
            this.first = false;
          } else {
            s0 = (a2 >>> 2 | a2 << 30) ^ (a2 >>> 13 | a2 << 19) ^ (a2 >>> 22 | a2 << 10);
            s1 = (e3 >>> 6 | e3 << 26) ^ (e3 >>> 11 | e3 << 21) ^ (e3 >>> 25 | e3 << 7);
            ab2 = a2 & b3;
            maj = ab2 ^ a2 & c4 ^ bc2;
            ch2 = e3 & f3 ^ ~e3 & g3;
            t1 = h3 + s1 + ch2 + K[j] + blocks[j];
            t22 = s0 + maj;
            h3 = d3 + t1 << 0;
            d3 = t1 + t22 << 0;
          }
          s0 = (d3 >>> 2 | d3 << 30) ^ (d3 >>> 13 | d3 << 19) ^ (d3 >>> 22 | d3 << 10);
          s1 = (h3 >>> 6 | h3 << 26) ^ (h3 >>> 11 | h3 << 21) ^ (h3 >>> 25 | h3 << 7);
          da2 = d3 & a2;
          maj = da2 ^ d3 & b3 ^ ab2;
          ch2 = h3 & e3 ^ ~h3 & f3;
          t1 = g3 + s1 + ch2 + K[j + 1] + blocks[j + 1];
          t22 = s0 + maj;
          g3 = c4 + t1 << 0;
          c4 = t1 + t22 << 0;
          s0 = (c4 >>> 2 | c4 << 30) ^ (c4 >>> 13 | c4 << 19) ^ (c4 >>> 22 | c4 << 10);
          s1 = (g3 >>> 6 | g3 << 26) ^ (g3 >>> 11 | g3 << 21) ^ (g3 >>> 25 | g3 << 7);
          cd2 = c4 & d3;
          maj = cd2 ^ c4 & a2 ^ da2;
          ch2 = g3 & h3 ^ ~g3 & e3;
          t1 = f3 + s1 + ch2 + K[j + 2] + blocks[j + 2];
          t22 = s0 + maj;
          f3 = b3 + t1 << 0;
          b3 = t1 + t22 << 0;
          s0 = (b3 >>> 2 | b3 << 30) ^ (b3 >>> 13 | b3 << 19) ^ (b3 >>> 22 | b3 << 10);
          s1 = (f3 >>> 6 | f3 << 26) ^ (f3 >>> 11 | f3 << 21) ^ (f3 >>> 25 | f3 << 7);
          bc2 = b3 & c4;
          maj = bc2 ^ b3 & d3 ^ cd2;
          ch2 = f3 & g3 ^ ~f3 & h3;
          t1 = e3 + s1 + ch2 + K[j + 3] + blocks[j + 3];
          t22 = s0 + maj;
          e3 = a2 + t1 << 0;
          a2 = t1 + t22 << 0;
        }
        this.h0 = this.h0 + a2 << 0;
        this.h1 = this.h1 + b3 << 0;
        this.h2 = this.h2 + c4 << 0;
        this.h3 = this.h3 + d3 << 0;
        this.h4 = this.h4 + e3 << 0;
        this.h5 = this.h5 + f3 << 0;
        this.h6 = this.h6 + g3 << 0;
        this.h7 = this.h7 + h3 << 0;
      };
      Sha256.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h22 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var hex2 = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h22 >> 28 & 15] + HEX_CHARS[h22 >> 24 & 15] + HEX_CHARS[h22 >> 20 & 15] + HEX_CHARS[h22 >> 16 & 15] + HEX_CHARS[h22 >> 12 & 15] + HEX_CHARS[h22 >> 8 & 15] + HEX_CHARS[h22 >> 4 & 15] + HEX_CHARS[h22 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
        if (!this.is224) {
          hex2 += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
        }
        return hex2;
      };
      Sha256.prototype.toString = Sha256.prototype.hex;
      Sha256.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h22 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var arr = [
          h0 >> 24 & 255,
          h0 >> 16 & 255,
          h0 >> 8 & 255,
          h0 & 255,
          h1 >> 24 & 255,
          h1 >> 16 & 255,
          h1 >> 8 & 255,
          h1 & 255,
          h22 >> 24 & 255,
          h22 >> 16 & 255,
          h22 >> 8 & 255,
          h22 & 255,
          h3 >> 24 & 255,
          h3 >> 16 & 255,
          h3 >> 8 & 255,
          h3 & 255,
          h4 >> 24 & 255,
          h4 >> 16 & 255,
          h4 >> 8 & 255,
          h4 & 255,
          h5 >> 24 & 255,
          h5 >> 16 & 255,
          h5 >> 8 & 255,
          h5 & 255,
          h6 >> 24 & 255,
          h6 >> 16 & 255,
          h6 >> 8 & 255,
          h6 & 255
        ];
        if (!this.is224) {
          arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
        }
        return arr;
      };
      Sha256.prototype.array = Sha256.prototype.digest;
      Sha256.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
        var dataView = new DataView(buffer);
        dataView.setUint32(0, this.h0);
        dataView.setUint32(4, this.h1);
        dataView.setUint32(8, this.h2);
        dataView.setUint32(12, this.h3);
        dataView.setUint32(16, this.h4);
        dataView.setUint32(20, this.h5);
        dataView.setUint32(24, this.h6);
        if (!this.is224) {
          dataView.setUint32(28, this.h7);
        }
        return buffer;
      };
      function HmacSha256(key, is224, sharedMemory) {
        var i3, type = typeof key;
        if (type === "string") {
          var bytes = [], length = key.length, index3 = 0, code2;
          for (i3 = 0; i3 < length; ++i3) {
            code2 = key.charCodeAt(i3);
            if (code2 < 128) {
              bytes[index3++] = code2;
            } else if (code2 < 2048) {
              bytes[index3++] = 192 | code2 >> 6;
              bytes[index3++] = 128 | code2 & 63;
            } else if (code2 < 55296 || code2 >= 57344) {
              bytes[index3++] = 224 | code2 >> 12;
              bytes[index3++] = 128 | code2 >> 6 & 63;
              bytes[index3++] = 128 | code2 & 63;
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | key.charCodeAt(++i3) & 1023);
              bytes[index3++] = 240 | code2 >> 18;
              bytes[index3++] = 128 | code2 >> 12 & 63;
              bytes[index3++] = 128 | code2 >> 6 & 63;
              bytes[index3++] = 128 | code2 & 63;
            }
          }
          key = bytes;
        } else {
          if (type === "object") {
            if (key === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
              key = new Uint8Array(key);
            } else if (!Array.isArray(key)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
        }
        if (key.length > 64) {
          key = new Sha256(is224, true).update(key).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (i3 = 0; i3 < 64; ++i3) {
          var b3 = key[i3] || 0;
          oKeyPad[i3] = 92 ^ b3;
          iKeyPad[i3] = 54 ^ b3;
        }
        Sha256.call(this, is224, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha256.prototype = new Sha256();
      HmacSha256.prototype.finalize = function() {
        Sha256.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha256.call(this, this.is224, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha256.prototype.finalize.call(this);
        }
      };
      var exports = createMethod();
      exports.sha256 = exports;
      exports.sha224 = createMethod(true);
      exports.sha256.hmac = createHmacMethod();
      exports.sha224.hmac = createHmacMethod(true);
      if (COMMON_JS) {
        module.exports = exports;
      } else {
        root.sha256 = exports.sha256;
        root.sha224 = exports.sha224;
      }
    })();
  });
  var byteLength_1 = byteLength;
  var toByteArray_1 = toByteArray;
  var fromByteArray_1 = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i3;
    for (i3 = 0; i3 < len2; i3 += 4) {
      tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start3, end2) {
    var tmp;
    var output2 = [];
    for (var i3 = start3; i3 < end2; i3 += 3) {
      tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
      output2.push(tripletToBase64(tmp));
    }
    return output2.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
  var base64Js = {
    byteLength: byteLength_1,
    toByteArray: toByteArray_1,
    fromByteArray: fromByteArray_1
  };
  var keycloak = createCommonjsModule(function(module2, exports2) {
    (function(root3, factory) {
      {
        {
          module2.exports = factory(sha256, base64Js);
        }
      }
    })(window, function(sha256_imported, base64js_imported) {
      if (typeof Promise === "undefined") {
        throw Error("Keycloak requires an environment that supports Promises. Make sure that you include the appropriate polyfill.");
      }
      var loggedPromiseDeprecation = false;
      function logPromiseDeprecation() {
        if (!loggedPromiseDeprecation) {
          loggedPromiseDeprecation = true;
          console.warn("[KEYCLOAK] Usage of legacy style promise methods such as `.error()` and `.success()` has been deprecated and support will be removed in future versions. Use standard style promise methods such as `.then() and `.catch()` instead.");
        }
      }
      function Keycloak(config2) {
        if (!(this instanceof Keycloak)) {
          return new Keycloak(config2);
        }
        var kc2 = this;
        var adapter;
        var refreshQueue = [];
        var callbackStorage;
        var loginIframe = {
          enable: true,
          callbackList: [],
          interval: 5
        };
        var scripts = document.getElementsByTagName("script");
        for (var i3 = 0; i3 < scripts.length; i3++) {
          if ((scripts[i3].src.indexOf("keycloak.js") !== -1 || scripts[i3].src.indexOf("keycloak.min.js") !== -1) && scripts[i3].src.indexOf("version=") !== -1) {
            kc2.iframeVersion = scripts[i3].src.substring(scripts[i3].src.indexOf("version=") + 8).split("&")[0];
          }
        }
        var useNonce = true;
        var logInfo = createLogger(console.info);
        var logWarn = createLogger(console.warn);
        kc2.init = function(initOptions2) {
          kc2.authenticated = false;
          callbackStorage = createCallbackStorage();
          var adapters = ["default", "cordova", "cordova-native"];
          if (initOptions2 && adapters.indexOf(initOptions2.adapter) > -1) {
            adapter = loadAdapter(initOptions2.adapter);
          } else if (initOptions2 && typeof initOptions2.adapter === "object") {
            adapter = initOptions2.adapter;
          } else {
            if (window.Cordova || window.cordova) {
              adapter = loadAdapter("cordova");
            } else {
              adapter = loadAdapter();
            }
          }
          if (initOptions2) {
            if (typeof initOptions2.useNonce !== "undefined") {
              useNonce = initOptions2.useNonce;
            }
            if (typeof initOptions2.checkLoginIframe !== "undefined") {
              loginIframe.enable = initOptions2.checkLoginIframe;
            }
            if (initOptions2.checkLoginIframeInterval) {
              loginIframe.interval = initOptions2.checkLoginIframeInterval;
            }
            if (initOptions2.onLoad === "login-required") {
              kc2.loginRequired = true;
            }
            if (initOptions2.responseMode) {
              if (initOptions2.responseMode === "query" || initOptions2.responseMode === "fragment") {
                kc2.responseMode = initOptions2.responseMode;
              } else {
                throw "Invalid value for responseMode";
              }
            }
            if (initOptions2.flow) {
              switch (initOptions2.flow) {
                case "standard":
                  kc2.responseType = "code";
                  break;
                case "implicit":
                  kc2.responseType = "id_token token";
                  break;
                case "hybrid":
                  kc2.responseType = "code id_token token";
                  break;
                default:
                  throw "Invalid value for flow";
              }
              kc2.flow = initOptions2.flow;
            }
            if (initOptions2.timeSkew != null) {
              kc2.timeSkew = initOptions2.timeSkew;
            }
            if (initOptions2.redirectUri) {
              kc2.redirectUri = initOptions2.redirectUri;
            }
            if (initOptions2.silentCheckSsoRedirectUri) {
              kc2.silentCheckSsoRedirectUri = initOptions2.silentCheckSsoRedirectUri;
            }
            if (typeof initOptions2.silentCheckSsoFallback === "boolean") {
              kc2.silentCheckSsoFallback = initOptions2.silentCheckSsoFallback;
            } else {
              kc2.silentCheckSsoFallback = true;
            }
            if (initOptions2.pkceMethod) {
              if (initOptions2.pkceMethod !== "S256") {
                throw "Invalid value for pkceMethod";
              }
              kc2.pkceMethod = initOptions2.pkceMethod;
            }
            if (typeof initOptions2.enableLogging === "boolean") {
              kc2.enableLogging = initOptions2.enableLogging;
            } else {
              kc2.enableLogging = false;
            }
          }
          if (!kc2.responseMode) {
            kc2.responseMode = "fragment";
          }
          if (!kc2.responseType) {
            kc2.responseType = "code";
            kc2.flow = "standard";
          }
          var promise = createPromise();
          var initPromise = createPromise();
          initPromise.promise.then(function() {
            kc2.onReady && kc2.onReady(kc2.authenticated);
            promise.setSuccess(kc2.authenticated);
          }).catch(function(errorData) {
            promise.setError(errorData);
          });
          var configPromise = loadConfig();
          function onLoad() {
            var doLogin = function(prompt) {
              if (!prompt) {
                options.prompt = "none";
              }
              kc2.login(options).then(function() {
                initPromise.setSuccess();
              }).catch(function() {
                initPromise.setError();
              });
            };
            var checkSsoSilently = function() {
              var ifrm = document.createElement("iframe");
              var src = kc2.createLoginUrl({prompt: "none", redirectUri: kc2.silentCheckSsoRedirectUri});
              ifrm.setAttribute("src", src);
              ifrm.setAttribute("title", "keycloak-silent-check-sso");
              ifrm.style.display = "none";
              document.body.appendChild(ifrm);
              var messageCallback = function(event) {
                if (event.origin !== window.location.origin || ifrm.contentWindow !== event.source) {
                  return;
                }
                var oauth = parseCallback(event.data);
                processCallback(oauth, initPromise);
                document.body.removeChild(ifrm);
                window.removeEventListener("message", messageCallback);
              };
              window.addEventListener("message", messageCallback);
            };
            var options = {};
            switch (initOptions2.onLoad) {
              case "check-sso":
                if (loginIframe.enable) {
                  setupCheckLoginIframe().then(function() {
                    checkLoginIframe().then(function(unchanged) {
                      if (!unchanged) {
                        kc2.silentCheckSsoRedirectUri ? checkSsoSilently() : doLogin(false);
                      } else {
                        initPromise.setSuccess();
                      }
                    }).catch(function() {
                      initPromise.setError();
                    });
                  });
                } else {
                  kc2.silentCheckSsoRedirectUri ? checkSsoSilently() : doLogin(false);
                }
                break;
              case "login-required":
                doLogin(true);
                break;
              default:
                throw "Invalid value for onLoad";
            }
          }
          function processInit() {
            var callback = parseCallback(window.location.href);
            if (callback) {
              window.history.replaceState(window.history.state, null, callback.newUrl);
            }
            if (callback && callback.valid) {
              return setupCheckLoginIframe().then(function() {
                processCallback(callback, initPromise);
              }).catch(function(e3) {
                initPromise.setError();
              });
            } else if (initOptions2) {
              if (initOptions2.token && initOptions2.refreshToken) {
                setToken(initOptions2.token, initOptions2.refreshToken, initOptions2.idToken);
                if (loginIframe.enable) {
                  setupCheckLoginIframe().then(function() {
                    checkLoginIframe().then(function(unchanged) {
                      if (unchanged) {
                        kc2.onAuthSuccess && kc2.onAuthSuccess();
                        initPromise.setSuccess();
                        scheduleCheckIframe();
                      } else {
                        initPromise.setSuccess();
                      }
                    }).catch(function() {
                      initPromise.setError();
                    });
                  });
                } else {
                  kc2.updateToken(-1).then(function() {
                    kc2.onAuthSuccess && kc2.onAuthSuccess();
                    initPromise.setSuccess();
                  }).catch(function() {
                    kc2.onAuthError && kc2.onAuthError();
                    if (initOptions2.onLoad) {
                      onLoad();
                    } else {
                      initPromise.setError();
                    }
                  });
                }
              } else if (initOptions2.onLoad) {
                onLoad();
              } else {
                initPromise.setSuccess();
              }
            } else {
              initPromise.setSuccess();
            }
          }
          function domReady() {
            var promise2 = createPromise();
            var checkReadyState = function() {
              if (document.readyState === "interactive" || document.readyState === "complete") {
                document.removeEventListener("readystatechange", checkReadyState);
                promise2.setSuccess();
              }
            };
            document.addEventListener("readystatechange", checkReadyState);
            checkReadyState();
            return promise2.promise;
          }
          configPromise.then(function() {
            domReady().then(check3pCookiesSupported).then(processInit).catch(function() {
              promise.setError();
            });
          });
          configPromise.catch(function() {
            promise.setError();
          });
          return promise.promise;
        };
        kc2.login = function(options) {
          return adapter.login(options);
        };
        function generateRandomData(len2) {
          var array2 = null;
          var crypto = window.crypto || window.msCrypto;
          if (crypto && crypto.getRandomValues && window.Uint8Array) {
            array2 = new Uint8Array(len2);
            crypto.getRandomValues(array2);
            return array2;
          }
          array2 = new Array(len2);
          for (var j = 0; j < array2.length; j++) {
            array2[j] = Math.floor(256 * Math.random());
          }
          return array2;
        }
        function generateCodeVerifier(len2) {
          return generateRandomString(len2, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
        }
        function generateRandomString(len2, alphabet) {
          var randomData = generateRandomData(len2);
          var chars = new Array(len2);
          for (var i4 = 0; i4 < len2; i4++) {
            chars[i4] = alphabet.charCodeAt(randomData[i4] % alphabet.length);
          }
          return String.fromCharCode.apply(null, chars);
        }
        function generatePkceChallenge(pkceMethod, codeVerifier) {
          switch (pkceMethod) {
            case "S256":
              var hashBytes = new Uint8Array(sha256_imported.arrayBuffer(codeVerifier));
              var encodedHash = base64js_imported.fromByteArray(hashBytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
              return encodedHash;
            default:
              throw "Invalid value for pkceMethod";
          }
        }
        kc2.createLoginUrl = function(options) {
          var state = createUUID();
          var nonce = createUUID();
          var redirectUri = adapter.redirectUri(options);
          var callbackState = {
            state,
            nonce,
            redirectUri: encodeURIComponent(redirectUri)
          };
          if (options && options.prompt) {
            callbackState.prompt = options.prompt;
          }
          var baseUrl;
          if (options && options.action == "register") {
            baseUrl = kc2.endpoints.register();
          } else {
            baseUrl = kc2.endpoints.authorize();
          }
          var scope;
          if (options && options.scope) {
            if (options.scope.indexOf("openid") != -1) {
              scope = options.scope;
            } else {
              scope = "openid " + options.scope;
            }
          } else {
            scope = "openid";
          }
          var url = baseUrl + "?client_id=" + encodeURIComponent(kc2.clientId) + "&redirect_uri=" + encodeURIComponent(redirectUri) + "&state=" + encodeURIComponent(state) + "&response_mode=" + encodeURIComponent(kc2.responseMode) + "&response_type=" + encodeURIComponent(kc2.responseType) + "&scope=" + encodeURIComponent(scope);
          if (useNonce) {
            url = url + "&nonce=" + encodeURIComponent(nonce);
          }
          if (options && options.prompt) {
            url += "&prompt=" + encodeURIComponent(options.prompt);
          }
          if (options && options.maxAge) {
            url += "&max_age=" + encodeURIComponent(options.maxAge);
          }
          if (options && options.loginHint) {
            url += "&login_hint=" + encodeURIComponent(options.loginHint);
          }
          if (options && options.idpHint) {
            url += "&kc_idp_hint=" + encodeURIComponent(options.idpHint);
          }
          if (options && options.action && options.action != "register") {
            url += "&kc_action=" + encodeURIComponent(options.action);
          }
          if (options && options.locale) {
            url += "&ui_locales=" + encodeURIComponent(options.locale);
          }
          if (kc2.pkceMethod) {
            var codeVerifier = generateCodeVerifier(96);
            callbackState.pkceCodeVerifier = codeVerifier;
            var pkceChallenge = generatePkceChallenge(kc2.pkceMethod, codeVerifier);
            url += "&code_challenge=" + pkceChallenge;
            url += "&code_challenge_method=" + kc2.pkceMethod;
          }
          callbackStorage.add(callbackState);
          return url;
        };
        kc2.logout = function(options) {
          return adapter.logout(options);
        };
        kc2.createLogoutUrl = function(options) {
          var url = kc2.endpoints.logout() + "?redirect_uri=" + encodeURIComponent(adapter.redirectUri(options, false));
          return url;
        };
        kc2.register = function(options) {
          return adapter.register(options);
        };
        kc2.createRegisterUrl = function(options) {
          if (!options) {
            options = {};
          }
          options.action = "register";
          return kc2.createLoginUrl(options);
        };
        kc2.createAccountUrl = function(options) {
          var realm2 = getRealmUrl();
          var url = void 0;
          if (typeof realm2 !== "undefined") {
            url = realm2 + "/account?referrer=" + encodeURIComponent(kc2.clientId) + "&referrer_uri=" + encodeURIComponent(adapter.redirectUri(options));
          }
          return url;
        };
        kc2.accountManagement = function() {
          return adapter.accountManagement();
        };
        kc2.hasRealmRole = function(role) {
          var access = kc2.realmAccess;
          return !!access && access.roles.indexOf(role) >= 0;
        };
        kc2.hasResourceRole = function(role, resource2) {
          if (!kc2.resourceAccess) {
            return false;
          }
          var access = kc2.resourceAccess[resource2 || kc2.clientId];
          return !!access && access.roles.indexOf(role) >= 0;
        };
        kc2.loadUserProfile = function() {
          var url = getRealmUrl() + "/account";
          var req = new XMLHttpRequest();
          req.open("GET", url, true);
          req.setRequestHeader("Accept", "application/json");
          req.setRequestHeader("Authorization", "bearer " + kc2.token);
          var promise = createPromise();
          req.onreadystatechange = function() {
            if (req.readyState == 4) {
              if (req.status == 200) {
                kc2.profile = JSON.parse(req.responseText);
                promise.setSuccess(kc2.profile);
              } else {
                promise.setError();
              }
            }
          };
          req.send();
          return promise.promise;
        };
        kc2.loadUserInfo = function() {
          var url = kc2.endpoints.userinfo();
          var req = new XMLHttpRequest();
          req.open("GET", url, true);
          req.setRequestHeader("Accept", "application/json");
          req.setRequestHeader("Authorization", "bearer " + kc2.token);
          var promise = createPromise();
          req.onreadystatechange = function() {
            if (req.readyState == 4) {
              if (req.status == 200) {
                kc2.userInfo = JSON.parse(req.responseText);
                promise.setSuccess(kc2.userInfo);
              } else {
                promise.setError();
              }
            }
          };
          req.send();
          return promise.promise;
        };
        kc2.isTokenExpired = function(minValidity) {
          if (!kc2.tokenParsed || !kc2.refreshToken && kc2.flow != "implicit") {
            throw "Not authenticated";
          }
          if (kc2.timeSkew == null) {
            logInfo("[KEYCLOAK] Unable to determine if token is expired as timeskew is not set");
            return true;
          }
          var expiresIn = kc2.tokenParsed["exp"] - Math.ceil(new Date().getTime() / 1e3) + kc2.timeSkew;
          if (minValidity) {
            if (isNaN(minValidity)) {
              throw "Invalid minValidity";
            }
            expiresIn -= minValidity;
          }
          return expiresIn < 0;
        };
        kc2.updateToken = function(minValidity) {
          var promise = createPromise();
          if (!kc2.refreshToken) {
            promise.setError();
            return promise.promise;
          }
          minValidity = minValidity || 5;
          var exec = function() {
            var refreshToken = false;
            if (minValidity == -1) {
              refreshToken = true;
              logInfo("[KEYCLOAK] Refreshing token: forced refresh");
            } else if (!kc2.tokenParsed || kc2.isTokenExpired(minValidity)) {
              refreshToken = true;
              logInfo("[KEYCLOAK] Refreshing token: token expired");
            }
            if (!refreshToken) {
              promise.setSuccess(false);
            } else {
              var params = "grant_type=refresh_token&refresh_token=" + kc2.refreshToken;
              var url = kc2.endpoints.token();
              refreshQueue.push(promise);
              if (refreshQueue.length == 1) {
                var req = new XMLHttpRequest();
                req.open("POST", url, true);
                req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                req.withCredentials = true;
                params += "&client_id=" + encodeURIComponent(kc2.clientId);
                var timeLocal = new Date().getTime();
                req.onreadystatechange = function() {
                  if (req.readyState == 4) {
                    if (req.status == 200) {
                      logInfo("[KEYCLOAK] Token refreshed");
                      timeLocal = (timeLocal + new Date().getTime()) / 2;
                      var tokenResponse = JSON.parse(req.responseText);
                      setToken(tokenResponse["access_token"], tokenResponse["refresh_token"], tokenResponse["id_token"], timeLocal);
                      kc2.onAuthRefreshSuccess && kc2.onAuthRefreshSuccess();
                      for (var p3 = refreshQueue.pop(); p3 != null; p3 = refreshQueue.pop()) {
                        p3.setSuccess(true);
                      }
                    } else {
                      logWarn("[KEYCLOAK] Failed to refresh token");
                      if (req.status == 400) {
                        kc2.clearToken();
                      }
                      kc2.onAuthRefreshError && kc2.onAuthRefreshError();
                      for (var p3 = refreshQueue.pop(); p3 != null; p3 = refreshQueue.pop()) {
                        p3.setError(true);
                      }
                    }
                  }
                };
                req.send(params);
              }
            }
          };
          if (loginIframe.enable) {
            var iframePromise = checkLoginIframe();
            iframePromise.then(function() {
              exec();
            }).catch(function() {
              promise.setError();
            });
          } else {
            exec();
          }
          return promise.promise;
        };
        kc2.clearToken = function() {
          if (kc2.token) {
            setToken(null, null, null);
            kc2.onAuthLogout && kc2.onAuthLogout();
            if (kc2.loginRequired) {
              kc2.login();
            }
          }
        };
        function getRealmUrl() {
          if (typeof kc2.authServerUrl !== "undefined") {
            if (kc2.authServerUrl.charAt(kc2.authServerUrl.length - 1) == "/") {
              return kc2.authServerUrl + "realms/" + encodeURIComponent(kc2.realm);
            } else {
              return kc2.authServerUrl + "/realms/" + encodeURIComponent(kc2.realm);
            }
          } else {
            return void 0;
          }
        }
        function getOrigin() {
          if (!window.location.origin) {
            return window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port : "");
          } else {
            return window.location.origin;
          }
        }
        function processCallback(oauth, promise) {
          var code2 = oauth.code;
          var error2 = oauth.error;
          var prompt = oauth.prompt;
          var timeLocal = new Date().getTime();
          if (oauth["kc_action_status"]) {
            kc2.onActionUpdate && kc2.onActionUpdate(oauth["kc_action_status"]);
          }
          if (error2) {
            if (prompt != "none") {
              var errorData = {error: error2, error_description: oauth.error_description};
              kc2.onAuthError && kc2.onAuthError(errorData);
              promise && promise.setError(errorData);
            } else {
              promise && promise.setSuccess();
            }
            return;
          } else if (kc2.flow != "standard" && (oauth.access_token || oauth.id_token)) {
            authSuccess(oauth.access_token, null, oauth.id_token, true);
          }
          if (kc2.flow != "implicit" && code2) {
            var params = "code=" + code2 + "&grant_type=authorization_code";
            var url = kc2.endpoints.token();
            var req = new XMLHttpRequest();
            req.open("POST", url, true);
            req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            params += "&client_id=" + encodeURIComponent(kc2.clientId);
            params += "&redirect_uri=" + oauth.redirectUri;
            if (oauth.pkceCodeVerifier) {
              params += "&code_verifier=" + oauth.pkceCodeVerifier;
            }
            req.withCredentials = true;
            req.onreadystatechange = function() {
              if (req.readyState == 4) {
                if (req.status == 200) {
                  var tokenResponse = JSON.parse(req.responseText);
                  authSuccess(tokenResponse["access_token"], tokenResponse["refresh_token"], tokenResponse["id_token"], kc2.flow === "standard");
                  scheduleCheckIframe();
                } else {
                  kc2.onAuthError && kc2.onAuthError();
                  promise && promise.setError();
                }
              }
            };
            req.send(params);
          }
          function authSuccess(accessToken, refreshToken, idToken, fulfillPromise) {
            timeLocal = (timeLocal + new Date().getTime()) / 2;
            setToken(accessToken, refreshToken, idToken, timeLocal);
            if (useNonce && (kc2.tokenParsed && kc2.tokenParsed.nonce != oauth.storedNonce || kc2.refreshTokenParsed && kc2.refreshTokenParsed.nonce != oauth.storedNonce || kc2.idTokenParsed && kc2.idTokenParsed.nonce != oauth.storedNonce)) {
              logInfo("[KEYCLOAK] Invalid nonce, clearing token");
              kc2.clearToken();
              promise && promise.setError();
            } else {
              if (fulfillPromise) {
                kc2.onAuthSuccess && kc2.onAuthSuccess();
                promise && promise.setSuccess();
              }
            }
          }
        }
        function loadConfig(url) {
          var promise = createPromise();
          var configUrl;
          if (!config2) {
            configUrl = "keycloak.json";
          } else if (typeof config2 === "string") {
            configUrl = config2;
          }
          function setupOidcEndoints(oidcConfiguration) {
            if (!oidcConfiguration) {
              kc2.endpoints = {
                authorize: function() {
                  return getRealmUrl() + "/protocol/openid-connect/auth";
                },
                token: function() {
                  return getRealmUrl() + "/protocol/openid-connect/token";
                },
                logout: function() {
                  return getRealmUrl() + "/protocol/openid-connect/logout";
                },
                checkSessionIframe: function() {
                  var src = getRealmUrl() + "/protocol/openid-connect/login-status-iframe.html";
                  if (kc2.iframeVersion) {
                    src = src + "?version=" + kc2.iframeVersion;
                  }
                  return src;
                },
                thirdPartyCookiesIframe: function() {
                  var src = getRealmUrl() + "/protocol/openid-connect/3p-cookies/step1.html";
                  if (kc2.iframeVersion) {
                    src = src + "?version=" + kc2.iframeVersion;
                  }
                  return src;
                },
                register: function() {
                  return getRealmUrl() + "/protocol/openid-connect/registrations";
                },
                userinfo: function() {
                  return getRealmUrl() + "/protocol/openid-connect/userinfo";
                }
              };
            } else {
              kc2.endpoints = {
                authorize: function() {
                  return oidcConfiguration.authorization_endpoint;
                },
                token: function() {
                  return oidcConfiguration.token_endpoint;
                },
                logout: function() {
                  if (!oidcConfiguration.end_session_endpoint) {
                    throw "Not supported by the OIDC server";
                  }
                  return oidcConfiguration.end_session_endpoint;
                },
                checkSessionIframe: function() {
                  if (!oidcConfiguration.check_session_iframe) {
                    throw "Not supported by the OIDC server";
                  }
                  return oidcConfiguration.check_session_iframe;
                },
                register: function() {
                  throw 'Redirection to "Register user" page not supported in standard OIDC mode';
                },
                userinfo: function() {
                  if (!oidcConfiguration.userinfo_endpoint) {
                    throw "Not supported by the OIDC server";
                  }
                  return oidcConfiguration.userinfo_endpoint;
                }
              };
            }
          }
          if (configUrl) {
            var req = new XMLHttpRequest();
            req.open("GET", configUrl, true);
            req.setRequestHeader("Accept", "application/json");
            req.onreadystatechange = function() {
              if (req.readyState == 4) {
                if (req.status == 200 || fileLoaded(req)) {
                  var config3 = JSON.parse(req.responseText);
                  kc2.authServerUrl = config3["auth-server-url"];
                  kc2.realm = config3["realm"];
                  kc2.clientId = config3["resource"];
                  setupOidcEndoints(null);
                  promise.setSuccess();
                } else {
                  promise.setError();
                }
              }
            };
            req.send();
          } else {
            if (!config2.clientId) {
              throw "clientId missing";
            }
            kc2.clientId = config2.clientId;
            var oidcProvider = config2["oidcProvider"];
            if (!oidcProvider) {
              if (!config2["url"]) {
                var scripts2 = document.getElementsByTagName("script");
                for (var i4 = 0; i4 < scripts2.length; i4++) {
                  if (scripts2[i4].src.match(/.*keycloak\.js/)) {
                    config2.url = scripts2[i4].src.substr(0, scripts2[i4].src.indexOf("/js/keycloak.js"));
                    break;
                  }
                }
              }
              if (!config2.realm) {
                throw "realm missing";
              }
              kc2.authServerUrl = config2.url;
              kc2.realm = config2.realm;
              setupOidcEndoints(null);
              promise.setSuccess();
            } else {
              if (typeof oidcProvider === "string") {
                var oidcProviderConfigUrl;
                if (oidcProvider.charAt(oidcProvider.length - 1) == "/") {
                  oidcProviderConfigUrl = oidcProvider + ".well-known/openid-configuration";
                } else {
                  oidcProviderConfigUrl = oidcProvider + "/.well-known/openid-configuration";
                }
                var req = new XMLHttpRequest();
                req.open("GET", oidcProviderConfigUrl, true);
                req.setRequestHeader("Accept", "application/json");
                req.onreadystatechange = function() {
                  if (req.readyState == 4) {
                    if (req.status == 200 || fileLoaded(req)) {
                      var oidcProviderConfig = JSON.parse(req.responseText);
                      setupOidcEndoints(oidcProviderConfig);
                      promise.setSuccess();
                    } else {
                      promise.setError();
                    }
                  }
                };
                req.send();
              } else {
                setupOidcEndoints(oidcProvider);
                promise.setSuccess();
              }
            }
          }
          return promise.promise;
        }
        function fileLoaded(xhr2) {
          return xhr2.status == 0 && xhr2.responseText && xhr2.responseURL.startsWith("file:");
        }
        function setToken(token2, refreshToken, idToken, timeLocal) {
          if (kc2.tokenTimeoutHandle) {
            clearTimeout(kc2.tokenTimeoutHandle);
            kc2.tokenTimeoutHandle = null;
          }
          if (refreshToken) {
            kc2.refreshToken = refreshToken;
            kc2.refreshTokenParsed = decodeToken(refreshToken);
          } else {
            delete kc2.refreshToken;
            delete kc2.refreshTokenParsed;
          }
          if (idToken) {
            kc2.idToken = idToken;
            kc2.idTokenParsed = decodeToken(idToken);
          } else {
            delete kc2.idToken;
            delete kc2.idTokenParsed;
          }
          if (token2) {
            kc2.token = token2;
            kc2.tokenParsed = decodeToken(token2);
            kc2.sessionId = kc2.tokenParsed.session_state;
            kc2.authenticated = true;
            kc2.subject = kc2.tokenParsed.sub;
            kc2.realmAccess = kc2.tokenParsed.realm_access;
            kc2.resourceAccess = kc2.tokenParsed.resource_access;
            if (timeLocal) {
              kc2.timeSkew = Math.floor(timeLocal / 1e3) - kc2.tokenParsed.iat;
            }
            if (kc2.timeSkew != null) {
              logInfo("[KEYCLOAK] Estimated time difference between browser and server is " + kc2.timeSkew + " seconds");
              if (kc2.onTokenExpired) {
                var expiresIn = (kc2.tokenParsed["exp"] - new Date().getTime() / 1e3 + kc2.timeSkew) * 1e3;
                logInfo("[KEYCLOAK] Token expires in " + Math.round(expiresIn / 1e3) + " s");
                if (expiresIn <= 0) {
                  kc2.onTokenExpired();
                } else {
                  kc2.tokenTimeoutHandle = setTimeout(kc2.onTokenExpired, expiresIn);
                }
              }
            }
          } else {
            delete kc2.token;
            delete kc2.tokenParsed;
            delete kc2.subject;
            delete kc2.realmAccess;
            delete kc2.resourceAccess;
            kc2.authenticated = false;
          }
        }
        function decodeToken(str) {
          str = str.split(".")[1];
          str = str.replace(/-/g, "+");
          str = str.replace(/_/g, "/");
          switch (str.length % 4) {
            case 0:
              break;
            case 2:
              str += "==";
              break;
            case 3:
              str += "=";
              break;
            default:
              throw "Invalid token";
          }
          str = decodeURIComponent(escape(atob(str)));
          str = JSON.parse(str);
          return str;
        }
        function createUUID() {
          var hexDigits = "0123456789abcdef";
          var s2 = generateRandomString(36, hexDigits).split("");
          s2[14] = "4";
          s2[19] = hexDigits.substr(s2[19] & 3 | 8, 1);
          s2[8] = s2[13] = s2[18] = s2[23] = "-";
          var uuid = s2.join("");
          return uuid;
        }
        function parseCallback(url) {
          var oauth = parseCallbackUrl(url);
          if (!oauth) {
            return;
          }
          var oauthState = callbackStorage.get(oauth.state);
          if (oauthState) {
            oauth.valid = true;
            oauth.redirectUri = oauthState.redirectUri;
            oauth.storedNonce = oauthState.nonce;
            oauth.prompt = oauthState.prompt;
            oauth.pkceCodeVerifier = oauthState.pkceCodeVerifier;
          }
          return oauth;
        }
        function parseCallbackUrl(url) {
          var supportedParams;
          switch (kc2.flow) {
            case "standard":
              supportedParams = ["code", "state", "session_state", "kc_action_status"];
              break;
            case "implicit":
              supportedParams = ["access_token", "token_type", "id_token", "state", "session_state", "expires_in", "kc_action_status"];
              break;
            case "hybrid":
              supportedParams = ["access_token", "id_token", "code", "state", "session_state", "kc_action_status"];
              break;
          }
          supportedParams.push("error");
          supportedParams.push("error_description");
          supportedParams.push("error_uri");
          var queryIndex = url.indexOf("?");
          var fragmentIndex = url.indexOf("#");
          var newUrl;
          var parsed;
          if (kc2.responseMode === "query" && queryIndex !== -1) {
            newUrl = url.substring(0, queryIndex);
            parsed = parseCallbackParams(url.substring(queryIndex + 1, fragmentIndex !== -1 ? fragmentIndex : url.length), supportedParams);
            if (parsed.paramsString !== "") {
              newUrl += "?" + parsed.paramsString;
            }
            if (fragmentIndex !== -1) {
              newUrl += url.substring(fragmentIndex);
            }
          } else if (kc2.responseMode === "fragment" && fragmentIndex !== -1) {
            newUrl = url.substring(0, fragmentIndex);
            parsed = parseCallbackParams(url.substring(fragmentIndex + 1), supportedParams);
            if (parsed.paramsString !== "") {
              newUrl += "#" + parsed.paramsString;
            }
          }
          if (parsed && parsed.oauthParams) {
            if (kc2.flow === "standard" || kc2.flow === "hybrid") {
              if ((parsed.oauthParams.code || parsed.oauthParams.error) && parsed.oauthParams.state) {
                parsed.oauthParams.newUrl = newUrl;
                return parsed.oauthParams;
              }
            } else if (kc2.flow === "implicit") {
              if ((parsed.oauthParams.access_token || parsed.oauthParams.error) && parsed.oauthParams.state) {
                parsed.oauthParams.newUrl = newUrl;
                return parsed.oauthParams;
              }
            }
          }
        }
        function parseCallbackParams(paramsString, supportedParams) {
          var p3 = paramsString.split("&");
          var result = {
            paramsString: "",
            oauthParams: {}
          };
          for (var i4 = 0; i4 < p3.length; i4++) {
            var split2 = p3[i4].indexOf("=");
            var key = p3[i4].slice(0, split2);
            if (supportedParams.indexOf(key) !== -1) {
              result.oauthParams[key] = p3[i4].slice(split2 + 1);
            } else {
              if (result.paramsString !== "") {
                result.paramsString += "&";
              }
              result.paramsString += p3[i4];
            }
          }
          return result;
        }
        function createPromise() {
          var p3 = {
            setSuccess: function(result) {
              p3.resolve(result);
            },
            setError: function(result) {
              p3.reject(result);
            }
          };
          p3.promise = new Promise(function(resolve, reject) {
            p3.resolve = resolve;
            p3.reject = reject;
          });
          p3.promise.success = function(callback) {
            logPromiseDeprecation();
            this.then(function handleSuccess(value) {
              callback(value);
            });
            return this;
          };
          p3.promise.error = function(callback) {
            logPromiseDeprecation();
            this.catch(function handleError(error2) {
              callback(error2);
            });
            return this;
          };
          return p3;
        }
        function setupCheckLoginIframe() {
          var promise = createPromise();
          if (!loginIframe.enable) {
            promise.setSuccess();
            return promise.promise;
          }
          if (loginIframe.iframe) {
            promise.setSuccess();
            return promise.promise;
          }
          var iframe = document.createElement("iframe");
          loginIframe.iframe = iframe;
          iframe.onload = function() {
            var authUrl = kc2.endpoints.authorize();
            if (authUrl.charAt(0) === "/") {
              loginIframe.iframeOrigin = getOrigin();
            } else {
              loginIframe.iframeOrigin = authUrl.substring(0, authUrl.indexOf("/", 8));
            }
            promise.setSuccess();
          };
          var src = kc2.endpoints.checkSessionIframe();
          iframe.setAttribute("src", src);
          iframe.setAttribute("title", "keycloak-session-iframe");
          iframe.style.display = "none";
          document.body.appendChild(iframe);
          var messageCallback = function(event) {
            if (event.origin !== loginIframe.iframeOrigin || loginIframe.iframe.contentWindow !== event.source) {
              return;
            }
            if (!(event.data == "unchanged" || event.data == "changed" || event.data == "error")) {
              return;
            }
            if (event.data != "unchanged") {
              kc2.clearToken();
            }
            var callbacks = loginIframe.callbackList.splice(0, loginIframe.callbackList.length);
            for (var i4 = callbacks.length - 1; i4 >= 0; --i4) {
              var promise2 = callbacks[i4];
              if (event.data == "error") {
                promise2.setError();
              } else {
                promise2.setSuccess(event.data == "unchanged");
              }
            }
          };
          window.addEventListener("message", messageCallback, false);
          return promise.promise;
        }
        function scheduleCheckIframe() {
          if (loginIframe.enable) {
            if (kc2.token) {
              setTimeout(function() {
                checkLoginIframe().then(function(unchanged) {
                  if (unchanged) {
                    scheduleCheckIframe();
                  }
                });
              }, loginIframe.interval * 1e3);
            }
          }
        }
        function checkLoginIframe() {
          var promise = createPromise();
          if (loginIframe.iframe && loginIframe.iframeOrigin) {
            var msg = kc2.clientId + " " + (kc2.sessionId ? kc2.sessionId : "");
            loginIframe.callbackList.push(promise);
            var origin = loginIframe.iframeOrigin;
            if (loginIframe.callbackList.length == 1) {
              loginIframe.iframe.contentWindow.postMessage(msg, origin);
            }
          } else {
            promise.setSuccess();
          }
          return promise.promise;
        }
        function check3pCookiesSupported() {
          var promise = createPromise();
          if (loginIframe.enable || kc2.silentCheckSsoRedirectUri) {
            var iframe = document.createElement("iframe");
            iframe.setAttribute("src", kc2.endpoints.thirdPartyCookiesIframe());
            iframe.setAttribute("title", "keycloak-3p-check-iframe");
            iframe.style.display = "none";
            document.body.appendChild(iframe);
            var messageCallback = function(event) {
              if (iframe.contentWindow !== event.source) {
                return;
              }
              if (event.data !== "supported" && event.data !== "unsupported") {
                promise.setError();
              } else if (event.data === "unsupported") {
                loginIframe.enable = false;
                if (kc2.silentCheckSsoFallback) {
                  kc2.silentCheckSsoRedirectUri = false;
                }
                logWarn("[KEYCLOAK] 3rd party cookies aren't supported by this browser. checkLoginIframe and silent check-sso are not available.");
              }
              document.body.removeChild(iframe);
              window.removeEventListener("message", messageCallback);
              promise.setSuccess();
            };
            window.addEventListener("message", messageCallback, false);
          } else {
            promise.setSuccess();
          }
          return promise.promise;
        }
        function loadAdapter(type) {
          if (!type || type == "default") {
            return {
              login: function(options) {
                window.location.replace(kc2.createLoginUrl(options));
                return createPromise().promise;
              },
              logout: function(options) {
                window.location.replace(kc2.createLogoutUrl(options));
                return createPromise().promise;
              },
              register: function(options) {
                window.location.replace(kc2.createRegisterUrl(options));
                return createPromise().promise;
              },
              accountManagement: function() {
                var accountUrl = kc2.createAccountUrl();
                if (typeof accountUrl !== "undefined") {
                  window.location.href = accountUrl;
                } else {
                  throw "Not supported by the OIDC server";
                }
                return createPromise().promise;
              },
              redirectUri: function(options, encodeHash) {
                if (options && options.redirectUri) {
                  return options.redirectUri;
                } else if (kc2.redirectUri) {
                  return kc2.redirectUri;
                } else {
                  return location.href;
                }
              }
            };
          }
          if (type == "cordova") {
            loginIframe.enable = false;
            var cordovaOpenWindowWrapper = function(loginUrl, target, options) {
              if (window.cordova && window.cordova.InAppBrowser) {
                return window.cordova.InAppBrowser.open(loginUrl, target, options);
              } else {
                return window.open(loginUrl, target, options);
              }
            };
            var shallowCloneCordovaOptions = function(userOptions) {
              if (userOptions && userOptions.cordovaOptions) {
                return Object.keys(userOptions.cordovaOptions).reduce(function(options, optionName) {
                  options[optionName] = userOptions.cordovaOptions[optionName];
                  return options;
                }, {});
              } else {
                return {};
              }
            };
            var formatCordovaOptions = function(cordovaOptions) {
              return Object.keys(cordovaOptions).reduce(function(options, optionName) {
                options.push(optionName + "=" + cordovaOptions[optionName]);
                return options;
              }, []).join(",");
            };
            var createCordovaOptions = function(userOptions) {
              var cordovaOptions = shallowCloneCordovaOptions(userOptions);
              cordovaOptions.location = "no";
              if (userOptions && userOptions.prompt == "none") {
                cordovaOptions.hidden = "yes";
              }
              return formatCordovaOptions(cordovaOptions);
            };
            return {
              login: function(options) {
                var promise = createPromise();
                var cordovaOptions = createCordovaOptions(options);
                var loginUrl = kc2.createLoginUrl(options);
                var ref = cordovaOpenWindowWrapper(loginUrl, "_blank", cordovaOptions);
                var completed = false;
                var closed = false;
                var closeBrowser = function() {
                  closed = true;
                  ref.close();
                };
                ref.addEventListener("loadstart", function(event) {
                  if (event.url.indexOf("http://localhost") == 0) {
                    var callback = parseCallback(event.url);
                    processCallback(callback, promise);
                    closeBrowser();
                    completed = true;
                  }
                });
                ref.addEventListener("loaderror", function(event) {
                  if (!completed) {
                    if (event.url.indexOf("http://localhost") == 0) {
                      var callback = parseCallback(event.url);
                      processCallback(callback, promise);
                      closeBrowser();
                      completed = true;
                    } else {
                      promise.setError();
                      closeBrowser();
                    }
                  }
                });
                ref.addEventListener("exit", function(event) {
                  if (!closed) {
                    promise.setError({
                      reason: "closed_by_user"
                    });
                  }
                });
                return promise.promise;
              },
              logout: function(options) {
                var promise = createPromise();
                var logoutUrl = kc2.createLogoutUrl(options);
                var ref = cordovaOpenWindowWrapper(logoutUrl, "_blank", "location=no,hidden=yes");
                var error2;
                ref.addEventListener("loadstart", function(event) {
                  if (event.url.indexOf("http://localhost") == 0) {
                    ref.close();
                  }
                });
                ref.addEventListener("loaderror", function(event) {
                  if (event.url.indexOf("http://localhost") == 0) {
                    ref.close();
                  } else {
                    error2 = true;
                    ref.close();
                  }
                });
                ref.addEventListener("exit", function(event) {
                  if (error2) {
                    promise.setError();
                  } else {
                    kc2.clearToken();
                    promise.setSuccess();
                  }
                });
                return promise.promise;
              },
              register: function(options) {
                var promise = createPromise();
                var registerUrl = kc2.createRegisterUrl();
                var cordovaOptions = createCordovaOptions(options);
                var ref = cordovaOpenWindowWrapper(registerUrl, "_blank", cordovaOptions);
                ref.addEventListener("loadstart", function(event) {
                  if (event.url.indexOf("http://localhost") == 0) {
                    ref.close();
                    var oauth = parseCallback(event.url);
                    processCallback(oauth, promise);
                  }
                });
                return promise.promise;
              },
              accountManagement: function() {
                var accountUrl = kc2.createAccountUrl();
                if (typeof accountUrl !== "undefined") {
                  var ref = cordovaOpenWindowWrapper(accountUrl, "_blank", "location=no");
                  ref.addEventListener("loadstart", function(event) {
                    if (event.url.indexOf("http://localhost") == 0) {
                      ref.close();
                    }
                  });
                } else {
                  throw "Not supported by the OIDC server";
                }
              },
              redirectUri: function(options) {
                return "http://localhost";
              }
            };
          }
          if (type == "cordova-native") {
            loginIframe.enable = false;
            return {
              login: function(options) {
                var promise = createPromise();
                var loginUrl = kc2.createLoginUrl(options);
                universalLinks.subscribe("keycloak", function(event) {
                  universalLinks.unsubscribe("keycloak");
                  window.cordova.plugins.browsertab.close();
                  var oauth = parseCallback(event.url);
                  processCallback(oauth, promise);
                });
                window.cordova.plugins.browsertab.openUrl(loginUrl);
                return promise.promise;
              },
              logout: function(options) {
                var promise = createPromise();
                var logoutUrl = kc2.createLogoutUrl(options);
                universalLinks.subscribe("keycloak", function(event) {
                  universalLinks.unsubscribe("keycloak");
                  window.cordova.plugins.browsertab.close();
                  kc2.clearToken();
                  promise.setSuccess();
                });
                window.cordova.plugins.browsertab.openUrl(logoutUrl);
                return promise.promise;
              },
              register: function(options) {
                var promise = createPromise();
                var registerUrl = kc2.createRegisterUrl(options);
                universalLinks.subscribe("keycloak", function(event) {
                  universalLinks.unsubscribe("keycloak");
                  window.cordova.plugins.browsertab.close();
                  var oauth = parseCallback(event.url);
                  processCallback(oauth, promise);
                });
                window.cordova.plugins.browsertab.openUrl(registerUrl);
                return promise.promise;
              },
              accountManagement: function() {
                var accountUrl = kc2.createAccountUrl();
                if (typeof accountUrl !== "undefined") {
                  window.cordova.plugins.browsertab.openUrl(accountUrl);
                } else {
                  throw "Not supported by the OIDC server";
                }
              },
              redirectUri: function(options) {
                if (options && options.redirectUri) {
                  return options.redirectUri;
                } else if (kc2.redirectUri) {
                  return kc2.redirectUri;
                } else {
                  return "http://localhost";
                }
              }
            };
          }
          throw "invalid adapter type: " + type;
        }
        var LocalStorage = function() {
          if (!(this instanceof LocalStorage)) {
            return new LocalStorage();
          }
          localStorage.setItem("kc-test", "test");
          localStorage.removeItem("kc-test");
          var cs = this;
          function clearExpired() {
            var time2 = new Date().getTime();
            for (var i4 = 0; i4 < localStorage.length; i4++) {
              var key = localStorage.key(i4);
              if (key && key.indexOf("kc-callback-") == 0) {
                var value = localStorage.getItem(key);
                if (value) {
                  try {
                    var expires2 = JSON.parse(value).expires;
                    if (!expires2 || expires2 < time2) {
                      localStorage.removeItem(key);
                    }
                  } catch (err) {
                    localStorage.removeItem(key);
                  }
                }
              }
            }
          }
          cs.get = function(state) {
            if (!state) {
              return;
            }
            var key = "kc-callback-" + state;
            var value = localStorage.getItem(key);
            if (value) {
              localStorage.removeItem(key);
              value = JSON.parse(value);
            }
            clearExpired();
            return value;
          };
          cs.add = function(state) {
            clearExpired();
            var key = "kc-callback-" + state.state;
            state.expires = new Date().getTime() + 60 * 60 * 1e3;
            localStorage.setItem(key, JSON.stringify(state));
          };
        };
        var CookieStorage = function() {
          if (!(this instanceof CookieStorage)) {
            return new CookieStorage();
          }
          var cs = this;
          cs.get = function(state) {
            if (!state) {
              return;
            }
            var value = getCookie("kc-callback-" + state);
            setCookie("kc-callback-" + state, "", cookieExpiration(-100));
            if (value) {
              return JSON.parse(value);
            }
          };
          cs.add = function(state) {
            setCookie("kc-callback-" + state.state, JSON.stringify(state), cookieExpiration(60));
          };
          cs.removeItem = function(key) {
            setCookie(key, "", cookieExpiration(-100));
          };
          var cookieExpiration = function(minutes) {
            var exp = new Date();
            exp.setTime(exp.getTime() + minutes * 60 * 1e3);
            return exp;
          };
          var getCookie = function(key) {
            var name = key + "=";
            var ca2 = document.cookie.split(";");
            for (var i4 = 0; i4 < ca2.length; i4++) {
              var c4 = ca2[i4];
              while (c4.charAt(0) == " ") {
                c4 = c4.substring(1);
              }
              if (c4.indexOf(name) == 0) {
                return c4.substring(name.length, c4.length);
              }
            }
            return "";
          };
          var setCookie = function(key, value, expirationDate) {
            var cookie = key + "=" + value + "; expires=" + expirationDate.toUTCString() + "; ";
            document.cookie = cookie;
          };
        };
        function createCallbackStorage() {
          try {
            return new LocalStorage();
          } catch (err) {
          }
          return new CookieStorage();
        }
        function createLogger(fn) {
          return function() {
            if (kc2.enableLogging) {
              fn.apply(console, Array.prototype.slice.call(arguments));
            }
          };
        }
      }
      return Keycloak;
    });
  });
  var client = createCommonjsModule(function(module2, exports2) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o, k22, {enumerable: true, get: function() {
        return m3[k3];
      }});
    } : function(o, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o[k22] = m3[k3];
    });
    var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v3) {
      Object.defineProperty(o, "default", {enumerable: true, value: v3});
    } : function(o, v3) {
      o["default"] = v3;
    });
    var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
      var _23 = {label: 0, sent: function() {
        if (t4[0] & 1)
          throw t4[1];
        return t4[1];
      }, trys: [], ops: []}, f3, y4, t4, g3;
      return g3 = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
        return this;
      }), g3;
      function verb(n4) {
        return function(v3) {
          return step([n4, v3]);
        };
      }
      function step(op) {
        if (f3)
          throw new TypeError("Generator is already executing.");
        while (_23)
          try {
            if (f3 = 1, y4 && (t4 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t4 = y4["return"]) && t4.call(y4), 0) : y4.next) && !(t4 = t4.call(y4, op[1])).done)
              return t4;
            if (y4 = 0, t4)
              op = [op[0] & 2, t4.value];
            switch (op[0]) {
              case 0:
              case 1:
                t4 = op;
                break;
              case 4:
                _23.label++;
                return {value: op[1], done: false};
              case 5:
                _23.label++;
                y4 = op[1];
                op = [0];
                continue;
              case 7:
                op = _23.ops.pop();
                _23.trys.pop();
                continue;
              default:
                if (!(t4 = _23.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _23 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t4 || op[1] > t4[0] && op[1] < t4[3])) {
                  _23.label = op[1];
                  break;
                }
                if (op[0] === 6 && _23.label < t4[1]) {
                  _23.label = t4[1];
                  t4 = op;
                  break;
                }
                if (t4 && _23.label < t4[2]) {
                  _23.label = t4[2];
                  _23.ops.push(op);
                  break;
                }
                if (t4[2])
                  _23.ops.pop();
                _23.trys.pop();
                continue;
            }
            op = body.call(thisArg, _23);
          } catch (e3) {
            op = [6, e3];
            y4 = 0;
          } finally {
            f3 = t4 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {value: op[0] ? op[1] : void 0, done: true};
      }
    };
    exports2.__esModule = true;
    exports2.KeycloakAdminClient = void 0;
    var KeycloakAdminClient = function() {
      function KeycloakAdminClient2(connectionConfig) {
        this.baseUrl = connectionConfig && connectionConfig.baseUrl || constants.defaultBaseUrl;
        this.realmName = connectionConfig && connectionConfig.realmName || constants.defaultRealm;
        this.requestConfig = connectionConfig && connectionConfig.requestConfig;
        this.users = new users.Users(this);
        this.userStorageProvider = new userStorageProvider.UserStorageProvider(this);
        this.groups = new groups.Groups(this);
        this.roles = new roles.Roles(this);
        this.clients = new clients.Clients(this);
        this.realms = new realms.Realms(this);
        this.clientScopes = new clientScopes.ClientScopes(this);
        this.identityProviders = new identityProviders.IdentityProviders(this);
        this.components = new components.Components(this);
        this.authenticationManagement = new authenticationManagement.AuthenticationManagement(this);
        this.serverInfo = new serverInfo.ServerInfo(this);
        this.whoAmI = new whoAmI.WhoAmI(this);
        this.sessions = new sessions.Sessions(this);
        this.attackDetection = new attackDetection.AttackDetection(this);
        this.cache = new cache.Cache(this);
      }
      KeycloakAdminClient2.prototype.auth = function(credentials) {
        return __awaiter2(this, void 0, void 0, function() {
          var _a, accessToken, refreshToken;
          return __generator2(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, auth.getToken({
                  baseUrl: this.baseUrl,
                  realmName: this.realmName,
                  credentials,
                  requestConfig: this.requestConfig
                })];
              case 1:
                _a = _b.sent(), accessToken = _a.accessToken, refreshToken = _a.refreshToken;
                this.accessToken = accessToken;
                this.refreshToken = refreshToken;
                return [2];
            }
          });
        });
      };
      KeycloakAdminClient2.prototype.init = function(init3, config2) {
        return __awaiter2(this, void 0, void 0, function() {
          var Keycloak_1;
          return __generator2(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!window)
                  return [3, 3];
                return [4, Promise.resolve().then(function() {
                  return __importStar(keycloak);
                })];
              case 1:
                Keycloak_1 = _a.sent()["default"];
                this.keycloak = Keycloak_1(config2);
                return [4, this.keycloak.init(init3)];
              case 2:
                _a.sent();
                this.baseUrl = this.keycloak.authServerUrl;
                _a.label = 3;
              case 3:
                return [2];
            }
          });
        });
      };
      KeycloakAdminClient2.prototype.setAccessToken = function(token2) {
        this.accessToken = token2;
      };
      KeycloakAdminClient2.prototype.getAccessToken = function() {
        return __awaiter2(this, void 0, void 0, function() {
          return __generator2(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!this.keycloak)
                  return [3, 5];
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, this.keycloak.updateToken(5)];
              case 2:
                _a.sent();
                return [3, 4];
              case 3:
                _a.sent();
                this.keycloak.login();
                return [3, 4];
              case 4:
                return [2, this.keycloak.token];
              case 5:
                return [2, this.accessToken];
            }
          });
        });
      };
      KeycloakAdminClient2.prototype.getRequestConfig = function() {
        return this.requestConfig;
      };
      KeycloakAdminClient2.prototype.setConfig = function(connectionConfig) {
        if (typeof connectionConfig.baseUrl === "string" && connectionConfig.baseUrl) {
          this.baseUrl = connectionConfig.baseUrl;
        }
        if (typeof connectionConfig.realmName === "string" && connectionConfig.realmName) {
          this.realmName = connectionConfig.realmName;
        }
        this.requestConfig = connectionConfig.requestConfig;
      };
      return KeycloakAdminClient2;
    }();
    exports2.KeycloakAdminClient = KeycloakAdminClient;
  });
  var lib = createCommonjsModule(function(module2, exports2) {
    exports2.__esModule = true;
    exports2.requiredAction = void 0;
    exports2.requiredAction = requiredActionProviderRepresentation.RequiredActionAlias;
    exports2["default"] = client.KeycloakAdminClient;
  });
  var __pika_web_default_export_for_treeshaking__ = /* @__PURE__ */ getDefaultExportFromCjs(lib);
  var keycloak_admin_default = __pika_web_default_export_for_treeshaking__;
});

// build/_snowpack/env.js
var env_exports = {};
__export(env_exports, {
  MODE: () => MODE,
  NODE_ENV: () => NODE_ENV,
  SSR: () => SSR
});
var MODE = "production";
var NODE_ENV = "production";
var SSR = false;

// build/_snowpack/pkg/common/_commonjsHelpers-4f955397.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x3) {
  return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3["default"] : x3;
}
function createCommonjsModule(fn, basedir, module2) {
  return module2 = {
    path: basedir,
    exports: {},
    require: function(path, base) {
      return commonjsRequire(path, base === void 0 || base === null ? module2.path : base);
    }
  }, fn(module2, module2.exports), module2.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}

// build/_snowpack/pkg/common/index-7cda8b13.js
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i3 = 0; i3 < 10; i3++) {
      test2["_" + String.fromCharCode(i3)] = i3;
    }
    var order22 = Object.getOwnPropertyNames(test2).map(function(n4) {
      return test2[n4];
    });
    if (order22.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source2) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s2 = 1; s2 < arguments.length; s2++) {
    from = Object(arguments[s2]);
    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i3 = 0; i3 < symbols.length; i3++) {
        if (propIsEnumerable.call(from, symbols[i3])) {
          to[symbols[i3]] = from[symbols[i3]];
        }
      }
    }
  }
  return to;
};
var react_production_min = createCommonjsModule(function(module2, exports2) {
  var n4 = 60103, p3 = 60106;
  exports2.Fragment = 60107;
  exports2.StrictMode = 60108;
  exports2.Profiler = 60114;
  var q3 = 60109, r4 = 60110, t4 = 60112;
  exports2.Suspense = 60113;
  var u = 60115, v3 = 60116;
  if (typeof Symbol === "function" && Symbol.for) {
    var w3 = Symbol.for;
    n4 = w3("react.element");
    p3 = w3("react.portal");
    exports2.Fragment = w3("react.fragment");
    exports2.StrictMode = w3("react.strict_mode");
    exports2.Profiler = w3("react.profiler");
    q3 = w3("react.provider");
    r4 = w3("react.context");
    t4 = w3("react.forward_ref");
    exports2.Suspense = w3("react.suspense");
    u = w3("react.memo");
    v3 = w3("react.lazy");
  }
  var x3 = typeof Symbol === "function" && Symbol.iterator;
  function y4(a2) {
    if (a2 === null || typeof a2 !== "object")
      return null;
    a2 = x3 && a2[x3] || a2["@@iterator"];
    return typeof a2 === "function" ? a2 : null;
  }
  function z3(a2) {
    for (var b3 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c4 = 1; c4 < arguments.length; c4++)
      b3 += "&args[]=" + encodeURIComponent(arguments[c4]);
    return "Minified React error #" + a2 + "; visit " + b3 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var A3 = {isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  }}, B2 = {};
  function C(a2, b3, c4) {
    this.props = a2;
    this.context = b3;
    this.refs = B2;
    this.updater = c4 || A3;
  }
  C.prototype.isReactComponent = {};
  C.prototype.setState = function(a2, b3) {
    if (typeof a2 !== "object" && typeof a2 !== "function" && a2 != null)
      throw Error(z3(85));
    this.updater.enqueueSetState(this, a2, b3, "setState");
  };
  C.prototype.forceUpdate = function(a2) {
    this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
  };
  function D2() {
  }
  D2.prototype = C.prototype;
  function E(a2, b3, c4) {
    this.props = a2;
    this.context = b3;
    this.refs = B2;
    this.updater = c4 || A3;
  }
  var F2 = E.prototype = new D2();
  F2.constructor = E;
  objectAssign(F2, C.prototype);
  F2.isPureReactComponent = true;
  var G2 = {current: null}, H2 = Object.prototype.hasOwnProperty, I2 = {key: true, ref: true, __self: true, __source: true};
  function J(a2, b3, c4) {
    var e3, d3 = {}, k3 = null, h3 = null;
    if (b3 != null)
      for (e3 in b3.ref !== void 0 && (h3 = b3.ref), b3.key !== void 0 && (k3 = "" + b3.key), b3)
        H2.call(b3, e3) && !I2.hasOwnProperty(e3) && (d3[e3] = b3[e3]);
    var g3 = arguments.length - 2;
    if (g3 === 1)
      d3.children = c4;
    else if (1 < g3) {
      for (var f3 = Array(g3), m3 = 0; m3 < g3; m3++)
        f3[m3] = arguments[m3 + 2];
      d3.children = f3;
    }
    if (a2 && a2.defaultProps)
      for (e3 in g3 = a2.defaultProps, g3)
        d3[e3] === void 0 && (d3[e3] = g3[e3]);
    return {$$typeof: n4, type: a2, key: k3, ref: h3, props: d3, _owner: G2.current};
  }
  function K(a2, b3) {
    return {$$typeof: n4, type: a2.type, key: b3, ref: a2.ref, props: a2.props, _owner: a2._owner};
  }
  function L(a2) {
    return typeof a2 === "object" && a2 !== null && a2.$$typeof === n4;
  }
  function escape3(a2) {
    var b3 = {"=": "=0", ":": "=2"};
    return "$" + a2.replace(/[=:]/g, function(a3) {
      return b3[a3];
    });
  }
  var M2 = /\/+/g;
  function N2(a2, b3) {
    return typeof a2 === "object" && a2 !== null && a2.key != null ? escape3("" + a2.key) : b3.toString(36);
  }
  function O2(a2, b3, c4, e3, d3) {
    var k3 = typeof a2;
    if (k3 === "undefined" || k3 === "boolean")
      a2 = null;
    var h3 = false;
    if (a2 === null)
      h3 = true;
    else
      switch (k3) {
        case "string":
        case "number":
          h3 = true;
          break;
        case "object":
          switch (a2.$$typeof) {
            case n4:
            case p3:
              h3 = true;
          }
      }
    if (h3)
      return h3 = a2, d3 = d3(h3), a2 = e3 === "" ? "." + N2(h3, 0) : e3, Array.isArray(d3) ? (c4 = "", a2 != null && (c4 = a2.replace(M2, "$&/") + "/"), O2(d3, b3, c4, "", function(a3) {
        return a3;
      })) : d3 != null && (L(d3) && (d3 = K(d3, c4 + (!d3.key || h3 && h3.key === d3.key ? "" : ("" + d3.key).replace(M2, "$&/") + "/") + a2)), b3.push(d3)), 1;
    h3 = 0;
    e3 = e3 === "" ? "." : e3 + ":";
    if (Array.isArray(a2))
      for (var g3 = 0; g3 < a2.length; g3++) {
        k3 = a2[g3];
        var f3 = e3 + N2(k3, g3);
        h3 += O2(k3, b3, c4, f3, d3);
      }
    else if (f3 = y4(a2), typeof f3 === "function")
      for (a2 = f3.call(a2), g3 = 0; !(k3 = a2.next()).done; )
        k3 = k3.value, f3 = e3 + N2(k3, g3++), h3 += O2(k3, b3, c4, f3, d3);
    else if (k3 === "object")
      throw b3 = "" + a2, Error(z3(31, b3 === "[object Object]" ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b3));
    return h3;
  }
  function P2(a2, b3, c4) {
    if (a2 == null)
      return a2;
    var e3 = [], d3 = 0;
    O2(a2, e3, "", "", function(a3) {
      return b3.call(c4, a3, d3++);
    });
    return e3;
  }
  function Q(a2) {
    if (a2._status === -1) {
      var b3 = a2._result;
      b3 = b3();
      a2._status = 0;
      a2._result = b3;
      b3.then(function(b4) {
        a2._status === 0 && (b4 = b4.default, a2._status = 1, a2._result = b4);
      }, function(b4) {
        a2._status === 0 && (a2._status = 2, a2._result = b4);
      });
    }
    if (a2._status === 1)
      return a2._result;
    throw a2._result;
  }
  var R2 = {current: null};
  function S2() {
    var a2 = R2.current;
    if (a2 === null)
      throw Error(z3(321));
    return a2;
  }
  var T2 = {ReactCurrentDispatcher: R2, ReactCurrentBatchConfig: {transition: 0}, ReactCurrentOwner: G2, IsSomeRendererActing: {current: false}, assign: objectAssign};
  exports2.Children = {map: P2, forEach: function(a2, b3, c4) {
    P2(a2, function() {
      b3.apply(this, arguments);
    }, c4);
  }, count: function(a2) {
    var b3 = 0;
    P2(a2, function() {
      b3++;
    });
    return b3;
  }, toArray: function(a2) {
    return P2(a2, function(a3) {
      return a3;
    }) || [];
  }, only: function(a2) {
    if (!L(a2))
      throw Error(z3(143));
    return a2;
  }};
  exports2.Component = C;
  exports2.PureComponent = E;
  exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T2;
  exports2.cloneElement = function(a2, b3, c4) {
    if (a2 === null || a2 === void 0)
      throw Error(z3(267, a2));
    var e3 = objectAssign({}, a2.props), d3 = a2.key, k3 = a2.ref, h3 = a2._owner;
    if (b3 != null) {
      b3.ref !== void 0 && (k3 = b3.ref, h3 = G2.current);
      b3.key !== void 0 && (d3 = "" + b3.key);
      if (a2.type && a2.type.defaultProps)
        var g3 = a2.type.defaultProps;
      for (f3 in b3)
        H2.call(b3, f3) && !I2.hasOwnProperty(f3) && (e3[f3] = b3[f3] === void 0 && g3 !== void 0 ? g3[f3] : b3[f3]);
    }
    var f3 = arguments.length - 2;
    if (f3 === 1)
      e3.children = c4;
    else if (1 < f3) {
      g3 = Array(f3);
      for (var m3 = 0; m3 < f3; m3++)
        g3[m3] = arguments[m3 + 2];
      e3.children = g3;
    }
    return {
      $$typeof: n4,
      type: a2.type,
      key: d3,
      ref: k3,
      props: e3,
      _owner: h3
    };
  };
  exports2.createContext = function(a2, b3) {
    b3 === void 0 && (b3 = null);
    a2 = {$$typeof: r4, _calculateChangedBits: b3, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null};
    a2.Provider = {$$typeof: q3, _context: a2};
    return a2.Consumer = a2;
  };
  exports2.createElement = J;
  exports2.createFactory = function(a2) {
    var b3 = J.bind(null, a2);
    b3.type = a2;
    return b3;
  };
  exports2.createRef = function() {
    return {current: null};
  };
  exports2.forwardRef = function(a2) {
    return {$$typeof: t4, render: a2};
  };
  exports2.isValidElement = L;
  exports2.lazy = function(a2) {
    return {$$typeof: v3, _payload: {_status: -1, _result: a2}, _init: Q};
  };
  exports2.memo = function(a2, b3) {
    return {$$typeof: u, type: a2, compare: b3 === void 0 ? null : b3};
  };
  exports2.useCallback = function(a2, b3) {
    return S2().useCallback(a2, b3);
  };
  exports2.useContext = function(a2, b3) {
    return S2().useContext(a2, b3);
  };
  exports2.useDebugValue = function() {
  };
  exports2.useEffect = function(a2, b3) {
    return S2().useEffect(a2, b3);
  };
  exports2.useImperativeHandle = function(a2, b3, c4) {
    return S2().useImperativeHandle(a2, b3, c4);
  };
  exports2.useLayoutEffect = function(a2, b3) {
    return S2().useLayoutEffect(a2, b3);
  };
  exports2.useMemo = function(a2, b3) {
    return S2().useMemo(a2, b3);
  };
  exports2.useReducer = function(a2, b3, c4) {
    return S2().useReducer(a2, b3, c4);
  };
  exports2.useRef = function(a2) {
    return S2().useRef(a2);
  };
  exports2.useState = function(a2) {
    return S2().useState(a2);
  };
  exports2.version = "17.0.2";
});
var react = createCommonjsModule(function(module2) {
  {
    module2.exports = react_production_min;
  }
});

// build/_snowpack/pkg/react.js
var Children = react.Children;
var Fragment = react.Fragment;
var StrictMode = react.StrictMode;
var cloneElement = react.cloneElement;
var createContext = react.createContext;
var isValidElement = react.isValidElement;
var memo = react.memo;
var useContext = react.useContext;
var useEffect = react.useEffect;
var useMemo = react.useMemo;
var useRef = react.useRef;
var useState = react.useState;

// build/_snowpack/pkg/common/index-916de6ed.js
var scheduler_production_min = createCommonjsModule(function(module2, exports2) {
  var f3, g3, h3, k3;
  if (typeof performance === "object" && typeof performance.now === "function") {
    var l3 = performance;
    exports2.unstable_now = function() {
      return l3.now();
    };
  } else {
    var p3 = Date, q3 = p3.now();
    exports2.unstable_now = function() {
      return p3.now() - q3;
    };
  }
  if (typeof window === "undefined" || typeof MessageChannel !== "function") {
    var t4 = null, u = null, w3 = function() {
      if (t4 !== null)
        try {
          var a2 = exports2.unstable_now();
          t4(true, a2);
          t4 = null;
        } catch (b3) {
          throw setTimeout(w3, 0), b3;
        }
    };
    f3 = function(a2) {
      t4 !== null ? setTimeout(f3, 0, a2) : (t4 = a2, setTimeout(w3, 0));
    };
    g3 = function(a2, b3) {
      u = setTimeout(a2, b3);
    };
    h3 = function() {
      clearTimeout(u);
    };
    exports2.unstable_shouldYield = function() {
      return false;
    };
    k3 = exports2.unstable_forceFrameRate = function() {
    };
  } else {
    var x3 = window.setTimeout, y4 = window.clearTimeout;
    if (typeof console !== "undefined") {
      var z3 = window.cancelAnimationFrame;
      typeof window.requestAnimationFrame !== "function" && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      typeof z3 !== "function" && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    }
    var A3 = false, B2 = null, C = -1, D2 = 5, E = 0;
    exports2.unstable_shouldYield = function() {
      return exports2.unstable_now() >= E;
    };
    k3 = function() {
    };
    exports2.unstable_forceFrameRate = function(a2) {
      0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
    };
    var F2 = new MessageChannel(), G2 = F2.port2;
    F2.port1.onmessage = function() {
      if (B2 !== null) {
        var a2 = exports2.unstable_now();
        E = a2 + D2;
        try {
          B2(true, a2) ? G2.postMessage(null) : (A3 = false, B2 = null);
        } catch (b3) {
          throw G2.postMessage(null), b3;
        }
      } else
        A3 = false;
    };
    f3 = function(a2) {
      B2 = a2;
      A3 || (A3 = true, G2.postMessage(null));
    };
    g3 = function(a2, b3) {
      C = x3(function() {
        a2(exports2.unstable_now());
      }, b3);
    };
    h3 = function() {
      y4(C);
      C = -1;
    };
  }
  function H2(a2, b3) {
    var c4 = a2.length;
    a2.push(b3);
    a:
      for (; ; ) {
        var d3 = c4 - 1 >>> 1, e3 = a2[d3];
        if (e3 !== void 0 && 0 < I2(e3, b3))
          a2[d3] = b3, a2[c4] = e3, c4 = d3;
        else
          break a;
      }
  }
  function J(a2) {
    a2 = a2[0];
    return a2 === void 0 ? null : a2;
  }
  function K(a2) {
    var b3 = a2[0];
    if (b3 !== void 0) {
      var c4 = a2.pop();
      if (c4 !== b3) {
        a2[0] = c4;
        a:
          for (var d3 = 0, e3 = a2.length; d3 < e3; ) {
            var m3 = 2 * (d3 + 1) - 1, n4 = a2[m3], v3 = m3 + 1, r4 = a2[v3];
            if (n4 !== void 0 && 0 > I2(n4, c4))
              r4 !== void 0 && 0 > I2(r4, n4) ? (a2[d3] = r4, a2[v3] = c4, d3 = v3) : (a2[d3] = n4, a2[m3] = c4, d3 = m3);
            else if (r4 !== void 0 && 0 > I2(r4, c4))
              a2[d3] = r4, a2[v3] = c4, d3 = v3;
            else
              break a;
          }
      }
      return b3;
    }
    return null;
  }
  function I2(a2, b3) {
    var c4 = a2.sortIndex - b3.sortIndex;
    return c4 !== 0 ? c4 : a2.id - b3.id;
  }
  var L = [], M2 = [], N2 = 1, O2 = null, P2 = 3, Q = false, R2 = false, S2 = false;
  function T2(a2) {
    for (var b3 = J(M2); b3 !== null; ) {
      if (b3.callback === null)
        K(M2);
      else if (b3.startTime <= a2)
        K(M2), b3.sortIndex = b3.expirationTime, H2(L, b3);
      else
        break;
      b3 = J(M2);
    }
  }
  function U2(a2) {
    S2 = false;
    T2(a2);
    if (!R2)
      if (J(L) !== null)
        R2 = true, f3(V2);
      else {
        var b3 = J(M2);
        b3 !== null && g3(U2, b3.startTime - a2);
      }
  }
  function V2(a2, b3) {
    R2 = false;
    S2 && (S2 = false, h3());
    Q = true;
    var c4 = P2;
    try {
      T2(b3);
      for (O2 = J(L); O2 !== null && (!(O2.expirationTime > b3) || a2 && !exports2.unstable_shouldYield()); ) {
        var d3 = O2.callback;
        if (typeof d3 === "function") {
          O2.callback = null;
          P2 = O2.priorityLevel;
          var e3 = d3(O2.expirationTime <= b3);
          b3 = exports2.unstable_now();
          typeof e3 === "function" ? O2.callback = e3 : O2 === J(L) && K(L);
          T2(b3);
        } else
          K(L);
        O2 = J(L);
      }
      if (O2 !== null)
        var m3 = true;
      else {
        var n4 = J(M2);
        n4 !== null && g3(U2, n4.startTime - b3);
        m3 = false;
      }
      return m3;
    } finally {
      O2 = null, P2 = c4, Q = false;
    }
  }
  var W2 = k3;
  exports2.unstable_IdlePriority = 5;
  exports2.unstable_ImmediatePriority = 1;
  exports2.unstable_LowPriority = 4;
  exports2.unstable_NormalPriority = 3;
  exports2.unstable_Profiling = null;
  exports2.unstable_UserBlockingPriority = 2;
  exports2.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports2.unstable_continueExecution = function() {
    R2 || Q || (R2 = true, f3(V2));
  };
  exports2.unstable_getCurrentPriorityLevel = function() {
    return P2;
  };
  exports2.unstable_getFirstCallbackNode = function() {
    return J(L);
  };
  exports2.unstable_next = function(a2) {
    switch (P2) {
      case 1:
      case 2:
      case 3:
        var b3 = 3;
        break;
      default:
        b3 = P2;
    }
    var c4 = P2;
    P2 = b3;
    try {
      return a2();
    } finally {
      P2 = c4;
    }
  };
  exports2.unstable_pauseExecution = function() {
  };
  exports2.unstable_requestPaint = W2;
  exports2.unstable_runWithPriority = function(a2, b3) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c4 = P2;
    P2 = a2;
    try {
      return b3();
    } finally {
      P2 = c4;
    }
  };
  exports2.unstable_scheduleCallback = function(a2, b3, c4) {
    var d3 = exports2.unstable_now();
    typeof c4 === "object" && c4 !== null ? (c4 = c4.delay, c4 = typeof c4 === "number" && 0 < c4 ? d3 + c4 : d3) : c4 = d3;
    switch (a2) {
      case 1:
        var e3 = -1;
        break;
      case 2:
        e3 = 250;
        break;
      case 5:
        e3 = 1073741823;
        break;
      case 4:
        e3 = 1e4;
        break;
      default:
        e3 = 5e3;
    }
    e3 = c4 + e3;
    a2 = {id: N2++, callback: b3, priorityLevel: a2, startTime: c4, expirationTime: e3, sortIndex: -1};
    c4 > d3 ? (a2.sortIndex = c4, H2(M2, a2), J(L) === null && a2 === J(M2) && (S2 ? h3() : S2 = true, g3(U2, c4 - d3))) : (a2.sortIndex = e3, H2(L, a2), R2 || Q || (R2 = true, f3(V2)));
    return a2;
  };
  exports2.unstable_wrapCallback = function(a2) {
    var b3 = P2;
    return function() {
      var c4 = P2;
      P2 = b3;
      try {
        return a2.apply(this, arguments);
      } finally {
        P2 = c4;
      }
    };
  };
});
var scheduler = createCommonjsModule(function(module2) {
  {
    module2.exports = scheduler_production_min;
  }
});
function y(a2) {
  for (var b3 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c4 = 1; c4 < arguments.length; c4++)
    b3 += "&args[]=" + encodeURIComponent(arguments[c4]);
  return "Minified React error #" + a2 + "; visit " + b3 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
if (!react)
  throw Error(y(227));
var ba = new Set();
var ca = {};
function da(a2, b3) {
  ea(a2, b3);
  ea(a2 + "Capture", b3);
}
function ea(a2, b3) {
  ca[a2] = b3;
  for (a2 = 0; a2 < b3.length; a2++)
    ba.add(b3[a2]);
}
var fa = !(typeof window === "undefined" || typeof window.document === "undefined" || typeof window.document.createElement === "undefined");
var ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
var ia = Object.prototype.hasOwnProperty;
var ja = {};
var ka = {};
function la(a2) {
  if (ia.call(ka, a2))
    return true;
  if (ia.call(ja, a2))
    return false;
  if (ha.test(a2))
    return ka[a2] = true;
  ja[a2] = true;
  return false;
}
function ma(a2, b3, c4, d3) {
  if (c4 !== null && c4.type === 0)
    return false;
  switch (typeof b3) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d3)
        return false;
      if (c4 !== null)
        return !c4.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return a2 !== "data-" && a2 !== "aria-";
    default:
      return false;
  }
}
function na(a2, b3, c4, d3) {
  if (b3 === null || typeof b3 === "undefined" || ma(a2, b3, c4, d3))
    return true;
  if (d3)
    return false;
  if (c4 !== null)
    switch (c4.type) {
      case 3:
        return !b3;
      case 4:
        return b3 === false;
      case 5:
        return isNaN(b3);
      case 6:
        return isNaN(b3) || 1 > b3;
    }
  return false;
}
function B(a2, b3, c4, d3, e3, f3, g3) {
  this.acceptsBooleans = b3 === 2 || b3 === 3 || b3 === 4;
  this.attributeName = d3;
  this.attributeNamespace = e3;
  this.mustUseProperty = c4;
  this.propertyName = a2;
  this.type = b3;
  this.sanitizeURL = f3;
  this.removeEmptyString = g3;
}
var D = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  D[a2] = new B(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b3 = a2[0];
  D[b3] = new B(b3, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  D[a2] = new B(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  D[a2] = new B(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  D[a2] = new B(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  D[a2] = new B(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  D[a2] = new B(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  D[a2] = new B(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  D[a2] = new B(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var oa = /[\-:]([a-z])/g;
function pa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b3 = a2.replace(oa, pa);
  D[b3] = new B(b3, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b3 = a2.replace(oa, pa);
  D[b3] = new B(b3, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b3 = a2.replace(oa, pa);
  D[b3] = new B(b3, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  D[a2] = new B(a2, 1, false, a2.toLowerCase(), null, false, false);
});
D.xlinkHref = new B("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  D[a2] = new B(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function qa(a2, b3, c4, d3) {
  var e3 = D.hasOwnProperty(b3) ? D[b3] : null;
  var f3 = e3 !== null ? e3.type === 0 : d3 ? false : !(2 < b3.length) || b3[0] !== "o" && b3[0] !== "O" || b3[1] !== "n" && b3[1] !== "N" ? false : true;
  f3 || (na(b3, c4, e3, d3) && (c4 = null), d3 || e3 === null ? la(b3) && (c4 === null ? a2.removeAttribute(b3) : a2.setAttribute(b3, "" + c4)) : e3.mustUseProperty ? a2[e3.propertyName] = c4 === null ? e3.type === 3 ? false : "" : c4 : (b3 = e3.attributeName, d3 = e3.attributeNamespace, c4 === null ? a2.removeAttribute(b3) : (e3 = e3.type, c4 = e3 === 3 || e3 === 4 && c4 === true ? "" : "" + c4, d3 ? a2.setAttributeNS(d3, b3, c4) : a2.setAttribute(b3, c4))));
}
var ra = react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
var sa = 60103;
var ta = 60106;
var ua = 60107;
var wa = 60108;
var xa = 60114;
var ya = 60109;
var za = 60110;
var Aa = 60112;
var Ba = 60113;
var Ca = 60120;
var Da = 60115;
var Ea = 60116;
var Fa = 60121;
var Ga = 60128;
var Ha = 60129;
var Ia = 60130;
var Ja = 60131;
if (typeof Symbol === "function" && Symbol.for) {
  E = Symbol.for;
  sa = E("react.element");
  ta = E("react.portal");
  ua = E("react.fragment");
  wa = E("react.strict_mode");
  xa = E("react.profiler");
  ya = E("react.provider");
  za = E("react.context");
  Aa = E("react.forward_ref");
  Ba = E("react.suspense");
  Ca = E("react.suspense_list");
  Da = E("react.memo");
  Ea = E("react.lazy");
  Fa = E("react.block");
  E("react.scope");
  Ga = E("react.opaque.id");
  Ha = E("react.debug_trace_mode");
  Ia = E("react.offscreen");
  Ja = E("react.legacy_hidden");
}
var E;
var Ka = typeof Symbol === "function" && Symbol.iterator;
function La(a2) {
  if (a2 === null || typeof a2 !== "object")
    return null;
  a2 = Ka && a2[Ka] || a2["@@iterator"];
  return typeof a2 === "function" ? a2 : null;
}
var Ma;
function Na(a2) {
  if (Ma === void 0)
    try {
      throw Error();
    } catch (c4) {
      var b3 = c4.stack.trim().match(/\n( *(at )?)/);
      Ma = b3 && b3[1] || "";
    }
  return "\n" + Ma + a2;
}
var Oa = false;
function Pa(a2, b3) {
  if (!a2 || Oa)
    return "";
  Oa = true;
  var c4 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b3)
      if (b3 = function() {
        throw Error();
      }, Object.defineProperty(b3.prototype, "props", {set: function() {
        throw Error();
      }}), typeof Reflect === "object" && Reflect.construct) {
        try {
          Reflect.construct(b3, []);
        } catch (k3) {
          var d3 = k3;
        }
        Reflect.construct(a2, [], b3);
      } else {
        try {
          b3.call();
        } catch (k3) {
          d3 = k3;
        }
        a2.call(b3.prototype);
      }
    else {
      try {
        throw Error();
      } catch (k3) {
        d3 = k3;
      }
      a2();
    }
  } catch (k3) {
    if (k3 && d3 && typeof k3.stack === "string") {
      for (var e3 = k3.stack.split("\n"), f3 = d3.stack.split("\n"), g3 = e3.length - 1, h3 = f3.length - 1; 1 <= g3 && 0 <= h3 && e3[g3] !== f3[h3]; )
        h3--;
      for (; 1 <= g3 && 0 <= h3; g3--, h3--)
        if (e3[g3] !== f3[h3]) {
          if (g3 !== 1 || h3 !== 1) {
            do
              if (g3--, h3--, 0 > h3 || e3[g3] !== f3[h3])
                return "\n" + e3[g3].replace(" at new ", " at ");
            while (1 <= g3 && 0 <= h3);
          }
          break;
        }
    }
  } finally {
    Oa = false, Error.prepareStackTrace = c4;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Na(a2) : "";
}
function Qa(a2) {
  switch (a2.tag) {
    case 5:
      return Na(a2.type);
    case 16:
      return Na("Lazy");
    case 13:
      return Na("Suspense");
    case 19:
      return Na("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Pa(a2.type, false), a2;
    case 11:
      return a2 = Pa(a2.type.render, false), a2;
    case 22:
      return a2 = Pa(a2.type._render, false), a2;
    case 1:
      return a2 = Pa(a2.type, true), a2;
    default:
      return "";
  }
}
function Ra(a2) {
  if (a2 == null)
    return null;
  if (typeof a2 === "function")
    return a2.displayName || a2.name || null;
  if (typeof a2 === "string")
    return a2;
  switch (a2) {
    case ua:
      return "Fragment";
    case ta:
      return "Portal";
    case xa:
      return "Profiler";
    case wa:
      return "StrictMode";
    case Ba:
      return "Suspense";
    case Ca:
      return "SuspenseList";
  }
  if (typeof a2 === "object")
    switch (a2.$$typeof) {
      case za:
        return (a2.displayName || "Context") + ".Consumer";
      case ya:
        return (a2._context.displayName || "Context") + ".Provider";
      case Aa:
        var b3 = a2.render;
        b3 = b3.displayName || b3.name || "";
        return a2.displayName || (b3 !== "" ? "ForwardRef(" + b3 + ")" : "ForwardRef");
      case Da:
        return Ra(a2.type);
      case Fa:
        return Ra(a2._render);
      case Ea:
        b3 = a2._payload;
        a2 = a2._init;
        try {
          return Ra(a2(b3));
        } catch (c4) {
        }
    }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "object":
    case "string":
    case "undefined":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b3 = a2.type;
  return (a2 = a2.nodeName) && a2.toLowerCase() === "input" && (b3 === "checkbox" || b3 === "radio");
}
function Ua(a2) {
  var b3 = Ta(a2) ? "checked" : "value", c4 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b3), d3 = "" + a2[b3];
  if (!a2.hasOwnProperty(b3) && typeof c4 !== "undefined" && typeof c4.get === "function" && typeof c4.set === "function") {
    var e3 = c4.get, f3 = c4.set;
    Object.defineProperty(a2, b3, {configurable: true, get: function() {
      return e3.call(this);
    }, set: function(a3) {
      d3 = "" + a3;
      f3.call(this, a3);
    }});
    Object.defineProperty(a2, b3, {enumerable: c4.enumerable});
    return {getValue: function() {
      return d3;
    }, setValue: function(a3) {
      d3 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b3];
    }};
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b3 = a2._valueTracker;
  if (!b3)
    return true;
  var c4 = b3.getValue();
  var d3 = "";
  a2 && (d3 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d3;
  return a2 !== c4 ? (b3.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || (typeof document !== "undefined" ? document : void 0);
  if (typeof a2 === "undefined")
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b3) {
    return a2.body;
  }
}
function Ya(a2, b3) {
  var c4 = b3.checked;
  return objectAssign({}, b3, {defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: c4 != null ? c4 : a2._wrapperState.initialChecked});
}
function Za(a2, b3) {
  var c4 = b3.defaultValue == null ? "" : b3.defaultValue, d3 = b3.checked != null ? b3.checked : b3.defaultChecked;
  c4 = Sa(b3.value != null ? b3.value : c4);
  a2._wrapperState = {initialChecked: d3, initialValue: c4, controlled: b3.type === "checkbox" || b3.type === "radio" ? b3.checked != null : b3.value != null};
}
function $a(a2, b3) {
  b3 = b3.checked;
  b3 != null && qa(a2, "checked", b3, false);
}
function ab(a2, b3) {
  $a(a2, b3);
  var c4 = Sa(b3.value), d3 = b3.type;
  if (c4 != null)
    if (d3 === "number") {
      if (c4 === 0 && a2.value === "" || a2.value != c4)
        a2.value = "" + c4;
    } else
      a2.value !== "" + c4 && (a2.value = "" + c4);
  else if (d3 === "submit" || d3 === "reset") {
    a2.removeAttribute("value");
    return;
  }
  b3.hasOwnProperty("value") ? bb(a2, b3.type, c4) : b3.hasOwnProperty("defaultValue") && bb(a2, b3.type, Sa(b3.defaultValue));
  b3.checked == null && b3.defaultChecked != null && (a2.defaultChecked = !!b3.defaultChecked);
}
function cb(a2, b3, c4) {
  if (b3.hasOwnProperty("value") || b3.hasOwnProperty("defaultValue")) {
    var d3 = b3.type;
    if (!(d3 !== "submit" && d3 !== "reset" || b3.value !== void 0 && b3.value !== null))
      return;
    b3 = "" + a2._wrapperState.initialValue;
    c4 || b3 === a2.value || (a2.value = b3);
    a2.defaultValue = b3;
  }
  c4 = a2.name;
  c4 !== "" && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  c4 !== "" && (a2.name = c4);
}
function bb(a2, b3, c4) {
  if (b3 !== "number" || Xa(a2.ownerDocument) !== a2)
    c4 == null ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c4 && (a2.defaultValue = "" + c4);
}
function db(a2) {
  var b3 = "";
  react.Children.forEach(a2, function(a3) {
    a3 != null && (b3 += a3);
  });
  return b3;
}
function eb(a2, b3) {
  a2 = objectAssign({children: void 0}, b3);
  if (b3 = db(b3.children))
    a2.children = b3;
  return a2;
}
function fb(a2, b3, c4, d3) {
  a2 = a2.options;
  if (b3) {
    b3 = {};
    for (var e3 = 0; e3 < c4.length; e3++)
      b3["$" + c4[e3]] = true;
    for (c4 = 0; c4 < a2.length; c4++)
      e3 = b3.hasOwnProperty("$" + a2[c4].value), a2[c4].selected !== e3 && (a2[c4].selected = e3), e3 && d3 && (a2[c4].defaultSelected = true);
  } else {
    c4 = "" + Sa(c4);
    b3 = null;
    for (e3 = 0; e3 < a2.length; e3++) {
      if (a2[e3].value === c4) {
        a2[e3].selected = true;
        d3 && (a2[e3].defaultSelected = true);
        return;
      }
      b3 !== null || a2[e3].disabled || (b3 = a2[e3]);
    }
    b3 !== null && (b3.selected = true);
  }
}
function gb(a2, b3) {
  if (b3.dangerouslySetInnerHTML != null)
    throw Error(y(91));
  return objectAssign({}, b3, {value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue});
}
function hb(a2, b3) {
  var c4 = b3.value;
  if (c4 == null) {
    c4 = b3.children;
    b3 = b3.defaultValue;
    if (c4 != null) {
      if (b3 != null)
        throw Error(y(92));
      if (Array.isArray(c4)) {
        if (!(1 >= c4.length))
          throw Error(y(93));
        c4 = c4[0];
      }
      b3 = c4;
    }
    b3 == null && (b3 = "");
    c4 = b3;
  }
  a2._wrapperState = {initialValue: Sa(c4)};
}
function ib(a2, b3) {
  var c4 = Sa(b3.value), d3 = Sa(b3.defaultValue);
  c4 != null && (c4 = "" + c4, c4 !== a2.value && (a2.value = c4), b3.defaultValue == null && a2.defaultValue !== c4 && (a2.defaultValue = c4));
  d3 != null && (a2.defaultValue = "" + d3);
}
function jb(a2) {
  var b3 = a2.textContent;
  b3 === a2._wrapperState.initialValue && b3 !== "" && b3 !== null && (a2.value = b3);
}
var kb = {html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg"};
function lb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function mb(a2, b3) {
  return a2 == null || a2 === "http://www.w3.org/1999/xhtml" ? lb(b3) : a2 === "http://www.w3.org/2000/svg" && b3 === "foreignObject" ? "http://www.w3.org/1999/xhtml" : a2;
}
var nb;
var ob = function(a2) {
  return typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction ? function(b3, c4, d3, e3) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b3, c4, d3, e3);
    });
  } : a2;
}(function(a2, b3) {
  if (a2.namespaceURI !== kb.svg || "innerHTML" in a2)
    a2.innerHTML = b3;
  else {
    nb = nb || document.createElement("div");
    nb.innerHTML = "<svg>" + b3.valueOf().toString() + "</svg>";
    for (b3 = nb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b3.firstChild; )
      a2.appendChild(b3.firstChild);
  }
});
function pb(a2, b3) {
  if (b3) {
    var c4 = a2.firstChild;
    if (c4 && c4 === a2.lastChild && c4.nodeType === 3) {
      c4.nodeValue = b3;
      return;
    }
  }
  a2.textContent = b3;
}
var qb = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var rb = ["Webkit", "ms", "Moz", "O"];
Object.keys(qb).forEach(function(a2) {
  rb.forEach(function(b3) {
    b3 = b3 + a2.charAt(0).toUpperCase() + a2.substring(1);
    qb[b3] = qb[a2];
  });
});
function sb(a2, b3, c4) {
  return b3 == null || typeof b3 === "boolean" || b3 === "" ? "" : c4 || typeof b3 !== "number" || b3 === 0 || qb.hasOwnProperty(a2) && qb[a2] ? ("" + b3).trim() : b3 + "px";
}
function tb(a2, b3) {
  a2 = a2.style;
  for (var c4 in b3)
    if (b3.hasOwnProperty(c4)) {
      var d3 = c4.indexOf("--") === 0, e3 = sb(c4, b3[c4], d3);
      c4 === "float" && (c4 = "cssFloat");
      d3 ? a2.setProperty(c4, e3) : a2[c4] = e3;
    }
}
var ub = objectAssign({menuitem: true}, {area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true});
function vb(a2, b3) {
  if (b3) {
    if (ub[a2] && (b3.children != null || b3.dangerouslySetInnerHTML != null))
      throw Error(y(137, a2));
    if (b3.dangerouslySetInnerHTML != null) {
      if (b3.children != null)
        throw Error(y(60));
      if (!(typeof b3.dangerouslySetInnerHTML === "object" && "__html" in b3.dangerouslySetInnerHTML))
        throw Error(y(61));
    }
    if (b3.style != null && typeof b3.style !== "object")
      throw Error(y(62));
  }
}
function wb(a2, b3) {
  if (a2.indexOf("-") === -1)
    return typeof b3.is === "string";
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return a2.nodeType === 3 ? a2.parentNode : a2;
}
var yb = null;
var zb = null;
var Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if (typeof yb !== "function")
      throw Error(y(280));
    var b3 = a2.stateNode;
    b3 && (b3 = Db(b3), yb(a2.stateNode, a2.type, b3));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b3 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b3)
      for (a2 = 0; a2 < b3.length; a2++)
        Bb(b3[a2]);
  }
}
function Gb(a2, b3) {
  return a2(b3);
}
function Hb(a2, b3, c4, d3, e3) {
  return a2(b3, c4, d3, e3);
}
function Ib() {
}
var Jb = Gb;
var Kb = false;
var Lb = false;
function Mb() {
  if (zb !== null || Ab !== null)
    Ib(), Fb();
}
function Nb(a2, b3, c4) {
  if (Lb)
    return a2(b3, c4);
  Lb = true;
  try {
    return Jb(a2, b3, c4);
  } finally {
    Lb = false, Mb();
  }
}
function Ob(a2, b3) {
  var c4 = a2.stateNode;
  if (c4 === null)
    return null;
  var d3 = Db(c4);
  if (d3 === null)
    return null;
  c4 = d3[b3];
  a:
    switch (b3) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d3 = !d3.disabled) || (a2 = a2.type, d3 = !(a2 === "button" || a2 === "input" || a2 === "select" || a2 === "textarea"));
        a2 = !d3;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c4 && typeof c4 !== "function")
    throw Error(y(231, b3, typeof c4));
  return c4;
}
var Pb = false;
if (fa)
  try {
    Qb = {};
    Object.defineProperty(Qb, "passive", {get: function() {
      Pb = true;
    }});
    window.addEventListener("test", Qb, Qb);
    window.removeEventListener("test", Qb, Qb);
  } catch (a2) {
    Pb = false;
  }
var Qb;
function Rb(a2, b3, c4, d3, e3, f3, g3, h3, k3) {
  var l3 = Array.prototype.slice.call(arguments, 3);
  try {
    b3.apply(c4, l3);
  } catch (n4) {
    this.onError(n4);
  }
}
var Sb = false;
var Tb = null;
var Ub = false;
var Vb = null;
var Wb = {onError: function(a2) {
  Sb = true;
  Tb = a2;
}};
function Xb(a2, b3, c4, d3, e3, f3, g3, h3, k3) {
  Sb = false;
  Tb = null;
  Rb.apply(Wb, arguments);
}
function Yb(a2, b3, c4, d3, e3, f3, g3, h3, k3) {
  Xb.apply(this, arguments);
  if (Sb) {
    if (Sb) {
      var l3 = Tb;
      Sb = false;
      Tb = null;
    } else
      throw Error(y(198));
    Ub || (Ub = true, Vb = l3);
  }
}
function Zb(a2) {
  var b3 = a2, c4 = a2;
  if (a2.alternate)
    for (; b3.return; )
      b3 = b3.return;
  else {
    a2 = b3;
    do
      b3 = a2, (b3.flags & 1026) !== 0 && (c4 = b3.return), a2 = b3.return;
    while (a2);
  }
  return b3.tag === 3 ? c4 : null;
}
function $b(a2) {
  if (a2.tag === 13) {
    var b3 = a2.memoizedState;
    b3 === null && (a2 = a2.alternate, a2 !== null && (b3 = a2.memoizedState));
    if (b3 !== null)
      return b3.dehydrated;
  }
  return null;
}
function ac(a2) {
  if (Zb(a2) !== a2)
    throw Error(y(188));
}
function bc(a2) {
  var b3 = a2.alternate;
  if (!b3) {
    b3 = Zb(a2);
    if (b3 === null)
      throw Error(y(188));
    return b3 !== a2 ? null : a2;
  }
  for (var c4 = a2, d3 = b3; ; ) {
    var e3 = c4.return;
    if (e3 === null)
      break;
    var f3 = e3.alternate;
    if (f3 === null) {
      d3 = e3.return;
      if (d3 !== null) {
        c4 = d3;
        continue;
      }
      break;
    }
    if (e3.child === f3.child) {
      for (f3 = e3.child; f3; ) {
        if (f3 === c4)
          return ac(e3), a2;
        if (f3 === d3)
          return ac(e3), b3;
        f3 = f3.sibling;
      }
      throw Error(y(188));
    }
    if (c4.return !== d3.return)
      c4 = e3, d3 = f3;
    else {
      for (var g3 = false, h3 = e3.child; h3; ) {
        if (h3 === c4) {
          g3 = true;
          c4 = e3;
          d3 = f3;
          break;
        }
        if (h3 === d3) {
          g3 = true;
          d3 = e3;
          c4 = f3;
          break;
        }
        h3 = h3.sibling;
      }
      if (!g3) {
        for (h3 = f3.child; h3; ) {
          if (h3 === c4) {
            g3 = true;
            c4 = f3;
            d3 = e3;
            break;
          }
          if (h3 === d3) {
            g3 = true;
            d3 = f3;
            c4 = e3;
            break;
          }
          h3 = h3.sibling;
        }
        if (!g3)
          throw Error(y(189));
      }
    }
    if (c4.alternate !== d3)
      throw Error(y(190));
  }
  if (c4.tag !== 3)
    throw Error(y(188));
  return c4.stateNode.current === c4 ? a2 : b3;
}
function cc(a2) {
  a2 = bc(a2);
  if (!a2)
    return null;
  for (var b3 = a2; ; ) {
    if (b3.tag === 5 || b3.tag === 6)
      return b3;
    if (b3.child)
      b3.child.return = b3, b3 = b3.child;
    else {
      if (b3 === a2)
        break;
      for (; !b3.sibling; ) {
        if (!b3.return || b3.return === a2)
          return null;
        b3 = b3.return;
      }
      b3.sibling.return = b3.return;
      b3 = b3.sibling;
    }
  }
  return null;
}
function dc(a2, b3) {
  for (var c4 = a2.alternate; b3 !== null; ) {
    if (b3 === a2 || b3 === c4)
      return true;
    b3 = b3.return;
  }
  return false;
}
var ec;
var fc;
var gc;
var hc;
var ic = false;
var jc = [];
var kc = null;
var lc = null;
var mc = null;
var nc = new Map();
var oc = new Map();
var pc = [];
var qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function rc(a2, b3, c4, d3, e3) {
  return {blockedOn: a2, domEventName: b3, eventSystemFlags: c4 | 16, nativeEvent: e3, targetContainers: [d3]};
}
function sc(a2, b3) {
  switch (a2) {
    case "focusin":
    case "focusout":
      kc = null;
      break;
    case "dragenter":
    case "dragleave":
      lc = null;
      break;
    case "mouseover":
    case "mouseout":
      mc = null;
      break;
    case "pointerover":
    case "pointerout":
      nc.delete(b3.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      oc.delete(b3.pointerId);
  }
}
function tc(a2, b3, c4, d3, e3, f3) {
  if (a2 === null || a2.nativeEvent !== f3)
    return a2 = rc(b3, c4, d3, e3, f3), b3 !== null && (b3 = Cb(b3), b3 !== null && fc(b3)), a2;
  a2.eventSystemFlags |= d3;
  b3 = a2.targetContainers;
  e3 !== null && b3.indexOf(e3) === -1 && b3.push(e3);
  return a2;
}
function uc(a2, b3, c4, d3, e3) {
  switch (b3) {
    case "focusin":
      return kc = tc(kc, a2, b3, c4, d3, e3), true;
    case "dragenter":
      return lc = tc(lc, a2, b3, c4, d3, e3), true;
    case "mouseover":
      return mc = tc(mc, a2, b3, c4, d3, e3), true;
    case "pointerover":
      var f3 = e3.pointerId;
      nc.set(f3, tc(nc.get(f3) || null, a2, b3, c4, d3, e3));
      return true;
    case "gotpointercapture":
      return f3 = e3.pointerId, oc.set(f3, tc(oc.get(f3) || null, a2, b3, c4, d3, e3)), true;
  }
  return false;
}
function vc(a2) {
  var b3 = wc(a2.target);
  if (b3 !== null) {
    var c4 = Zb(b3);
    if (c4 !== null) {
      if (b3 = c4.tag, b3 === 13) {
        if (b3 = $b(c4), b3 !== null) {
          a2.blockedOn = b3;
          hc(a2.lanePriority, function() {
            scheduler.unstable_runWithPriority(a2.priority, function() {
              gc(c4);
            });
          });
          return;
        }
      } else if (b3 === 3 && c4.stateNode.hydrate) {
        a2.blockedOn = c4.tag === 3 ? c4.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function xc(a2) {
  if (a2.blockedOn !== null)
    return false;
  for (var b3 = a2.targetContainers; 0 < b3.length; ) {
    var c4 = yc(a2.domEventName, a2.eventSystemFlags, b3[0], a2.nativeEvent);
    if (c4 !== null)
      return b3 = Cb(c4), b3 !== null && fc(b3), a2.blockedOn = c4, false;
    b3.shift();
  }
  return true;
}
function zc(a2, b3, c4) {
  xc(a2) && c4.delete(b3);
}
function Ac() {
  for (ic = false; 0 < jc.length; ) {
    var a2 = jc[0];
    if (a2.blockedOn !== null) {
      a2 = Cb(a2.blockedOn);
      a2 !== null && ec(a2);
      break;
    }
    for (var b3 = a2.targetContainers; 0 < b3.length; ) {
      var c4 = yc(a2.domEventName, a2.eventSystemFlags, b3[0], a2.nativeEvent);
      if (c4 !== null) {
        a2.blockedOn = c4;
        break;
      }
      b3.shift();
    }
    a2.blockedOn === null && jc.shift();
  }
  kc !== null && xc(kc) && (kc = null);
  lc !== null && xc(lc) && (lc = null);
  mc !== null && xc(mc) && (mc = null);
  nc.forEach(zc);
  oc.forEach(zc);
}
function Bc(a2, b3) {
  a2.blockedOn === b3 && (a2.blockedOn = null, ic || (ic = true, scheduler.unstable_scheduleCallback(scheduler.unstable_NormalPriority, Ac)));
}
function Cc(a2) {
  function b3(b4) {
    return Bc(b4, a2);
  }
  if (0 < jc.length) {
    Bc(jc[0], a2);
    for (var c4 = 1; c4 < jc.length; c4++) {
      var d3 = jc[c4];
      d3.blockedOn === a2 && (d3.blockedOn = null);
    }
  }
  kc !== null && Bc(kc, a2);
  lc !== null && Bc(lc, a2);
  mc !== null && Bc(mc, a2);
  nc.forEach(b3);
  oc.forEach(b3);
  for (c4 = 0; c4 < pc.length; c4++)
    d3 = pc[c4], d3.blockedOn === a2 && (d3.blockedOn = null);
  for (; 0 < pc.length && (c4 = pc[0], c4.blockedOn === null); )
    vc(c4), c4.blockedOn === null && pc.shift();
}
function Dc(a2, b3) {
  var c4 = {};
  c4[a2.toLowerCase()] = b3.toLowerCase();
  c4["Webkit" + a2] = "webkit" + b3;
  c4["Moz" + a2] = "moz" + b3;
  return c4;
}
var Ec = {animationend: Dc("Animation", "AnimationEnd"), animationiteration: Dc("Animation", "AnimationIteration"), animationstart: Dc("Animation", "AnimationStart"), transitionend: Dc("Transition", "TransitionEnd")};
var Fc = {};
var Gc = {};
fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);
function Hc(a2) {
  if (Fc[a2])
    return Fc[a2];
  if (!Ec[a2])
    return a2;
  var b3 = Ec[a2], c4;
  for (c4 in b3)
    if (b3.hasOwnProperty(c4) && c4 in Gc)
      return Fc[a2] = b3[c4];
  return a2;
}
var Ic = Hc("animationend");
var Jc = Hc("animationiteration");
var Kc = Hc("animationstart");
var Lc = Hc("transitionend");
var Mc = new Map();
var Nc = new Map();
var Oc = [
  "abort",
  "abort",
  Ic,
  "animationEnd",
  Jc,
  "animationIteration",
  Kc,
  "animationStart",
  "canplay",
  "canPlay",
  "canplaythrough",
  "canPlayThrough",
  "durationchange",
  "durationChange",
  "emptied",
  "emptied",
  "encrypted",
  "encrypted",
  "ended",
  "ended",
  "error",
  "error",
  "gotpointercapture",
  "gotPointerCapture",
  "load",
  "load",
  "loadeddata",
  "loadedData",
  "loadedmetadata",
  "loadedMetadata",
  "loadstart",
  "loadStart",
  "lostpointercapture",
  "lostPointerCapture",
  "playing",
  "playing",
  "progress",
  "progress",
  "seeking",
  "seeking",
  "stalled",
  "stalled",
  "suspend",
  "suspend",
  "timeupdate",
  "timeUpdate",
  Lc,
  "transitionEnd",
  "waiting",
  "waiting"
];
function Pc(a2, b3) {
  for (var c4 = 0; c4 < a2.length; c4 += 2) {
    var d3 = a2[c4], e3 = a2[c4 + 1];
    e3 = "on" + (e3[0].toUpperCase() + e3.slice(1));
    Nc.set(d3, b3);
    Mc.set(d3, e3);
    da(e3, [d3]);
  }
}
var Qc = scheduler.unstable_now;
Qc();
var F = 8;
function Rc(a2) {
  if ((1 & a2) !== 0)
    return F = 15, 1;
  if ((2 & a2) !== 0)
    return F = 14, 2;
  if ((4 & a2) !== 0)
    return F = 13, 4;
  var b3 = 24 & a2;
  if (b3 !== 0)
    return F = 12, b3;
  if ((a2 & 32) !== 0)
    return F = 11, 32;
  b3 = 192 & a2;
  if (b3 !== 0)
    return F = 10, b3;
  if ((a2 & 256) !== 0)
    return F = 9, 256;
  b3 = 3584 & a2;
  if (b3 !== 0)
    return F = 8, b3;
  if ((a2 & 4096) !== 0)
    return F = 7, 4096;
  b3 = 4186112 & a2;
  if (b3 !== 0)
    return F = 6, b3;
  b3 = 62914560 & a2;
  if (b3 !== 0)
    return F = 5, b3;
  if (a2 & 67108864)
    return F = 4, 67108864;
  if ((a2 & 134217728) !== 0)
    return F = 3, 134217728;
  b3 = 805306368 & a2;
  if (b3 !== 0)
    return F = 2, b3;
  if ((1073741824 & a2) !== 0)
    return F = 1, 1073741824;
  F = 8;
  return a2;
}
function Sc(a2) {
  switch (a2) {
    case 99:
      return 15;
    case 98:
      return 10;
    case 97:
    case 96:
      return 8;
    case 95:
      return 2;
    default:
      return 0;
  }
}
function Tc(a2) {
  switch (a2) {
    case 15:
    case 14:
      return 99;
    case 13:
    case 12:
    case 11:
    case 10:
      return 98;
    case 9:
    case 8:
    case 7:
    case 6:
    case 4:
    case 5:
      return 97;
    case 3:
    case 2:
    case 1:
      return 95;
    case 0:
      return 90;
    default:
      throw Error(y(358, a2));
  }
}
function Uc(a2, b3) {
  var c4 = a2.pendingLanes;
  if (c4 === 0)
    return F = 0;
  var d3 = 0, e3 = 0, f3 = a2.expiredLanes, g3 = a2.suspendedLanes, h3 = a2.pingedLanes;
  if (f3 !== 0)
    d3 = f3, e3 = F = 15;
  else if (f3 = c4 & 134217727, f3 !== 0) {
    var k3 = f3 & ~g3;
    k3 !== 0 ? (d3 = Rc(k3), e3 = F) : (h3 &= f3, h3 !== 0 && (d3 = Rc(h3), e3 = F));
  } else
    f3 = c4 & ~g3, f3 !== 0 ? (d3 = Rc(f3), e3 = F) : h3 !== 0 && (d3 = Rc(h3), e3 = F);
  if (d3 === 0)
    return 0;
  d3 = 31 - Vc(d3);
  d3 = c4 & ((0 > d3 ? 0 : 1 << d3) << 1) - 1;
  if (b3 !== 0 && b3 !== d3 && (b3 & g3) === 0) {
    Rc(b3);
    if (e3 <= F)
      return b3;
    F = e3;
  }
  b3 = a2.entangledLanes;
  if (b3 !== 0)
    for (a2 = a2.entanglements, b3 &= d3; 0 < b3; )
      c4 = 31 - Vc(b3), e3 = 1 << c4, d3 |= a2[c4], b3 &= ~e3;
  return d3;
}
function Wc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return a2 !== 0 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function Xc(a2, b3) {
  switch (a2) {
    case 15:
      return 1;
    case 14:
      return 2;
    case 12:
      return a2 = Yc(24 & ~b3), a2 === 0 ? Xc(10, b3) : a2;
    case 10:
      return a2 = Yc(192 & ~b3), a2 === 0 ? Xc(8, b3) : a2;
    case 8:
      return a2 = Yc(3584 & ~b3), a2 === 0 && (a2 = Yc(4186112 & ~b3), a2 === 0 && (a2 = 512)), a2;
    case 2:
      return b3 = Yc(805306368 & ~b3), b3 === 0 && (b3 = 268435456), b3;
  }
  throw Error(y(358, a2));
}
function Yc(a2) {
  return a2 & -a2;
}
function Zc(a2) {
  for (var b3 = [], c4 = 0; 31 > c4; c4++)
    b3.push(a2);
  return b3;
}
function $c(a2, b3, c4) {
  a2.pendingLanes |= b3;
  var d3 = b3 - 1;
  a2.suspendedLanes &= d3;
  a2.pingedLanes &= d3;
  a2 = a2.eventTimes;
  b3 = 31 - Vc(b3);
  a2[b3] = c4;
}
var Vc = Math.clz32 ? Math.clz32 : ad;
var bd = Math.log;
var cd = Math.LN2;
function ad(a2) {
  return a2 === 0 ? 32 : 31 - (bd(a2) / cd | 0) | 0;
}
var dd = scheduler.unstable_UserBlockingPriority;
var ed = scheduler.unstable_runWithPriority;
var fd = true;
function gd(a2, b3, c4, d3) {
  Kb || Ib();
  var e3 = hd, f3 = Kb;
  Kb = true;
  try {
    Hb(e3, a2, b3, c4, d3);
  } finally {
    (Kb = f3) || Mb();
  }
}
function id(a2, b3, c4, d3) {
  ed(dd, hd.bind(null, a2, b3, c4, d3));
}
function hd(a2, b3, c4, d3) {
  if (fd) {
    var e3;
    if ((e3 = (b3 & 4) === 0) && 0 < jc.length && -1 < qc.indexOf(a2))
      a2 = rc(null, a2, b3, c4, d3), jc.push(a2);
    else {
      var f3 = yc(a2, b3, c4, d3);
      if (f3 === null)
        e3 && sc(a2, d3);
      else {
        if (e3) {
          if (-1 < qc.indexOf(a2)) {
            a2 = rc(f3, a2, b3, c4, d3);
            jc.push(a2);
            return;
          }
          if (uc(f3, a2, b3, c4, d3))
            return;
          sc(a2, d3);
        }
        jd(a2, b3, d3, null, c4);
      }
    }
  }
}
function yc(a2, b3, c4, d3) {
  var e3 = xb(d3);
  e3 = wc(e3);
  if (e3 !== null) {
    var f3 = Zb(e3);
    if (f3 === null)
      e3 = null;
    else {
      var g3 = f3.tag;
      if (g3 === 13) {
        e3 = $b(f3);
        if (e3 !== null)
          return e3;
        e3 = null;
      } else if (g3 === 3) {
        if (f3.stateNode.hydrate)
          return f3.tag === 3 ? f3.stateNode.containerInfo : null;
        e3 = null;
      } else
        f3 !== e3 && (e3 = null);
    }
  }
  jd(a2, b3, d3, e3, c4);
  return null;
}
var kd = null;
var ld = null;
var md = null;
function nd() {
  if (md)
    return md;
  var a2, b3 = ld, c4 = b3.length, d3, e3 = "value" in kd ? kd.value : kd.textContent, f3 = e3.length;
  for (a2 = 0; a2 < c4 && b3[a2] === e3[a2]; a2++)
    ;
  var g3 = c4 - a2;
  for (d3 = 1; d3 <= g3 && b3[c4 - d3] === e3[f3 - d3]; d3++)
    ;
  return md = e3.slice(a2, 1 < d3 ? 1 - d3 : void 0);
}
function od(a2) {
  var b3 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, a2 === 0 && b3 === 13 && (a2 = 13)) : a2 = b3;
  a2 === 10 && (a2 = 13);
  return 32 <= a2 || a2 === 13 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b3(b4, d3, e3, f3, g3) {
    this._reactName = b4;
    this._targetInst = e3;
    this.type = d3;
    this.nativeEvent = f3;
    this.target = g3;
    this.currentTarget = null;
    for (var c4 in a2)
      a2.hasOwnProperty(c4) && (b4 = a2[c4], this[c4] = b4 ? b4(f3) : f3[c4]);
    this.isDefaultPrevented = (f3.defaultPrevented != null ? f3.defaultPrevented : f3.returnValue === false) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  objectAssign(b3.prototype, {preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : typeof a3.returnValue !== "unknown" && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : typeof a3.cancelBubble !== "unknown" && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd});
  return b3;
}
var sd = {eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0};
var td = rd(sd);
var ud = objectAssign({}, sd, {view: 0, detail: 0});
var vd = rd(ud);
var wd;
var xd;
var yd;
var Ad = objectAssign({}, ud, {screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return a2.relatedTarget === void 0 ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && a2.type === "mousemove" ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
}});
var Bd = rd(Ad);
var Cd = objectAssign({}, Ad, {dataTransfer: 0});
var Dd = rd(Cd);
var Ed = objectAssign({}, ud, {relatedTarget: 0});
var Fd = rd(Ed);
var Gd = objectAssign({}, sd, {animationName: 0, elapsedTime: 0, pseudoElement: 0});
var Hd = rd(Gd);
var Id = objectAssign({}, sd, {clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
}});
var Jd = rd(Id);
var Kd = objectAssign({}, sd, {data: 0});
var Ld = rd(Kd);
var Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
};
var Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
};
var Od = {Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey"};
function Pd(a2) {
  var b3 = this.nativeEvent;
  return b3.getModifierState ? b3.getModifierState(a2) : (a2 = Od[a2]) ? !!b3[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = objectAssign({}, ud, {key: function(a2) {
  if (a2.key) {
    var b3 = Md[a2.key] || a2.key;
    if (b3 !== "Unidentified")
      return b3;
  }
  return a2.type === "keypress" ? (a2 = od(a2), a2 === 13 ? "Enter" : String.fromCharCode(a2)) : a2.type === "keydown" || a2.type === "keyup" ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return a2.type === "keypress" ? od(a2) : 0;
}, keyCode: function(a2) {
  return a2.type === "keydown" || a2.type === "keyup" ? a2.keyCode : 0;
}, which: function(a2) {
  return a2.type === "keypress" ? od(a2) : a2.type === "keydown" || a2.type === "keyup" ? a2.keyCode : 0;
}});
var Rd = rd(Qd);
var Sd = objectAssign({}, Ad, {pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0});
var Td = rd(Sd);
var Ud = objectAssign({}, ud, {touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd});
var Vd = rd(Ud);
var Wd = objectAssign({}, sd, {propertyName: 0, elapsedTime: 0, pseudoElement: 0});
var Xd = rd(Wd);
var Yd = objectAssign({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
});
var Zd = rd(Yd);
var $d = [9, 13, 27, 32];
var ae = fa && "CompositionEvent" in window;
var be = null;
fa && "documentMode" in document && (be = document.documentMode);
var ce = fa && "TextEvent" in window && !be;
var de = fa && (!ae || be && 8 < be && 11 >= be);
var ee = String.fromCharCode(32);
var fe = false;
function ge(a2, b3) {
  switch (a2) {
    case "keyup":
      return $d.indexOf(b3.keyCode) !== -1;
    case "keydown":
      return b3.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a2) {
  a2 = a2.detail;
  return typeof a2 === "object" && "data" in a2 ? a2.data : null;
}
var ie = false;
function je(a2, b3) {
  switch (a2) {
    case "compositionend":
      return he(b3);
    case "keypress":
      if (b3.which !== 32)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a2 = b3.data, a2 === ee && fe ? null : a2;
    default:
      return null;
  }
}
function ke(a2, b3) {
  if (ie)
    return a2 === "compositionend" || !ae && ge(a2, b3) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b3.ctrlKey || b3.altKey || b3.metaKey) || b3.ctrlKey && b3.altKey) {
        if (b3.char && 1 < b3.char.length)
          return b3.char;
        if (b3.which)
          return String.fromCharCode(b3.which);
      }
      return null;
    case "compositionend":
      return de && b3.locale !== "ko" ? null : b3.data;
    default:
      return null;
  }
}
var le = {color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true};
function me(a2) {
  var b3 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b3 === "input" ? !!le[a2.type] : b3 === "textarea" ? true : false;
}
function ne(a2, b3, c4, d3) {
  Eb(d3);
  b3 = oe(b3, "onChange");
  0 < b3.length && (c4 = new td("onChange", "change", null, c4, d3), a2.push({event: c4, listeners: b3}));
}
var pe = null;
var qe = null;
function re(a2) {
  se(a2, 0);
}
function te(a2) {
  var b3 = ue(a2);
  if (Wa(b3))
    return a2;
}
function ve(a2, b3) {
  if (a2 === "change")
    return b3;
}
var we = false;
if (fa) {
  if (fa) {
    ye = "oninput" in document;
    if (!ye) {
      ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = typeof ze.oninput === "function";
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
var xe;
var ye;
var ze;
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a2) {
  if (a2.propertyName === "value" && te(qe)) {
    var b3 = [];
    ne(b3, qe, a2, xb(a2));
    a2 = re;
    if (Kb)
      a2(b3);
    else {
      Kb = true;
      try {
        Gb(a2, b3);
      } finally {
        Kb = false, Mb();
      }
    }
  }
}
function Ce(a2, b3, c4) {
  a2 === "focusin" ? (Ae(), pe = b3, qe = c4, pe.attachEvent("onpropertychange", Be)) : a2 === "focusout" && Ae();
}
function De(a2) {
  if (a2 === "selectionchange" || a2 === "keyup" || a2 === "keydown")
    return te(qe);
}
function Ee(a2, b3) {
  if (a2 === "click")
    return te(b3);
}
function Fe(a2, b3) {
  if (a2 === "input" || a2 === "change")
    return te(b3);
}
function Ge(a2, b3) {
  return a2 === b3 && (a2 !== 0 || 1 / a2 === 1 / b3) || a2 !== a2 && b3 !== b3;
}
var He = typeof Object.is === "function" ? Object.is : Ge;
var Ie = Object.prototype.hasOwnProperty;
function Je(a2, b3) {
  if (He(a2, b3))
    return true;
  if (typeof a2 !== "object" || a2 === null || typeof b3 !== "object" || b3 === null)
    return false;
  var c4 = Object.keys(a2), d3 = Object.keys(b3);
  if (c4.length !== d3.length)
    return false;
  for (d3 = 0; d3 < c4.length; d3++)
    if (!Ie.call(b3, c4[d3]) || !He(a2[c4[d3]], b3[c4[d3]]))
      return false;
  return true;
}
function Ke(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Le(a2, b3) {
  var c4 = Ke(a2);
  a2 = 0;
  for (var d3; c4; ) {
    if (c4.nodeType === 3) {
      d3 = a2 + c4.textContent.length;
      if (a2 <= b3 && d3 >= b3)
        return {node: c4, offset: b3 - a2};
      a2 = d3;
    }
    a: {
      for (; c4; ) {
        if (c4.nextSibling) {
          c4 = c4.nextSibling;
          break a;
        }
        c4 = c4.parentNode;
      }
      c4 = void 0;
    }
    c4 = Ke(c4);
  }
}
function Me(a2, b3) {
  return a2 && b3 ? a2 === b3 ? true : a2 && a2.nodeType === 3 ? false : b3 && b3.nodeType === 3 ? Me(a2, b3.parentNode) : "contains" in a2 ? a2.contains(b3) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b3) & 16) : false : false;
}
function Ne() {
  for (var a2 = window, b3 = Xa(); b3 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c4 = typeof b3.contentWindow.location.href === "string";
    } catch (d3) {
      c4 = false;
    }
    if (c4)
      a2 = b3.contentWindow;
    else
      break;
    b3 = Xa(a2.document);
  }
  return b3;
}
function Oe(a2) {
  var b3 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b3 && (b3 === "input" && (a2.type === "text" || a2.type === "search" || a2.type === "tel" || a2.type === "url" || a2.type === "password") || b3 === "textarea" || a2.contentEditable === "true");
}
var Pe = fa && "documentMode" in document && 11 >= document.documentMode;
var Qe = null;
var Re = null;
var Se = null;
var Te = false;
function Ue(a2, b3, c4) {
  var d3 = c4.window === c4 ? c4.document : c4.nodeType === 9 ? c4 : c4.ownerDocument;
  Te || Qe == null || Qe !== Xa(d3) || (d3 = Qe, "selectionStart" in d3 && Oe(d3) ? d3 = {start: d3.selectionStart, end: d3.selectionEnd} : (d3 = (d3.ownerDocument && d3.ownerDocument.defaultView || window).getSelection(), d3 = {anchorNode: d3.anchorNode, anchorOffset: d3.anchorOffset, focusNode: d3.focusNode, focusOffset: d3.focusOffset}), Se && Je(Se, d3) || (Se = d3, d3 = oe(Re, "onSelect"), 0 < d3.length && (b3 = new td("onSelect", "select", null, b3, c4), a2.push({event: b3, listeners: d3}), b3.target = Qe)));
}
Pc("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0);
Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
Pc(Oc, 2);
for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++)
  Nc.set(Ve[We], 0);
ea("onMouseEnter", ["mouseout", "mouseover"]);
ea("onMouseLeave", ["mouseout", "mouseover"]);
ea("onPointerEnter", ["pointerout", "pointerover"]);
ea("onPointerLeave", ["pointerout", "pointerover"]);
da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
var Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
function Ze(a2, b3, c4) {
  var d3 = a2.type || "unknown-event";
  a2.currentTarget = c4;
  Yb(d3, b3, void 0, a2);
  a2.currentTarget = null;
}
function se(a2, b3) {
  b3 = (b3 & 4) !== 0;
  for (var c4 = 0; c4 < a2.length; c4++) {
    var d3 = a2[c4], e3 = d3.event;
    d3 = d3.listeners;
    a: {
      var f3 = void 0;
      if (b3)
        for (var g3 = d3.length - 1; 0 <= g3; g3--) {
          var h3 = d3[g3], k3 = h3.instance, l3 = h3.currentTarget;
          h3 = h3.listener;
          if (k3 !== f3 && e3.isPropagationStopped())
            break a;
          Ze(e3, h3, l3);
          f3 = k3;
        }
      else
        for (g3 = 0; g3 < d3.length; g3++) {
          h3 = d3[g3];
          k3 = h3.instance;
          l3 = h3.currentTarget;
          h3 = h3.listener;
          if (k3 !== f3 && e3.isPropagationStopped())
            break a;
          Ze(e3, h3, l3);
          f3 = k3;
        }
    }
  }
  if (Ub)
    throw a2 = Vb, Ub = false, Vb = null, a2;
}
function G(a2, b3) {
  var c4 = $e(b3), d3 = a2 + "__bubble";
  c4.has(d3) || (af(b3, a2, 2, false), c4.add(d3));
}
var bf = "_reactListening" + Math.random().toString(36).slice(2);
function cf(a2) {
  a2[bf] || (a2[bf] = true, ba.forEach(function(b3) {
    Ye.has(b3) || df(b3, false, a2, null);
    df(b3, true, a2, null);
  }));
}
function df(a2, b3, c4, d3) {
  var e3 = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : 0, f3 = c4;
  a2 === "selectionchange" && c4.nodeType !== 9 && (f3 = c4.ownerDocument);
  if (d3 !== null && !b3 && Ye.has(a2)) {
    if (a2 !== "scroll")
      return;
    e3 |= 2;
    f3 = d3;
  }
  var g3 = $e(f3), h3 = a2 + "__" + (b3 ? "capture" : "bubble");
  g3.has(h3) || (b3 && (e3 |= 4), af(f3, a2, e3, b3), g3.add(h3));
}
function af(a2, b3, c4, d3) {
  var e3 = Nc.get(b3);
  switch (e3 === void 0 ? 2 : e3) {
    case 0:
      e3 = gd;
      break;
    case 1:
      e3 = id;
      break;
    default:
      e3 = hd;
  }
  c4 = e3.bind(null, b3, c4, a2);
  e3 = void 0;
  !Pb || b3 !== "touchstart" && b3 !== "touchmove" && b3 !== "wheel" || (e3 = true);
  d3 ? e3 !== void 0 ? a2.addEventListener(b3, c4, {capture: true, passive: e3}) : a2.addEventListener(b3, c4, true) : e3 !== void 0 ? a2.addEventListener(b3, c4, {passive: e3}) : a2.addEventListener(b3, c4, false);
}
function jd(a2, b3, c4, d3, e3) {
  var f3 = d3;
  if ((b3 & 1) === 0 && (b3 & 2) === 0 && d3 !== null)
    a:
      for (; ; ) {
        if (d3 === null)
          return;
        var g3 = d3.tag;
        if (g3 === 3 || g3 === 4) {
          var h3 = d3.stateNode.containerInfo;
          if (h3 === e3 || h3.nodeType === 8 && h3.parentNode === e3)
            break;
          if (g3 === 4)
            for (g3 = d3.return; g3 !== null; ) {
              var k3 = g3.tag;
              if (k3 === 3 || k3 === 4) {
                if (k3 = g3.stateNode.containerInfo, k3 === e3 || k3.nodeType === 8 && k3.parentNode === e3)
                  return;
              }
              g3 = g3.return;
            }
          for (; h3 !== null; ) {
            g3 = wc(h3);
            if (g3 === null)
              return;
            k3 = g3.tag;
            if (k3 === 5 || k3 === 6) {
              d3 = f3 = g3;
              continue a;
            }
            h3 = h3.parentNode;
          }
        }
        d3 = d3.return;
      }
  Nb(function() {
    var d4 = f3, e4 = xb(c4), g4 = [];
    a: {
      var h4 = Mc.get(a2);
      if (h4 !== void 0) {
        var k4 = td, x3 = a2;
        switch (a2) {
          case "keypress":
            if (od(c4) === 0)
              break a;
          case "keydown":
          case "keyup":
            k4 = Rd;
            break;
          case "focusin":
            x3 = "focus";
            k4 = Fd;
            break;
          case "focusout":
            x3 = "blur";
            k4 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k4 = Fd;
            break;
          case "click":
            if (c4.button === 2)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k4 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k4 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k4 = Vd;
            break;
          case Ic:
          case Jc:
          case Kc:
            k4 = Hd;
            break;
          case Lc:
            k4 = Xd;
            break;
          case "scroll":
            k4 = vd;
            break;
          case "wheel":
            k4 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k4 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k4 = Td;
        }
        var w3 = (b3 & 4) !== 0, z3 = !w3 && a2 === "scroll", u = w3 ? h4 !== null ? h4 + "Capture" : null : h4;
        w3 = [];
        for (var t4 = d4, q3; t4 !== null; ) {
          q3 = t4;
          var v3 = q3.stateNode;
          q3.tag === 5 && v3 !== null && (q3 = v3, u !== null && (v3 = Ob(t4, u), v3 != null && w3.push(ef(t4, v3, q3))));
          if (z3)
            break;
          t4 = t4.return;
        }
        0 < w3.length && (h4 = new k4(h4, x3, null, c4, e4), g4.push({event: h4, listeners: w3}));
      }
    }
    if ((b3 & 7) === 0) {
      a: {
        h4 = a2 === "mouseover" || a2 === "pointerover";
        k4 = a2 === "mouseout" || a2 === "pointerout";
        if (h4 && (b3 & 16) === 0 && (x3 = c4.relatedTarget || c4.fromElement) && (wc(x3) || x3[ff]))
          break a;
        if (k4 || h4) {
          h4 = e4.window === e4 ? e4 : (h4 = e4.ownerDocument) ? h4.defaultView || h4.parentWindow : window;
          if (k4) {
            if (x3 = c4.relatedTarget || c4.toElement, k4 = d4, x3 = x3 ? wc(x3) : null, x3 !== null && (z3 = Zb(x3), x3 !== z3 || x3.tag !== 5 && x3.tag !== 6))
              x3 = null;
          } else
            k4 = null, x3 = d4;
          if (k4 !== x3) {
            w3 = Bd;
            v3 = "onMouseLeave";
            u = "onMouseEnter";
            t4 = "mouse";
            if (a2 === "pointerout" || a2 === "pointerover")
              w3 = Td, v3 = "onPointerLeave", u = "onPointerEnter", t4 = "pointer";
            z3 = k4 == null ? h4 : ue(k4);
            q3 = x3 == null ? h4 : ue(x3);
            h4 = new w3(v3, t4 + "leave", k4, c4, e4);
            h4.target = z3;
            h4.relatedTarget = q3;
            v3 = null;
            wc(e4) === d4 && (w3 = new w3(u, t4 + "enter", x3, c4, e4), w3.target = q3, w3.relatedTarget = z3, v3 = w3);
            z3 = v3;
            if (k4 && x3)
              b: {
                w3 = k4;
                u = x3;
                t4 = 0;
                for (q3 = w3; q3; q3 = gf(q3))
                  t4++;
                q3 = 0;
                for (v3 = u; v3; v3 = gf(v3))
                  q3++;
                for (; 0 < t4 - q3; )
                  w3 = gf(w3), t4--;
                for (; 0 < q3 - t4; )
                  u = gf(u), q3--;
                for (; t4--; ) {
                  if (w3 === u || u !== null && w3 === u.alternate)
                    break b;
                  w3 = gf(w3);
                  u = gf(u);
                }
                w3 = null;
              }
            else
              w3 = null;
            k4 !== null && hf(g4, h4, k4, w3, false);
            x3 !== null && z3 !== null && hf(g4, z3, x3, w3, true);
          }
        }
      }
      a: {
        h4 = d4 ? ue(d4) : window;
        k4 = h4.nodeName && h4.nodeName.toLowerCase();
        if (k4 === "select" || k4 === "input" && h4.type === "file")
          var J = ve;
        else if (me(h4))
          if (we)
            J = Fe;
          else {
            J = De;
            var K = Ce;
          }
        else
          (k4 = h4.nodeName) && k4.toLowerCase() === "input" && (h4.type === "checkbox" || h4.type === "radio") && (J = Ee);
        if (J && (J = J(a2, d4))) {
          ne(g4, J, c4, e4);
          break a;
        }
        K && K(a2, h4, d4);
        a2 === "focusout" && (K = h4._wrapperState) && K.controlled && h4.type === "number" && bb(h4, "number", h4.value);
      }
      K = d4 ? ue(d4) : window;
      switch (a2) {
        case "focusin":
          if (me(K) || K.contentEditable === "true")
            Qe = K, Re = d4, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g4, c4, e4);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g4, c4, e4);
      }
      var Q;
      if (ae)
        b: {
          switch (a2) {
            case "compositionstart":
              var L = "onCompositionStart";
              break b;
            case "compositionend":
              L = "onCompositionEnd";
              break b;
            case "compositionupdate":
              L = "onCompositionUpdate";
              break b;
          }
          L = void 0;
        }
      else
        ie ? ge(a2, c4) && (L = "onCompositionEnd") : a2 === "keydown" && c4.keyCode === 229 && (L = "onCompositionStart");
      L && (de && c4.locale !== "ko" && (ie || L !== "onCompositionStart" ? L === "onCompositionEnd" && ie && (Q = nd()) : (kd = e4, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), K = oe(d4, L), 0 < K.length && (L = new Ld(L, a2, null, c4, e4), g4.push({event: L, listeners: K}), Q ? L.data = Q : (Q = he(c4), Q !== null && (L.data = Q))));
      if (Q = ce ? je(a2, c4) : ke(a2, c4))
        d4 = oe(d4, "onBeforeInput"), 0 < d4.length && (e4 = new Ld("onBeforeInput", "beforeinput", null, c4, e4), g4.push({event: e4, listeners: d4}), e4.data = Q);
    }
    se(g4, b3);
  });
}
function ef(a2, b3, c4) {
  return {instance: a2, listener: b3, currentTarget: c4};
}
function oe(a2, b3) {
  for (var c4 = b3 + "Capture", d3 = []; a2 !== null; ) {
    var e3 = a2, f3 = e3.stateNode;
    e3.tag === 5 && f3 !== null && (e3 = f3, f3 = Ob(a2, c4), f3 != null && d3.unshift(ef(a2, f3, e3)), f3 = Ob(a2, b3), f3 != null && d3.push(ef(a2, f3, e3)));
    a2 = a2.return;
  }
  return d3;
}
function gf(a2) {
  if (a2 === null)
    return null;
  do
    a2 = a2.return;
  while (a2 && a2.tag !== 5);
  return a2 ? a2 : null;
}
function hf(a2, b3, c4, d3, e3) {
  for (var f3 = b3._reactName, g3 = []; c4 !== null && c4 !== d3; ) {
    var h3 = c4, k3 = h3.alternate, l3 = h3.stateNode;
    if (k3 !== null && k3 === d3)
      break;
    h3.tag === 5 && l3 !== null && (h3 = l3, e3 ? (k3 = Ob(c4, f3), k3 != null && g3.unshift(ef(c4, k3, h3))) : e3 || (k3 = Ob(c4, f3), k3 != null && g3.push(ef(c4, k3, h3))));
    c4 = c4.return;
  }
  g3.length !== 0 && a2.push({event: b3, listeners: g3});
}
function jf() {
}
var kf = null;
var lf = null;
function mf(a2, b3) {
  switch (a2) {
    case "button":
    case "input":
    case "select":
    case "textarea":
      return !!b3.autoFocus;
  }
  return false;
}
function nf(a2, b3) {
  return a2 === "textarea" || a2 === "option" || a2 === "noscript" || typeof b3.children === "string" || typeof b3.children === "number" || typeof b3.dangerouslySetInnerHTML === "object" && b3.dangerouslySetInnerHTML !== null && b3.dangerouslySetInnerHTML.__html != null;
}
var of = typeof setTimeout === "function" ? setTimeout : void 0;
var pf = typeof clearTimeout === "function" ? clearTimeout : void 0;
function qf(a2) {
  a2.nodeType === 1 ? a2.textContent = "" : a2.nodeType === 9 && (a2 = a2.body, a2 != null && (a2.textContent = ""));
}
function rf(a2) {
  for (; a2 != null; a2 = a2.nextSibling) {
    var b3 = a2.nodeType;
    if (b3 === 1 || b3 === 3)
      break;
  }
  return a2;
}
function sf(a2) {
  a2 = a2.previousSibling;
  for (var b3 = 0; a2; ) {
    if (a2.nodeType === 8) {
      var c4 = a2.data;
      if (c4 === "$" || c4 === "$!" || c4 === "$?") {
        if (b3 === 0)
          return a2;
        b3--;
      } else
        c4 === "/$" && b3++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var tf = 0;
function uf(a2) {
  return {$$typeof: Ga, toString: a2, valueOf: a2};
}
var vf = Math.random().toString(36).slice(2);
var wf = "__reactFiber$" + vf;
var xf = "__reactProps$" + vf;
var ff = "__reactContainer$" + vf;
var yf = "__reactEvents$" + vf;
function wc(a2) {
  var b3 = a2[wf];
  if (b3)
    return b3;
  for (var c4 = a2.parentNode; c4; ) {
    if (b3 = c4[ff] || c4[wf]) {
      c4 = b3.alternate;
      if (b3.child !== null || c4 !== null && c4.child !== null)
        for (a2 = sf(a2); a2 !== null; ) {
          if (c4 = a2[wf])
            return c4;
          a2 = sf(a2);
        }
      return b3;
    }
    a2 = c4;
    c4 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[wf] || a2[ff];
  return !a2 || a2.tag !== 5 && a2.tag !== 6 && a2.tag !== 13 && a2.tag !== 3 ? null : a2;
}
function ue(a2) {
  if (a2.tag === 5 || a2.tag === 6)
    return a2.stateNode;
  throw Error(y(33));
}
function Db(a2) {
  return a2[xf] || null;
}
function $e(a2) {
  var b3 = a2[yf];
  b3 === void 0 && (b3 = a2[yf] = new Set());
  return b3;
}
var zf = [];
var Af = -1;
function Bf(a2) {
  return {current: a2};
}
function H(a2) {
  0 > Af || (a2.current = zf[Af], zf[Af] = null, Af--);
}
function I(a2, b3) {
  Af++;
  zf[Af] = a2.current;
  a2.current = b3;
}
var Cf = {};
var M = Bf(Cf);
var N = Bf(false);
var Df = Cf;
function Ef(a2, b3) {
  var c4 = a2.type.contextTypes;
  if (!c4)
    return Cf;
  var d3 = a2.stateNode;
  if (d3 && d3.__reactInternalMemoizedUnmaskedChildContext === b3)
    return d3.__reactInternalMemoizedMaskedChildContext;
  var e3 = {}, f3;
  for (f3 in c4)
    e3[f3] = b3[f3];
  d3 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b3, a2.__reactInternalMemoizedMaskedChildContext = e3);
  return e3;
}
function Ff(a2) {
  a2 = a2.childContextTypes;
  return a2 !== null && a2 !== void 0;
}
function Gf() {
  H(N);
  H(M);
}
function Hf(a2, b3, c4) {
  if (M.current !== Cf)
    throw Error(y(168));
  I(M, b3);
  I(N, c4);
}
function If(a2, b3, c4) {
  var d3 = a2.stateNode;
  a2 = b3.childContextTypes;
  if (typeof d3.getChildContext !== "function")
    return c4;
  d3 = d3.getChildContext();
  for (var e3 in d3)
    if (!(e3 in a2))
      throw Error(y(108, Ra(b3) || "Unknown", e3));
  return objectAssign({}, c4, d3);
}
function Jf(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Cf;
  Df = M.current;
  I(M, a2);
  I(N, N.current);
  return true;
}
function Kf(a2, b3, c4) {
  var d3 = a2.stateNode;
  if (!d3)
    throw Error(y(169));
  c4 ? (a2 = If(a2, b3, Df), d3.__reactInternalMemoizedMergedChildContext = a2, H(N), H(M), I(M, a2)) : H(N);
  I(N, c4);
}
var Lf = null;
var Mf = null;
var Nf = scheduler.unstable_runWithPriority;
var Of = scheduler.unstable_scheduleCallback;
var Pf = scheduler.unstable_cancelCallback;
var Qf = scheduler.unstable_shouldYield;
var Rf = scheduler.unstable_requestPaint;
var Sf = scheduler.unstable_now;
var Tf = scheduler.unstable_getCurrentPriorityLevel;
var Uf = scheduler.unstable_ImmediatePriority;
var Vf = scheduler.unstable_UserBlockingPriority;
var Wf = scheduler.unstable_NormalPriority;
var Xf = scheduler.unstable_LowPriority;
var Yf = scheduler.unstable_IdlePriority;
var Zf = {};
var $f = Rf !== void 0 ? Rf : function() {
};
var ag = null;
var bg = null;
var cg = false;
var dg = Sf();
var O = 1e4 > dg ? Sf : function() {
  return Sf() - dg;
};
function eg() {
  switch (Tf()) {
    case Uf:
      return 99;
    case Vf:
      return 98;
    case Wf:
      return 97;
    case Xf:
      return 96;
    case Yf:
      return 95;
    default:
      throw Error(y(332));
  }
}
function fg(a2) {
  switch (a2) {
    case 99:
      return Uf;
    case 98:
      return Vf;
    case 97:
      return Wf;
    case 96:
      return Xf;
    case 95:
      return Yf;
    default:
      throw Error(y(332));
  }
}
function gg(a2, b3) {
  a2 = fg(a2);
  return Nf(a2, b3);
}
function hg(a2, b3, c4) {
  a2 = fg(a2);
  return Of(a2, b3, c4);
}
function ig() {
  if (bg !== null) {
    var a2 = bg;
    bg = null;
    Pf(a2);
  }
  jg();
}
function jg() {
  if (!cg && ag !== null) {
    cg = true;
    var a2 = 0;
    try {
      var b3 = ag;
      gg(99, function() {
        for (; a2 < b3.length; a2++) {
          var c4 = b3[a2];
          do
            c4 = c4(true);
          while (c4 !== null);
        }
      });
      ag = null;
    } catch (c4) {
      throw ag !== null && (ag = ag.slice(a2 + 1)), Of(Uf, ig), c4;
    } finally {
      cg = false;
    }
  }
}
var kg = ra.ReactCurrentBatchConfig;
function lg(a2, b3) {
  if (a2 && a2.defaultProps) {
    b3 = objectAssign({}, b3);
    a2 = a2.defaultProps;
    for (var c4 in a2)
      b3[c4] === void 0 && (b3[c4] = a2[c4]);
    return b3;
  }
  return b3;
}
var mg = Bf(null);
var ng = null;
var og = null;
var pg = null;
function qg() {
  pg = og = ng = null;
}
function rg(a2) {
  var b3 = mg.current;
  H(mg);
  a2.type._context._currentValue = b3;
}
function sg(a2, b3) {
  for (; a2 !== null; ) {
    var c4 = a2.alternate;
    if ((a2.childLanes & b3) === b3)
      if (c4 === null || (c4.childLanes & b3) === b3)
        break;
      else
        c4.childLanes |= b3;
    else
      a2.childLanes |= b3, c4 !== null && (c4.childLanes |= b3);
    a2 = a2.return;
  }
}
function tg(a2, b3) {
  ng = a2;
  pg = og = null;
  a2 = a2.dependencies;
  a2 !== null && a2.firstContext !== null && ((a2.lanes & b3) !== 0 && (ug = true), a2.firstContext = null);
}
function vg(a2, b3) {
  if (pg !== a2 && b3 !== false && b3 !== 0) {
    if (typeof b3 !== "number" || b3 === 1073741823)
      pg = a2, b3 = 1073741823;
    b3 = {context: a2, observedBits: b3, next: null};
    if (og === null) {
      if (ng === null)
        throw Error(y(308));
      og = b3;
      ng.dependencies = {lanes: 0, firstContext: b3, responders: null};
    } else
      og = og.next = b3;
  }
  return a2._currentValue;
}
var wg = false;
function xg(a2) {
  a2.updateQueue = {baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: {pending: null}, effects: null};
}
function yg(a2, b3) {
  a2 = a2.updateQueue;
  b3.updateQueue === a2 && (b3.updateQueue = {baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects});
}
function zg(a2, b3) {
  return {eventTime: a2, lane: b3, tag: 0, payload: null, callback: null, next: null};
}
function Ag(a2, b3) {
  a2 = a2.updateQueue;
  if (a2 !== null) {
    a2 = a2.shared;
    var c4 = a2.pending;
    c4 === null ? b3.next = b3 : (b3.next = c4.next, c4.next = b3);
    a2.pending = b3;
  }
}
function Bg(a2, b3) {
  var c4 = a2.updateQueue, d3 = a2.alternate;
  if (d3 !== null && (d3 = d3.updateQueue, c4 === d3)) {
    var e3 = null, f3 = null;
    c4 = c4.firstBaseUpdate;
    if (c4 !== null) {
      do {
        var g3 = {eventTime: c4.eventTime, lane: c4.lane, tag: c4.tag, payload: c4.payload, callback: c4.callback, next: null};
        f3 === null ? e3 = f3 = g3 : f3 = f3.next = g3;
        c4 = c4.next;
      } while (c4 !== null);
      f3 === null ? e3 = f3 = b3 : f3 = f3.next = b3;
    } else
      e3 = f3 = b3;
    c4 = {baseState: d3.baseState, firstBaseUpdate: e3, lastBaseUpdate: f3, shared: d3.shared, effects: d3.effects};
    a2.updateQueue = c4;
    return;
  }
  a2 = c4.lastBaseUpdate;
  a2 === null ? c4.firstBaseUpdate = b3 : a2.next = b3;
  c4.lastBaseUpdate = b3;
}
function Cg(a2, b3, c4, d3) {
  var e3 = a2.updateQueue;
  wg = false;
  var f3 = e3.firstBaseUpdate, g3 = e3.lastBaseUpdate, h3 = e3.shared.pending;
  if (h3 !== null) {
    e3.shared.pending = null;
    var k3 = h3, l3 = k3.next;
    k3.next = null;
    g3 === null ? f3 = l3 : g3.next = l3;
    g3 = k3;
    var n4 = a2.alternate;
    if (n4 !== null) {
      n4 = n4.updateQueue;
      var A3 = n4.lastBaseUpdate;
      A3 !== g3 && (A3 === null ? n4.firstBaseUpdate = l3 : A3.next = l3, n4.lastBaseUpdate = k3);
    }
  }
  if (f3 !== null) {
    A3 = e3.baseState;
    g3 = 0;
    n4 = l3 = k3 = null;
    do {
      h3 = f3.lane;
      var p3 = f3.eventTime;
      if ((d3 & h3) === h3) {
        n4 !== null && (n4 = n4.next = {
          eventTime: p3,
          lane: 0,
          tag: f3.tag,
          payload: f3.payload,
          callback: f3.callback,
          next: null
        });
        a: {
          var C = a2, x3 = f3;
          h3 = b3;
          p3 = c4;
          switch (x3.tag) {
            case 1:
              C = x3.payload;
              if (typeof C === "function") {
                A3 = C.call(p3, A3, h3);
                break a;
              }
              A3 = C;
              break a;
            case 3:
              C.flags = C.flags & -4097 | 64;
            case 0:
              C = x3.payload;
              h3 = typeof C === "function" ? C.call(p3, A3, h3) : C;
              if (h3 === null || h3 === void 0)
                break a;
              A3 = objectAssign({}, A3, h3);
              break a;
            case 2:
              wg = true;
          }
        }
        f3.callback !== null && (a2.flags |= 32, h3 = e3.effects, h3 === null ? e3.effects = [f3] : h3.push(f3));
      } else
        p3 = {eventTime: p3, lane: h3, tag: f3.tag, payload: f3.payload, callback: f3.callback, next: null}, n4 === null ? (l3 = n4 = p3, k3 = A3) : n4 = n4.next = p3, g3 |= h3;
      f3 = f3.next;
      if (f3 === null)
        if (h3 = e3.shared.pending, h3 === null)
          break;
        else
          f3 = h3.next, h3.next = null, e3.lastBaseUpdate = h3, e3.shared.pending = null;
    } while (1);
    n4 === null && (k3 = A3);
    e3.baseState = k3;
    e3.firstBaseUpdate = l3;
    e3.lastBaseUpdate = n4;
    Dg |= g3;
    a2.lanes = g3;
    a2.memoizedState = A3;
  }
}
function Eg(a2, b3, c4) {
  a2 = b3.effects;
  b3.effects = null;
  if (a2 !== null)
    for (b3 = 0; b3 < a2.length; b3++) {
      var d3 = a2[b3], e3 = d3.callback;
      if (e3 !== null) {
        d3.callback = null;
        d3 = c4;
        if (typeof e3 !== "function")
          throw Error(y(191, e3));
        e3.call(d3);
      }
    }
}
var Fg = new react.Component().refs;
function Gg(a2, b3, c4, d3) {
  b3 = a2.memoizedState;
  c4 = c4(d3, b3);
  c4 = c4 === null || c4 === void 0 ? b3 : objectAssign({}, b3, c4);
  a2.memoizedState = c4;
  a2.lanes === 0 && (a2.updateQueue.baseState = c4);
}
var Kg = {isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Zb(a2) === a2 : false;
}, enqueueSetState: function(a2, b3, c4) {
  a2 = a2._reactInternals;
  var d3 = Hg(), e3 = Ig(a2), f3 = zg(d3, e3);
  f3.payload = b3;
  c4 !== void 0 && c4 !== null && (f3.callback = c4);
  Ag(a2, f3);
  Jg(a2, e3, d3);
}, enqueueReplaceState: function(a2, b3, c4) {
  a2 = a2._reactInternals;
  var d3 = Hg(), e3 = Ig(a2), f3 = zg(d3, e3);
  f3.tag = 1;
  f3.payload = b3;
  c4 !== void 0 && c4 !== null && (f3.callback = c4);
  Ag(a2, f3);
  Jg(a2, e3, d3);
}, enqueueForceUpdate: function(a2, b3) {
  a2 = a2._reactInternals;
  var c4 = Hg(), d3 = Ig(a2), e3 = zg(c4, d3);
  e3.tag = 2;
  b3 !== void 0 && b3 !== null && (e3.callback = b3);
  Ag(a2, e3);
  Jg(a2, d3, c4);
}};
function Lg(a2, b3, c4, d3, e3, f3, g3) {
  a2 = a2.stateNode;
  return typeof a2.shouldComponentUpdate === "function" ? a2.shouldComponentUpdate(d3, f3, g3) : b3.prototype && b3.prototype.isPureReactComponent ? !Je(c4, d3) || !Je(e3, f3) : true;
}
function Mg(a2, b3, c4) {
  var d3 = false, e3 = Cf;
  var f3 = b3.contextType;
  typeof f3 === "object" && f3 !== null ? f3 = vg(f3) : (e3 = Ff(b3) ? Df : M.current, d3 = b3.contextTypes, f3 = (d3 = d3 !== null && d3 !== void 0) ? Ef(a2, e3) : Cf);
  b3 = new b3(c4, f3);
  a2.memoizedState = b3.state !== null && b3.state !== void 0 ? b3.state : null;
  b3.updater = Kg;
  a2.stateNode = b3;
  b3._reactInternals = a2;
  d3 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e3, a2.__reactInternalMemoizedMaskedChildContext = f3);
  return b3;
}
function Ng(a2, b3, c4, d3) {
  a2 = b3.state;
  typeof b3.componentWillReceiveProps === "function" && b3.componentWillReceiveProps(c4, d3);
  typeof b3.UNSAFE_componentWillReceiveProps === "function" && b3.UNSAFE_componentWillReceiveProps(c4, d3);
  b3.state !== a2 && Kg.enqueueReplaceState(b3, b3.state, null);
}
function Og(a2, b3, c4, d3) {
  var e3 = a2.stateNode;
  e3.props = c4;
  e3.state = a2.memoizedState;
  e3.refs = Fg;
  xg(a2);
  var f3 = b3.contextType;
  typeof f3 === "object" && f3 !== null ? e3.context = vg(f3) : (f3 = Ff(b3) ? Df : M.current, e3.context = Ef(a2, f3));
  Cg(a2, c4, e3, d3);
  e3.state = a2.memoizedState;
  f3 = b3.getDerivedStateFromProps;
  typeof f3 === "function" && (Gg(a2, b3, f3, c4), e3.state = a2.memoizedState);
  typeof b3.getDerivedStateFromProps === "function" || typeof e3.getSnapshotBeforeUpdate === "function" || typeof e3.UNSAFE_componentWillMount !== "function" && typeof e3.componentWillMount !== "function" || (b3 = e3.state, typeof e3.componentWillMount === "function" && e3.componentWillMount(), typeof e3.UNSAFE_componentWillMount === "function" && e3.UNSAFE_componentWillMount(), b3 !== e3.state && Kg.enqueueReplaceState(e3, e3.state, null), Cg(a2, c4, e3, d3), e3.state = a2.memoizedState);
  typeof e3.componentDidMount === "function" && (a2.flags |= 4);
}
var Pg = Array.isArray;
function Qg(a2, b3, c4) {
  a2 = c4.ref;
  if (a2 !== null && typeof a2 !== "function" && typeof a2 !== "object") {
    if (c4._owner) {
      c4 = c4._owner;
      if (c4) {
        if (c4.tag !== 1)
          throw Error(y(309));
        var d3 = c4.stateNode;
      }
      if (!d3)
        throw Error(y(147, a2));
      var e3 = "" + a2;
      if (b3 !== null && b3.ref !== null && typeof b3.ref === "function" && b3.ref._stringRef === e3)
        return b3.ref;
      b3 = function(a3) {
        var b4 = d3.refs;
        b4 === Fg && (b4 = d3.refs = {});
        a3 === null ? delete b4[e3] : b4[e3] = a3;
      };
      b3._stringRef = e3;
      return b3;
    }
    if (typeof a2 !== "string")
      throw Error(y(284));
    if (!c4._owner)
      throw Error(y(290, a2));
  }
  return a2;
}
function Rg(a2, b3) {
  if (a2.type !== "textarea")
    throw Error(y(31, Object.prototype.toString.call(b3) === "[object Object]" ? "object with keys {" + Object.keys(b3).join(", ") + "}" : b3));
}
function Sg(a2) {
  function b3(b4, c5) {
    if (a2) {
      var d4 = b4.lastEffect;
      d4 !== null ? (d4.nextEffect = c5, b4.lastEffect = c5) : b4.firstEffect = b4.lastEffect = c5;
      c5.nextEffect = null;
      c5.flags = 8;
    }
  }
  function c4(c5, d4) {
    if (!a2)
      return null;
    for (; d4 !== null; )
      b3(c5, d4), d4 = d4.sibling;
    return null;
  }
  function d3(a3, b4) {
    for (a3 = new Map(); b4 !== null; )
      b4.key !== null ? a3.set(b4.key, b4) : a3.set(b4.index, b4), b4 = b4.sibling;
    return a3;
  }
  function e3(a3, b4) {
    a3 = Tg(a3, b4);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f3(b4, c5, d4) {
    b4.index = d4;
    if (!a2)
      return c5;
    d4 = b4.alternate;
    if (d4 !== null)
      return d4 = d4.index, d4 < c5 ? (b4.flags = 2, c5) : d4;
    b4.flags = 2;
    return c5;
  }
  function g3(b4) {
    a2 && b4.alternate === null && (b4.flags = 2);
    return b4;
  }
  function h3(a3, b4, c5, d4) {
    if (b4 === null || b4.tag !== 6)
      return b4 = Ug(c5, a3.mode, d4), b4.return = a3, b4;
    b4 = e3(b4, c5);
    b4.return = a3;
    return b4;
  }
  function k3(a3, b4, c5, d4) {
    if (b4 !== null && b4.elementType === c5.type)
      return d4 = e3(b4, c5.props), d4.ref = Qg(a3, b4, c5), d4.return = a3, d4;
    d4 = Vg(c5.type, c5.key, c5.props, null, a3.mode, d4);
    d4.ref = Qg(a3, b4, c5);
    d4.return = a3;
    return d4;
  }
  function l3(a3, b4, c5, d4) {
    if (b4 === null || b4.tag !== 4 || b4.stateNode.containerInfo !== c5.containerInfo || b4.stateNode.implementation !== c5.implementation)
      return b4 = Wg(c5, a3.mode, d4), b4.return = a3, b4;
    b4 = e3(b4, c5.children || []);
    b4.return = a3;
    return b4;
  }
  function n4(a3, b4, c5, d4, f4) {
    if (b4 === null || b4.tag !== 7)
      return b4 = Xg(c5, a3.mode, d4, f4), b4.return = a3, b4;
    b4 = e3(b4, c5);
    b4.return = a3;
    return b4;
  }
  function A3(a3, b4, c5) {
    if (typeof b4 === "string" || typeof b4 === "number")
      return b4 = Ug("" + b4, a3.mode, c5), b4.return = a3, b4;
    if (typeof b4 === "object" && b4 !== null) {
      switch (b4.$$typeof) {
        case sa:
          return c5 = Vg(b4.type, b4.key, b4.props, null, a3.mode, c5), c5.ref = Qg(a3, null, b4), c5.return = a3, c5;
        case ta:
          return b4 = Wg(b4, a3.mode, c5), b4.return = a3, b4;
      }
      if (Pg(b4) || La(b4))
        return b4 = Xg(b4, a3.mode, c5, null), b4.return = a3, b4;
      Rg(a3, b4);
    }
    return null;
  }
  function p3(a3, b4, c5, d4) {
    var e4 = b4 !== null ? b4.key : null;
    if (typeof c5 === "string" || typeof c5 === "number")
      return e4 !== null ? null : h3(a3, b4, "" + c5, d4);
    if (typeof c5 === "object" && c5 !== null) {
      switch (c5.$$typeof) {
        case sa:
          return c5.key === e4 ? c5.type === ua ? n4(a3, b4, c5.props.children, d4, e4) : k3(a3, b4, c5, d4) : null;
        case ta:
          return c5.key === e4 ? l3(a3, b4, c5, d4) : null;
      }
      if (Pg(c5) || La(c5))
        return e4 !== null ? null : n4(a3, b4, c5, d4, null);
      Rg(a3, c5);
    }
    return null;
  }
  function C(a3, b4, c5, d4, e4) {
    if (typeof d4 === "string" || typeof d4 === "number")
      return a3 = a3.get(c5) || null, h3(b4, a3, "" + d4, e4);
    if (typeof d4 === "object" && d4 !== null) {
      switch (d4.$$typeof) {
        case sa:
          return a3 = a3.get(d4.key === null ? c5 : d4.key) || null, d4.type === ua ? n4(b4, a3, d4.props.children, e4, d4.key) : k3(b4, a3, d4, e4);
        case ta:
          return a3 = a3.get(d4.key === null ? c5 : d4.key) || null, l3(b4, a3, d4, e4);
      }
      if (Pg(d4) || La(d4))
        return a3 = a3.get(c5) || null, n4(b4, a3, d4, e4, null);
      Rg(b4, d4);
    }
    return null;
  }
  function x3(e4, g4, h4, k4) {
    for (var l4 = null, t4 = null, u = g4, z3 = g4 = 0, q3 = null; u !== null && z3 < h4.length; z3++) {
      u.index > z3 ? (q3 = u, u = null) : q3 = u.sibling;
      var n5 = p3(e4, u, h4[z3], k4);
      if (n5 === null) {
        u === null && (u = q3);
        break;
      }
      a2 && u && n5.alternate === null && b3(e4, u);
      g4 = f3(n5, g4, z3);
      t4 === null ? l4 = n5 : t4.sibling = n5;
      t4 = n5;
      u = q3;
    }
    if (z3 === h4.length)
      return c4(e4, u), l4;
    if (u === null) {
      for (; z3 < h4.length; z3++)
        u = A3(e4, h4[z3], k4), u !== null && (g4 = f3(u, g4, z3), t4 === null ? l4 = u : t4.sibling = u, t4 = u);
      return l4;
    }
    for (u = d3(e4, u); z3 < h4.length; z3++)
      q3 = C(u, e4, z3, h4[z3], k4), q3 !== null && (a2 && q3.alternate !== null && u.delete(q3.key === null ? z3 : q3.key), g4 = f3(q3, g4, z3), t4 === null ? l4 = q3 : t4.sibling = q3, t4 = q3);
    a2 && u.forEach(function(a3) {
      return b3(e4, a3);
    });
    return l4;
  }
  function w3(e4, g4, h4, k4) {
    var l4 = La(h4);
    if (typeof l4 !== "function")
      throw Error(y(150));
    h4 = l4.call(h4);
    if (h4 == null)
      throw Error(y(151));
    for (var t4 = l4 = null, u = g4, z3 = g4 = 0, q3 = null, n5 = h4.next(); u !== null && !n5.done; z3++, n5 = h4.next()) {
      u.index > z3 ? (q3 = u, u = null) : q3 = u.sibling;
      var w4 = p3(e4, u, n5.value, k4);
      if (w4 === null) {
        u === null && (u = q3);
        break;
      }
      a2 && u && w4.alternate === null && b3(e4, u);
      g4 = f3(w4, g4, z3);
      t4 === null ? l4 = w4 : t4.sibling = w4;
      t4 = w4;
      u = q3;
    }
    if (n5.done)
      return c4(e4, u), l4;
    if (u === null) {
      for (; !n5.done; z3++, n5 = h4.next())
        n5 = A3(e4, n5.value, k4), n5 !== null && (g4 = f3(n5, g4, z3), t4 === null ? l4 = n5 : t4.sibling = n5, t4 = n5);
      return l4;
    }
    for (u = d3(e4, u); !n5.done; z3++, n5 = h4.next())
      n5 = C(u, e4, z3, n5.value, k4), n5 !== null && (a2 && n5.alternate !== null && u.delete(n5.key === null ? z3 : n5.key), g4 = f3(n5, g4, z3), t4 === null ? l4 = n5 : t4.sibling = n5, t4 = n5);
    a2 && u.forEach(function(a3) {
      return b3(e4, a3);
    });
    return l4;
  }
  return function(a3, d4, f4, h4) {
    var k4 = typeof f4 === "object" && f4 !== null && f4.type === ua && f4.key === null;
    k4 && (f4 = f4.props.children);
    var l4 = typeof f4 === "object" && f4 !== null;
    if (l4)
      switch (f4.$$typeof) {
        case sa:
          a: {
            l4 = f4.key;
            for (k4 = d4; k4 !== null; ) {
              if (k4.key === l4) {
                switch (k4.tag) {
                  case 7:
                    if (f4.type === ua) {
                      c4(a3, k4.sibling);
                      d4 = e3(k4, f4.props.children);
                      d4.return = a3;
                      a3 = d4;
                      break a;
                    }
                    break;
                  default:
                    if (k4.elementType === f4.type) {
                      c4(a3, k4.sibling);
                      d4 = e3(k4, f4.props);
                      d4.ref = Qg(a3, k4, f4);
                      d4.return = a3;
                      a3 = d4;
                      break a;
                    }
                }
                c4(a3, k4);
                break;
              } else
                b3(a3, k4);
              k4 = k4.sibling;
            }
            f4.type === ua ? (d4 = Xg(f4.props.children, a3.mode, h4, f4.key), d4.return = a3, a3 = d4) : (h4 = Vg(f4.type, f4.key, f4.props, null, a3.mode, h4), h4.ref = Qg(a3, d4, f4), h4.return = a3, a3 = h4);
          }
          return g3(a3);
        case ta:
          a: {
            for (k4 = f4.key; d4 !== null; ) {
              if (d4.key === k4)
                if (d4.tag === 4 && d4.stateNode.containerInfo === f4.containerInfo && d4.stateNode.implementation === f4.implementation) {
                  c4(a3, d4.sibling);
                  d4 = e3(d4, f4.children || []);
                  d4.return = a3;
                  a3 = d4;
                  break a;
                } else {
                  c4(a3, d4);
                  break;
                }
              else
                b3(a3, d4);
              d4 = d4.sibling;
            }
            d4 = Wg(f4, a3.mode, h4);
            d4.return = a3;
            a3 = d4;
          }
          return g3(a3);
      }
    if (typeof f4 === "string" || typeof f4 === "number")
      return f4 = "" + f4, d4 !== null && d4.tag === 6 ? (c4(a3, d4.sibling), d4 = e3(d4, f4), d4.return = a3, a3 = d4) : (c4(a3, d4), d4 = Ug(f4, a3.mode, h4), d4.return = a3, a3 = d4), g3(a3);
    if (Pg(f4))
      return x3(a3, d4, f4, h4);
    if (La(f4))
      return w3(a3, d4, f4, h4);
    l4 && Rg(a3, f4);
    if (typeof f4 === "undefined" && !k4)
      switch (a3.tag) {
        case 1:
        case 22:
        case 0:
        case 11:
        case 15:
          throw Error(y(152, Ra(a3.type) || "Component"));
      }
    return c4(a3, d4);
  };
}
var Yg = Sg(true);
var Zg = Sg(false);
var $g = {};
var ah = Bf($g);
var bh = Bf($g);
var ch = Bf($g);
function dh(a2) {
  if (a2 === $g)
    throw Error(y(174));
  return a2;
}
function eh(a2, b3) {
  I(ch, b3);
  I(bh, a2);
  I(ah, $g);
  a2 = b3.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b3 = (b3 = b3.documentElement) ? b3.namespaceURI : mb(null, "");
      break;
    default:
      a2 = a2 === 8 ? b3.parentNode : b3, b3 = a2.namespaceURI || null, a2 = a2.tagName, b3 = mb(b3, a2);
  }
  H(ah);
  I(ah, b3);
}
function fh() {
  H(ah);
  H(bh);
  H(ch);
}
function gh(a2) {
  dh(ch.current);
  var b3 = dh(ah.current);
  var c4 = mb(b3, a2.type);
  b3 !== c4 && (I(bh, a2), I(ah, c4));
}
function hh(a2) {
  bh.current === a2 && (H(ah), H(bh));
}
var P = Bf(0);
function ih(a2) {
  for (var b3 = a2; b3 !== null; ) {
    if (b3.tag === 13) {
      var c4 = b3.memoizedState;
      if (c4 !== null && (c4 = c4.dehydrated, c4 === null || c4.data === "$?" || c4.data === "$!"))
        return b3;
    } else if (b3.tag === 19 && b3.memoizedProps.revealOrder !== void 0) {
      if ((b3.flags & 64) !== 0)
        return b3;
    } else if (b3.child !== null) {
      b3.child.return = b3;
      b3 = b3.child;
      continue;
    }
    if (b3 === a2)
      break;
    for (; b3.sibling === null; ) {
      if (b3.return === null || b3.return === a2)
        return null;
      b3 = b3.return;
    }
    b3.sibling.return = b3.return;
    b3 = b3.sibling;
  }
  return null;
}
var jh = null;
var kh = null;
var lh = false;
function mh(a2, b3) {
  var c4 = nh(5, null, null, 0);
  c4.elementType = "DELETED";
  c4.type = "DELETED";
  c4.stateNode = b3;
  c4.return = a2;
  c4.flags = 8;
  a2.lastEffect !== null ? (a2.lastEffect.nextEffect = c4, a2.lastEffect = c4) : a2.firstEffect = a2.lastEffect = c4;
}
function oh(a2, b3) {
  switch (a2.tag) {
    case 5:
      var c4 = a2.type;
      b3 = b3.nodeType !== 1 || c4.toLowerCase() !== b3.nodeName.toLowerCase() ? null : b3;
      return b3 !== null ? (a2.stateNode = b3, true) : false;
    case 6:
      return b3 = a2.pendingProps === "" || b3.nodeType !== 3 ? null : b3, b3 !== null ? (a2.stateNode = b3, true) : false;
    case 13:
      return false;
    default:
      return false;
  }
}
function ph(a2) {
  if (lh) {
    var b3 = kh;
    if (b3) {
      var c4 = b3;
      if (!oh(a2, b3)) {
        b3 = rf(c4.nextSibling);
        if (!b3 || !oh(a2, b3)) {
          a2.flags = a2.flags & -1025 | 2;
          lh = false;
          jh = a2;
          return;
        }
        mh(jh, c4);
      }
      jh = a2;
      kh = rf(b3.firstChild);
    } else
      a2.flags = a2.flags & -1025 | 2, lh = false, jh = a2;
  }
}
function qh(a2) {
  for (a2 = a2.return; a2 !== null && a2.tag !== 5 && a2.tag !== 3 && a2.tag !== 13; )
    a2 = a2.return;
  jh = a2;
}
function rh(a2) {
  if (a2 !== jh)
    return false;
  if (!lh)
    return qh(a2), lh = true, false;
  var b3 = a2.type;
  if (a2.tag !== 5 || b3 !== "head" && b3 !== "body" && !nf(b3, a2.memoizedProps))
    for (b3 = kh; b3; )
      mh(a2, b3), b3 = rf(b3.nextSibling);
  qh(a2);
  if (a2.tag === 13) {
    a2 = a2.memoizedState;
    a2 = a2 !== null ? a2.dehydrated : null;
    if (!a2)
      throw Error(y(317));
    a: {
      a2 = a2.nextSibling;
      for (b3 = 0; a2; ) {
        if (a2.nodeType === 8) {
          var c4 = a2.data;
          if (c4 === "/$") {
            if (b3 === 0) {
              kh = rf(a2.nextSibling);
              break a;
            }
            b3--;
          } else
            c4 !== "$" && c4 !== "$!" && c4 !== "$?" || b3++;
        }
        a2 = a2.nextSibling;
      }
      kh = null;
    }
  } else
    kh = jh ? rf(a2.stateNode.nextSibling) : null;
  return true;
}
function sh() {
  kh = jh = null;
  lh = false;
}
var th = [];
function uh() {
  for (var a2 = 0; a2 < th.length; a2++)
    th[a2]._workInProgressVersionPrimary = null;
  th.length = 0;
}
var vh = ra.ReactCurrentDispatcher;
var wh = ra.ReactCurrentBatchConfig;
var xh = 0;
var R = null;
var S = null;
var T = null;
var yh = false;
var zh = false;
function Ah() {
  throw Error(y(321));
}
function Bh(a2, b3) {
  if (b3 === null)
    return false;
  for (var c4 = 0; c4 < b3.length && c4 < a2.length; c4++)
    if (!He(a2[c4], b3[c4]))
      return false;
  return true;
}
function Ch(a2, b3, c4, d3, e3, f3) {
  xh = f3;
  R = b3;
  b3.memoizedState = null;
  b3.updateQueue = null;
  b3.lanes = 0;
  vh.current = a2 === null || a2.memoizedState === null ? Dh : Eh;
  a2 = c4(d3, e3);
  if (zh) {
    f3 = 0;
    do {
      zh = false;
      if (!(25 > f3))
        throw Error(y(301));
      f3 += 1;
      T = S = null;
      b3.updateQueue = null;
      vh.current = Fh;
      a2 = c4(d3, e3);
    } while (zh);
  }
  vh.current = Gh;
  b3 = S !== null && S.next !== null;
  xh = 0;
  T = S = R = null;
  yh = false;
  if (b3)
    throw Error(y(300));
  return a2;
}
function Hh() {
  var a2 = {memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null};
  T === null ? R.memoizedState = T = a2 : T = T.next = a2;
  return T;
}
function Ih() {
  if (S === null) {
    var a2 = R.alternate;
    a2 = a2 !== null ? a2.memoizedState : null;
  } else
    a2 = S.next;
  var b3 = T === null ? R.memoizedState : T.next;
  if (b3 !== null)
    T = b3, S = a2;
  else {
    if (a2 === null)
      throw Error(y(310));
    S = a2;
    a2 = {memoizedState: S.memoizedState, baseState: S.baseState, baseQueue: S.baseQueue, queue: S.queue, next: null};
    T === null ? R.memoizedState = T = a2 : T = T.next = a2;
  }
  return T;
}
function Jh(a2, b3) {
  return typeof b3 === "function" ? b3(a2) : b3;
}
function Kh(a2) {
  var b3 = Ih(), c4 = b3.queue;
  if (c4 === null)
    throw Error(y(311));
  c4.lastRenderedReducer = a2;
  var d3 = S, e3 = d3.baseQueue, f3 = c4.pending;
  if (f3 !== null) {
    if (e3 !== null) {
      var g3 = e3.next;
      e3.next = f3.next;
      f3.next = g3;
    }
    d3.baseQueue = e3 = f3;
    c4.pending = null;
  }
  if (e3 !== null) {
    e3 = e3.next;
    d3 = d3.baseState;
    var h3 = g3 = f3 = null, k3 = e3;
    do {
      var l3 = k3.lane;
      if ((xh & l3) === l3)
        h3 !== null && (h3 = h3.next = {lane: 0, action: k3.action, eagerReducer: k3.eagerReducer, eagerState: k3.eagerState, next: null}), d3 = k3.eagerReducer === a2 ? k3.eagerState : a2(d3, k3.action);
      else {
        var n4 = {
          lane: l3,
          action: k3.action,
          eagerReducer: k3.eagerReducer,
          eagerState: k3.eagerState,
          next: null
        };
        h3 === null ? (g3 = h3 = n4, f3 = d3) : h3 = h3.next = n4;
        R.lanes |= l3;
        Dg |= l3;
      }
      k3 = k3.next;
    } while (k3 !== null && k3 !== e3);
    h3 === null ? f3 = d3 : h3.next = g3;
    He(d3, b3.memoizedState) || (ug = true);
    b3.memoizedState = d3;
    b3.baseState = f3;
    b3.baseQueue = h3;
    c4.lastRenderedState = d3;
  }
  return [b3.memoizedState, c4.dispatch];
}
function Lh(a2) {
  var b3 = Ih(), c4 = b3.queue;
  if (c4 === null)
    throw Error(y(311));
  c4.lastRenderedReducer = a2;
  var d3 = c4.dispatch, e3 = c4.pending, f3 = b3.memoizedState;
  if (e3 !== null) {
    c4.pending = null;
    var g3 = e3 = e3.next;
    do
      f3 = a2(f3, g3.action), g3 = g3.next;
    while (g3 !== e3);
    He(f3, b3.memoizedState) || (ug = true);
    b3.memoizedState = f3;
    b3.baseQueue === null && (b3.baseState = f3);
    c4.lastRenderedState = f3;
  }
  return [f3, d3];
}
function Mh(a2, b3, c4) {
  var d3 = b3._getVersion;
  d3 = d3(b3._source);
  var e3 = b3._workInProgressVersionPrimary;
  if (e3 !== null)
    a2 = e3 === d3;
  else if (a2 = a2.mutableReadLanes, a2 = (xh & a2) === a2)
    b3._workInProgressVersionPrimary = d3, th.push(b3);
  if (a2)
    return c4(b3._source);
  th.push(b3);
  throw Error(y(350));
}
function Nh(a2, b3, c4, d3) {
  var e3 = U;
  if (e3 === null)
    throw Error(y(349));
  var f3 = b3._getVersion, g3 = f3(b3._source), h3 = vh.current, k3 = h3.useState(function() {
    return Mh(e3, b3, c4);
  }), l3 = k3[1], n4 = k3[0];
  k3 = T;
  var A3 = a2.memoizedState, p3 = A3.refs, C = p3.getSnapshot, x3 = A3.source;
  A3 = A3.subscribe;
  var w3 = R;
  a2.memoizedState = {refs: p3, source: b3, subscribe: d3};
  h3.useEffect(function() {
    p3.getSnapshot = c4;
    p3.setSnapshot = l3;
    var a3 = f3(b3._source);
    if (!He(g3, a3)) {
      a3 = c4(b3._source);
      He(n4, a3) || (l3(a3), a3 = Ig(w3), e3.mutableReadLanes |= a3 & e3.pendingLanes);
      a3 = e3.mutableReadLanes;
      e3.entangledLanes |= a3;
      for (var d4 = e3.entanglements, h4 = a3; 0 < h4; ) {
        var k4 = 31 - Vc(h4), v3 = 1 << k4;
        d4[k4] |= a3;
        h4 &= ~v3;
      }
    }
  }, [c4, b3, d3]);
  h3.useEffect(function() {
    return d3(b3._source, function() {
      var a3 = p3.getSnapshot, c5 = p3.setSnapshot;
      try {
        c5(a3(b3._source));
        var d4 = Ig(w3);
        e3.mutableReadLanes |= d4 & e3.pendingLanes;
      } catch (q3) {
        c5(function() {
          throw q3;
        });
      }
    });
  }, [b3, d3]);
  He(C, c4) && He(x3, b3) && He(A3, d3) || (a2 = {pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n4}, a2.dispatch = l3 = Oh.bind(null, R, a2), k3.queue = a2, k3.baseQueue = null, n4 = Mh(e3, b3, c4), k3.memoizedState = k3.baseState = n4);
  return n4;
}
function Ph(a2, b3, c4) {
  var d3 = Ih();
  return Nh(d3, a2, b3, c4);
}
function Qh(a2) {
  var b3 = Hh();
  typeof a2 === "function" && (a2 = a2());
  b3.memoizedState = b3.baseState = a2;
  a2 = b3.queue = {pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a2};
  a2 = a2.dispatch = Oh.bind(null, R, a2);
  return [b3.memoizedState, a2];
}
function Rh(a2, b3, c4, d3) {
  a2 = {tag: a2, create: b3, destroy: c4, deps: d3, next: null};
  b3 = R.updateQueue;
  b3 === null ? (b3 = {lastEffect: null}, R.updateQueue = b3, b3.lastEffect = a2.next = a2) : (c4 = b3.lastEffect, c4 === null ? b3.lastEffect = a2.next = a2 : (d3 = c4.next, c4.next = a2, a2.next = d3, b3.lastEffect = a2));
  return a2;
}
function Sh(a2) {
  var b3 = Hh();
  a2 = {current: a2};
  return b3.memoizedState = a2;
}
function Th() {
  return Ih().memoizedState;
}
function Uh(a2, b3, c4, d3) {
  var e3 = Hh();
  R.flags |= a2;
  e3.memoizedState = Rh(1 | b3, c4, void 0, d3 === void 0 ? null : d3);
}
function Vh(a2, b3, c4, d3) {
  var e3 = Ih();
  d3 = d3 === void 0 ? null : d3;
  var f3 = void 0;
  if (S !== null) {
    var g3 = S.memoizedState;
    f3 = g3.destroy;
    if (d3 !== null && Bh(d3, g3.deps)) {
      Rh(b3, c4, f3, d3);
      return;
    }
  }
  R.flags |= a2;
  e3.memoizedState = Rh(1 | b3, c4, f3, d3);
}
function Wh(a2, b3) {
  return Uh(516, 4, a2, b3);
}
function Xh(a2, b3) {
  return Vh(516, 4, a2, b3);
}
function Yh(a2, b3) {
  return Vh(4, 2, a2, b3);
}
function Zh(a2, b3) {
  if (typeof b3 === "function")
    return a2 = a2(), b3(a2), function() {
      b3(null);
    };
  if (b3 !== null && b3 !== void 0)
    return a2 = a2(), b3.current = a2, function() {
      b3.current = null;
    };
}
function $h(a2, b3, c4) {
  c4 = c4 !== null && c4 !== void 0 ? c4.concat([a2]) : null;
  return Vh(4, 2, Zh.bind(null, b3, a2), c4);
}
function ai() {
}
function bi(a2, b3) {
  var c4 = Ih();
  b3 = b3 === void 0 ? null : b3;
  var d3 = c4.memoizedState;
  if (d3 !== null && b3 !== null && Bh(b3, d3[1]))
    return d3[0];
  c4.memoizedState = [a2, b3];
  return a2;
}
function ci(a2, b3) {
  var c4 = Ih();
  b3 = b3 === void 0 ? null : b3;
  var d3 = c4.memoizedState;
  if (d3 !== null && b3 !== null && Bh(b3, d3[1]))
    return d3[0];
  a2 = a2();
  c4.memoizedState = [a2, b3];
  return a2;
}
function di(a2, b3) {
  var c4 = eg();
  gg(98 > c4 ? 98 : c4, function() {
    a2(true);
  });
  gg(97 < c4 ? 97 : c4, function() {
    var c5 = wh.transition;
    wh.transition = 1;
    try {
      a2(false), b3();
    } finally {
      wh.transition = c5;
    }
  });
}
function Oh(a2, b3, c4) {
  var d3 = Hg(), e3 = Ig(a2), f3 = {lane: e3, action: c4, eagerReducer: null, eagerState: null, next: null}, g3 = b3.pending;
  g3 === null ? f3.next = f3 : (f3.next = g3.next, g3.next = f3);
  b3.pending = f3;
  g3 = a2.alternate;
  if (a2 === R || g3 !== null && g3 === R)
    zh = yh = true;
  else {
    if (a2.lanes === 0 && (g3 === null || g3.lanes === 0) && (g3 = b3.lastRenderedReducer, g3 !== null))
      try {
        var h3 = b3.lastRenderedState, k3 = g3(h3, c4);
        f3.eagerReducer = g3;
        f3.eagerState = k3;
        if (He(k3, h3))
          return;
      } catch (l3) {
      } finally {
      }
    Jg(a2, e3, d3);
  }
}
var Gh = {readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false};
var Dh = {readContext: vg, useCallback: function(a2, b3) {
  Hh().memoizedState = [a2, b3 === void 0 ? null : b3];
  return a2;
}, useContext: vg, useEffect: Wh, useImperativeHandle: function(a2, b3, c4) {
  c4 = c4 !== null && c4 !== void 0 ? c4.concat([a2]) : null;
  return Uh(4, 2, Zh.bind(null, b3, a2), c4);
}, useLayoutEffect: function(a2, b3) {
  return Uh(4, 2, a2, b3);
}, useMemo: function(a2, b3) {
  var c4 = Hh();
  b3 = b3 === void 0 ? null : b3;
  a2 = a2();
  c4.memoizedState = [a2, b3];
  return a2;
}, useReducer: function(a2, b3, c4) {
  var d3 = Hh();
  b3 = c4 !== void 0 ? c4(b3) : b3;
  d3.memoizedState = d3.baseState = b3;
  a2 = d3.queue = {pending: null, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b3};
  a2 = a2.dispatch = Oh.bind(null, R, a2);
  return [d3.memoizedState, a2];
}, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a2) {
  var b3 = Qh(a2), c4 = b3[0], d3 = b3[1];
  Wh(function() {
    var b4 = wh.transition;
    wh.transition = 1;
    try {
      d3(a2);
    } finally {
      wh.transition = b4;
    }
  }, [a2]);
  return c4;
}, useTransition: function() {
  var a2 = Qh(false), b3 = a2[0];
  a2 = di.bind(null, a2[1]);
  Sh(a2);
  return [a2, b3];
}, useMutableSource: function(a2, b3, c4) {
  var d3 = Hh();
  d3.memoizedState = {refs: {getSnapshot: b3, setSnapshot: null}, source: a2, subscribe: c4};
  return Nh(d3, a2, b3, c4);
}, useOpaqueIdentifier: function() {
  if (lh) {
    var a2 = false, b3 = uf(function() {
      a2 || (a2 = true, c4("r:" + (tf++).toString(36)));
      throw Error(y(355));
    }), c4 = Qh(b3)[1];
    (R.mode & 2) === 0 && (R.flags |= 516, Rh(5, function() {
      c4("r:" + (tf++).toString(36));
    }, void 0, null));
    return b3;
  }
  b3 = "r:" + (tf++).toString(36);
  Qh(b3);
  return b3;
}, unstable_isNewReconciler: false};
var Eh = {readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {
  return Kh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a2) {
  var b3 = Kh(Jh), c4 = b3[0], d3 = b3[1];
  Xh(function() {
    var b4 = wh.transition;
    wh.transition = 1;
    try {
      d3(a2);
    } finally {
      wh.transition = b4;
    }
  }, [a2]);
  return c4;
}, useTransition: function() {
  var a2 = Kh(Jh)[0];
  return [
    Th().current,
    a2
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Kh(Jh)[0];
}, unstable_isNewReconciler: false};
var Fh = {readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {
  return Lh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a2) {
  var b3 = Lh(Jh), c4 = b3[0], d3 = b3[1];
  Xh(function() {
    var b4 = wh.transition;
    wh.transition = 1;
    try {
      d3(a2);
    } finally {
      wh.transition = b4;
    }
  }, [a2]);
  return c4;
}, useTransition: function() {
  var a2 = Lh(Jh)[0];
  return [
    Th().current,
    a2
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Lh(Jh)[0];
}, unstable_isNewReconciler: false};
var ei = ra.ReactCurrentOwner;
var ug = false;
function fi(a2, b3, c4, d3) {
  b3.child = a2 === null ? Zg(b3, null, c4, d3) : Yg(b3, a2.child, c4, d3);
}
function gi(a2, b3, c4, d3, e3) {
  c4 = c4.render;
  var f3 = b3.ref;
  tg(b3, e3);
  d3 = Ch(a2, b3, c4, d3, f3, e3);
  if (a2 !== null && !ug)
    return b3.updateQueue = a2.updateQueue, b3.flags &= -517, a2.lanes &= ~e3, hi(a2, b3, e3);
  b3.flags |= 1;
  fi(a2, b3, d3, e3);
  return b3.child;
}
function ii(a2, b3, c4, d3, e3, f3) {
  if (a2 === null) {
    var g3 = c4.type;
    if (typeof g3 === "function" && !ji(g3) && g3.defaultProps === void 0 && c4.compare === null && c4.defaultProps === void 0)
      return b3.tag = 15, b3.type = g3, ki(a2, b3, g3, d3, e3, f3);
    a2 = Vg(c4.type, null, d3, b3, b3.mode, f3);
    a2.ref = b3.ref;
    a2.return = b3;
    return b3.child = a2;
  }
  g3 = a2.child;
  if ((e3 & f3) === 0 && (e3 = g3.memoizedProps, c4 = c4.compare, c4 = c4 !== null ? c4 : Je, c4(e3, d3) && a2.ref === b3.ref))
    return hi(a2, b3, f3);
  b3.flags |= 1;
  a2 = Tg(g3, d3);
  a2.ref = b3.ref;
  a2.return = b3;
  return b3.child = a2;
}
function ki(a2, b3, c4, d3, e3, f3) {
  if (a2 !== null && Je(a2.memoizedProps, d3) && a2.ref === b3.ref)
    if (ug = false, (f3 & e3) !== 0)
      (a2.flags & 16384) !== 0 && (ug = true);
    else
      return b3.lanes = a2.lanes, hi(a2, b3, f3);
  return li(a2, b3, c4, d3, f3);
}
function mi(a2, b3, c4) {
  var d3 = b3.pendingProps, e3 = d3.children, f3 = a2 !== null ? a2.memoizedState : null;
  if (d3.mode === "hidden" || d3.mode === "unstable-defer-without-hiding")
    if ((b3.mode & 4) === 0)
      b3.memoizedState = {baseLanes: 0}, ni(b3, c4);
    else if ((c4 & 1073741824) !== 0)
      b3.memoizedState = {baseLanes: 0}, ni(b3, f3 !== null ? f3.baseLanes : c4);
    else
      return a2 = f3 !== null ? f3.baseLanes | c4 : c4, b3.lanes = b3.childLanes = 1073741824, b3.memoizedState = {baseLanes: a2}, ni(b3, a2), null;
  else
    f3 !== null ? (d3 = f3.baseLanes | c4, b3.memoizedState = null) : d3 = c4, ni(b3, d3);
  fi(a2, b3, e3, c4);
  return b3.child;
}
function oi(a2, b3) {
  var c4 = b3.ref;
  if (a2 === null && c4 !== null || a2 !== null && a2.ref !== c4)
    b3.flags |= 128;
}
function li(a2, b3, c4, d3, e3) {
  var f3 = Ff(c4) ? Df : M.current;
  f3 = Ef(b3, f3);
  tg(b3, e3);
  c4 = Ch(a2, b3, c4, d3, f3, e3);
  if (a2 !== null && !ug)
    return b3.updateQueue = a2.updateQueue, b3.flags &= -517, a2.lanes &= ~e3, hi(a2, b3, e3);
  b3.flags |= 1;
  fi(a2, b3, c4, e3);
  return b3.child;
}
function pi(a2, b3, c4, d3, e3) {
  if (Ff(c4)) {
    var f3 = true;
    Jf(b3);
  } else
    f3 = false;
  tg(b3, e3);
  if (b3.stateNode === null)
    a2 !== null && (a2.alternate = null, b3.alternate = null, b3.flags |= 2), Mg(b3, c4, d3), Og(b3, c4, d3, e3), d3 = true;
  else if (a2 === null) {
    var g3 = b3.stateNode, h3 = b3.memoizedProps;
    g3.props = h3;
    var k3 = g3.context, l3 = c4.contextType;
    typeof l3 === "object" && l3 !== null ? l3 = vg(l3) : (l3 = Ff(c4) ? Df : M.current, l3 = Ef(b3, l3));
    var n4 = c4.getDerivedStateFromProps, A3 = typeof n4 === "function" || typeof g3.getSnapshotBeforeUpdate === "function";
    A3 || typeof g3.UNSAFE_componentWillReceiveProps !== "function" && typeof g3.componentWillReceiveProps !== "function" || (h3 !== d3 || k3 !== l3) && Ng(b3, g3, d3, l3);
    wg = false;
    var p3 = b3.memoizedState;
    g3.state = p3;
    Cg(b3, d3, g3, e3);
    k3 = b3.memoizedState;
    h3 !== d3 || p3 !== k3 || N.current || wg ? (typeof n4 === "function" && (Gg(b3, c4, n4, d3), k3 = b3.memoizedState), (h3 = wg || Lg(b3, c4, h3, d3, p3, k3, l3)) ? (A3 || typeof g3.UNSAFE_componentWillMount !== "function" && typeof g3.componentWillMount !== "function" || (typeof g3.componentWillMount === "function" && g3.componentWillMount(), typeof g3.UNSAFE_componentWillMount === "function" && g3.UNSAFE_componentWillMount()), typeof g3.componentDidMount === "function" && (b3.flags |= 4)) : (typeof g3.componentDidMount === "function" && (b3.flags |= 4), b3.memoizedProps = d3, b3.memoizedState = k3), g3.props = d3, g3.state = k3, g3.context = l3, d3 = h3) : (typeof g3.componentDidMount === "function" && (b3.flags |= 4), d3 = false);
  } else {
    g3 = b3.stateNode;
    yg(a2, b3);
    h3 = b3.memoizedProps;
    l3 = b3.type === b3.elementType ? h3 : lg(b3.type, h3);
    g3.props = l3;
    A3 = b3.pendingProps;
    p3 = g3.context;
    k3 = c4.contextType;
    typeof k3 === "object" && k3 !== null ? k3 = vg(k3) : (k3 = Ff(c4) ? Df : M.current, k3 = Ef(b3, k3));
    var C = c4.getDerivedStateFromProps;
    (n4 = typeof C === "function" || typeof g3.getSnapshotBeforeUpdate === "function") || typeof g3.UNSAFE_componentWillReceiveProps !== "function" && typeof g3.componentWillReceiveProps !== "function" || (h3 !== A3 || p3 !== k3) && Ng(b3, g3, d3, k3);
    wg = false;
    p3 = b3.memoizedState;
    g3.state = p3;
    Cg(b3, d3, g3, e3);
    var x3 = b3.memoizedState;
    h3 !== A3 || p3 !== x3 || N.current || wg ? (typeof C === "function" && (Gg(b3, c4, C, d3), x3 = b3.memoizedState), (l3 = wg || Lg(b3, c4, l3, d3, p3, x3, k3)) ? (n4 || typeof g3.UNSAFE_componentWillUpdate !== "function" && typeof g3.componentWillUpdate !== "function" || (typeof g3.componentWillUpdate === "function" && g3.componentWillUpdate(d3, x3, k3), typeof g3.UNSAFE_componentWillUpdate === "function" && g3.UNSAFE_componentWillUpdate(d3, x3, k3)), typeof g3.componentDidUpdate === "function" && (b3.flags |= 4), typeof g3.getSnapshotBeforeUpdate === "function" && (b3.flags |= 256)) : (typeof g3.componentDidUpdate !== "function" || h3 === a2.memoizedProps && p3 === a2.memoizedState || (b3.flags |= 4), typeof g3.getSnapshotBeforeUpdate !== "function" || h3 === a2.memoizedProps && p3 === a2.memoizedState || (b3.flags |= 256), b3.memoizedProps = d3, b3.memoizedState = x3), g3.props = d3, g3.state = x3, g3.context = k3, d3 = l3) : (typeof g3.componentDidUpdate !== "function" || h3 === a2.memoizedProps && p3 === a2.memoizedState || (b3.flags |= 4), typeof g3.getSnapshotBeforeUpdate !== "function" || h3 === a2.memoizedProps && p3 === a2.memoizedState || (b3.flags |= 256), d3 = false);
  }
  return qi(a2, b3, c4, d3, f3, e3);
}
function qi(a2, b3, c4, d3, e3, f3) {
  oi(a2, b3);
  var g3 = (b3.flags & 64) !== 0;
  if (!d3 && !g3)
    return e3 && Kf(b3, c4, false), hi(a2, b3, f3);
  d3 = b3.stateNode;
  ei.current = b3;
  var h3 = g3 && typeof c4.getDerivedStateFromError !== "function" ? null : d3.render();
  b3.flags |= 1;
  a2 !== null && g3 ? (b3.child = Yg(b3, a2.child, null, f3), b3.child = Yg(b3, null, h3, f3)) : fi(a2, b3, h3, f3);
  b3.memoizedState = d3.state;
  e3 && Kf(b3, c4, true);
  return b3.child;
}
function ri(a2) {
  var b3 = a2.stateNode;
  b3.pendingContext ? Hf(a2, b3.pendingContext, b3.pendingContext !== b3.context) : b3.context && Hf(a2, b3.context, false);
  eh(a2, b3.containerInfo);
}
var si = {dehydrated: null, retryLane: 0};
function ti(a2, b3, c4) {
  var d3 = b3.pendingProps, e3 = P.current, f3 = false, g3;
  (g3 = (b3.flags & 64) !== 0) || (g3 = a2 !== null && a2.memoizedState === null ? false : (e3 & 2) !== 0);
  g3 ? (f3 = true, b3.flags &= -65) : a2 !== null && a2.memoizedState === null || d3.fallback === void 0 || d3.unstable_avoidThisFallback === true || (e3 |= 1);
  I(P, e3 & 1);
  if (a2 === null) {
    d3.fallback !== void 0 && ph(b3);
    a2 = d3.children;
    e3 = d3.fallback;
    if (f3)
      return a2 = ui(b3, a2, e3, c4), b3.child.memoizedState = {baseLanes: c4}, b3.memoizedState = si, a2;
    if (typeof d3.unstable_expectedLoadTime === "number")
      return a2 = ui(b3, a2, e3, c4), b3.child.memoizedState = {baseLanes: c4}, b3.memoizedState = si, b3.lanes = 33554432, a2;
    c4 = vi({mode: "visible", children: a2}, b3.mode, c4, null);
    c4.return = b3;
    return b3.child = c4;
  }
  if (a2.memoizedState !== null) {
    if (f3)
      return d3 = wi(a2, b3, d3.children, d3.fallback, c4), f3 = b3.child, e3 = a2.child.memoizedState, f3.memoizedState = e3 === null ? {baseLanes: c4} : {baseLanes: e3.baseLanes | c4}, f3.childLanes = a2.childLanes & ~c4, b3.memoizedState = si, d3;
    c4 = xi(a2, b3, d3.children, c4);
    b3.memoizedState = null;
    return c4;
  }
  if (f3)
    return d3 = wi(a2, b3, d3.children, d3.fallback, c4), f3 = b3.child, e3 = a2.child.memoizedState, f3.memoizedState = e3 === null ? {baseLanes: c4} : {baseLanes: e3.baseLanes | c4}, f3.childLanes = a2.childLanes & ~c4, b3.memoizedState = si, d3;
  c4 = xi(a2, b3, d3.children, c4);
  b3.memoizedState = null;
  return c4;
}
function ui(a2, b3, c4, d3) {
  var e3 = a2.mode, f3 = a2.child;
  b3 = {mode: "hidden", children: b3};
  (e3 & 2) === 0 && f3 !== null ? (f3.childLanes = 0, f3.pendingProps = b3) : f3 = vi(b3, e3, 0, null);
  c4 = Xg(c4, e3, d3, null);
  f3.return = a2;
  c4.return = a2;
  f3.sibling = c4;
  a2.child = f3;
  return c4;
}
function xi(a2, b3, c4, d3) {
  var e3 = a2.child;
  a2 = e3.sibling;
  c4 = Tg(e3, {mode: "visible", children: c4});
  (b3.mode & 2) === 0 && (c4.lanes = d3);
  c4.return = b3;
  c4.sibling = null;
  a2 !== null && (a2.nextEffect = null, a2.flags = 8, b3.firstEffect = b3.lastEffect = a2);
  return b3.child = c4;
}
function wi(a2, b3, c4, d3, e3) {
  var f3 = b3.mode, g3 = a2.child;
  a2 = g3.sibling;
  var h3 = {mode: "hidden", children: c4};
  (f3 & 2) === 0 && b3.child !== g3 ? (c4 = b3.child, c4.childLanes = 0, c4.pendingProps = h3, g3 = c4.lastEffect, g3 !== null ? (b3.firstEffect = c4.firstEffect, b3.lastEffect = g3, g3.nextEffect = null) : b3.firstEffect = b3.lastEffect = null) : c4 = Tg(g3, h3);
  a2 !== null ? d3 = Tg(a2, d3) : (d3 = Xg(d3, f3, e3, null), d3.flags |= 2);
  d3.return = b3;
  c4.return = b3;
  c4.sibling = d3;
  b3.child = c4;
  return d3;
}
function yi(a2, b3) {
  a2.lanes |= b3;
  var c4 = a2.alternate;
  c4 !== null && (c4.lanes |= b3);
  sg(a2.return, b3);
}
function zi(a2, b3, c4, d3, e3, f3) {
  var g3 = a2.memoizedState;
  g3 === null ? a2.memoizedState = {isBackwards: b3, rendering: null, renderingStartTime: 0, last: d3, tail: c4, tailMode: e3, lastEffect: f3} : (g3.isBackwards = b3, g3.rendering = null, g3.renderingStartTime = 0, g3.last = d3, g3.tail = c4, g3.tailMode = e3, g3.lastEffect = f3);
}
function Ai(a2, b3, c4) {
  var d3 = b3.pendingProps, e3 = d3.revealOrder, f3 = d3.tail;
  fi(a2, b3, d3.children, c4);
  d3 = P.current;
  if ((d3 & 2) !== 0)
    d3 = d3 & 1 | 2, b3.flags |= 64;
  else {
    if (a2 !== null && (a2.flags & 64) !== 0)
      a:
        for (a2 = b3.child; a2 !== null; ) {
          if (a2.tag === 13)
            a2.memoizedState !== null && yi(a2, c4);
          else if (a2.tag === 19)
            yi(a2, c4);
          else if (a2.child !== null) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b3)
            break a;
          for (; a2.sibling === null; ) {
            if (a2.return === null || a2.return === b3)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d3 &= 1;
  }
  I(P, d3);
  if ((b3.mode & 2) === 0)
    b3.memoizedState = null;
  else
    switch (e3) {
      case "forwards":
        c4 = b3.child;
        for (e3 = null; c4 !== null; )
          a2 = c4.alternate, a2 !== null && ih(a2) === null && (e3 = c4), c4 = c4.sibling;
        c4 = e3;
        c4 === null ? (e3 = b3.child, b3.child = null) : (e3 = c4.sibling, c4.sibling = null);
        zi(b3, false, e3, c4, f3, b3.lastEffect);
        break;
      case "backwards":
        c4 = null;
        e3 = b3.child;
        for (b3.child = null; e3 !== null; ) {
          a2 = e3.alternate;
          if (a2 !== null && ih(a2) === null) {
            b3.child = e3;
            break;
          }
          a2 = e3.sibling;
          e3.sibling = c4;
          c4 = e3;
          e3 = a2;
        }
        zi(b3, true, c4, null, f3, b3.lastEffect);
        break;
      case "together":
        zi(b3, false, null, null, void 0, b3.lastEffect);
        break;
      default:
        b3.memoizedState = null;
    }
  return b3.child;
}
function hi(a2, b3, c4) {
  a2 !== null && (b3.dependencies = a2.dependencies);
  Dg |= b3.lanes;
  if ((c4 & b3.childLanes) !== 0) {
    if (a2 !== null && b3.child !== a2.child)
      throw Error(y(153));
    if (b3.child !== null) {
      a2 = b3.child;
      c4 = Tg(a2, a2.pendingProps);
      b3.child = c4;
      for (c4.return = b3; a2.sibling !== null; )
        a2 = a2.sibling, c4 = c4.sibling = Tg(a2, a2.pendingProps), c4.return = b3;
      c4.sibling = null;
    }
    return b3.child;
  }
  return null;
}
var Bi;
var Ci;
var Di;
var Ei;
Bi = function(a2, b3) {
  for (var c4 = b3.child; c4 !== null; ) {
    if (c4.tag === 5 || c4.tag === 6)
      a2.appendChild(c4.stateNode);
    else if (c4.tag !== 4 && c4.child !== null) {
      c4.child.return = c4;
      c4 = c4.child;
      continue;
    }
    if (c4 === b3)
      break;
    for (; c4.sibling === null; ) {
      if (c4.return === null || c4.return === b3)
        return;
      c4 = c4.return;
    }
    c4.sibling.return = c4.return;
    c4 = c4.sibling;
  }
};
Ci = function() {
};
Di = function(a2, b3, c4, d3) {
  var e3 = a2.memoizedProps;
  if (e3 !== d3) {
    a2 = b3.stateNode;
    dh(ah.current);
    var f3 = null;
    switch (c4) {
      case "input":
        e3 = Ya(a2, e3);
        d3 = Ya(a2, d3);
        f3 = [];
        break;
      case "option":
        e3 = eb(a2, e3);
        d3 = eb(a2, d3);
        f3 = [];
        break;
      case "select":
        e3 = objectAssign({}, e3, {value: void 0});
        d3 = objectAssign({}, d3, {value: void 0});
        f3 = [];
        break;
      case "textarea":
        e3 = gb(a2, e3);
        d3 = gb(a2, d3);
        f3 = [];
        break;
      default:
        typeof e3.onClick !== "function" && typeof d3.onClick === "function" && (a2.onclick = jf);
    }
    vb(c4, d3);
    var g3;
    c4 = null;
    for (l3 in e3)
      if (!d3.hasOwnProperty(l3) && e3.hasOwnProperty(l3) && e3[l3] != null)
        if (l3 === "style") {
          var h3 = e3[l3];
          for (g3 in h3)
            h3.hasOwnProperty(g3) && (c4 || (c4 = {}), c4[g3] = "");
        } else
          l3 !== "dangerouslySetInnerHTML" && l3 !== "children" && l3 !== "suppressContentEditableWarning" && l3 !== "suppressHydrationWarning" && l3 !== "autoFocus" && (ca.hasOwnProperty(l3) ? f3 || (f3 = []) : (f3 = f3 || []).push(l3, null));
    for (l3 in d3) {
      var k3 = d3[l3];
      h3 = e3 != null ? e3[l3] : void 0;
      if (d3.hasOwnProperty(l3) && k3 !== h3 && (k3 != null || h3 != null))
        if (l3 === "style")
          if (h3) {
            for (g3 in h3)
              !h3.hasOwnProperty(g3) || k3 && k3.hasOwnProperty(g3) || (c4 || (c4 = {}), c4[g3] = "");
            for (g3 in k3)
              k3.hasOwnProperty(g3) && h3[g3] !== k3[g3] && (c4 || (c4 = {}), c4[g3] = k3[g3]);
          } else
            c4 || (f3 || (f3 = []), f3.push(l3, c4)), c4 = k3;
        else
          l3 === "dangerouslySetInnerHTML" ? (k3 = k3 ? k3.__html : void 0, h3 = h3 ? h3.__html : void 0, k3 != null && h3 !== k3 && (f3 = f3 || []).push(l3, k3)) : l3 === "children" ? typeof k3 !== "string" && typeof k3 !== "number" || (f3 = f3 || []).push(l3, "" + k3) : l3 !== "suppressContentEditableWarning" && l3 !== "suppressHydrationWarning" && (ca.hasOwnProperty(l3) ? (k3 != null && l3 === "onScroll" && G("scroll", a2), f3 || h3 === k3 || (f3 = [])) : typeof k3 === "object" && k3 !== null && k3.$$typeof === Ga ? k3.toString() : (f3 = f3 || []).push(l3, k3));
    }
    c4 && (f3 = f3 || []).push("style", c4);
    var l3 = f3;
    if (b3.updateQueue = l3)
      b3.flags |= 4;
  }
};
Ei = function(a2, b3, c4, d3) {
  c4 !== d3 && (b3.flags |= 4);
};
function Fi(a2, b3) {
  if (!lh)
    switch (a2.tailMode) {
      case "hidden":
        b3 = a2.tail;
        for (var c4 = null; b3 !== null; )
          b3.alternate !== null && (c4 = b3), b3 = b3.sibling;
        c4 === null ? a2.tail = null : c4.sibling = null;
        break;
      case "collapsed":
        c4 = a2.tail;
        for (var d3 = null; c4 !== null; )
          c4.alternate !== null && (d3 = c4), c4 = c4.sibling;
        d3 === null ? b3 || a2.tail === null ? a2.tail = null : a2.tail.sibling = null : d3.sibling = null;
    }
}
function Gi(a2, b3, c4) {
  var d3 = b3.pendingProps;
  switch (b3.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return null;
    case 1:
      return Ff(b3.type) && Gf(), null;
    case 3:
      fh();
      H(N);
      H(M);
      uh();
      d3 = b3.stateNode;
      d3.pendingContext && (d3.context = d3.pendingContext, d3.pendingContext = null);
      if (a2 === null || a2.child === null)
        rh(b3) ? b3.flags |= 4 : d3.hydrate || (b3.flags |= 256);
      Ci(b3);
      return null;
    case 5:
      hh(b3);
      var e3 = dh(ch.current);
      c4 = b3.type;
      if (a2 !== null && b3.stateNode != null)
        Di(a2, b3, c4, d3, e3), a2.ref !== b3.ref && (b3.flags |= 128);
      else {
        if (!d3) {
          if (b3.stateNode === null)
            throw Error(y(166));
          return null;
        }
        a2 = dh(ah.current);
        if (rh(b3)) {
          d3 = b3.stateNode;
          c4 = b3.type;
          var f3 = b3.memoizedProps;
          d3[wf] = b3;
          d3[xf] = f3;
          switch (c4) {
            case "dialog":
              G("cancel", d3);
              G("close", d3);
              break;
            case "iframe":
            case "object":
            case "embed":
              G("load", d3);
              break;
            case "video":
            case "audio":
              for (a2 = 0; a2 < Xe.length; a2++)
                G(Xe[a2], d3);
              break;
            case "source":
              G("error", d3);
              break;
            case "img":
            case "image":
            case "link":
              G("error", d3);
              G("load", d3);
              break;
            case "details":
              G("toggle", d3);
              break;
            case "input":
              Za(d3, f3);
              G("invalid", d3);
              break;
            case "select":
              d3._wrapperState = {wasMultiple: !!f3.multiple};
              G("invalid", d3);
              break;
            case "textarea":
              hb(d3, f3), G("invalid", d3);
          }
          vb(c4, f3);
          a2 = null;
          for (var g3 in f3)
            f3.hasOwnProperty(g3) && (e3 = f3[g3], g3 === "children" ? typeof e3 === "string" ? d3.textContent !== e3 && (a2 = ["children", e3]) : typeof e3 === "number" && d3.textContent !== "" + e3 && (a2 = ["children", "" + e3]) : ca.hasOwnProperty(g3) && e3 != null && g3 === "onScroll" && G("scroll", d3));
          switch (c4) {
            case "input":
              Va(d3);
              cb(d3, f3, true);
              break;
            case "textarea":
              Va(d3);
              jb(d3);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof f3.onClick === "function" && (d3.onclick = jf);
          }
          d3 = a2;
          b3.updateQueue = d3;
          d3 !== null && (b3.flags |= 4);
        } else {
          g3 = e3.nodeType === 9 ? e3 : e3.ownerDocument;
          a2 === kb.html && (a2 = lb(c4));
          a2 === kb.html ? c4 === "script" ? (a2 = g3.createElement("div"), a2.innerHTML = "<script></script>", a2 = a2.removeChild(a2.firstChild)) : typeof d3.is === "string" ? a2 = g3.createElement(c4, {is: d3.is}) : (a2 = g3.createElement(c4), c4 === "select" && (g3 = a2, d3.multiple ? g3.multiple = true : d3.size && (g3.size = d3.size))) : a2 = g3.createElementNS(a2, c4);
          a2[wf] = b3;
          a2[xf] = d3;
          Bi(a2, b3, false, false);
          b3.stateNode = a2;
          g3 = wb(c4, d3);
          switch (c4) {
            case "dialog":
              G("cancel", a2);
              G("close", a2);
              e3 = d3;
              break;
            case "iframe":
            case "object":
            case "embed":
              G("load", a2);
              e3 = d3;
              break;
            case "video":
            case "audio":
              for (e3 = 0; e3 < Xe.length; e3++)
                G(Xe[e3], a2);
              e3 = d3;
              break;
            case "source":
              G("error", a2);
              e3 = d3;
              break;
            case "img":
            case "image":
            case "link":
              G("error", a2);
              G("load", a2);
              e3 = d3;
              break;
            case "details":
              G("toggle", a2);
              e3 = d3;
              break;
            case "input":
              Za(a2, d3);
              e3 = Ya(a2, d3);
              G("invalid", a2);
              break;
            case "option":
              e3 = eb(a2, d3);
              break;
            case "select":
              a2._wrapperState = {wasMultiple: !!d3.multiple};
              e3 = objectAssign({}, d3, {value: void 0});
              G("invalid", a2);
              break;
            case "textarea":
              hb(a2, d3);
              e3 = gb(a2, d3);
              G("invalid", a2);
              break;
            default:
              e3 = d3;
          }
          vb(c4, e3);
          var h3 = e3;
          for (f3 in h3)
            if (h3.hasOwnProperty(f3)) {
              var k3 = h3[f3];
              f3 === "style" ? tb(a2, k3) : f3 === "dangerouslySetInnerHTML" ? (k3 = k3 ? k3.__html : void 0, k3 != null && ob(a2, k3)) : f3 === "children" ? typeof k3 === "string" ? (c4 !== "textarea" || k3 !== "") && pb(a2, k3) : typeof k3 === "number" && pb(a2, "" + k3) : f3 !== "suppressContentEditableWarning" && f3 !== "suppressHydrationWarning" && f3 !== "autoFocus" && (ca.hasOwnProperty(f3) ? k3 != null && f3 === "onScroll" && G("scroll", a2) : k3 != null && qa(a2, f3, k3, g3));
            }
          switch (c4) {
            case "input":
              Va(a2);
              cb(a2, d3, false);
              break;
            case "textarea":
              Va(a2);
              jb(a2);
              break;
            case "option":
              d3.value != null && a2.setAttribute("value", "" + Sa(d3.value));
              break;
            case "select":
              a2.multiple = !!d3.multiple;
              f3 = d3.value;
              f3 != null ? fb(a2, !!d3.multiple, f3, false) : d3.defaultValue != null && fb(a2, !!d3.multiple, d3.defaultValue, true);
              break;
            default:
              typeof e3.onClick === "function" && (a2.onclick = jf);
          }
          mf(c4, d3) && (b3.flags |= 4);
        }
        b3.ref !== null && (b3.flags |= 128);
      }
      return null;
    case 6:
      if (a2 && b3.stateNode != null)
        Ei(a2, b3, a2.memoizedProps, d3);
      else {
        if (typeof d3 !== "string" && b3.stateNode === null)
          throw Error(y(166));
        c4 = dh(ch.current);
        dh(ah.current);
        rh(b3) ? (d3 = b3.stateNode, c4 = b3.memoizedProps, d3[wf] = b3, d3.nodeValue !== c4 && (b3.flags |= 4)) : (d3 = (c4.nodeType === 9 ? c4 : c4.ownerDocument).createTextNode(d3), d3[wf] = b3, b3.stateNode = d3);
      }
      return null;
    case 13:
      H(P);
      d3 = b3.memoizedState;
      if ((b3.flags & 64) !== 0)
        return b3.lanes = c4, b3;
      d3 = d3 !== null;
      c4 = false;
      a2 === null ? b3.memoizedProps.fallback !== void 0 && rh(b3) : c4 = a2.memoizedState !== null;
      if (d3 && !c4 && (b3.mode & 2) !== 0)
        if (a2 === null && b3.memoizedProps.unstable_avoidThisFallback !== true || (P.current & 1) !== 0)
          V === 0 && (V = 3);
        else {
          if (V === 0 || V === 3)
            V = 4;
          U === null || (Dg & 134217727) === 0 && (Hi & 134217727) === 0 || Ii(U, W);
        }
      if (d3 || c4)
        b3.flags |= 4;
      return null;
    case 4:
      return fh(), Ci(b3), a2 === null && cf(b3.stateNode.containerInfo), null;
    case 10:
      return rg(b3), null;
    case 17:
      return Ff(b3.type) && Gf(), null;
    case 19:
      H(P);
      d3 = b3.memoizedState;
      if (d3 === null)
        return null;
      f3 = (b3.flags & 64) !== 0;
      g3 = d3.rendering;
      if (g3 === null)
        if (f3)
          Fi(d3, false);
        else {
          if (V !== 0 || a2 !== null && (a2.flags & 64) !== 0)
            for (a2 = b3.child; a2 !== null; ) {
              g3 = ih(a2);
              if (g3 !== null) {
                b3.flags |= 64;
                Fi(d3, false);
                f3 = g3.updateQueue;
                f3 !== null && (b3.updateQueue = f3, b3.flags |= 4);
                d3.lastEffect === null && (b3.firstEffect = null);
                b3.lastEffect = d3.lastEffect;
                d3 = c4;
                for (c4 = b3.child; c4 !== null; )
                  f3 = c4, a2 = d3, f3.flags &= 2, f3.nextEffect = null, f3.firstEffect = null, f3.lastEffect = null, g3 = f3.alternate, g3 === null ? (f3.childLanes = 0, f3.lanes = a2, f3.child = null, f3.memoizedProps = null, f3.memoizedState = null, f3.updateQueue = null, f3.dependencies = null, f3.stateNode = null) : (f3.childLanes = g3.childLanes, f3.lanes = g3.lanes, f3.child = g3.child, f3.memoizedProps = g3.memoizedProps, f3.memoizedState = g3.memoizedState, f3.updateQueue = g3.updateQueue, f3.type = g3.type, a2 = g3.dependencies, f3.dependencies = a2 === null ? null : {lanes: a2.lanes, firstContext: a2.firstContext}), c4 = c4.sibling;
                I(P, P.current & 1 | 2);
                return b3.child;
              }
              a2 = a2.sibling;
            }
          d3.tail !== null && O() > Ji && (b3.flags |= 64, f3 = true, Fi(d3, false), b3.lanes = 33554432);
        }
      else {
        if (!f3)
          if (a2 = ih(g3), a2 !== null) {
            if (b3.flags |= 64, f3 = true, c4 = a2.updateQueue, c4 !== null && (b3.updateQueue = c4, b3.flags |= 4), Fi(d3, true), d3.tail === null && d3.tailMode === "hidden" && !g3.alternate && !lh)
              return b3 = b3.lastEffect = d3.lastEffect, b3 !== null && (b3.nextEffect = null), null;
          } else
            2 * O() - d3.renderingStartTime > Ji && c4 !== 1073741824 && (b3.flags |= 64, f3 = true, Fi(d3, false), b3.lanes = 33554432);
        d3.isBackwards ? (g3.sibling = b3.child, b3.child = g3) : (c4 = d3.last, c4 !== null ? c4.sibling = g3 : b3.child = g3, d3.last = g3);
      }
      return d3.tail !== null ? (c4 = d3.tail, d3.rendering = c4, d3.tail = c4.sibling, d3.lastEffect = b3.lastEffect, d3.renderingStartTime = O(), c4.sibling = null, b3 = P.current, I(P, f3 ? b3 & 1 | 2 : b3 & 1), c4) : null;
    case 23:
    case 24:
      return Ki(), a2 !== null && a2.memoizedState !== null !== (b3.memoizedState !== null) && d3.mode !== "unstable-defer-without-hiding" && (b3.flags |= 4), null;
  }
  throw Error(y(156, b3.tag));
}
function Li(a2) {
  switch (a2.tag) {
    case 1:
      Ff(a2.type) && Gf();
      var b3 = a2.flags;
      return b3 & 4096 ? (a2.flags = b3 & -4097 | 64, a2) : null;
    case 3:
      fh();
      H(N);
      H(M);
      uh();
      b3 = a2.flags;
      if ((b3 & 64) !== 0)
        throw Error(y(285));
      a2.flags = b3 & -4097 | 64;
      return a2;
    case 5:
      return hh(a2), null;
    case 13:
      return H(P), b3 = a2.flags, b3 & 4096 ? (a2.flags = b3 & -4097 | 64, a2) : null;
    case 19:
      return H(P), null;
    case 4:
      return fh(), null;
    case 10:
      return rg(a2), null;
    case 23:
    case 24:
      return Ki(), null;
    default:
      return null;
  }
}
function Mi(a2, b3) {
  try {
    var c4 = "", d3 = b3;
    do
      c4 += Qa(d3), d3 = d3.return;
    while (d3);
    var e3 = c4;
  } catch (f3) {
    e3 = "\nError generating stack: " + f3.message + "\n" + f3.stack;
  }
  return {value: a2, source: b3, stack: e3};
}
function Ni(a2, b3) {
  try {
    console.error(b3.value);
  } catch (c4) {
    setTimeout(function() {
      throw c4;
    });
  }
}
var Oi = typeof WeakMap === "function" ? WeakMap : Map;
function Pi(a2, b3, c4) {
  c4 = zg(-1, c4);
  c4.tag = 3;
  c4.payload = {element: null};
  var d3 = b3.value;
  c4.callback = function() {
    Qi || (Qi = true, Ri = d3);
    Ni(a2, b3);
  };
  return c4;
}
function Si(a2, b3, c4) {
  c4 = zg(-1, c4);
  c4.tag = 3;
  var d3 = a2.type.getDerivedStateFromError;
  if (typeof d3 === "function") {
    var e3 = b3.value;
    c4.payload = function() {
      Ni(a2, b3);
      return d3(e3);
    };
  }
  var f3 = a2.stateNode;
  f3 !== null && typeof f3.componentDidCatch === "function" && (c4.callback = function() {
    typeof d3 !== "function" && (Ti === null ? Ti = new Set([this]) : Ti.add(this), Ni(a2, b3));
    var c5 = b3.stack;
    this.componentDidCatch(b3.value, {componentStack: c5 !== null ? c5 : ""});
  });
  return c4;
}
var Ui = typeof WeakSet === "function" ? WeakSet : Set;
function Vi(a2) {
  var b3 = a2.ref;
  if (b3 !== null)
    if (typeof b3 === "function")
      try {
        b3(null);
      } catch (c4) {
        Wi(a2, c4);
      }
    else
      b3.current = null;
}
function Xi(a2, b3) {
  switch (b3.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      return;
    case 1:
      if (b3.flags & 256 && a2 !== null) {
        var c4 = a2.memoizedProps, d3 = a2.memoizedState;
        a2 = b3.stateNode;
        b3 = a2.getSnapshotBeforeUpdate(b3.elementType === b3.type ? c4 : lg(b3.type, c4), d3);
        a2.__reactInternalSnapshotBeforeUpdate = b3;
      }
      return;
    case 3:
      b3.flags & 256 && qf(b3.stateNode.containerInfo);
      return;
    case 5:
    case 6:
    case 4:
    case 17:
      return;
  }
  throw Error(y(163));
}
function Yi(a2, b3, c4) {
  switch (c4.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      b3 = c4.updateQueue;
      b3 = b3 !== null ? b3.lastEffect : null;
      if (b3 !== null) {
        a2 = b3 = b3.next;
        do {
          if ((a2.tag & 3) === 3) {
            var d3 = a2.create;
            a2.destroy = d3();
          }
          a2 = a2.next;
        } while (a2 !== b3);
      }
      b3 = c4.updateQueue;
      b3 = b3 !== null ? b3.lastEffect : null;
      if (b3 !== null) {
        a2 = b3 = b3.next;
        do {
          var e3 = a2;
          d3 = e3.next;
          e3 = e3.tag;
          (e3 & 4) !== 0 && (e3 & 1) !== 0 && (Zi(c4, a2), $i(c4, a2));
          a2 = d3;
        } while (a2 !== b3);
      }
      return;
    case 1:
      a2 = c4.stateNode;
      c4.flags & 4 && (b3 === null ? a2.componentDidMount() : (d3 = c4.elementType === c4.type ? b3.memoizedProps : lg(c4.type, b3.memoizedProps), a2.componentDidUpdate(d3, b3.memoizedState, a2.__reactInternalSnapshotBeforeUpdate)));
      b3 = c4.updateQueue;
      b3 !== null && Eg(c4, b3, a2);
      return;
    case 3:
      b3 = c4.updateQueue;
      if (b3 !== null) {
        a2 = null;
        if (c4.child !== null)
          switch (c4.child.tag) {
            case 5:
              a2 = c4.child.stateNode;
              break;
            case 1:
              a2 = c4.child.stateNode;
          }
        Eg(c4, b3, a2);
      }
      return;
    case 5:
      a2 = c4.stateNode;
      b3 === null && c4.flags & 4 && mf(c4.type, c4.memoizedProps) && a2.focus();
      return;
    case 6:
      return;
    case 4:
      return;
    case 12:
      return;
    case 13:
      c4.memoizedState === null && (c4 = c4.alternate, c4 !== null && (c4 = c4.memoizedState, c4 !== null && (c4 = c4.dehydrated, c4 !== null && Cc(c4))));
      return;
    case 19:
    case 17:
    case 20:
    case 21:
    case 23:
    case 24:
      return;
  }
  throw Error(y(163));
}
function aj(a2, b3) {
  for (var c4 = a2; ; ) {
    if (c4.tag === 5) {
      var d3 = c4.stateNode;
      if (b3)
        d3 = d3.style, typeof d3.setProperty === "function" ? d3.setProperty("display", "none", "important") : d3.display = "none";
      else {
        d3 = c4.stateNode;
        var e3 = c4.memoizedProps.style;
        e3 = e3 !== void 0 && e3 !== null && e3.hasOwnProperty("display") ? e3.display : null;
        d3.style.display = sb("display", e3);
      }
    } else if (c4.tag === 6)
      c4.stateNode.nodeValue = b3 ? "" : c4.memoizedProps;
    else if ((c4.tag !== 23 && c4.tag !== 24 || c4.memoizedState === null || c4 === a2) && c4.child !== null) {
      c4.child.return = c4;
      c4 = c4.child;
      continue;
    }
    if (c4 === a2)
      break;
    for (; c4.sibling === null; ) {
      if (c4.return === null || c4.return === a2)
        return;
      c4 = c4.return;
    }
    c4.sibling.return = c4.return;
    c4 = c4.sibling;
  }
}
function bj(a2, b3) {
  if (Mf && typeof Mf.onCommitFiberUnmount === "function")
    try {
      Mf.onCommitFiberUnmount(Lf, b3);
    } catch (f3) {
    }
  switch (b3.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      a2 = b3.updateQueue;
      if (a2 !== null && (a2 = a2.lastEffect, a2 !== null)) {
        var c4 = a2 = a2.next;
        do {
          var d3 = c4, e3 = d3.destroy;
          d3 = d3.tag;
          if (e3 !== void 0)
            if ((d3 & 4) !== 0)
              Zi(b3, c4);
            else {
              d3 = b3;
              try {
                e3();
              } catch (f3) {
                Wi(d3, f3);
              }
            }
          c4 = c4.next;
        } while (c4 !== a2);
      }
      break;
    case 1:
      Vi(b3);
      a2 = b3.stateNode;
      if (typeof a2.componentWillUnmount === "function")
        try {
          a2.props = b3.memoizedProps, a2.state = b3.memoizedState, a2.componentWillUnmount();
        } catch (f3) {
          Wi(b3, f3);
        }
      break;
    case 5:
      Vi(b3);
      break;
    case 4:
      cj(a2, b3);
  }
}
function dj(a2) {
  a2.alternate = null;
  a2.child = null;
  a2.dependencies = null;
  a2.firstEffect = null;
  a2.lastEffect = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.return = null;
  a2.updateQueue = null;
}
function ej(a2) {
  return a2.tag === 5 || a2.tag === 3 || a2.tag === 4;
}
function fj(a2) {
  a: {
    for (var b3 = a2.return; b3 !== null; ) {
      if (ej(b3))
        break a;
      b3 = b3.return;
    }
    throw Error(y(160));
  }
  var c4 = b3;
  b3 = c4.stateNode;
  switch (c4.tag) {
    case 5:
      var d3 = false;
      break;
    case 3:
      b3 = b3.containerInfo;
      d3 = true;
      break;
    case 4:
      b3 = b3.containerInfo;
      d3 = true;
      break;
    default:
      throw Error(y(161));
  }
  c4.flags & 16 && (pb(b3, ""), c4.flags &= -17);
  a:
    b:
      for (c4 = a2; ; ) {
        for (; c4.sibling === null; ) {
          if (c4.return === null || ej(c4.return)) {
            c4 = null;
            break a;
          }
          c4 = c4.return;
        }
        c4.sibling.return = c4.return;
        for (c4 = c4.sibling; c4.tag !== 5 && c4.tag !== 6 && c4.tag !== 18; ) {
          if (c4.flags & 2)
            continue b;
          if (c4.child === null || c4.tag === 4)
            continue b;
          else
            c4.child.return = c4, c4 = c4.child;
        }
        if (!(c4.flags & 2)) {
          c4 = c4.stateNode;
          break a;
        }
      }
  d3 ? gj(a2, c4, b3) : hj(a2, c4, b3);
}
function gj(a2, b3, c4) {
  var d3 = a2.tag, e3 = d3 === 5 || d3 === 6;
  if (e3)
    a2 = e3 ? a2.stateNode : a2.stateNode.instance, b3 ? c4.nodeType === 8 ? c4.parentNode.insertBefore(a2, b3) : c4.insertBefore(a2, b3) : (c4.nodeType === 8 ? (b3 = c4.parentNode, b3.insertBefore(a2, c4)) : (b3 = c4, b3.appendChild(a2)), c4 = c4._reactRootContainer, c4 !== null && c4 !== void 0 || b3.onclick !== null || (b3.onclick = jf));
  else if (d3 !== 4 && (a2 = a2.child, a2 !== null))
    for (gj(a2, b3, c4), a2 = a2.sibling; a2 !== null; )
      gj(a2, b3, c4), a2 = a2.sibling;
}
function hj(a2, b3, c4) {
  var d3 = a2.tag, e3 = d3 === 5 || d3 === 6;
  if (e3)
    a2 = e3 ? a2.stateNode : a2.stateNode.instance, b3 ? c4.insertBefore(a2, b3) : c4.appendChild(a2);
  else if (d3 !== 4 && (a2 = a2.child, a2 !== null))
    for (hj(a2, b3, c4), a2 = a2.sibling; a2 !== null; )
      hj(a2, b3, c4), a2 = a2.sibling;
}
function cj(a2, b3) {
  for (var c4 = b3, d3 = false, e3, f3; ; ) {
    if (!d3) {
      d3 = c4.return;
      a:
        for (; ; ) {
          if (d3 === null)
            throw Error(y(160));
          e3 = d3.stateNode;
          switch (d3.tag) {
            case 5:
              f3 = false;
              break a;
            case 3:
              e3 = e3.containerInfo;
              f3 = true;
              break a;
            case 4:
              e3 = e3.containerInfo;
              f3 = true;
              break a;
          }
          d3 = d3.return;
        }
      d3 = true;
    }
    if (c4.tag === 5 || c4.tag === 6) {
      a:
        for (var g3 = a2, h3 = c4, k3 = h3; ; )
          if (bj(g3, k3), k3.child !== null && k3.tag !== 4)
            k3.child.return = k3, k3 = k3.child;
          else {
            if (k3 === h3)
              break a;
            for (; k3.sibling === null; ) {
              if (k3.return === null || k3.return === h3)
                break a;
              k3 = k3.return;
            }
            k3.sibling.return = k3.return;
            k3 = k3.sibling;
          }
      f3 ? (g3 = e3, h3 = c4.stateNode, g3.nodeType === 8 ? g3.parentNode.removeChild(h3) : g3.removeChild(h3)) : e3.removeChild(c4.stateNode);
    } else if (c4.tag === 4) {
      if (c4.child !== null) {
        e3 = c4.stateNode.containerInfo;
        f3 = true;
        c4.child.return = c4;
        c4 = c4.child;
        continue;
      }
    } else if (bj(a2, c4), c4.child !== null) {
      c4.child.return = c4;
      c4 = c4.child;
      continue;
    }
    if (c4 === b3)
      break;
    for (; c4.sibling === null; ) {
      if (c4.return === null || c4.return === b3)
        return;
      c4 = c4.return;
      c4.tag === 4 && (d3 = false);
    }
    c4.sibling.return = c4.return;
    c4 = c4.sibling;
  }
}
function ij(a2, b3) {
  switch (b3.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      var c4 = b3.updateQueue;
      c4 = c4 !== null ? c4.lastEffect : null;
      if (c4 !== null) {
        var d3 = c4 = c4.next;
        do
          (d3.tag & 3) === 3 && (a2 = d3.destroy, d3.destroy = void 0, a2 !== void 0 && a2()), d3 = d3.next;
        while (d3 !== c4);
      }
      return;
    case 1:
      return;
    case 5:
      c4 = b3.stateNode;
      if (c4 != null) {
        d3 = b3.memoizedProps;
        var e3 = a2 !== null ? a2.memoizedProps : d3;
        a2 = b3.type;
        var f3 = b3.updateQueue;
        b3.updateQueue = null;
        if (f3 !== null) {
          c4[xf] = d3;
          a2 === "input" && d3.type === "radio" && d3.name != null && $a(c4, d3);
          wb(a2, e3);
          b3 = wb(a2, d3);
          for (e3 = 0; e3 < f3.length; e3 += 2) {
            var g3 = f3[e3], h3 = f3[e3 + 1];
            g3 === "style" ? tb(c4, h3) : g3 === "dangerouslySetInnerHTML" ? ob(c4, h3) : g3 === "children" ? pb(c4, h3) : qa(c4, g3, h3, b3);
          }
          switch (a2) {
            case "input":
              ab(c4, d3);
              break;
            case "textarea":
              ib(c4, d3);
              break;
            case "select":
              a2 = c4._wrapperState.wasMultiple, c4._wrapperState.wasMultiple = !!d3.multiple, f3 = d3.value, f3 != null ? fb(c4, !!d3.multiple, f3, false) : a2 !== !!d3.multiple && (d3.defaultValue != null ? fb(c4, !!d3.multiple, d3.defaultValue, true) : fb(c4, !!d3.multiple, d3.multiple ? [] : "", false));
          }
        }
      }
      return;
    case 6:
      if (b3.stateNode === null)
        throw Error(y(162));
      b3.stateNode.nodeValue = b3.memoizedProps;
      return;
    case 3:
      c4 = b3.stateNode;
      c4.hydrate && (c4.hydrate = false, Cc(c4.containerInfo));
      return;
    case 12:
      return;
    case 13:
      b3.memoizedState !== null && (jj = O(), aj(b3.child, true));
      kj(b3);
      return;
    case 19:
      kj(b3);
      return;
    case 17:
      return;
    case 23:
    case 24:
      aj(b3, b3.memoizedState !== null);
      return;
  }
  throw Error(y(163));
}
function kj(a2) {
  var b3 = a2.updateQueue;
  if (b3 !== null) {
    a2.updateQueue = null;
    var c4 = a2.stateNode;
    c4 === null && (c4 = a2.stateNode = new Ui());
    b3.forEach(function(b4) {
      var d3 = lj.bind(null, a2, b4);
      c4.has(b4) || (c4.add(b4), b4.then(d3, d3));
    });
  }
}
function mj(a2, b3) {
  return a2 !== null && (a2 = a2.memoizedState, a2 === null || a2.dehydrated !== null) ? (b3 = b3.memoizedState, b3 !== null && b3.dehydrated === null) : false;
}
var nj = Math.ceil;
var oj = ra.ReactCurrentDispatcher;
var pj = ra.ReactCurrentOwner;
var X = 0;
var U = null;
var Y = null;
var W = 0;
var qj = 0;
var rj = Bf(0);
var V = 0;
var sj = null;
var tj = 0;
var Dg = 0;
var Hi = 0;
var uj = 0;
var vj = null;
var jj = 0;
var Ji = Infinity;
function wj() {
  Ji = O() + 500;
}
var Z = null;
var Qi = false;
var Ri = null;
var Ti = null;
var xj = false;
var yj = null;
var zj = 90;
var Aj = [];
var Bj = [];
var Cj = null;
var Dj = 0;
var Ej = null;
var Fj = -1;
var Gj = 0;
var Hj = 0;
var Ij = null;
var Jj = false;
function Hg() {
  return (X & 48) !== 0 ? O() : Fj !== -1 ? Fj : Fj = O();
}
function Ig(a2) {
  a2 = a2.mode;
  if ((a2 & 2) === 0)
    return 1;
  if ((a2 & 4) === 0)
    return eg() === 99 ? 1 : 2;
  Gj === 0 && (Gj = tj);
  if (kg.transition !== 0) {
    Hj !== 0 && (Hj = vj !== null ? vj.pendingLanes : 0);
    a2 = Gj;
    var b3 = 4186112 & ~Hj;
    b3 &= -b3;
    b3 === 0 && (a2 = 4186112 & ~a2, b3 = a2 & -a2, b3 === 0 && (b3 = 8192));
    return b3;
  }
  a2 = eg();
  (X & 4) !== 0 && a2 === 98 ? a2 = Xc(12, Gj) : (a2 = Sc(a2), a2 = Xc(a2, Gj));
  return a2;
}
function Jg(a2, b3, c4) {
  if (50 < Dj)
    throw Dj = 0, Ej = null, Error(y(185));
  a2 = Kj(a2, b3);
  if (a2 === null)
    return null;
  $c(a2, b3, c4);
  a2 === U && (Hi |= b3, V === 4 && Ii(a2, W));
  var d3 = eg();
  b3 === 1 ? (X & 8) !== 0 && (X & 48) === 0 ? Lj(a2) : (Mj(a2, c4), X === 0 && (wj(), ig())) : ((X & 4) === 0 || d3 !== 98 && d3 !== 99 || (Cj === null ? Cj = new Set([a2]) : Cj.add(a2)), Mj(a2, c4));
  vj = a2;
}
function Kj(a2, b3) {
  a2.lanes |= b3;
  var c4 = a2.alternate;
  c4 !== null && (c4.lanes |= b3);
  c4 = a2;
  for (a2 = a2.return; a2 !== null; )
    a2.childLanes |= b3, c4 = a2.alternate, c4 !== null && (c4.childLanes |= b3), c4 = a2, a2 = a2.return;
  return c4.tag === 3 ? c4.stateNode : null;
}
function Mj(a2, b3) {
  for (var c4 = a2.callbackNode, d3 = a2.suspendedLanes, e3 = a2.pingedLanes, f3 = a2.expirationTimes, g3 = a2.pendingLanes; 0 < g3; ) {
    var h3 = 31 - Vc(g3), k3 = 1 << h3, l3 = f3[h3];
    if (l3 === -1) {
      if ((k3 & d3) === 0 || (k3 & e3) !== 0) {
        l3 = b3;
        Rc(k3);
        var n4 = F;
        f3[h3] = 10 <= n4 ? l3 + 250 : 6 <= n4 ? l3 + 5e3 : -1;
      }
    } else
      l3 <= b3 && (a2.expiredLanes |= k3);
    g3 &= ~k3;
  }
  d3 = Uc(a2, a2 === U ? W : 0);
  b3 = F;
  if (d3 === 0)
    c4 !== null && (c4 !== Zf && Pf(c4), a2.callbackNode = null, a2.callbackPriority = 0);
  else {
    if (c4 !== null) {
      if (a2.callbackPriority === b3)
        return;
      c4 !== Zf && Pf(c4);
    }
    b3 === 15 ? (c4 = Lj.bind(null, a2), ag === null ? (ag = [c4], bg = Of(Uf, jg)) : ag.push(c4), c4 = Zf) : b3 === 14 ? c4 = hg(99, Lj.bind(null, a2)) : (c4 = Tc(b3), c4 = hg(c4, Nj.bind(null, a2)));
    a2.callbackPriority = b3;
    a2.callbackNode = c4;
  }
}
function Nj(a2) {
  Fj = -1;
  Hj = Gj = 0;
  if ((X & 48) !== 0)
    throw Error(y(327));
  var b3 = a2.callbackNode;
  if (Oj() && a2.callbackNode !== b3)
    return null;
  var c4 = Uc(a2, a2 === U ? W : 0);
  if (c4 === 0)
    return null;
  var d3 = c4;
  var e3 = X;
  X |= 16;
  var f3 = Pj();
  if (U !== a2 || W !== d3)
    wj(), Qj(a2, d3);
  do
    try {
      Rj();
      break;
    } catch (h3) {
      Sj(a2, h3);
    }
  while (1);
  qg();
  oj.current = f3;
  X = e3;
  Y !== null ? d3 = 0 : (U = null, W = 0, d3 = V);
  if ((tj & Hi) !== 0)
    Qj(a2, 0);
  else if (d3 !== 0) {
    d3 === 2 && (X |= 64, a2.hydrate && (a2.hydrate = false, qf(a2.containerInfo)), c4 = Wc(a2), c4 !== 0 && (d3 = Tj(a2, c4)));
    if (d3 === 1)
      throw b3 = sj, Qj(a2, 0), Ii(a2, c4), Mj(a2, O()), b3;
    a2.finishedWork = a2.current.alternate;
    a2.finishedLanes = c4;
    switch (d3) {
      case 0:
      case 1:
        throw Error(y(345));
      case 2:
        Uj(a2);
        break;
      case 3:
        Ii(a2, c4);
        if ((c4 & 62914560) === c4 && (d3 = jj + 500 - O(), 10 < d3)) {
          if (Uc(a2, 0) !== 0)
            break;
          e3 = a2.suspendedLanes;
          if ((e3 & c4) !== c4) {
            Hg();
            a2.pingedLanes |= a2.suspendedLanes & e3;
            break;
          }
          a2.timeoutHandle = of(Uj.bind(null, a2), d3);
          break;
        }
        Uj(a2);
        break;
      case 4:
        Ii(a2, c4);
        if ((c4 & 4186112) === c4)
          break;
        d3 = a2.eventTimes;
        for (e3 = -1; 0 < c4; ) {
          var g3 = 31 - Vc(c4);
          f3 = 1 << g3;
          g3 = d3[g3];
          g3 > e3 && (e3 = g3);
          c4 &= ~f3;
        }
        c4 = e3;
        c4 = O() - c4;
        c4 = (120 > c4 ? 120 : 480 > c4 ? 480 : 1080 > c4 ? 1080 : 1920 > c4 ? 1920 : 3e3 > c4 ? 3e3 : 4320 > c4 ? 4320 : 1960 * nj(c4 / 1960)) - c4;
        if (10 < c4) {
          a2.timeoutHandle = of(Uj.bind(null, a2), c4);
          break;
        }
        Uj(a2);
        break;
      case 5:
        Uj(a2);
        break;
      default:
        throw Error(y(329));
    }
  }
  Mj(a2, O());
  return a2.callbackNode === b3 ? Nj.bind(null, a2) : null;
}
function Ii(a2, b3) {
  b3 &= ~uj;
  b3 &= ~Hi;
  a2.suspendedLanes |= b3;
  a2.pingedLanes &= ~b3;
  for (a2 = a2.expirationTimes; 0 < b3; ) {
    var c4 = 31 - Vc(b3), d3 = 1 << c4;
    a2[c4] = -1;
    b3 &= ~d3;
  }
}
function Lj(a2) {
  if ((X & 48) !== 0)
    throw Error(y(327));
  Oj();
  if (a2 === U && (a2.expiredLanes & W) !== 0) {
    var b3 = W;
    var c4 = Tj(a2, b3);
    (tj & Hi) !== 0 && (b3 = Uc(a2, b3), c4 = Tj(a2, b3));
  } else
    b3 = Uc(a2, 0), c4 = Tj(a2, b3);
  a2.tag !== 0 && c4 === 2 && (X |= 64, a2.hydrate && (a2.hydrate = false, qf(a2.containerInfo)), b3 = Wc(a2), b3 !== 0 && (c4 = Tj(a2, b3)));
  if (c4 === 1)
    throw c4 = sj, Qj(a2, 0), Ii(a2, b3), Mj(a2, O()), c4;
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b3;
  Uj(a2);
  Mj(a2, O());
  return null;
}
function Vj() {
  if (Cj !== null) {
    var a2 = Cj;
    Cj = null;
    a2.forEach(function(a3) {
      a3.expiredLanes |= 24 & a3.pendingLanes;
      Mj(a3, O());
    });
  }
  ig();
}
function Wj(a2, b3) {
  var c4 = X;
  X |= 1;
  try {
    return a2(b3);
  } finally {
    X = c4, X === 0 && (wj(), ig());
  }
}
function Xj(a2, b3) {
  var c4 = X;
  X &= -2;
  X |= 8;
  try {
    return a2(b3);
  } finally {
    X = c4, X === 0 && (wj(), ig());
  }
}
function ni(a2, b3) {
  I(rj, qj);
  qj |= b3;
  tj |= b3;
}
function Ki() {
  qj = rj.current;
  H(rj);
}
function Qj(a2, b3) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c4 = a2.timeoutHandle;
  c4 !== -1 && (a2.timeoutHandle = -1, pf(c4));
  if (Y !== null)
    for (c4 = Y.return; c4 !== null; ) {
      var d3 = c4;
      switch (d3.tag) {
        case 1:
          d3 = d3.type.childContextTypes;
          d3 !== null && d3 !== void 0 && Gf();
          break;
        case 3:
          fh();
          H(N);
          H(M);
          uh();
          break;
        case 5:
          hh(d3);
          break;
        case 4:
          fh();
          break;
        case 13:
          H(P);
          break;
        case 19:
          H(P);
          break;
        case 10:
          rg(d3);
          break;
        case 23:
        case 24:
          Ki();
      }
      c4 = c4.return;
    }
  U = a2;
  Y = Tg(a2.current, null);
  W = qj = tj = b3;
  V = 0;
  sj = null;
  uj = Hi = Dg = 0;
}
function Sj(a2, b3) {
  do {
    var c4 = Y;
    try {
      qg();
      vh.current = Gh;
      if (yh) {
        for (var d3 = R.memoizedState; d3 !== null; ) {
          var e3 = d3.queue;
          e3 !== null && (e3.pending = null);
          d3 = d3.next;
        }
        yh = false;
      }
      xh = 0;
      T = S = R = null;
      zh = false;
      pj.current = null;
      if (c4 === null || c4.return === null) {
        V = 1;
        sj = b3;
        Y = null;
        break;
      }
      a: {
        var f3 = a2, g3 = c4.return, h3 = c4, k3 = b3;
        b3 = W;
        h3.flags |= 2048;
        h3.firstEffect = h3.lastEffect = null;
        if (k3 !== null && typeof k3 === "object" && typeof k3.then === "function") {
          var l3 = k3;
          if ((h3.mode & 2) === 0) {
            var n4 = h3.alternate;
            n4 ? (h3.updateQueue = n4.updateQueue, h3.memoizedState = n4.memoizedState, h3.lanes = n4.lanes) : (h3.updateQueue = null, h3.memoizedState = null);
          }
          var A3 = (P.current & 1) !== 0, p3 = g3;
          do {
            var C;
            if (C = p3.tag === 13) {
              var x3 = p3.memoizedState;
              if (x3 !== null)
                C = x3.dehydrated !== null ? true : false;
              else {
                var w3 = p3.memoizedProps;
                C = w3.fallback === void 0 ? false : w3.unstable_avoidThisFallback !== true ? true : A3 ? false : true;
              }
            }
            if (C) {
              var z3 = p3.updateQueue;
              if (z3 === null) {
                var u = new Set();
                u.add(l3);
                p3.updateQueue = u;
              } else
                z3.add(l3);
              if ((p3.mode & 2) === 0) {
                p3.flags |= 64;
                h3.flags |= 16384;
                h3.flags &= -2981;
                if (h3.tag === 1)
                  if (h3.alternate === null)
                    h3.tag = 17;
                  else {
                    var t4 = zg(-1, 1);
                    t4.tag = 2;
                    Ag(h3, t4);
                  }
                h3.lanes |= 1;
                break a;
              }
              k3 = void 0;
              h3 = b3;
              var q3 = f3.pingCache;
              q3 === null ? (q3 = f3.pingCache = new Oi(), k3 = new Set(), q3.set(l3, k3)) : (k3 = q3.get(l3), k3 === void 0 && (k3 = new Set(), q3.set(l3, k3)));
              if (!k3.has(h3)) {
                k3.add(h3);
                var v3 = Yj.bind(null, f3, l3, h3);
                l3.then(v3, v3);
              }
              p3.flags |= 4096;
              p3.lanes = b3;
              break a;
            }
            p3 = p3.return;
          } while (p3 !== null);
          k3 = Error((Ra(h3.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
        }
        V !== 5 && (V = 2);
        k3 = Mi(k3, h3);
        p3 = g3;
        do {
          switch (p3.tag) {
            case 3:
              f3 = k3;
              p3.flags |= 4096;
              b3 &= -b3;
              p3.lanes |= b3;
              var J = Pi(p3, f3, b3);
              Bg(p3, J);
              break a;
            case 1:
              f3 = k3;
              var K = p3.type, Q = p3.stateNode;
              if ((p3.flags & 64) === 0 && (typeof K.getDerivedStateFromError === "function" || Q !== null && typeof Q.componentDidCatch === "function" && (Ti === null || !Ti.has(Q)))) {
                p3.flags |= 4096;
                b3 &= -b3;
                p3.lanes |= b3;
                var L = Si(p3, f3, b3);
                Bg(p3, L);
                break a;
              }
          }
          p3 = p3.return;
        } while (p3 !== null);
      }
      Zj(c4);
    } catch (va) {
      b3 = va;
      Y === c4 && c4 !== null && (Y = c4 = c4.return);
      continue;
    }
    break;
  } while (1);
}
function Pj() {
  var a2 = oj.current;
  oj.current = Gh;
  return a2 === null ? Gh : a2;
}
function Tj(a2, b3) {
  var c4 = X;
  X |= 16;
  var d3 = Pj();
  U === a2 && W === b3 || Qj(a2, b3);
  do
    try {
      ak();
      break;
    } catch (e3) {
      Sj(a2, e3);
    }
  while (1);
  qg();
  X = c4;
  oj.current = d3;
  if (Y !== null)
    throw Error(y(261));
  U = null;
  W = 0;
  return V;
}
function ak() {
  for (; Y !== null; )
    bk(Y);
}
function Rj() {
  for (; Y !== null && !Qf(); )
    bk(Y);
}
function bk(a2) {
  var b3 = ck(a2.alternate, a2, qj);
  a2.memoizedProps = a2.pendingProps;
  b3 === null ? Zj(a2) : Y = b3;
  pj.current = null;
}
function Zj(a2) {
  var b3 = a2;
  do {
    var c4 = b3.alternate;
    a2 = b3.return;
    if ((b3.flags & 2048) === 0) {
      c4 = Gi(c4, b3, qj);
      if (c4 !== null) {
        Y = c4;
        return;
      }
      c4 = b3;
      if (c4.tag !== 24 && c4.tag !== 23 || c4.memoizedState === null || (qj & 1073741824) !== 0 || (c4.mode & 4) === 0) {
        for (var d3 = 0, e3 = c4.child; e3 !== null; )
          d3 |= e3.lanes | e3.childLanes, e3 = e3.sibling;
        c4.childLanes = d3;
      }
      a2 !== null && (a2.flags & 2048) === 0 && (a2.firstEffect === null && (a2.firstEffect = b3.firstEffect), b3.lastEffect !== null && (a2.lastEffect !== null && (a2.lastEffect.nextEffect = b3.firstEffect), a2.lastEffect = b3.lastEffect), 1 < b3.flags && (a2.lastEffect !== null ? a2.lastEffect.nextEffect = b3 : a2.firstEffect = b3, a2.lastEffect = b3));
    } else {
      c4 = Li(b3);
      if (c4 !== null) {
        c4.flags &= 2047;
        Y = c4;
        return;
      }
      a2 !== null && (a2.firstEffect = a2.lastEffect = null, a2.flags |= 2048);
    }
    b3 = b3.sibling;
    if (b3 !== null) {
      Y = b3;
      return;
    }
    Y = b3 = a2;
  } while (b3 !== null);
  V === 0 && (V = 5);
}
function Uj(a2) {
  var b3 = eg();
  gg(99, dk.bind(null, a2, b3));
  return null;
}
function dk(a2, b3) {
  do
    Oj();
  while (yj !== null);
  if ((X & 48) !== 0)
    throw Error(y(327));
  var c4 = a2.finishedWork;
  if (c4 === null)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c4 === a2.current)
    throw Error(y(177));
  a2.callbackNode = null;
  var d3 = c4.lanes | c4.childLanes, e3 = d3, f3 = a2.pendingLanes & ~e3;
  a2.pendingLanes = e3;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= e3;
  a2.mutableReadLanes &= e3;
  a2.entangledLanes &= e3;
  e3 = a2.entanglements;
  for (var g3 = a2.eventTimes, h3 = a2.expirationTimes; 0 < f3; ) {
    var k3 = 31 - Vc(f3), l3 = 1 << k3;
    e3[k3] = 0;
    g3[k3] = -1;
    h3[k3] = -1;
    f3 &= ~l3;
  }
  Cj !== null && (d3 & 24) === 0 && Cj.has(a2) && Cj.delete(a2);
  a2 === U && (Y = U = null, W = 0);
  1 < c4.flags ? c4.lastEffect !== null ? (c4.lastEffect.nextEffect = c4, d3 = c4.firstEffect) : d3 = c4 : d3 = c4.firstEffect;
  if (d3 !== null) {
    e3 = X;
    X |= 32;
    pj.current = null;
    kf = fd;
    g3 = Ne();
    if (Oe(g3)) {
      if ("selectionStart" in g3)
        h3 = {start: g3.selectionStart, end: g3.selectionEnd};
      else
        a:
          if (h3 = (h3 = g3.ownerDocument) && h3.defaultView || window, (l3 = h3.getSelection && h3.getSelection()) && l3.rangeCount !== 0) {
            h3 = l3.anchorNode;
            f3 = l3.anchorOffset;
            k3 = l3.focusNode;
            l3 = l3.focusOffset;
            try {
              h3.nodeType, k3.nodeType;
            } catch (va) {
              h3 = null;
              break a;
            }
            var n4 = 0, A3 = -1, p3 = -1, C = 0, x3 = 0, w3 = g3, z3 = null;
            b:
              for (; ; ) {
                for (var u; ; ) {
                  w3 !== h3 || f3 !== 0 && w3.nodeType !== 3 || (A3 = n4 + f3);
                  w3 !== k3 || l3 !== 0 && w3.nodeType !== 3 || (p3 = n4 + l3);
                  w3.nodeType === 3 && (n4 += w3.nodeValue.length);
                  if ((u = w3.firstChild) === null)
                    break;
                  z3 = w3;
                  w3 = u;
                }
                for (; ; ) {
                  if (w3 === g3)
                    break b;
                  z3 === h3 && ++C === f3 && (A3 = n4);
                  z3 === k3 && ++x3 === l3 && (p3 = n4);
                  if ((u = w3.nextSibling) !== null)
                    break;
                  w3 = z3;
                  z3 = w3.parentNode;
                }
                w3 = u;
              }
            h3 = A3 === -1 || p3 === -1 ? null : {start: A3, end: p3};
          } else
            h3 = null;
      h3 = h3 || {start: 0, end: 0};
    } else
      h3 = null;
    lf = {focusedElem: g3, selectionRange: h3};
    fd = false;
    Ij = null;
    Jj = false;
    Z = d3;
    do
      try {
        ek();
      } catch (va) {
        if (Z === null)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (Z !== null);
    Ij = null;
    Z = d3;
    do
      try {
        for (g3 = a2; Z !== null; ) {
          var t4 = Z.flags;
          t4 & 16 && pb(Z.stateNode, "");
          if (t4 & 128) {
            var q3 = Z.alternate;
            if (q3 !== null) {
              var v3 = q3.ref;
              v3 !== null && (typeof v3 === "function" ? v3(null) : v3.current = null);
            }
          }
          switch (t4 & 1038) {
            case 2:
              fj(Z);
              Z.flags &= -3;
              break;
            case 6:
              fj(Z);
              Z.flags &= -3;
              ij(Z.alternate, Z);
              break;
            case 1024:
              Z.flags &= -1025;
              break;
            case 1028:
              Z.flags &= -1025;
              ij(Z.alternate, Z);
              break;
            case 4:
              ij(Z.alternate, Z);
              break;
            case 8:
              h3 = Z;
              cj(g3, h3);
              var J = h3.alternate;
              dj(h3);
              J !== null && dj(J);
          }
          Z = Z.nextEffect;
        }
      } catch (va) {
        if (Z === null)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (Z !== null);
    v3 = lf;
    q3 = Ne();
    t4 = v3.focusedElem;
    g3 = v3.selectionRange;
    if (q3 !== t4 && t4 && t4.ownerDocument && Me(t4.ownerDocument.documentElement, t4)) {
      g3 !== null && Oe(t4) && (q3 = g3.start, v3 = g3.end, v3 === void 0 && (v3 = q3), "selectionStart" in t4 ? (t4.selectionStart = q3, t4.selectionEnd = Math.min(v3, t4.value.length)) : (v3 = (q3 = t4.ownerDocument || document) && q3.defaultView || window, v3.getSelection && (v3 = v3.getSelection(), h3 = t4.textContent.length, J = Math.min(g3.start, h3), g3 = g3.end === void 0 ? J : Math.min(g3.end, h3), !v3.extend && J > g3 && (h3 = g3, g3 = J, J = h3), h3 = Le(t4, J), f3 = Le(t4, g3), h3 && f3 && (v3.rangeCount !== 1 || v3.anchorNode !== h3.node || v3.anchorOffset !== h3.offset || v3.focusNode !== f3.node || v3.focusOffset !== f3.offset) && (q3 = q3.createRange(), q3.setStart(h3.node, h3.offset), v3.removeAllRanges(), J > g3 ? (v3.addRange(q3), v3.extend(f3.node, f3.offset)) : (q3.setEnd(f3.node, f3.offset), v3.addRange(q3))))));
      q3 = [];
      for (v3 = t4; v3 = v3.parentNode; )
        v3.nodeType === 1 && q3.push({element: v3, left: v3.scrollLeft, top: v3.scrollTop});
      typeof t4.focus === "function" && t4.focus();
      for (t4 = 0; t4 < q3.length; t4++)
        v3 = q3[t4], v3.element.scrollLeft = v3.left, v3.element.scrollTop = v3.top;
    }
    fd = !!kf;
    lf = kf = null;
    a2.current = c4;
    Z = d3;
    do
      try {
        for (t4 = a2; Z !== null; ) {
          var K = Z.flags;
          K & 36 && Yi(t4, Z.alternate, Z);
          if (K & 128) {
            q3 = void 0;
            var Q = Z.ref;
            if (Q !== null) {
              var L = Z.stateNode;
              switch (Z.tag) {
                case 5:
                  q3 = L;
                  break;
                default:
                  q3 = L;
              }
              typeof Q === "function" ? Q(q3) : Q.current = q3;
            }
          }
          Z = Z.nextEffect;
        }
      } catch (va) {
        if (Z === null)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (Z !== null);
    Z = null;
    $f();
    X = e3;
  } else
    a2.current = c4;
  if (xj)
    xj = false, yj = a2, zj = b3;
  else
    for (Z = d3; Z !== null; )
      b3 = Z.nextEffect, Z.nextEffect = null, Z.flags & 8 && (K = Z, K.sibling = null, K.stateNode = null), Z = b3;
  d3 = a2.pendingLanes;
  d3 === 0 && (Ti = null);
  d3 === 1 ? a2 === Ej ? Dj++ : (Dj = 0, Ej = a2) : Dj = 0;
  c4 = c4.stateNode;
  if (Mf && typeof Mf.onCommitFiberRoot === "function")
    try {
      Mf.onCommitFiberRoot(Lf, c4, void 0, (c4.current.flags & 64) === 64);
    } catch (va) {
    }
  Mj(a2, O());
  if (Qi)
    throw Qi = false, a2 = Ri, Ri = null, a2;
  if ((X & 8) !== 0)
    return null;
  ig();
  return null;
}
function ek() {
  for (; Z !== null; ) {
    var a2 = Z.alternate;
    Jj || Ij === null || ((Z.flags & 8) !== 0 ? dc(Z, Ij) && (Jj = true) : Z.tag === 13 && mj(a2, Z) && dc(Z, Ij) && (Jj = true));
    var b3 = Z.flags;
    (b3 & 256) !== 0 && Xi(a2, Z);
    (b3 & 512) === 0 || xj || (xj = true, hg(97, function() {
      Oj();
      return null;
    }));
    Z = Z.nextEffect;
  }
}
function Oj() {
  if (zj !== 90) {
    var a2 = 97 < zj ? 97 : zj;
    zj = 90;
    return gg(a2, fk);
  }
  return false;
}
function $i(a2, b3) {
  Aj.push(b3, a2);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function Zi(a2, b3) {
  Bj.push(b3, a2);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function fk() {
  if (yj === null)
    return false;
  var a2 = yj;
  yj = null;
  if ((X & 48) !== 0)
    throw Error(y(331));
  var b3 = X;
  X |= 32;
  var c4 = Bj;
  Bj = [];
  for (var d3 = 0; d3 < c4.length; d3 += 2) {
    var e3 = c4[d3], f3 = c4[d3 + 1], g3 = e3.destroy;
    e3.destroy = void 0;
    if (typeof g3 === "function")
      try {
        g3();
      } catch (k3) {
        if (f3 === null)
          throw Error(y(330));
        Wi(f3, k3);
      }
  }
  c4 = Aj;
  Aj = [];
  for (d3 = 0; d3 < c4.length; d3 += 2) {
    e3 = c4[d3];
    f3 = c4[d3 + 1];
    try {
      var h3 = e3.create;
      e3.destroy = h3();
    } catch (k3) {
      if (f3 === null)
        throw Error(y(330));
      Wi(f3, k3);
    }
  }
  for (h3 = a2.current.firstEffect; h3 !== null; )
    a2 = h3.nextEffect, h3.nextEffect = null, h3.flags & 8 && (h3.sibling = null, h3.stateNode = null), h3 = a2;
  X = b3;
  ig();
  return true;
}
function gk(a2, b3, c4) {
  b3 = Mi(c4, b3);
  b3 = Pi(a2, b3, 1);
  Ag(a2, b3);
  b3 = Hg();
  a2 = Kj(a2, 1);
  a2 !== null && ($c(a2, 1, b3), Mj(a2, b3));
}
function Wi(a2, b3) {
  if (a2.tag === 3)
    gk(a2, a2, b3);
  else
    for (var c4 = a2.return; c4 !== null; ) {
      if (c4.tag === 3) {
        gk(c4, a2, b3);
        break;
      } else if (c4.tag === 1) {
        var d3 = c4.stateNode;
        if (typeof c4.type.getDerivedStateFromError === "function" || typeof d3.componentDidCatch === "function" && (Ti === null || !Ti.has(d3))) {
          a2 = Mi(b3, a2);
          var e3 = Si(c4, a2, 1);
          Ag(c4, e3);
          e3 = Hg();
          c4 = Kj(c4, 1);
          if (c4 !== null)
            $c(c4, 1, e3), Mj(c4, e3);
          else if (typeof d3.componentDidCatch === "function" && (Ti === null || !Ti.has(d3)))
            try {
              d3.componentDidCatch(b3, a2);
            } catch (f3) {
            }
          break;
        }
      }
      c4 = c4.return;
    }
}
function Yj(a2, b3, c4) {
  var d3 = a2.pingCache;
  d3 !== null && d3.delete(b3);
  b3 = Hg();
  a2.pingedLanes |= a2.suspendedLanes & c4;
  U === a2 && (W & c4) === c4 && (V === 4 || V === 3 && (W & 62914560) === W && 500 > O() - jj ? Qj(a2, 0) : uj |= c4);
  Mj(a2, b3);
}
function lj(a2, b3) {
  var c4 = a2.stateNode;
  c4 !== null && c4.delete(b3);
  b3 = 0;
  b3 === 0 && (b3 = a2.mode, (b3 & 2) === 0 ? b3 = 1 : (b3 & 4) === 0 ? b3 = eg() === 99 ? 1 : 2 : (Gj === 0 && (Gj = tj), b3 = Yc(62914560 & ~Gj), b3 === 0 && (b3 = 4194304)));
  c4 = Hg();
  a2 = Kj(a2, b3);
  a2 !== null && ($c(a2, b3, c4), Mj(a2, c4));
}
var ck;
ck = function(a2, b3, c4) {
  var d3 = b3.lanes;
  if (a2 !== null)
    if (a2.memoizedProps !== b3.pendingProps || N.current)
      ug = true;
    else if ((c4 & d3) !== 0)
      ug = (a2.flags & 16384) !== 0 ? true : false;
    else {
      ug = false;
      switch (b3.tag) {
        case 3:
          ri(b3);
          sh();
          break;
        case 5:
          gh(b3);
          break;
        case 1:
          Ff(b3.type) && Jf(b3);
          break;
        case 4:
          eh(b3, b3.stateNode.containerInfo);
          break;
        case 10:
          d3 = b3.memoizedProps.value;
          var e3 = b3.type._context;
          I(mg, e3._currentValue);
          e3._currentValue = d3;
          break;
        case 13:
          if (b3.memoizedState !== null) {
            if ((c4 & b3.child.childLanes) !== 0)
              return ti(a2, b3, c4);
            I(P, P.current & 1);
            b3 = hi(a2, b3, c4);
            return b3 !== null ? b3.sibling : null;
          }
          I(P, P.current & 1);
          break;
        case 19:
          d3 = (c4 & b3.childLanes) !== 0;
          if ((a2.flags & 64) !== 0) {
            if (d3)
              return Ai(a2, b3, c4);
            b3.flags |= 64;
          }
          e3 = b3.memoizedState;
          e3 !== null && (e3.rendering = null, e3.tail = null, e3.lastEffect = null);
          I(P, P.current);
          if (d3)
            break;
          else
            return null;
        case 23:
        case 24:
          return b3.lanes = 0, mi(a2, b3, c4);
      }
      return hi(a2, b3, c4);
    }
  else
    ug = false;
  b3.lanes = 0;
  switch (b3.tag) {
    case 2:
      d3 = b3.type;
      a2 !== null && (a2.alternate = null, b3.alternate = null, b3.flags |= 2);
      a2 = b3.pendingProps;
      e3 = Ef(b3, M.current);
      tg(b3, c4);
      e3 = Ch(null, b3, d3, a2, e3, c4);
      b3.flags |= 1;
      if (typeof e3 === "object" && e3 !== null && typeof e3.render === "function" && e3.$$typeof === void 0) {
        b3.tag = 1;
        b3.memoizedState = null;
        b3.updateQueue = null;
        if (Ff(d3)) {
          var f3 = true;
          Jf(b3);
        } else
          f3 = false;
        b3.memoizedState = e3.state !== null && e3.state !== void 0 ? e3.state : null;
        xg(b3);
        var g3 = d3.getDerivedStateFromProps;
        typeof g3 === "function" && Gg(b3, d3, g3, a2);
        e3.updater = Kg;
        b3.stateNode = e3;
        e3._reactInternals = b3;
        Og(b3, d3, a2, c4);
        b3 = qi(null, b3, d3, true, f3, c4);
      } else
        b3.tag = 0, fi(null, b3, e3, c4), b3 = b3.child;
      return b3;
    case 16:
      e3 = b3.elementType;
      a: {
        a2 !== null && (a2.alternate = null, b3.alternate = null, b3.flags |= 2);
        a2 = b3.pendingProps;
        f3 = e3._init;
        e3 = f3(e3._payload);
        b3.type = e3;
        f3 = b3.tag = hk(e3);
        a2 = lg(e3, a2);
        switch (f3) {
          case 0:
            b3 = li(null, b3, e3, a2, c4);
            break a;
          case 1:
            b3 = pi(null, b3, e3, a2, c4);
            break a;
          case 11:
            b3 = gi(null, b3, e3, a2, c4);
            break a;
          case 14:
            b3 = ii(null, b3, e3, lg(e3.type, a2), d3, c4);
            break a;
        }
        throw Error(y(306, e3, ""));
      }
      return b3;
    case 0:
      return d3 = b3.type, e3 = b3.pendingProps, e3 = b3.elementType === d3 ? e3 : lg(d3, e3), li(a2, b3, d3, e3, c4);
    case 1:
      return d3 = b3.type, e3 = b3.pendingProps, e3 = b3.elementType === d3 ? e3 : lg(d3, e3), pi(a2, b3, d3, e3, c4);
    case 3:
      ri(b3);
      d3 = b3.updateQueue;
      if (a2 === null || d3 === null)
        throw Error(y(282));
      d3 = b3.pendingProps;
      e3 = b3.memoizedState;
      e3 = e3 !== null ? e3.element : null;
      yg(a2, b3);
      Cg(b3, d3, null, c4);
      d3 = b3.memoizedState.element;
      if (d3 === e3)
        sh(), b3 = hi(a2, b3, c4);
      else {
        e3 = b3.stateNode;
        if (f3 = e3.hydrate)
          kh = rf(b3.stateNode.containerInfo.firstChild), jh = b3, f3 = lh = true;
        if (f3) {
          a2 = e3.mutableSourceEagerHydrationData;
          if (a2 != null)
            for (e3 = 0; e3 < a2.length; e3 += 2)
              f3 = a2[e3], f3._workInProgressVersionPrimary = a2[e3 + 1], th.push(f3);
          c4 = Zg(b3, null, d3, c4);
          for (b3.child = c4; c4; )
            c4.flags = c4.flags & -3 | 1024, c4 = c4.sibling;
        } else
          fi(a2, b3, d3, c4), sh();
        b3 = b3.child;
      }
      return b3;
    case 5:
      return gh(b3), a2 === null && ph(b3), d3 = b3.type, e3 = b3.pendingProps, f3 = a2 !== null ? a2.memoizedProps : null, g3 = e3.children, nf(d3, e3) ? g3 = null : f3 !== null && nf(d3, f3) && (b3.flags |= 16), oi(a2, b3), fi(a2, b3, g3, c4), b3.child;
    case 6:
      return a2 === null && ph(b3), null;
    case 13:
      return ti(a2, b3, c4);
    case 4:
      return eh(b3, b3.stateNode.containerInfo), d3 = b3.pendingProps, a2 === null ? b3.child = Yg(b3, null, d3, c4) : fi(a2, b3, d3, c4), b3.child;
    case 11:
      return d3 = b3.type, e3 = b3.pendingProps, e3 = b3.elementType === d3 ? e3 : lg(d3, e3), gi(a2, b3, d3, e3, c4);
    case 7:
      return fi(a2, b3, b3.pendingProps, c4), b3.child;
    case 8:
      return fi(a2, b3, b3.pendingProps.children, c4), b3.child;
    case 12:
      return fi(a2, b3, b3.pendingProps.children, c4), b3.child;
    case 10:
      a: {
        d3 = b3.type._context;
        e3 = b3.pendingProps;
        g3 = b3.memoizedProps;
        f3 = e3.value;
        var h3 = b3.type._context;
        I(mg, h3._currentValue);
        h3._currentValue = f3;
        if (g3 !== null)
          if (h3 = g3.value, f3 = He(h3, f3) ? 0 : (typeof d3._calculateChangedBits === "function" ? d3._calculateChangedBits(h3, f3) : 1073741823) | 0, f3 === 0) {
            if (g3.children === e3.children && !N.current) {
              b3 = hi(a2, b3, c4);
              break a;
            }
          } else
            for (h3 = b3.child, h3 !== null && (h3.return = b3); h3 !== null; ) {
              var k3 = h3.dependencies;
              if (k3 !== null) {
                g3 = h3.child;
                for (var l3 = k3.firstContext; l3 !== null; ) {
                  if (l3.context === d3 && (l3.observedBits & f3) !== 0) {
                    h3.tag === 1 && (l3 = zg(-1, c4 & -c4), l3.tag = 2, Ag(h3, l3));
                    h3.lanes |= c4;
                    l3 = h3.alternate;
                    l3 !== null && (l3.lanes |= c4);
                    sg(h3.return, c4);
                    k3.lanes |= c4;
                    break;
                  }
                  l3 = l3.next;
                }
              } else
                g3 = h3.tag === 10 ? h3.type === b3.type ? null : h3.child : h3.child;
              if (g3 !== null)
                g3.return = h3;
              else
                for (g3 = h3; g3 !== null; ) {
                  if (g3 === b3) {
                    g3 = null;
                    break;
                  }
                  h3 = g3.sibling;
                  if (h3 !== null) {
                    h3.return = g3.return;
                    g3 = h3;
                    break;
                  }
                  g3 = g3.return;
                }
              h3 = g3;
            }
        fi(a2, b3, e3.children, c4);
        b3 = b3.child;
      }
      return b3;
    case 9:
      return e3 = b3.type, f3 = b3.pendingProps, d3 = f3.children, tg(b3, c4), e3 = vg(e3, f3.unstable_observedBits), d3 = d3(e3), b3.flags |= 1, fi(a2, b3, d3, c4), b3.child;
    case 14:
      return e3 = b3.type, f3 = lg(e3, b3.pendingProps), f3 = lg(e3.type, f3), ii(a2, b3, e3, f3, d3, c4);
    case 15:
      return ki(a2, b3, b3.type, b3.pendingProps, d3, c4);
    case 17:
      return d3 = b3.type, e3 = b3.pendingProps, e3 = b3.elementType === d3 ? e3 : lg(d3, e3), a2 !== null && (a2.alternate = null, b3.alternate = null, b3.flags |= 2), b3.tag = 1, Ff(d3) ? (a2 = true, Jf(b3)) : a2 = false, tg(b3, c4), Mg(b3, d3, e3), Og(b3, d3, e3, c4), qi(null, b3, d3, true, a2, c4);
    case 19:
      return Ai(a2, b3, c4);
    case 23:
      return mi(a2, b3, c4);
    case 24:
      return mi(a2, b3, c4);
  }
  throw Error(y(156, b3.tag));
};
function ik(a2, b3, c4, d3) {
  this.tag = a2;
  this.key = c4;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b3;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d3;
  this.flags = 0;
  this.lastEffect = this.firstEffect = this.nextEffect = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function nh(a2, b3, c4, d3) {
  return new ik(a2, b3, c4, d3);
}
function ji(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function hk(a2) {
  if (typeof a2 === "function")
    return ji(a2) ? 1 : 0;
  if (a2 !== void 0 && a2 !== null) {
    a2 = a2.$$typeof;
    if (a2 === Aa)
      return 11;
    if (a2 === Da)
      return 14;
  }
  return 2;
}
function Tg(a2, b3) {
  var c4 = a2.alternate;
  c4 === null ? (c4 = nh(a2.tag, b3, a2.key, a2.mode), c4.elementType = a2.elementType, c4.type = a2.type, c4.stateNode = a2.stateNode, c4.alternate = a2, a2.alternate = c4) : (c4.pendingProps = b3, c4.type = a2.type, c4.flags = 0, c4.nextEffect = null, c4.firstEffect = null, c4.lastEffect = null);
  c4.childLanes = a2.childLanes;
  c4.lanes = a2.lanes;
  c4.child = a2.child;
  c4.memoizedProps = a2.memoizedProps;
  c4.memoizedState = a2.memoizedState;
  c4.updateQueue = a2.updateQueue;
  b3 = a2.dependencies;
  c4.dependencies = b3 === null ? null : {lanes: b3.lanes, firstContext: b3.firstContext};
  c4.sibling = a2.sibling;
  c4.index = a2.index;
  c4.ref = a2.ref;
  return c4;
}
function Vg(a2, b3, c4, d3, e3, f3) {
  var g3 = 2;
  d3 = a2;
  if (typeof a2 === "function")
    ji(a2) && (g3 = 1);
  else if (typeof a2 === "string")
    g3 = 5;
  else
    a:
      switch (a2) {
        case ua:
          return Xg(c4.children, e3, f3, b3);
        case Ha:
          g3 = 8;
          e3 |= 16;
          break;
        case wa:
          g3 = 8;
          e3 |= 1;
          break;
        case xa:
          return a2 = nh(12, c4, b3, e3 | 8), a2.elementType = xa, a2.type = xa, a2.lanes = f3, a2;
        case Ba:
          return a2 = nh(13, c4, b3, e3), a2.type = Ba, a2.elementType = Ba, a2.lanes = f3, a2;
        case Ca:
          return a2 = nh(19, c4, b3, e3), a2.elementType = Ca, a2.lanes = f3, a2;
        case Ia:
          return vi(c4, e3, f3, b3);
        case Ja:
          return a2 = nh(24, c4, b3, e3), a2.elementType = Ja, a2.lanes = f3, a2;
        default:
          if (typeof a2 === "object" && a2 !== null)
            switch (a2.$$typeof) {
              case ya:
                g3 = 10;
                break a;
              case za:
                g3 = 9;
                break a;
              case Aa:
                g3 = 11;
                break a;
              case Da:
                g3 = 14;
                break a;
              case Ea:
                g3 = 16;
                d3 = null;
                break a;
              case Fa:
                g3 = 22;
                break a;
            }
          throw Error(y(130, a2 == null ? a2 : typeof a2, ""));
      }
  b3 = nh(g3, c4, b3, e3);
  b3.elementType = a2;
  b3.type = d3;
  b3.lanes = f3;
  return b3;
}
function Xg(a2, b3, c4, d3) {
  a2 = nh(7, a2, d3, b3);
  a2.lanes = c4;
  return a2;
}
function vi(a2, b3, c4, d3) {
  a2 = nh(23, a2, d3, b3);
  a2.elementType = Ia;
  a2.lanes = c4;
  return a2;
}
function Ug(a2, b3, c4) {
  a2 = nh(6, a2, null, b3);
  a2.lanes = c4;
  return a2;
}
function Wg(a2, b3, c4) {
  b3 = nh(4, a2.children !== null ? a2.children : [], a2.key, b3);
  b3.lanes = c4;
  b3.stateNode = {containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation};
  return b3;
}
function jk(a2, b3, c4) {
  this.tag = b3;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.pendingContext = this.context = null;
  this.hydrate = c4;
  this.callbackNode = null;
  this.callbackPriority = 0;
  this.eventTimes = Zc(0);
  this.expirationTimes = Zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = Zc(0);
  this.mutableSourceEagerHydrationData = null;
}
function kk(a2, b3, c4) {
  var d3 = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {$$typeof: ta, key: d3 == null ? null : "" + d3, children: a2, containerInfo: b3, implementation: c4};
}
function lk(a2, b3, c4, d3) {
  var e3 = b3.current, f3 = Hg(), g3 = Ig(e3);
  a:
    if (c4) {
      c4 = c4._reactInternals;
      b: {
        if (Zb(c4) !== c4 || c4.tag !== 1)
          throw Error(y(170));
        var h3 = c4;
        do {
          switch (h3.tag) {
            case 3:
              h3 = h3.stateNode.context;
              break b;
            case 1:
              if (Ff(h3.type)) {
                h3 = h3.stateNode.__reactInternalMemoizedMergedChildContext;
                break b;
              }
          }
          h3 = h3.return;
        } while (h3 !== null);
        throw Error(y(171));
      }
      if (c4.tag === 1) {
        var k3 = c4.type;
        if (Ff(k3)) {
          c4 = If(c4, k3, h3);
          break a;
        }
      }
      c4 = h3;
    } else
      c4 = Cf;
  b3.context === null ? b3.context = c4 : b3.pendingContext = c4;
  b3 = zg(f3, g3);
  b3.payload = {element: a2};
  d3 = d3 === void 0 ? null : d3;
  d3 !== null && (b3.callback = d3);
  Ag(e3, b3);
  Jg(e3, g3, f3);
  return g3;
}
function mk(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function nk(a2, b3) {
  a2 = a2.memoizedState;
  if (a2 !== null && a2.dehydrated !== null) {
    var c4 = a2.retryLane;
    a2.retryLane = c4 !== 0 && c4 < b3 ? c4 : b3;
  }
}
function ok(a2, b3) {
  nk(a2, b3);
  (a2 = a2.alternate) && nk(a2, b3);
}
function pk() {
  return null;
}
function qk(a2, b3, c4) {
  var d3 = c4 != null && c4.hydrationOptions != null && c4.hydrationOptions.mutableSources || null;
  c4 = new jk(a2, b3, c4 != null && c4.hydrate === true);
  b3 = nh(3, null, null, b3 === 2 ? 7 : b3 === 1 ? 3 : 0);
  c4.current = b3;
  b3.stateNode = c4;
  xg(b3);
  a2[ff] = c4.current;
  cf(a2.nodeType === 8 ? a2.parentNode : a2);
  if (d3)
    for (a2 = 0; a2 < d3.length; a2++) {
      b3 = d3[a2];
      var e3 = b3._getVersion;
      e3 = e3(b3._source);
      c4.mutableSourceEagerHydrationData == null ? c4.mutableSourceEagerHydrationData = [b3, e3] : c4.mutableSourceEagerHydrationData.push(b3, e3);
    }
  this._internalRoot = c4;
}
qk.prototype.render = function(a2) {
  lk(a2, this._internalRoot, null, null);
};
qk.prototype.unmount = function() {
  var a2 = this._internalRoot, b3 = a2.containerInfo;
  lk(null, a2, null, function() {
    b3[ff] = null;
  });
};
function rk(a2) {
  return !(!a2 || a2.nodeType !== 1 && a2.nodeType !== 9 && a2.nodeType !== 11 && (a2.nodeType !== 8 || a2.nodeValue !== " react-mount-point-unstable "));
}
function sk(a2, b3) {
  b3 || (b3 = a2 ? a2.nodeType === 9 ? a2.documentElement : a2.firstChild : null, b3 = !(!b3 || b3.nodeType !== 1 || !b3.hasAttribute("data-reactroot")));
  if (!b3)
    for (var c4; c4 = a2.lastChild; )
      a2.removeChild(c4);
  return new qk(a2, 0, b3 ? {hydrate: true} : void 0);
}
function tk(a2, b3, c4, d3, e3) {
  var f3 = c4._reactRootContainer;
  if (f3) {
    var g3 = f3._internalRoot;
    if (typeof e3 === "function") {
      var h3 = e3;
      e3 = function() {
        var a3 = mk(g3);
        h3.call(a3);
      };
    }
    lk(b3, g3, a2, e3);
  } else {
    f3 = c4._reactRootContainer = sk(c4, d3);
    g3 = f3._internalRoot;
    if (typeof e3 === "function") {
      var k3 = e3;
      e3 = function() {
        var a3 = mk(g3);
        k3.call(a3);
      };
    }
    Xj(function() {
      lk(b3, g3, a2, e3);
    });
  }
  return mk(g3);
}
ec = function(a2) {
  if (a2.tag === 13) {
    var b3 = Hg();
    Jg(a2, 4, b3);
    ok(a2, 4);
  }
};
fc = function(a2) {
  if (a2.tag === 13) {
    var b3 = Hg();
    Jg(a2, 67108864, b3);
    ok(a2, 67108864);
  }
};
gc = function(a2) {
  if (a2.tag === 13) {
    var b3 = Hg(), c4 = Ig(a2);
    Jg(a2, c4, b3);
    ok(a2, c4);
  }
};
hc = function(a2, b3) {
  return b3();
};
yb = function(a2, b3, c4) {
  switch (b3) {
    case "input":
      ab(a2, c4);
      b3 = c4.name;
      if (c4.type === "radio" && b3 != null) {
        for (c4 = a2; c4.parentNode; )
          c4 = c4.parentNode;
        c4 = c4.querySelectorAll("input[name=" + JSON.stringify("" + b3) + '][type="radio"]');
        for (b3 = 0; b3 < c4.length; b3++) {
          var d3 = c4[b3];
          if (d3 !== a2 && d3.form === a2.form) {
            var e3 = Db(d3);
            if (!e3)
              throw Error(y(90));
            Wa(d3);
            ab(d3, e3);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c4);
      break;
    case "select":
      b3 = c4.value, b3 != null && fb(a2, !!c4.multiple, b3, false);
  }
};
Gb = Wj;
Hb = function(a2, b3, c4, d3, e3) {
  var f3 = X;
  X |= 4;
  try {
    return gg(98, a2.bind(null, b3, c4, d3, e3));
  } finally {
    X = f3, X === 0 && (wj(), ig());
  }
};
Ib = function() {
  (X & 49) === 0 && (Vj(), Oj());
};
Jb = function(a2, b3) {
  var c4 = X;
  X |= 2;
  try {
    return a2(b3);
  } finally {
    X = c4, X === 0 && (wj(), ig());
  }
};
function uk(a2, b3) {
  var c4 = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!rk(b3))
    throw Error(y(200));
  return kk(a2, b3, null, c4);
}
var vk = {Events: [Cb, ue, Db, Eb, Fb, Oj, {current: false}]};
var wk = {findFiberByHostInstance: wc, bundleType: 0, version: "17.0.2", rendererPackageName: "react-dom"};
var xk = {bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = cc(a2);
  return a2 === null ? null : a2.stateNode;
}, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined") {
  yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!yk.isDisabled && yk.supportsFiber)
    try {
      Lf = yk.inject(xk), Mf = yk;
    } catch (a2) {
    }
}
var yk;
var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
var createPortal = uk;
var findDOMNode = function(a2) {
  if (a2 == null)
    return null;
  if (a2.nodeType === 1)
    return a2;
  var b3 = a2._reactInternals;
  if (b3 === void 0) {
    if (typeof a2.render === "function")
      throw Error(y(188));
    throw Error(y(268, Object.keys(a2)));
  }
  a2 = cc(b3);
  a2 = a2 === null ? null : a2.stateNode;
  return a2;
};
var flushSync = function(a2, b3) {
  var c4 = X;
  if ((c4 & 48) !== 0)
    return a2(b3);
  X |= 1;
  try {
    if (a2)
      return gg(99, a2.bind(null, b3));
  } finally {
    X = c4, ig();
  }
};
var hydrate = function(a2, b3, c4) {
  if (!rk(b3))
    throw Error(y(200));
  return tk(null, a2, b3, true, c4);
};
var render = function(a2, b3, c4) {
  if (!rk(b3))
    throw Error(y(200));
  return tk(null, a2, b3, false, c4);
};
var unmountComponentAtNode = function(a2) {
  if (!rk(a2))
    throw Error(y(40));
  return a2._reactRootContainer ? (Xj(function() {
    tk(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[ff] = null;
    });
  }), true) : false;
};
var unstable_batchedUpdates = Wj;
var unstable_createPortal = function(a2, b3) {
  return uk(a2, b3, 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null);
};
var unstable_renderSubtreeIntoContainer = function(a2, b3, c4, d3) {
  if (!rk(c4))
    throw Error(y(200));
  if (a2 == null || a2._reactInternals === void 0)
    throw Error(y(38));
  return tk(a2, b3, c4, false, d3);
};
var version = "17.0.2";
var reactDom_production_min = {
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  createPortal,
  findDOMNode,
  flushSync,
  hydrate,
  render,
  unmountComponentAtNode,
  unstable_batchedUpdates,
  unstable_createPortal,
  unstable_renderSubtreeIntoContainer,
  version
};
var reactDom = createCommonjsModule(function(module2) {
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    module2.exports = reactDom_production_min;
  }
});

// build/_snowpack/pkg/common/check-icon-0517e9a2.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __rest(s2, e3) {
  var t4 = {};
  for (var p3 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p3) && e3.indexOf(p3) < 0)
      t4[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s2); i3 < p3.length; i3++) {
      if (e3.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i3]))
        t4[p3[i3]] = s2[p3[i3]];
    }
  return t4;
}
var IconSize;
(function(IconSize2) {
  IconSize2["sm"] = "sm";
  IconSize2["md"] = "md";
  IconSize2["lg"] = "lg";
  IconSize2["xl"] = "xl";
})(IconSize || (IconSize = {}));
var getSize = (size2) => {
  switch (size2) {
    case IconSize.sm:
      return "1em";
    case IconSize.md:
      return "1.5em";
    case IconSize.lg:
      return "2em";
    case IconSize.xl:
      return "3em";
    default:
      return "1em";
  }
};
var currentId = 0;
function createIcon({name, xOffset = 0, yOffset = 0, width: width2, height, svgPath}) {
  var _a;
  return _a = class SVGIcon extends react.Component {
    constructor() {
      super(...arguments);
      this.id = `icon-title-${currentId++}`;
    }
    render() {
      const _a2 = this.props, {size: size2, color: color2, title: title3, noVerticalAlign} = _a2, props = __rest(_a2, ["size", "color", "title", "noVerticalAlign"]);
      const hasTitle = Boolean(title3);
      const heightWidth = getSize(size2);
      const baseAlign = -0.125 * Number.parseFloat(heightWidth);
      const style = noVerticalAlign ? null : {verticalAlign: `${baseAlign}em`};
      const viewBox = [xOffset, yOffset, width2, height].join(" ");
      return react.createElement("svg", Object.assign({style, fill: color2, height: heightWidth, width: heightWidth, viewBox, "aria-labelledby": hasTitle ? this.id : null, "aria-hidden": hasTitle ? null : true, role: "img"}, props), hasTitle && react.createElement("title", {id: this.id}, title3), react.createElement("path", {d: svgPath}));
    }
  }, _a.displayName = name, _a.defaultProps = {
    color: "currentColor",
    size: IconSize.sm,
    noVerticalAlign: false
  }, _a;
}
var CheckIconConfig = {
  name: "CheckIcon",
  height: 512,
  width: 512,
  svgPath: "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z",
  yOffset: 0,
  xOffset: 0
};
var CheckIcon = createIcon(CheckIconConfig);

// build/_snowpack/pkg/common/inline-edit-7e762ccb.js
function css(...args) {
  const classes = [];
  const hasOwn = {}.hasOwnProperty;
  args.filter(Boolean).forEach((arg) => {
    const argType = typeof arg;
    if (argType === "string" || argType === "number") {
      classes.push(arg);
    } else if (Array.isArray(arg) && arg.length) {
      const inner = css(...arg);
      if (inner) {
        classes.push(inner);
      }
    } else if (argType === "object") {
      for (const key in arg) {
        if (hasOwn.call(arg, key) && arg[key]) {
          classes.push(key);
        }
      }
    }
  });
  return classes.join(" ");
}
var KEY_CODES = {ARROW_UP: 38, ARROW_DOWN: 40, ESCAPE_KEY: 27, TAB: 9, ENTER: 13, SPACE: 32};
var KEYHANDLER_DIRECTION = {UP: "up", DOWN: "down", RIGHT: "right", LEFT: "left"};
var ValidatedOptions;
(function(ValidatedOptions2) {
  ValidatedOptions2["success"] = "success";
  ValidatedOptions2["error"] = "error";
  ValidatedOptions2["warning"] = "warning";
  ValidatedOptions2["default"] = "default";
})(ValidatedOptions || (ValidatedOptions = {}));
/*!
* tabbable 5.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
var matches = typeof Element === "undefined" ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getCandidates = function getCandidates2(el, includeContainer, filter3) {
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter3);
  return candidates;
};
var isContentEditable = function isContentEditable2(node) {
  return node.contentEditable === "true";
};
var getTabindex = function getTabindex2(node) {
  var tabindexAttr = parseInt(node.getAttribute("tabindex"), 10);
  if (!isNaN(tabindexAttr)) {
    return tabindexAttr;
  }
  if (isContentEditable(node)) {
    return 0;
  }
  if ((node.nodeName === "AUDIO" || node.nodeName === "VIDEO" || node.nodeName === "DETAILS") && node.getAttribute("tabindex") === null) {
    return 0;
  }
  return node.tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a2, b3) {
  return a2.tabIndex === b3.tabIndex ? a2.documentOrder - b3.documentOrder : a2.tabIndex - b3.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r4 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r4;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form2) {
  for (var i3 = 0; i3 < nodes.length; i3++) {
    if (nodes[i3].checked && nodes[i3].form === form2) {
      return nodes[i3];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || node.ownerDocument;
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isHidden = function isHidden2(node, displayCheck) {
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full") {
    while (node) {
      if (getComputedStyle(node).display === "none") {
        return true;
      }
      node = node.parentElement;
    }
  } else if (displayCheck === "non-zero-area") {
    var _node$getBoundingClie = node.getBoundingClientRect(), width2 = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
    return width2 === 0 && height === 0;
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || isHiddenInput(node) || isHidden(node, options.displayCheck) || isDetailsWithSummary(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (!isNodeMatchingSelectorFocusable(options, node) || isNonTabbableRadio(node) || getTabindex(node) < 0) {
    return false;
  }
  return true;
};
var tabbable = function tabbable2(el, options) {
  options = options || {};
  var regularTabbables = [];
  var orderedTabbables = [];
  var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  candidates.forEach(function(candidate, i3) {
    var candidateTabindex = getTabindex(candidate);
    if (candidateTabindex === 0) {
      regularTabbables.push(candidate);
    } else {
      orderedTabbables.push({
        documentOrder: i3,
        tabIndex: candidateTabindex,
        node: candidate
      });
    }
  });
  var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables).map(function(a2) {
    return a2.node;
  }).concat(regularTabbables);
  return tabbableNodes;
};
var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
var isFocusable = function isFocusable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};
/*!
* focus-trap 6.2.2
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys(Object(source2), true).forEach(function(key) {
        _defineProperty(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
var activeFocusDelay;
var activeFocusTraps = function() {
  var trapQueue = [];
  return {
    activateTrap: function activateTrap(trap) {
      if (trapQueue.length > 0) {
        var activeTrap = trapQueue[trapQueue.length - 1];
        if (activeTrap !== trap) {
          activeTrap.pause();
        }
      }
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex === -1) {
        trapQueue.push(trap);
      } else {
        trapQueue.splice(trapIndex, 1);
        trapQueue.push(trap);
      }
    },
    deactivateTrap: function deactivateTrap(trap) {
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex !== -1) {
        trapQueue.splice(trapIndex, 1);
      }
      if (trapQueue.length > 0) {
        trapQueue[trapQueue.length - 1].unpause();
      }
    }
  };
}();
var isSelectableInput = function isSelectableInput2(node) {
  return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e3) {
  return e3.key === "Escape" || e3.key === "Esc" || e3.keyCode === 27;
};
var isTabEvent = function isTabEvent2(e3) {
  return e3.key === "Tab" || e3.keyCode === 9;
};
var delay = function delay2(fn) {
  return setTimeout(fn, 0);
};
var createFocusTrap = function createFocusTrap2(elements, userOptions) {
  var doc = document;
  var config2 = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true
  }, userOptions);
  var state = {
    containers: [],
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false
  };
  var trap;
  var containersContain = function containersContain2(element) {
    return state.containers.some(function(container) {
      return container.contains(element);
    });
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var optionValue = config2[optionName];
    if (!optionValue) {
      return null;
    }
    var node = optionValue;
    if (typeof optionValue === "string") {
      node = doc.querySelector(optionValue);
      if (!node) {
        throw new Error("`".concat(optionName, "` refers to no known node"));
      }
    }
    if (typeof optionValue === "function") {
      node = optionValue();
      if (!node) {
        throw new Error("`".concat(optionName, "` did not return a node"));
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node;
    if (getNodeForOption("initialFocus") !== null) {
      node = getNodeForOption("initialFocus");
    } else if (containersContain(doc.activeElement)) {
      node = doc.activeElement;
    } else {
      var firstTabbableGroup = state.tabbableGroups[0];
      var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
      node = firstTabbableNode || getNodeForOption("fallbackFocus");
    }
    if (!node) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state.tabbableGroups = state.containers.map(function(container) {
      var tabbableNodes = tabbable(container);
      if (tabbableNodes.length > 0) {
        return {
          firstTabbableNode: tabbableNodes[0],
          lastTabbableNode: tabbableNodes[tabbableNodes.length - 1]
        };
      }
      return void 0;
    }).filter(function(group) {
      return !!group;
    });
    if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
  };
  var tryFocus = function tryFocus2(node) {
    if (node === doc.activeElement) {
      return;
    }
    if (!node || !node.focus) {
      tryFocus2(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config2.preventScroll
    });
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node = getNodeForOption("setReturnFocus");
    return node ? node : previousActiveElement;
  };
  var checkPointerDown = function checkPointerDown2(e3) {
    if (containersContain(e3.target)) {
      return;
    }
    if (config2.clickOutsideDeactivates) {
      trap.deactivate({
        returnFocus: config2.returnFocusOnDeactivate && !isFocusable(e3.target)
      });
      return;
    }
    if (config2.allowOutsideClick && (typeof config2.allowOutsideClick === "boolean" ? config2.allowOutsideClick : config2.allowOutsideClick(e3))) {
      return;
    }
    e3.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(e3) {
    var targetContained = containersContain(e3.target);
    if (targetContained || e3.target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = e3.target;
      }
    } else {
      e3.stopImmediatePropagation();
      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
    }
  };
  var checkTab = function checkTab2(e3) {
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      if (e3.shiftKey) {
        var startOfGroupIndex = state.tabbableGroups.findIndex(function(_ref) {
          var firstTabbableNode = _ref.firstTabbableNode;
          return e3.target === firstTabbableNode;
        });
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = destinationGroup.lastTabbableNode;
        }
      } else {
        var lastOfGroupIndex = state.tabbableGroups.findIndex(function(_ref2) {
          var lastTabbableNode = _ref2.lastTabbableNode;
          return e3.target === lastTabbableNode;
        });
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = _destinationGroup.firstTabbableNode;
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    if (destinationNode) {
      e3.preventDefault();
      tryFocus(destinationNode);
    }
  };
  var checkKey = function checkKey2(e3) {
    if (config2.escapeDeactivates !== false && isEscapeEvent(e3)) {
      e3.preventDefault();
      trap.deactivate();
      return;
    }
    if (isTabEvent(e3)) {
      checkTab(e3);
      return;
    }
  };
  var checkClick = function checkClick2(e3) {
    if (config2.clickOutsideDeactivates) {
      return;
    }
    if (containersContain(e3.target)) {
      return;
    }
    if (config2.allowOutsideClick && (typeof config2.allowOutsideClick === "boolean" ? config2.allowOutsideClick : config2.allowOutsideClick(e3))) {
      return;
    }
    e3.preventDefault();
    e3.stopImmediatePropagation();
  };
  var addListeners = function addListeners2() {
    if (!state.active) {
      return;
    }
    activeFocusTraps.activateTrap(trap);
    activeFocusDelay = config2.delayInitialFocus ? delay(function() {
      tryFocus(getInitialFocusNode());
    }) : tryFocus(getInitialFocusNode());
    doc.addEventListener("focusin", checkFocusIn, true);
    doc.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkKey, {
      capture: true,
      passive: false
    });
    return trap;
  };
  var removeListeners = function removeListeners2() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener("focusin", checkFocusIn, true);
    doc.removeEventListener("mousedown", checkPointerDown, true);
    doc.removeEventListener("touchstart", checkPointerDown, true);
    doc.removeEventListener("click", checkClick, true);
    doc.removeEventListener("keydown", checkKey, true);
    return trap;
  };
  trap = {
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      updateTabbableNodes();
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      var onActivate = activateOptions && activateOptions.onActivate ? activateOptions.onActivate : config2.onActivate;
      if (onActivate) {
        onActivate();
      }
      addListeners();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      clearTimeout(activeFocusDelay);
      removeListeners();
      state.active = false;
      state.paused = false;
      activeFocusTraps.deactivateTrap(trap);
      var onDeactivate = deactivateOptions && deactivateOptions.onDeactivate !== void 0 ? deactivateOptions.onDeactivate : config2.onDeactivate;
      if (onDeactivate) {
        onDeactivate();
      }
      var returnFocus = deactivateOptions && deactivateOptions.returnFocus !== void 0 ? deactivateOptions.returnFocus : config2.returnFocusOnDeactivate;
      if (returnFocus) {
        delay(function() {
          tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
        });
      }
      return this;
    },
    pause: function pause() {
      if (state.paused || !state.active) {
        return this;
      }
      state.paused = true;
      removeListeners();
      return this;
    },
    unpause: function unpause() {
      if (!state.paused || !state.active) {
        return this;
      }
      state.paused = false;
      updateTabbableNodes();
      addListeners();
      return this;
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      return this;
    }
  };
  trap.updateContainerElements(elements);
  return trap;
};
var FocusTrap = class extends react.Component {
  constructor(props) {
    super(props);
    this.divRef = react.createRef();
    if (typeof document !== "undefined") {
      this.previouslyFocusedElement = document.activeElement;
    }
  }
  componentDidMount() {
    this.focusTrap = createFocusTrap(this.divRef.current, Object.assign(Object.assign({}, this.props.focusTrapOptions), {returnFocusOnDeactivate: false}));
    if (this.props.active) {
      this.focusTrap.activate();
    }
    if (this.props.paused) {
      this.focusTrap.pause();
    }
  }
  componentDidUpdate(prevProps) {
    if (prevProps.active && !this.props.active) {
      this.focusTrap.deactivate();
    } else if (!prevProps.active && this.props.active) {
      this.focusTrap.activate();
    }
    if (prevProps.paused && !this.props.paused) {
      this.focusTrap.unpause();
    } else if (!prevProps.paused && this.props.paused) {
      this.focusTrap.pause();
    }
  }
  componentWillUnmount() {
    this.focusTrap.deactivate();
    if (this.props.focusTrapOptions.returnFocusOnDeactivate !== false && this.previouslyFocusedElement && this.previouslyFocusedElement.focus) {
      this.previouslyFocusedElement.focus({preventScroll: this.props.preventScrollOnDeactivate});
    }
  }
  render() {
    const _a = this.props, {children: children2, className, focusTrapOptions, active, paused, preventScrollOnDeactivate} = _a, rest = __rest(_a, ["children", "className", "focusTrapOptions", "active", "paused", "preventScrollOnDeactivate"]);
    return react.createElement("div", Object.assign({ref: this.divRef, className}, rest), children2);
  }
};
FocusTrap.displayName = "FocusTrap";
FocusTrap.defaultProps = {
  active: true,
  paused: false,
  focusTrapOptions: {},
  preventScrollOnDeactivate: false
};
var uid = 0;
var ouiaPrefix = "OUIA-Generated-";
var ouiaIdByRoute = {};
function getOUIAProps(componentType, id3, ouiaSafe = true) {
  return {
    "data-ouia-component-type": `PF4/${componentType}`,
    "data-ouia-safe": ouiaSafe,
    "data-ouia-component-id": id3
  };
}
var useOUIAProps = (componentType, id3, ouiaSafe = true, variant) => ({
  "data-ouia-component-type": `PF4/${componentType}`,
  "data-ouia-safe": ouiaSafe,
  "data-ouia-component-id": useOUIAId(componentType, id3, variant)
});
var useOUIAId = (componentType, id3, variant) => {
  if (id3 !== void 0) {
    return id3;
  }
  return react.useMemo(() => getDefaultOUIAId(componentType, variant), [componentType, variant]);
};
function getDefaultOUIAId(componentType, variant) {
  try {
    const key = `${window.location.href}-${componentType}-${variant || ""}`;
    if (!ouiaIdByRoute[key]) {
      ouiaIdByRoute[key] = 0;
    }
    return `${ouiaPrefix}${componentType}-${variant ? `${variant}-` : ""}${++ouiaIdByRoute[key]}`;
  } catch (exception) {
    return `${ouiaPrefix}${componentType}-${variant ? `${variant}-` : ""}${++uid}`;
  }
}
function capitalize(input) {
  return input[0].toUpperCase() + input.substring(1);
}
function getUniqueId(prefix2 = "pf") {
  const uid2 = new Date().getTime() + Math.random().toString(36).slice(2);
  return `${prefix2}-${uid2}`;
}
function debounce(func, wait) {
  let timeout2;
  return (...args) => {
    clearTimeout(timeout2);
    timeout2 = setTimeout(() => func.apply(this, args), wait);
  };
}
function isElementInView(container, element, partial) {
  if (!container || !element) {
    return false;
  }
  const containerBounds = container.getBoundingClientRect();
  const elementBounds = element.getBoundingClientRect();
  const containerBoundsLeft = Math.floor(containerBounds.left);
  const containerBoundsRight = Math.floor(containerBounds.right);
  const elementBoundsLeft = Math.floor(elementBounds.left);
  const elementBoundsRight = Math.floor(elementBounds.right);
  const isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;
  const isPartiallyInView = partial && (elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft || elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight);
  return isTotallyInView || isPartiallyInView;
}
function fillTemplate(templateString, templateVars) {
  return templateString.replace(/\${(.*?)}/g, (_23, match) => templateVars[match] || "");
}
function keyHandler(index3, innerIndex, position2, refsCollection, kids, custom = false) {
  if (!Array.isArray(kids)) {
    return;
  }
  const isMultiDimensional = refsCollection.filter((ref) => ref)[0].constructor === Array;
  let nextIndex = index3;
  let nextInnerIndex = innerIndex;
  if (position2 === "up") {
    if (index3 === 0) {
      nextIndex = kids.length - 1;
    } else {
      nextIndex = index3 - 1;
    }
  } else if (position2 === "down") {
    if (index3 === kids.length - 1) {
      nextIndex = 0;
    } else {
      nextIndex = index3 + 1;
    }
  } else if (position2 === "left") {
    if (innerIndex === 0) {
      nextInnerIndex = refsCollection[index3].length - 1;
    } else {
      nextInnerIndex = innerIndex - 1;
    }
  } else if (position2 === "right") {
    if (innerIndex === refsCollection[index3].length - 1) {
      nextInnerIndex = 0;
    } else {
      nextInnerIndex = innerIndex + 1;
    }
  }
  if (refsCollection[nextIndex] === null || refsCollection[nextIndex] === void 0 || isMultiDimensional && (refsCollection[nextIndex][nextInnerIndex] === null || refsCollection[nextIndex][nextInnerIndex] === void 0)) {
    keyHandler(nextIndex, nextInnerIndex, position2, refsCollection, kids, custom);
  } else if (custom) {
    if (refsCollection[nextIndex].focus) {
      refsCollection[nextIndex].focus();
    }
    const element = reactDom.findDOMNode(refsCollection[nextIndex]);
    element.focus();
  } else if (position2 !== "tab") {
    if (isMultiDimensional) {
      refsCollection[nextIndex][nextInnerIndex].focus();
    } else {
      refsCollection[nextIndex].focus();
    }
  }
}
function getNextIndex(index3, position2, collection) {
  let nextIndex;
  if (position2 === "up") {
    if (index3 === 0) {
      nextIndex = collection.length - 1;
    } else {
      nextIndex = index3 - 1;
    }
  } else if (index3 === collection.length - 1) {
    nextIndex = 0;
  } else {
    nextIndex = index3 + 1;
  }
  if (collection[nextIndex] === void 0 || collection[nextIndex][0] === null) {
    return getNextIndex(nextIndex, position2, collection);
  } else {
    return nextIndex;
  }
}
function pluralize(i3, singular, plural) {
  if (!plural) {
    plural = `${singular}s`;
  }
  return `${i3 || 0} ${i3 === 1 ? singular : plural}`;
}
var setBreakpointCssVars = (mods, cssVar) => Object.entries(mods || {}).reduce((acc, [breakpoint, value]) => breakpoint === "default" ? Object.assign(Object.assign({}, acc), {[cssVar]: value}) : Object.assign(Object.assign({}, acc), {[`${cssVar}-on-${breakpoint}`]: value}), {});
var formatBreakpointMods = (mods, styles4, stylePrefix = "") => Object.entries(mods || {}).map(([breakpoint, mod]) => `${stylePrefix}${mod}${breakpoint !== "default" ? `-on-${breakpoint}` : ""}`).map(toCamel).map((mod) => mod.replace(/-?(\dxl)/gi, (_res, group) => `_${group}`)).map((modifierKey) => styles4.modifiers[modifierKey]).filter(Boolean).join(" ");
var camelize2 = (s2) => s2.toUpperCase().replace("-", "").replace("_", "");
var toCamel = (s2) => s2.replace(/([-_][a-z])/gi, camelize2);
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var getTextWidth = (text, node) => {
  const computedStyle = getComputedStyle(node);
  const getFontFromComputedStyle = () => {
    let computedFont = "";
    const fontStretchLookupTable = {
      "50%": "ultra-condensed",
      "62.5%": "extra-condensed",
      "75%": "condensed",
      "87.5%": "semi-condensed",
      "100%": "normal",
      "112.5%": "semi-expanded",
      "125%": "expanded",
      "150%": "extra-expanded",
      "200%": "ultra-expanded"
    };
    let fontStretch;
    if (computedStyle.fontStretch in fontStretchLookupTable) {
      fontStretch = fontStretchLookupTable[computedStyle.fontStretch];
    } else {
      fontStretch = "normal";
    }
    computedFont = computedStyle.fontStyle + " " + computedStyle.fontVariant + " " + computedStyle.fontWeight + " " + fontStretch + " " + computedStyle.fontSize + "/" + computedStyle.lineHeight + " " + computedStyle.fontFamily;
    return computedFont;
  };
  const canvas = document.createElement("canvas");
  const context2 = canvas.getContext("2d");
  context2.font = computedStyle.font || getFontFromComputedStyle();
  return context2.measureText(text).width;
};
var innerDimensions = (node) => {
  const computedStyle = getComputedStyle(node);
  let width2 = node.clientWidth;
  let height = node.clientHeight;
  height -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);
  width2 -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
  return {height, width: width2};
};
var trimLeft = (node, value) => {
  const availableWidth = innerDimensions(node).width;
  let newValue = value;
  if (getTextWidth(value, node) > availableWidth) {
    while (getTextWidth(`...${newValue}`, node) > availableWidth) {
      newValue = newValue.substring(1);
    }
    if (node.value) {
      node.value = `...${newValue}`;
    } else {
      node.innerText = `...${newValue}`;
    }
  } else {
    if (node.value) {
      node.value = value;
    } else {
      node.innerText = value;
    }
  }
};
var preventedEvents = (events) => events.reduce((handlers, eventToPrevent) => Object.assign(Object.assign({}, handlers), {[eventToPrevent]: (event) => {
  event.preventDefault();
}}), {});
var FindRefWrapper = class extends react.Component {
  componentDidMount() {
    const root3 = reactDom.findDOMNode(this);
    this.props.onFoundRef(root3);
  }
  render() {
    return this.props.children || null;
  }
};
FindRefWrapper.displayName = "FindRefWrapper";
function getBoundingClientRect(element) {
  const rect = element.getBoundingClientRect();
  return {
    width: rect.width,
    height: rect.height,
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    x: rect.left,
    y: rect.top
  };
}
function getWindow(node) {
  if (node.toString() !== "[object Window]") {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }
  return node;
}
function getWindowScroll(node) {
  const win = getWindow(node);
  const scrollLeft = win.pageXOffset;
  const scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function isElement(node) {
  const OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  const OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getDocumentElement(element) {
  return (isElement(element) ? element.ownerDocument : element.document).documentElement;
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isScrollParent(element) {
  const {overflow, overflowX, overflowY} = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getCompositeRect(elementOrVirtualElement, offsetParent2, isFixed = false) {
  const documentElement = getDocumentElement(offsetParent2);
  const rect = getBoundingClientRect(elementOrVirtualElement);
  const isOffsetParentAnElement = isHTMLElement(offsetParent2);
  let scroll = {scrollLeft: 0, scrollTop: 0};
  let offsets = {x: 0, y: 0};
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent2) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent2);
    }
    if (isHTMLElement(offsetParent2)) {
      offsets = getBoundingClientRect(offsetParent2);
      offsets.x += offsetParent2.clientLeft;
      offsets.y += offsetParent2.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getLayoutRect(element) {
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: element.offsetWidth,
    height: element.offsetHeight
  };
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || element.host || getDocumentElement(element);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list3 = []) {
  const scrollParent = getScrollParent(element);
  const isBody = getNodeName(scrollParent) === "body";
  const win = getWindow(scrollParent);
  const target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  const updatedList = list3.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  const offsetParent2 = element.offsetParent;
  if (offsetParent2) {
    const html = getDocumentElement(offsetParent2);
    if (getNodeName(offsetParent2) === "body" && getComputedStyle$1(offsetParent2).position === "static" && getComputedStyle$1(html).position !== "static") {
      return html;
    }
  }
  return offsetParent2;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    const css2 = getComputedStyle$1(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.willChange && css2.willChange !== "auto") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  const window2 = getWindow(element);
  let offsetParent2 = getTrueOffsetParent(element);
  while (offsetParent2 && isTableElement(offsetParent2) && getComputedStyle$1(offsetParent2).position === "static") {
    offsetParent2 = getTrueOffsetParent(offsetParent2);
  }
  if (offsetParent2 && getNodeName(offsetParent2) === "body" && getComputedStyle$1(offsetParent2).position === "static") {
    return window2;
  }
  return offsetParent2 || getContainingBlock(element) || window2;
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce((acc, placement) => acc.concat([`${placement}-${start}`, `${placement}-${end}`]), []);
var placements = [...basePlacements, auto].reduce((acc, placement) => acc.concat([placement, `${placement}-${start}`, `${placement}-${end}`]), []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [
  beforeRead,
  read,
  afterRead,
  beforeMain,
  main,
  afterMain,
  beforeWrite,
  write,
  afterWrite
];
function order(modifiers) {
  const map3 = new Map();
  const visited = new Set();
  const result = [];
  modifiers.forEach((modifier) => {
    map3.set(modifier.name, modifier);
  });
  function sort2(modifier) {
    visited.add(modifier.name);
    const requires = [...modifier.requires || [], ...modifier.requiresIfExists || []];
    requires.forEach((dep) => {
      if (!visited.has(dep)) {
        const depModifier = map3.get(dep);
        if (depModifier) {
          sort2(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach((modifier) => {
    if (!visited.has(modifier.name)) {
      sort2(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  const orderedModifiers = order(modifiers);
  return modifierPhases.reduce((acc, phase) => acc.concat(orderedModifiers.filter((modifier) => modifier.phase === phase)), []);
}
function debounce$1(fn) {
  let pending;
  return () => {
    if (!pending) {
      pending = new Promise((resolve) => {
        Promise.resolve().then(() => {
          pending = void 0;
          resolve(fn());
        });
      });
    }
    return pending;
  };
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function mergeByName(modifiers) {
  const merged = modifiers.reduce((merged2, current) => {
    const existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign(Object.assign(Object.assign({}, existing), current), {options: Object.assign(Object.assign({}, existing.options), current.options), data: Object.assign(Object.assign({}, existing.data), current.data)}) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map((key) => merged[key]);
}
function getViewportRect(element) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width2 = html.clientWidth;
  let height = html.clientHeight;
  let x3 = 0;
  let y4 = 0;
  if (visualViewport) {
    width2 = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x3 = visualViewport.offsetLeft;
      y4 = visualViewport.offsetTop;
    }
  }
  return {
    width: width2,
    height,
    x: x3 + getWindowScrollBarX(element),
    y: y4
  };
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const winScroll = getWindowScroll(element);
  const body = element.ownerDocument.body;
  const width2 = Math.max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = Math.max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x3 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  const y4 = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x3 += Math.max(html.clientWidth, body ? body.clientWidth : 0) - width2;
  }
  return {width: width2, height, x: x3, y: y4};
}
function contains(parent, child) {
  const isShadow = Boolean(child.getRootNode && child.getRootNode().host);
  if (parent.contains(child)) {
    return true;
  } else if (isShadow) {
    let next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function rectToClientRect(rect) {
  return Object.assign(Object.assign({}, rect), {left: rect.x, top: rect.y, right: rect.x + rect.width, bottom: rect.y + rect.height});
}
function getInnerBoundingClientRect(element) {
  const rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  const clippingParents2 = listScrollParents(getParentNode(element));
  const canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter((clippingParent) => isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body");
}
function getClippingRect(element, boundary, rootBoundary) {
  const mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  const clippingParents2 = [...mainClippingParents, rootBoundary];
  const firstClippingParent = clippingParents2[0];
  const clippingRect = clippingParents2.reduce((accRect, clippingParent) => {
    const rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = Math.max(rect.top, accRect.top);
    accRect.right = Math.min(rect.right, accRect.right);
    accRect.bottom = Math.min(rect.bottom, accRect.bottom);
    accRect.left = Math.max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function getVariation(placement) {
  return placement.split("-")[1];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function computeOffsets({reference: reference2, element, placement}) {
  const basePlacement = placement ? getBasePlacement(placement) : null;
  const variation = placement ? getVariation(placement) : null;
  const commonX = reference2.x + reference2.width / 2 - element.width / 2;
  const commonY = reference2.y + reference2.height / 2 - element.height / 2;
  let offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  const mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    const len2 = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference2[len2] / 2 - element[len2] / 2);
        break;
      case end:
        offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference2[len2] / 2 - element[len2] / 2);
        break;
    }
  }
  return offsets;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign(Object.assign({}, getFreshSideObject()), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce((hashMap, key) => {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
function detectOverflow(state, options = {}) {
  const {placement = state.placement, boundary = clippingParents, rootBoundary = viewport, elementContext = popper, altBoundary = false, padding = 0} = options;
  const paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  const altContext = elementContext === popper ? reference : popper;
  const referenceElement = state.elements.reference;
  const popperRect = state.rects.popper;
  const element = state.elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  const referenceClientRect = getBoundingClientRect(referenceElement);
  const popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  const popperClientRect = rectToClientRect(Object.assign(Object.assign({}, popperRect), popperOffsets2));
  const elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  const overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  const offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    const offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach((key) => {
      const multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      const axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements(...args) {
  return !args.some((element) => !(element && typeof element.getBoundingClientRect === "function"));
}
function popperGenerator(generatorOptions = {}) {
  const {defaultModifiers: defaultModifiers2 = [], defaultOptions: defaultOptions2 = DEFAULT_OPTIONS} = generatorOptions;
  return function createPopper2(reference2, popper2, options = defaultOptions2) {
    let state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign(Object.assign({}, DEFAULT_OPTIONS), defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    let effectCleanupFns = [];
    let isDestroyed = false;
    const instance = {
      state,
      setOptions(options2) {
        cleanupModifierEffects();
        state.options = Object.assign(Object.assign(Object.assign({}, defaultOptions2), state.options), options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        const orderedModifiers = orderModifiers(mergeByName([...defaultModifiers2, ...state.options.modifiers]));
        state.orderedModifiers = orderedModifiers.filter((m3) => m3.enabled);
        runModifierEffects();
        return instance.update();
      },
      forceUpdate() {
        if (isDestroyed) {
          return;
        }
        const {reference: reference3, popper: popper3} = state.elements;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach((modifier) => state.modifiersData[modifier.name] = Object.assign({}, modifier.data));
        for (let index3 = 0; index3 < state.orderedModifiers.length; index3++) {
          if (state.reset === true) {
            state.reset = false;
            index3 = -1;
            continue;
          }
          const {fn, options: options2 = {}, name} = state.orderedModifiers[index3];
          if (typeof fn === "function") {
            state = fn({state, options: options2, name, instance}) || state;
          }
        }
      },
      update: debounce$1(() => new Promise((resolve) => {
        instance.forceUpdate();
        resolve(state);
      })),
      destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then((state2) => {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(({name, options: options2 = {}, effect: effect2}) => {
        if (typeof effect2 === "function") {
          const cleanupFn = effect2({state, name, instance, options: options2});
          const noopFn = () => {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach((fn) => fn());
      effectCleanupFns = [];
    }
    return instance;
  };
}
var passive = {passive: true};
function effect({state, instance, options}) {
  const {scroll = true, resize = true} = options;
  const window2 = getWindow(state.elements.popper);
  const scrollParents = [...state.scrollParents.reference, ...state.scrollParents.popper];
  if (scroll) {
    scrollParents.forEach((scrollParent) => {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return () => {
    if (scroll) {
      scrollParents.forEach((scrollParent) => {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: () => {
  },
  effect,
  data: {}
};
function popperOffsets({state, name}) {
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsets({x: x3, y: y4}) {
  const win = window;
  const dpr = win.devicePixelRatio || 1;
  return {
    x: Math.round(x3 * dpr) / dpr || 0,
    y: Math.round(y4 * dpr) / dpr || 0
  };
}
function mapToStyles({popper: popper2, popperRect, placement, offsets, position: position2, gpuAcceleration, adaptive}) {
  let {x: x3, y: y4} = roundOffsets(offsets);
  const hasX = offsets.hasOwnProperty("x");
  const hasY = offsets.hasOwnProperty("y");
  let sideX = left;
  let sideY = top;
  const win = window;
  if (adaptive) {
    let offsetParent2 = getOffsetParent(popper2);
    if (offsetParent2 === getWindow(popper2)) {
      offsetParent2 = getDocumentElement(popper2);
    }
    if (placement === top) {
      sideY = bottom;
      y4 -= offsetParent2.clientHeight - popperRect.height;
      y4 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left) {
      sideX = right;
      x3 -= offsetParent2.clientWidth - popperRect.width;
      x3 *= gpuAcceleration ? 1 : -1;
    }
  }
  const commonStyles = Object.assign({position: position2}, adaptive && unsetSides);
  if (gpuAcceleration) {
    return Object.assign(Object.assign({}, commonStyles), {
      [sideY]: hasY ? "0" : "",
      [sideX]: hasX ? "0" : "",
      transform: (win.devicePixelRatio || 1) < 2 ? `translate(${x3}px, ${y4}px)` : `translate3d(${x3}px, ${y4}px, 0)`
    });
  }
  return Object.assign(Object.assign({}, commonStyles), {[sideY]: hasY ? `${y4}px` : "", [sideX]: hasX ? `${x3}px` : "", transform: ""});
}
function computeStyles({state, options}) {
  const {gpuAcceleration = true, adaptive = true} = options;
  const commonStyles = {
    placement: getBasePlacement(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign(Object.assign({}, state.styles.popper), mapToStyles(Object.assign(Object.assign({}, commonStyles), {offsets: state.modifiersData.popperOffsets, position: state.options.strategy, adaptive})));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign(Object.assign({}, state.styles.arrow), mapToStyles(Object.assign(Object.assign({}, commonStyles), {offsets: state.modifiersData.arrow, position: "absolute", adaptive: false})));
  }
  state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), {"data-popper-placement": state.placement});
}
var computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
function applyStyles({state}) {
  Object.keys(state.elements).forEach((name) => {
    const style = state.styles[name] || {};
    const attributes = state.attributes[name] || {};
    const element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach((name2) => {
      const value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$1({state}) {
  const initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return () => {
    Object.keys(state.elements).forEach((name) => {
      const element = state.elements[name];
      const attributes = state.attributes[name] || {};
      const styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      const style = styleProperties.reduce((style2, property2) => {
        style2[property2] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach((attribute) => {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$1,
  requires: ["computeStyles"]
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  const basePlacement = getBasePlacement(placement);
  const invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  let [skidding, distance] = typeof offset2 === "function" ? offset2(Object.assign(Object.assign({}, rects), {placement})) : offset2;
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {x: distance, y: skidding} : {x: skidding, y: distance};
}
function offset({state, options, name}) {
  const {offset: offset2 = [0, 0]} = options;
  const data = placements.reduce((acc, placement) => {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  const {x: x3, y: y4} = data[state.placement];
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x3;
    state.modifiersData.popperOffsets.y += y4;
  }
  state.modifiersData[name] = data;
}
var offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
var hash = {left: "right", right: "left", bottom: "top", top: "bottom"};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (matched) => hash[matched]);
}
var hash$1 = {start: "end", end: "start"};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, (matched) => hash$1[matched]);
}
function computeAutoPlacement(state, options = {}) {
  const {placement, boundary, rootBoundary, padding, flipVariations, allowedAutoPlacements = placements} = options;
  const variation = getVariation(placement);
  const placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter((placement2) => getVariation(placement2) === variation) : basePlacements;
  let allowedPlacements = placements$1.filter((placement2) => allowedAutoPlacements.indexOf(placement2) >= 0);
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  const overflows = allowedPlacements.reduce((acc, placement2) => {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort((a2, b3) => overflows[a2] - overflows[b3]);
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  const oppositePlacement = getOppositePlacement(placement);
  return [
    getOppositeVariationPlacement(placement),
    oppositePlacement,
    getOppositeVariationPlacement(oppositePlacement)
  ];
}
function flip({state, options, name}) {
  if (state.modifiersData[name]._skip) {
    return;
  }
  const {mainAxis: checkMainAxis = true, altAxis: checkAltAxis = true, fallbackPlacements: specifiedFallbackPlacements, padding, boundary, rootBoundary, altBoundary, flipVariations = true, allowedAutoPlacements} = options;
  const preferredPlacement = state.options.placement;
  const basePlacement = getBasePlacement(preferredPlacement);
  const isBasePlacement = basePlacement === preferredPlacement;
  const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  const placements2 = [preferredPlacement, ...fallbackPlacements].reduce((acc, placement) => acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
    placement,
    boundary,
    rootBoundary,
    padding,
    flipVariations,
    allowedAutoPlacements
  }) : placement), []);
  const referenceRect = state.rects.reference;
  const popperRect = state.rects.popper;
  const checksMap = new Map();
  let makeFallbackChecks = true;
  let firstFittingPlacement = placements2[0];
  for (let i3 = 0; i3 < placements2.length; i3++) {
    const placement = placements2[i3];
    const basePlacement2 = getBasePlacement(placement);
    const isStartVariation = getVariation(placement) === start;
    const isVertical = [top, bottom].indexOf(basePlacement2) >= 0;
    const len2 = isVertical ? "width" : "height";
    const overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    let mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len2] > popperRect[len2]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    const altVariationSide = getOppositePlacement(mainVariationSide);
    const checks = [];
    if (checkMainAxis) {
      checks.push(overflow[basePlacement2] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every((check2) => check2)) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    const numberOfChecks = flipVariations ? 3 : 1;
    for (let i3 = numberOfChecks; i3 > 0; i3--) {
      const fittingPlacement = placements2.find((placement) => {
        const checks = checksMap.get(placement);
        if (checks) {
          return checks.slice(0, i3).every((check2) => check2);
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        break;
      }
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {_skip: false}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function within(min2, value, max2) {
  return Math.max(min2, Math.min(value, max2));
}
function preventOverflow({state, options, name}) {
  const {mainAxis: checkMainAxis = true, altAxis: checkAltAxis = false, boundary, rootBoundary, altBoundary, padding, tether = true, tetherOffset = 0} = options;
  const overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  const basePlacement = getBasePlacement(state.placement);
  const variation = getVariation(state.placement);
  const isBasePlacement = !variation;
  const mainAxis = getMainAxisFromPlacement(basePlacement);
  const altAxis = getAltAxis(mainAxis);
  const popperOffsets2 = state.modifiersData.popperOffsets;
  const referenceRect = state.rects.reference;
  const popperRect = state.rects.popper;
  const tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign(Object.assign({}, state.rects), {placement: state.placement})) : tetherOffset;
  const data = {x: 0, y: 0};
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    const mainSide = mainAxis === "y" ? top : left;
    const altSide = mainAxis === "y" ? bottom : right;
    const len2 = mainAxis === "y" ? "height" : "width";
    const offset2 = popperOffsets2[mainAxis];
    const min2 = popperOffsets2[mainAxis] + overflow[mainSide];
    const max2 = popperOffsets2[mainAxis] - overflow[altSide];
    const additive = tether ? -popperRect[len2] / 2 : 0;
    const minLen = variation === start ? referenceRect[len2] : popperRect[len2];
    const maxLen = variation === start ? -popperRect[len2] : -referenceRect[len2];
    const arrowElement = state.elements.arrow;
    const arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {width: 0, height: 0};
    const arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    const arrowPaddingMin = arrowPaddingObject[mainSide];
    const arrowPaddingMax = arrowPaddingObject[altSide];
    const arrowLen = within(0, referenceRect[len2], arrowRect[len2]);
    const minOffset = isBasePlacement ? referenceRect[len2] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
    const maxOffset = isBasePlacement ? -referenceRect[len2] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
    const arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    const clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    const offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
    const tetherMin = popperOffsets2[mainAxis] + minOffset - offsetModifierValue - clientOffset;
    const tetherMax = popperOffsets2[mainAxis] + maxOffset - offsetModifierValue;
    const preventedOffset = within(tether ? Math.min(min2, tetherMin) : min2, offset2, tether ? Math.max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    const mainSide = mainAxis === "x" ? top : left;
    const altSide = mainAxis === "x" ? bottom : right;
    const offset2 = popperOffsets2[altAxis];
    const min2 = offset2 + overflow[mainSide];
    const max2 = offset2 - overflow[altSide];
    const preventedOffset = within(min2, offset2, max2);
    popperOffsets2[altAxis] = preventedOffset;
    data[altAxis] = preventedOffset - offset2;
  }
  state.modifiersData[name] = data;
}
var preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function arrow({state, name}) {
  const arrowElement = state.elements.arrow;
  const popperOffsets2 = state.modifiersData.popperOffsets;
  const basePlacement = getBasePlacement(state.placement);
  const axis = getMainAxisFromPlacement(basePlacement);
  const isVertical = [left, right].indexOf(basePlacement) >= 0;
  const len2 = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  const paddingObject = state.modifiersData[`${name}#persistent`].padding;
  const arrowRect = getLayoutRect(arrowElement);
  const minProp = axis === "y" ? top : left;
  const maxProp = axis === "y" ? bottom : right;
  const endDiff = state.rects.reference[len2] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len2];
  const startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  const arrowOffsetParent = getOffsetParent(arrowElement);
  const clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  const centerToReference = endDiff / 2 - startDiff / 2;
  const min2 = paddingObject[minProp];
  const max2 = clientSize - arrowRect[len2] - paddingObject[maxProp];
  const center = clientSize / 2 - arrowRect[len2] / 2 + centerToReference;
  const offset2 = within(min2, center, max2);
  const axisProp = axis;
  state.modifiersData[name] = {
    [axisProp]: offset2,
    centerOffset: offset2 - center
  };
}
function effect$2({state, options, name}) {
  let {element: arrowElement = "[data-popper-arrow]", padding = 0} = options;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
  state.modifiersData[`${name}#persistent`] = {
    padding: mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements))
  };
}
var arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getSideOffsets(overflow, rect, preventedOffsets = {x: 0, y: 0}) {
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some((side) => overflow[side] >= 0);
}
function hide({state, name}) {
  const referenceRect = state.rects.reference;
  const popperRect = state.rects.popper;
  const preventedOffsets = state.modifiersData.preventOverflow;
  const referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  const popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  const referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  const popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  const isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  const hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), {"data-popper-reference-hidden": isReferenceHidden, "data-popper-escaped": hasPopperEscaped});
}
var hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
var defaultModifiers = [
  eventListeners,
  popperOffsets$1,
  computeStyles$1,
  applyStyles$1,
  offset$1,
  flip$1,
  preventOverflow$1,
  arrow$1,
  hide$1
];
var createPopper = popperGenerator({defaultModifiers});
var useIsomorphicLayoutEffect = canUseDOM ? react.useLayoutEffect : react.useEffect;
var isEqual = (a2, b3) => JSON.stringify(a2) === JSON.stringify(b3);
var fromEntries = (entries) => entries.reduce((acc, [key, value]) => {
  acc[key] = value;
  return acc;
}, {});
var EMPTY_MODIFIERS = [];
var usePopper = (referenceElement, popperElement, options = {}) => {
  const prevOptions = react.useRef(null);
  const optionsWithDefaults = {
    onFirstUpdate: options.onFirstUpdate,
    placement: options.placement || "bottom",
    strategy: options.strategy || "absolute",
    modifiers: options.modifiers || EMPTY_MODIFIERS
  };
  const [state, setState] = react.useState({
    styles: {
      popper: {
        position: optionsWithDefaults.strategy,
        left: "0",
        top: "0"
      }
    },
    attributes: {}
  });
  const updateStateModifier = react.useMemo(() => ({
    name: "updateState",
    enabled: true,
    phase: "write",
    fn: ({state: state2}) => {
      const elements = Object.keys(state2.elements);
      setState({
        styles: fromEntries(elements.map((element) => [element, state2.styles[element] || {}])),
        attributes: fromEntries(elements.map((element) => [element, state2.attributes[element]]))
      });
    },
    requires: ["computeStyles"]
  }), []);
  const popperOptions = react.useMemo(() => {
    const newOptions = {
      onFirstUpdate: optionsWithDefaults.onFirstUpdate,
      placement: optionsWithDefaults.placement,
      strategy: optionsWithDefaults.strategy,
      modifiers: [...optionsWithDefaults.modifiers, updateStateModifier, {name: "applyStyles", enabled: false}]
    };
    if (isEqual(prevOptions.current, newOptions)) {
      return prevOptions.current || newOptions;
    } else {
      prevOptions.current = newOptions;
      return newOptions;
    }
  }, [
    optionsWithDefaults.onFirstUpdate,
    optionsWithDefaults.placement,
    optionsWithDefaults.strategy,
    optionsWithDefaults.modifiers,
    updateStateModifier
  ]);
  const popperInstanceRef = react.useRef();
  useIsomorphicLayoutEffect(() => {
    if (popperInstanceRef && popperInstanceRef.current) {
      popperInstanceRef.current.setOptions(popperOptions);
    }
  }, [popperOptions]);
  useIsomorphicLayoutEffect(() => {
    if (referenceElement == null || popperElement == null) {
      return;
    }
    const createPopper$1 = options.createPopper || createPopper;
    const popperInstance = createPopper$1(referenceElement, popperElement, popperOptions);
    popperInstanceRef.current = popperInstance;
    return () => {
      popperInstance.destroy();
      popperInstanceRef.current = null;
    };
  }, [referenceElement, popperElement, options.createPopper]);
  return {
    state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
    styles: state.styles,
    attributes: state.attributes,
    update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
    forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
  };
};
var hash$2 = {left: "right", right: "left", bottom: "top", top: "bottom"};
var getOppositePlacement$1 = (placement) => placement.replace(/left|right|bottom|top/g, (matched) => hash$2[matched]);
var getOpacityTransition = (animationDuration) => `opacity ${animationDuration}ms cubic-bezier(.54, 1.5, .38, 1.11)`;
var Popper = ({trigger, popper: popper2, popperMatchesTriggerWidth = true, direction = "down", position: position2 = "left", placement, appendTo = () => document.body, zIndex = 9999, isVisible = true, positionModifiers, distance = 0, onMouseEnter, onMouseLeave, onFocus, onBlur, onDocumentClick, onTriggerClick, onTriggerEnter, onPopperClick, onDocumentKeyDown, enableFlip = true, flipBehavior = "flip", reference: reference2}) => {
  const [triggerElement, setTriggerElement] = react.useState(null);
  const [refElement, setRefElement] = react.useState(null);
  const [popperElement, setPopperElement] = react.useState(null);
  const [ready, setReady] = react.useState(false);
  const refOrTrigger = refElement || triggerElement;
  const onDocumentClickCallback = react.useCallback((event) => onDocumentClick(event, refOrTrigger, popperElement), [
    isVisible,
    triggerElement,
    refElement,
    popperElement,
    onDocumentClick
  ]);
  react.useEffect(() => {
    setReady(true);
  }, []);
  react.useEffect(() => {
    if (reference2) {
      if (reference2.current) {
        setRefElement(reference2.current);
      } else if (typeof reference2 === "function") {
        setRefElement(reference2());
      }
    }
  }, [reference2]);
  const addEventListener = (listener, element, event) => {
    if (listener && element) {
      element.addEventListener(event, listener);
    }
  };
  const removeEventListener = (listener, element, event) => {
    if (listener && element) {
      element.removeEventListener(event, listener);
    }
  };
  react.useEffect(() => {
    addEventListener(onMouseEnter, refOrTrigger, "mouseenter");
    addEventListener(onMouseLeave, refOrTrigger, "mouseleave");
    addEventListener(onFocus, refOrTrigger, "focus");
    addEventListener(onBlur, refOrTrigger, "blur");
    addEventListener(onTriggerClick, refOrTrigger, "click");
    addEventListener(onTriggerEnter, refOrTrigger, "keydown");
    addEventListener(onPopperClick, popperElement, "click");
    onDocumentClick && addEventListener(onDocumentClickCallback, document, "click");
    addEventListener(onDocumentKeyDown, document, "keydown");
    return () => {
      removeEventListener(onMouseEnter, refOrTrigger, "mouseenter");
      removeEventListener(onMouseLeave, refOrTrigger, "mouseleave");
      removeEventListener(onFocus, refOrTrigger, "focus");
      removeEventListener(onBlur, refOrTrigger, "blur");
      removeEventListener(onTriggerClick, refOrTrigger, "click");
      removeEventListener(onTriggerEnter, refOrTrigger, "keydown");
      removeEventListener(onPopperClick, popperElement, "click");
      onDocumentClick && removeEventListener(onDocumentClickCallback, document, "click");
      removeEventListener(onDocumentKeyDown, document, "keydown");
    };
  }, [
    triggerElement,
    popperElement,
    onMouseEnter,
    onMouseLeave,
    onFocus,
    onBlur,
    onTriggerClick,
    onTriggerEnter,
    onPopperClick,
    onDocumentClick,
    onDocumentKeyDown,
    refElement
  ]);
  const getPlacement = () => {
    if (placement) {
      return placement;
    }
    let convertedPlacement = direction === "up" ? "top" : "bottom";
    if (position2 !== "center") {
      convertedPlacement = `${convertedPlacement}-${position2 === "right" ? "end" : "start"}`;
    }
    return convertedPlacement;
  };
  const getPlacementMemo = react.useMemo(getPlacement, [direction, position2, placement]);
  const getOppositePlacementMemo = react.useMemo(() => getOppositePlacement$1(getPlacement()), [
    direction,
    position2,
    placement
  ]);
  const sameWidthMod = react.useMemo(() => ({
    name: "sameWidth",
    enabled: popperMatchesTriggerWidth,
    phase: "beforeWrite",
    requires: ["computeStyles"],
    fn: ({state}) => {
      state.styles.popper.width = `${state.rects.reference.width}px`;
    },
    effect: ({state}) => {
      state.elements.popper.style.width = `${state.elements.reference.offsetWidth}px`;
      return () => {
      };
    }
  }), [popperMatchesTriggerWidth]);
  const {styles: popperStyles, attributes} = usePopper(refOrTrigger, popperElement, {
    placement: getPlacementMemo,
    modifiers: [
      {
        name: "offset",
        options: {
          offset: [0, distance]
        }
      },
      {
        name: "preventOverflow",
        enabled: false
      },
      {
        name: "hide",
        enabled: true
      },
      {
        name: "flip",
        enabled: getPlacementMemo.startsWith("auto") || enableFlip,
        options: {
          fallbackPlacements: flipBehavior === "flip" ? [getOppositePlacementMemo] : flipBehavior
        }
      },
      sameWidthMod
    ]
  });
  const modifierFromPopperPosition = () => {
    if (attributes && attributes.popper && attributes.popper["data-popper-placement"]) {
      const popperPlacement = attributes.popper["data-popper-placement"];
      if (popperPlacement.startsWith("top")) {
        return positionModifiers.top || "";
      } else if (popperPlacement.startsWith("bottom")) {
        return positionModifiers.bottom || "";
      } else if (popperPlacement.startsWith("left")) {
        return positionModifiers.left || "";
      } else if (popperPlacement.startsWith("right")) {
        return positionModifiers.right || "";
      }
    }
    return positionModifiers.top;
  };
  const menuWithPopper = react.cloneElement(popper2, Object.assign({className: css(popper2.props && popper2.props.className, positionModifiers && modifierFromPopperPosition()), style: Object.assign(Object.assign(Object.assign({}, popper2.props && popper2.props.style || {}), popperStyles.popper), {zIndex})}, attributes.popper));
  const getTarget = () => {
    if (typeof appendTo === "function") {
      return appendTo();
    }
    return appendTo;
  };
  return react.createElement(react.Fragment, null, !reference2 && trigger && react.createElement(FindRefWrapper, {onFoundRef: (foundRef) => setTriggerElement(foundRef)}, trigger), ready && isVisible && reactDom.createPortal(react.createElement(FindRefWrapper, {onFoundRef: (foundRef) => setPopperElement(foundRef)}, menuWithPopper), getTarget()));
};
Popper.displayName = "Popper";
var bullseye = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    bullseye: "pf-l-bullseye"
  };
});
var styles = /* @__PURE__ */ getDefaultExportFromCjs(bullseye);
var title = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    modifiers: {
      "4xl": "pf-m-4xl",
      "3xl": "pf-m-3xl",
      "2xl": "pf-m-2xl",
      xl: "pf-m-xl",
      lg: "pf-m-lg",
      md: "pf-m-md",
      overpassFont: "pf-m-overpass-font"
    },
    title: "pf-c-title"
  };
});
var styles$1 = /* @__PURE__ */ getDefaultExportFromCjs(title);
var TitleSizes;
(function(TitleSizes2) {
  TitleSizes2["md"] = "md";
  TitleSizes2["lg"] = "lg";
  TitleSizes2["xl"] = "xl";
  TitleSizes2["2xl"] = "2xl";
  TitleSizes2["3xl"] = "3xl";
  TitleSizes2["4xl"] = "4xl";
})(TitleSizes || (TitleSizes = {}));
var headingLevelSizeMap;
(function(headingLevelSizeMap2) {
  headingLevelSizeMap2["h1"] = "2xl";
  headingLevelSizeMap2["h2"] = "xl";
  headingLevelSizeMap2["h3"] = "lg";
  headingLevelSizeMap2["h4"] = "md";
  headingLevelSizeMap2["h5"] = "md";
  headingLevelSizeMap2["h6"] = "md";
})(headingLevelSizeMap || (headingLevelSizeMap = {}));
var Title = (_a) => {
  var {className = "", children: children2 = "", headingLevel: HeadingLevel, size: size2 = headingLevelSizeMap[HeadingLevel], ouiaId, ouiaSafe = true} = _a, props = __rest(_a, ["className", "children", "headingLevel", "size", "ouiaId", "ouiaSafe"]);
  const ouiaProps = useOUIAProps(Title.displayName, ouiaId, ouiaSafe);
  return react.createElement(HeadingLevel, Object.assign({}, ouiaProps, props, {className: css(styles$1.title, size2 && styles$1.modifiers[size2], className)}), children2);
};
Title.displayName = "Title";
var button = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    button: "pf-c-button",
    buttonIcon: "pf-c-button__icon",
    buttonProgress: "pf-c-button__progress",
    modifiers: {
      active: "pf-m-active",
      block: "pf-m-block",
      small: "pf-m-small",
      primary: "pf-m-primary",
      displayLg: "pf-m-display-lg",
      secondary: "pf-m-secondary",
      tertiary: "pf-m-tertiary",
      link: "pf-m-link",
      inline: "pf-m-inline",
      danger: "pf-m-danger",
      warning: "pf-m-warning",
      control: "pf-m-control",
      expanded: "pf-m-expanded",
      plain: "pf-m-plain",
      disabled: "pf-m-disabled",
      ariaDisabled: "pf-m-aria-disabled",
      progress: "pf-m-progress",
      inProgress: "pf-m-in-progress",
      start: "pf-m-start",
      end: "pf-m-end",
      overpassFont: "pf-m-overpass-font"
    },
    spinner: "pf-c-spinner"
  };
});
var buttonStyles = /* @__PURE__ */ getDefaultExportFromCjs(button);
var spinner = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    modifiers: {
      sm: "pf-m-sm",
      md: "pf-m-md",
      lg: "pf-m-lg",
      xl: "pf-m-xl"
    },
    spinner: "pf-c-spinner",
    spinnerClipper: "pf-c-spinner__clipper",
    spinnerLeadBall: "pf-c-spinner__lead-ball",
    spinnerPath: "pf-c-spinner__path",
    spinnerTailBall: "pf-c-spinner__tail-ball"
  };
});
var styles$2 = /* @__PURE__ */ getDefaultExportFromCjs(spinner);
var spinnerSize;
(function(spinnerSize2) {
  spinnerSize2["sm"] = "sm";
  spinnerSize2["md"] = "md";
  spinnerSize2["lg"] = "lg";
  spinnerSize2["xl"] = "xl";
})(spinnerSize || (spinnerSize = {}));
var Spinner = (_a) => {
  var {
    className = "",
    size: size2 = "xl",
    "aria-valuetext": ariaValueText = "Loading...",
    isSVG = false,
    diameter
  } = _a, props = __rest(_a, ["className", "size", "aria-valuetext", "isSVG", "diameter"]);
  const Component = isSVG ? "svg" : "span";
  return react.createElement(Component, Object.assign({className: css(styles$2.spinner, styles$2.modifiers[size2], className), role: "progressbar", "aria-valuetext": ariaValueText}, isSVG && {viewBox: "0 0 100 100"}, diameter && {style: {"--pf-c-spinner--diameter": diameter}}, props), isSVG ? react.createElement("circle", {className: styles$2.spinnerPath, cx: "50", cy: "50", r: "45", fill: "none"}) : react.createElement(react.Fragment, null, react.createElement("span", {className: css(styles$2.spinnerClipper)}), react.createElement("span", {className: css(styles$2.spinnerLeadBall)}), react.createElement("span", {className: css(styles$2.spinnerTailBall)})));
};
Spinner.displayName = "Spinner";
var ButtonVariant;
(function(ButtonVariant2) {
  ButtonVariant2["primary"] = "primary";
  ButtonVariant2["secondary"] = "secondary";
  ButtonVariant2["tertiary"] = "tertiary";
  ButtonVariant2["danger"] = "danger";
  ButtonVariant2["warning"] = "warning";
  ButtonVariant2["link"] = "link";
  ButtonVariant2["plain"] = "plain";
  ButtonVariant2["control"] = "control";
})(ButtonVariant || (ButtonVariant = {}));
var ButtonType;
(function(ButtonType2) {
  ButtonType2["button"] = "button";
  ButtonType2["submit"] = "submit";
  ButtonType2["reset"] = "reset";
})(ButtonType || (ButtonType = {}));
var ButtonBase = (_a) => {
  var {children: children2 = null, className = "", component = "button", isActive = false, isBlock = false, isDisabled = false, isAriaDisabled = false, isLoading = null, isDanger = false, spinnerAriaValueText, isSmall = false, isLarge = false, inoperableEvents = ["onClick", "onKeyPress"], isInline = false, type = ButtonType.button, variant = ButtonVariant.primary, iconPosition = "left", "aria-label": ariaLabel = null, icon = null, ouiaId, ouiaSafe = true, tabIndex = null, innerRef} = _a, props = __rest(_a, ["children", "className", "component", "isActive", "isBlock", "isDisabled", "isAriaDisabled", "isLoading", "isDanger", "spinnerAriaValueText", "isSmall", "isLarge", "inoperableEvents", "isInline", "type", "variant", "iconPosition", "aria-label", "icon", "ouiaId", "ouiaSafe", "tabIndex", "innerRef"]);
  const ouiaProps = useOUIAProps(Button.displayName, ouiaId, ouiaSafe, variant);
  const Component = component;
  const isButtonElement = Component === "button";
  const isInlineSpan = isInline && Component === "span";
  const preventedEvents2 = inoperableEvents.reduce((handlers, eventToPrevent) => Object.assign(Object.assign({}, handlers), {[eventToPrevent]: (event) => {
    event.preventDefault();
  }}), {});
  const getDefaultTabIdx = () => {
    if (isDisabled) {
      return isButtonElement ? null : -1;
    } else if (isAriaDisabled) {
      return null;
    } else if (isInlineSpan) {
      return 0;
    }
  };
  return react.createElement(Component, Object.assign({}, props, isAriaDisabled ? preventedEvents2 : null, {"aria-disabled": isDisabled || isAriaDisabled, "aria-label": ariaLabel, className: css(buttonStyles.button, buttonStyles.modifiers[variant], isBlock && buttonStyles.modifiers.block, isDisabled && buttonStyles.modifiers.disabled, isAriaDisabled && buttonStyles.modifiers.ariaDisabled, isActive && buttonStyles.modifiers.active, isInline && variant === ButtonVariant.link && buttonStyles.modifiers.inline, isDanger && (variant === ButtonVariant.secondary || variant === ButtonVariant.link) && buttonStyles.modifiers.danger, isLoading !== null && buttonStyles.modifiers.progress, isLoading && buttonStyles.modifiers.inProgress, isSmall && buttonStyles.modifiers.small, isLarge && buttonStyles.modifiers.displayLg, className), disabled: isButtonElement ? isDisabled : null, tabIndex: tabIndex !== null ? tabIndex : getDefaultTabIdx(), type: isButtonElement || isInlineSpan ? type : null, role: isInlineSpan ? "button" : null, ref: innerRef}, ouiaProps), isLoading && react.createElement("span", {className: css(buttonStyles.buttonProgress)}, react.createElement(Spinner, {size: spinnerSize.md, "aria-valuetext": spinnerAriaValueText})), variant !== ButtonVariant.plain && icon && iconPosition === "left" && react.createElement("span", {className: css(buttonStyles.buttonIcon, buttonStyles.modifiers.start)}, icon), children2, variant !== ButtonVariant.plain && icon && iconPosition === "right" && react.createElement("span", {className: css(buttonStyles.buttonIcon, buttonStyles.modifiers.end)}, icon));
};
var Button = react.forwardRef((props, ref) => react.createElement(ButtonBase, Object.assign({innerRef: ref}, props)));
Button.displayName = "Button";
var TimesIconConfig = {
  name: "TimesIcon",
  height: 512,
  width: 352,
  svgPath: "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z",
  yOffset: 0,
  xOffset: 0
};
var TimesIcon = createIcon(TimesIconConfig);
var tooltip = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    modifiers: {
      top: "pf-m-top",
      bottom: "pf-m-bottom",
      left: "pf-m-left",
      right: "pf-m-right",
      textAlignLeft: "pf-m-text-align-left"
    },
    tooltip: "pf-c-tooltip",
    tooltipArrow: "pf-c-tooltip__arrow",
    tooltipContent: "pf-c-tooltip__content"
  };
});
var styles$3 = /* @__PURE__ */ getDefaultExportFromCjs(tooltip);
var TooltipContent = (_a) => {
  var {className, children: children2, isLeftAligned} = _a, props = __rest(_a, ["className", "children", "isLeftAligned"]);
  return react.createElement("div", Object.assign({className: css(styles$3.tooltipContent, isLeftAligned && styles$3.modifiers.textAlignLeft, className)}, props), children2);
};
TooltipContent.displayName = "TooltipContent";
var TooltipArrow = (_a) => {
  var {className} = _a, props = __rest(_a, ["className"]);
  return react.createElement("div", Object.assign({className: css(styles$3.tooltipArrow, className)}, props));
};
TooltipArrow.displayName = "TooltipArrow";
var c_tooltip_MaxWidth = {
  name: "--pf-c-tooltip--MaxWidth",
  value: "18.75rem",
  var: "var(--pf-c-tooltip--MaxWidth)"
};
var TooltipPosition;
(function(TooltipPosition2) {
  TooltipPosition2["auto"] = "auto";
  TooltipPosition2["top"] = "top";
  TooltipPosition2["bottom"] = "bottom";
  TooltipPosition2["left"] = "left";
  TooltipPosition2["right"] = "right";
})(TooltipPosition || (TooltipPosition = {}));
var pfTooltipIdCounter = 1;
var Tooltip = (_a) => {
  var {
    content: bodyContent,
    position: position2 = "top",
    trigger = "mouseenter focus",
    isVisible = false,
    isContentLeftAligned = false,
    enableFlip = true,
    className = "",
    entryDelay = 300,
    exitDelay = 0,
    appendTo = () => document.body,
    zIndex = 9999,
    maxWidth = c_tooltip_MaxWidth.value,
    distance = 15,
    aria = "describedby",
    flipBehavior = ["top", "right", "bottom", "left", "top", "right", "bottom"],
    id: id3 = `pf-tooltip-${pfTooltipIdCounter++}`,
    children: children2,
    animationDuration = 300,
    reference: reference2,
    boundary,
    isAppLauncher,
    tippyProps
  } = _a, rest = __rest(_a, ["content", "position", "trigger", "isVisible", "isContentLeftAligned", "enableFlip", "className", "entryDelay", "exitDelay", "appendTo", "zIndex", "maxWidth", "distance", "aria", "flipBehavior", "id", "children", "animationDuration", "reference", "boundary", "isAppLauncher", "tippyProps"]);
  const triggerOnMouseenter = trigger.includes("mouseenter");
  const triggerOnFocus = trigger.includes("focus");
  const triggerOnClick = trigger.includes("click");
  const triggerManually = trigger === "manual";
  const [visible, setVisible] = react.useState(false);
  const [opacity, setOpacity] = react.useState(0);
  const transitionTimerRef = react.useRef(null);
  const showTimerRef = react.useRef(null);
  const hideTimerRef = react.useRef(null);
  const clearTimeouts = (timeoutRefs) => {
    timeoutRefs.forEach((ref) => {
      if (ref.current) {
        clearTimeout(ref.current);
      }
    });
  };
  react.useEffect(() => () => {
    clearTimeouts([transitionTimerRef, hideTimerRef, showTimerRef]);
  }, []);
  const onDocumentKeyDown = (event) => {
    if (!triggerManually) {
      if (event.keyCode === KEY_CODES.ESCAPE_KEY && visible) {
        hide2();
      }
    }
  };
  const onTriggerEnter = (event) => {
    if (event.keyCode === KEY_CODES.ENTER) {
      if (!visible) {
        show();
      } else {
        hide2();
      }
    }
  };
  react.useEffect(() => {
    if (isVisible) {
      show();
    } else {
      hide2();
    }
  }, [isVisible]);
  const show = () => {
    clearTimeouts([transitionTimerRef, hideTimerRef]);
    showTimerRef.current = setTimeout(() => {
      setVisible(true);
      setOpacity(1);
    }, entryDelay);
  };
  const hide2 = () => {
    clearTimeouts([showTimerRef]);
    hideTimerRef.current = setTimeout(() => {
      setOpacity(0);
      transitionTimerRef.current = setTimeout(() => setVisible(false), animationDuration);
    }, exitDelay);
  };
  const positionModifiers = {
    top: styles$3.modifiers.top,
    bottom: styles$3.modifiers.bottom,
    left: styles$3.modifiers.left,
    right: styles$3.modifiers.right
  };
  const hasCustomMaxWidth = maxWidth !== c_tooltip_MaxWidth.value;
  const content2 = react.createElement("div", Object.assign({className: css(styles$3.tooltip, className), role: "tooltip", id: id3, style: {
    maxWidth: hasCustomMaxWidth ? maxWidth : null,
    opacity,
    transition: getOpacityTransition(animationDuration)
  }}, rest), react.createElement(TooltipArrow, null), react.createElement(TooltipContent, {isLeftAligned: isContentLeftAligned}, bodyContent));
  const onDocumentClick = (event, triggerElement) => {
    {
      if (visible) {
        hide2();
      } else if (event.target === triggerElement) {
        show();
      }
    }
  };
  const addAriaToTrigger = () => {
    if (aria === "describedby" && children2 && children2.props && !children2.props["aria-describedby"]) {
      return react.cloneElement(children2, {"aria-describedby": id3});
    } else if (aria === "labelledby" && children2.props && !children2.props["aria-labelledby"]) {
      return react.cloneElement(children2, {"aria-labelledby": id3});
    }
    return children2;
  };
  return react.createElement(Popper, {trigger: aria !== "none" && visible ? addAriaToTrigger() : children2, reference: reference2, popper: content2, popperMatchesTriggerWidth: false, appendTo, isVisible: visible, positionModifiers, distance, placement: position2, onMouseEnter: triggerOnMouseenter && show, onMouseLeave: triggerOnMouseenter && hide2, onFocus: triggerOnFocus && show, onBlur: triggerOnFocus && hide2, onDocumentClick: triggerOnClick && onDocumentClick, onDocumentKeyDown: triggerManually ? null : onDocumentKeyDown, onTriggerEnter: triggerManually ? null : onTriggerEnter, enableFlip, zIndex, flipBehavior});
};
Tooltip.displayName = "Tooltip";
var dropdown = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    badge: "pf-c-badge",
    check: "pf-c-check",
    divider: "pf-c-divider",
    dropdown: "pf-c-dropdown",
    dropdownGroup: "pf-c-dropdown__group",
    dropdownGroupTitle: "pf-c-dropdown__group-title",
    dropdownMenu: "pf-c-dropdown__menu",
    dropdownMenuItem: "pf-c-dropdown__menu-item",
    dropdownMenuItemDescription: "pf-c-dropdown__menu-item-description",
    dropdownMenuItemIcon: "pf-c-dropdown__menu-item-icon",
    dropdownMenuItemMain: "pf-c-dropdown__menu-item-main",
    dropdownToggle: "pf-c-dropdown__toggle",
    dropdownToggleButton: "pf-c-dropdown__toggle-button",
    dropdownToggleCheck: "pf-c-dropdown__toggle-check",
    dropdownToggleIcon: "pf-c-dropdown__toggle-icon",
    dropdownToggleImage: "pf-c-dropdown__toggle-image",
    dropdownToggleText: "pf-c-dropdown__toggle-text",
    menu: "pf-c-menu",
    modifiers: {
      fullHeight: "pf-m-full-height",
      action: "pf-m-action",
      disabled: "pf-m-disabled",
      plain: "pf-m-plain",
      splitButton: "pf-m-split-button",
      active: "pf-m-active",
      expanded: "pf-m-expanded",
      primary: "pf-m-primary",
      top: "pf-m-top",
      alignRight: "pf-m-align-right",
      alignLeft: "pf-m-align-left",
      alignRightOnSm: "pf-m-align-right-on-sm",
      alignLeftOnSm: "pf-m-align-left-on-sm",
      alignRightOnMd: "pf-m-align-right-on-md",
      alignLeftOnMd: "pf-m-align-left-on-md",
      alignRightOnLg: "pf-m-align-right-on-lg",
      alignLeftOnLg: "pf-m-align-left-on-lg",
      alignRightOnXl: "pf-m-align-right-on-xl",
      alignLeftOnXl: "pf-m-align-left-on-xl",
      alignRightOn_2xl: "pf-m-align-right-on-2xl",
      alignLeftOn_2xl: "pf-m-align-left-on-2xl",
      ariaDisabled: "pf-m-aria-disabled",
      icon: "pf-m-icon",
      description: "pf-m-description",
      text: "pf-m-text"
    }
  };
});
var styles$4 = /* @__PURE__ */ getDefaultExportFromCjs(dropdown);
var DropdownPosition;
(function(DropdownPosition2) {
  DropdownPosition2["right"] = "right";
  DropdownPosition2["left"] = "left";
})(DropdownPosition || (DropdownPosition = {}));
var DropdownDirection;
(function(DropdownDirection2) {
  DropdownDirection2["up"] = "up";
  DropdownDirection2["down"] = "down";
})(DropdownDirection || (DropdownDirection = {}));
var DropdownContext = react.createContext({
  onSelect: (event) => void 0,
  id: "",
  toggleIndicatorClass: "",
  toggleIconClass: "",
  toggleTextClass: "",
  menuClass: "",
  itemClass: "",
  toggleClass: "",
  baseClass: "",
  baseComponent: "div",
  sectionClass: "",
  sectionTitleClass: "",
  sectionComponent: "section",
  disabledClass: "",
  plainTextClass: "",
  menuComponent: "ul"
});
var DropdownArrowContext = react.createContext({
  keyHandler: null,
  sendRef: null
});
var DropdownMenu = class extends react.Component {
  constructor() {
    super(...arguments);
    this.refsCollection = [];
    this.componentWillUnmount = () => {
      document.removeEventListener("keydown", this.onKeyDown);
    };
    this.onKeyDown = (event) => {
      if (!this.props.isOpen || !Array.from(document.activeElement.classList).find((className) => DropdownMenu.validToggleClasses.concat(this.context.toggleClass).includes(className))) {
        return;
      }
      const refs = this.refsCollection;
      if (event.key === "ArrowDown") {
        const firstFocusTargetCollection = refs.find((ref) => ref && ref[0] && !ref[0].hasAttribute("disabled"));
        DropdownMenu.focusFirstRef(firstFocusTargetCollection);
      } else if (event.key === "ArrowUp") {
        const collectionLength = refs.length;
        const lastFocusTargetCollection = refs.slice(collectionLength - 1, collectionLength);
        const lastFocusTarget = lastFocusTargetCollection && lastFocusTargetCollection[0];
        DropdownMenu.focusFirstRef(lastFocusTarget);
      }
    };
    this.childKeyHandler = (index3, innerIndex, position2, custom = false) => {
      keyHandler(index3, innerIndex, position2, this.refsCollection, this.props.isGrouped ? this.refsCollection : react.Children.toArray(this.props.children), custom);
    };
    this.sendRef = (index3, nodes, isDisabled, isSeparator) => {
      this.refsCollection[index3] = [];
      nodes.map((node, innerIndex) => {
        if (!node) {
          this.refsCollection[index3][innerIndex] = null;
        } else if (!node.getAttribute) {
          this.refsCollection[index3][innerIndex] = reactDom.findDOMNode(node);
        } else if (isSeparator) {
          this.refsCollection[index3][innerIndex] = null;
        } else {
          this.refsCollection[index3][innerIndex] = node;
        }
      });
    };
  }
  componentDidMount() {
    document.addEventListener("keydown", this.onKeyDown);
    const {autoFocus} = this.props;
    if (autoFocus) {
      const focusTargetCollection = this.refsCollection.find((ref) => ref && ref[0] && !ref[0].hasAttribute("disabled"));
      const focusTarget = focusTargetCollection && focusTargetCollection[0];
      if (focusTarget && focusTarget.focus) {
        setTimeout(() => focusTarget.focus());
      }
    }
  }
  shouldComponentUpdate() {
    this.refsCollection = [];
    return true;
  }
  extendChildren() {
    const {children: children2, isGrouped} = this.props;
    if (isGrouped) {
      let index3 = 0;
      return react.Children.map(children2, (groupedChildren) => {
        const group = groupedChildren;
        const props = {};
        if (group.props && group.props.children) {
          if (Array.isArray(group.props.children)) {
            props.children = react.Children.map(group.props.children, (option) => react.cloneElement(option, {
              index: index3++
            }));
          } else {
            props.children = react.cloneElement(group.props.children, {
              index: index3++
            });
          }
        }
        return react.cloneElement(group, props);
      });
    }
    return react.Children.map(children2, (child, index3) => react.cloneElement(child, {
      index: index3
    }));
  }
  render() {
    const _a = this.props, {
      className,
      isOpen,
      position: position2,
      children: children2,
      component,
      isGrouped,
      setMenuComponentRef,
      openedOnEnter,
      alignments
    } = _a, props = __rest(_a, ["className", "isOpen", "position", "children", "component", "isGrouped", "setMenuComponentRef", "openedOnEnter", "alignments"]);
    return react.createElement(DropdownArrowContext.Provider, {value: {
      keyHandler: this.childKeyHandler,
      sendRef: this.sendRef
    }}, component === "div" ? react.createElement(DropdownContext.Consumer, null, ({onSelect, menuClass}) => react.createElement("div", {className: css(menuClass, position2 === DropdownPosition.right && styles$4.modifiers.alignRight, formatBreakpointMods(alignments, styles$4, "align-"), className), hidden: !isOpen, onClick: (event) => onSelect && onSelect(event), ref: setMenuComponentRef}, children2)) : isGrouped && react.createElement(DropdownContext.Consumer, null, ({menuClass, menuComponent}) => {
      const MenuComponent = menuComponent || "div";
      return react.createElement(MenuComponent, Object.assign({}, props, {className: css(menuClass, position2 === DropdownPosition.right && styles$4.modifiers.alignRight, formatBreakpointMods(alignments, styles$4, "align-"), className), hidden: !isOpen, role: "menu", ref: setMenuComponentRef}), this.extendChildren());
    }) || react.createElement(DropdownContext.Consumer, null, ({menuClass, menuComponent}) => {
      const MenuComponent = menuComponent || component;
      return react.createElement(MenuComponent, Object.assign({}, props, {className: css(menuClass, position2 === DropdownPosition.right && styles$4.modifiers.alignRight, formatBreakpointMods(alignments, styles$4, "align-"), className), hidden: !isOpen, role: "menu", ref: setMenuComponentRef}), this.extendChildren());
    }));
  }
};
DropdownMenu.displayName = "DropdownMenu";
DropdownMenu.defaultProps = {
  className: "",
  isOpen: true,
  openedOnEnter: false,
  autoFocus: true,
  position: DropdownPosition.left,
  component: "ul",
  isGrouped: false,
  setMenuComponentRef: null
};
DropdownMenu.validToggleClasses = [styles$4.dropdownToggle, styles$4.dropdownToggleButton];
DropdownMenu.focusFirstRef = (refCollection) => {
  if (refCollection && refCollection[0] && refCollection[0].focus) {
    setTimeout(() => refCollection[0].focus());
  }
};
DropdownMenu.contextType = DropdownContext;
var DropdownWithContext = class extends react.Component {
  constructor(props) {
    super(props);
    this.openedOnEnter = false;
    this.baseComponentRef = react.createRef();
    this.menuComponentRef = react.createRef();
    this.onEnter = () => {
      this.openedOnEnter = true;
    };
    this.setMenuComponentRef = (element) => {
      this.menuComponentRef = element;
    };
    this.getMenuComponentRef = () => this.menuComponentRef;
    if (props.dropdownItems && props.dropdownItems.length > 0 && props.children) {
      console.error("Children and dropdownItems props have been provided. Only the dropdownItems prop items will be rendered");
    }
  }
  componentDidUpdate() {
    if (!this.props.isOpen) {
      this.openedOnEnter = false;
    }
  }
  render() {
    const _a = this.props, {
      children: children2,
      className,
      direction,
      dropdownItems,
      isOpen,
      isPlain,
      isGrouped,
      onSelect,
      position: position2,
      toggle,
      autoFocus,
      menuAppendTo
    } = _a, props = __rest(_a, ["children", "className", "direction", "dropdownItems", "isOpen", "isPlain", "isGrouped", "onSelect", "position", "toggle", "autoFocus", "menuAppendTo"]);
    const id3 = toggle.props.id || `pf-dropdown-toggle-id-${DropdownWithContext.currentId++}`;
    let component;
    let renderedContent;
    let ariaHasPopup = false;
    if (dropdownItems && dropdownItems.length > 0) {
      component = "ul";
      renderedContent = dropdownItems;
      ariaHasPopup = true;
    } else {
      component = "div";
      renderedContent = react.Children.toArray(children2);
    }
    const openedOnEnter = this.openedOnEnter;
    return react.createElement(DropdownContext.Consumer, null, ({baseClass, baseComponent, id: contextId, ouiaId, ouiaComponentType, ouiaSafe, alignments}) => {
      const BaseComponent = baseComponent;
      const menuContainer = react.createElement(DropdownMenu, {setMenuComponentRef: this.setMenuComponentRef, component, isOpen, position: position2, "aria-labelledby": contextId ? `${contextId}-toggle` : id3, isGrouped, autoFocus: openedOnEnter && autoFocus, alignments}, renderedContent);
      const popperContainer = react.createElement("div", {className: css(baseClass, direction === DropdownDirection.up && styles$4.modifiers.top, position2 === DropdownPosition.right && styles$4.modifiers.alignRight, isOpen && styles$4.modifiers.expanded, className)}, isOpen && menuContainer);
      const mainContainer = react.createElement(BaseComponent, Object.assign({}, props, {className: css(baseClass, direction === DropdownDirection.up && styles$4.modifiers.top, position2 === DropdownPosition.right && styles$4.modifiers.alignRight, isOpen && styles$4.modifiers.expanded, className), ref: this.baseComponentRef}, getOUIAProps(ouiaComponentType, ouiaId, ouiaSafe)), react.Children.map(toggle, (oneToggle) => react.cloneElement(oneToggle, {
        parentRef: this.baseComponentRef,
        getMenuRef: this.getMenuComponentRef,
        isOpen,
        id: id3,
        isPlain,
        "aria-haspopup": ariaHasPopup,
        onEnter: () => {
          this.onEnter();
          oneToggle.props.onEnter && oneToggle.props.onEnter();
        }
      })), menuAppendTo === "inline" && isOpen && menuContainer);
      const getParentElement = () => {
        if (this.baseComponentRef && this.baseComponentRef.current) {
          return this.baseComponentRef.current.parentElement;
        }
        return null;
      };
      return menuAppendTo === "inline" ? mainContainer : react.createElement(Popper, {trigger: mainContainer, popper: popperContainer, direction, position: position2, appendTo: menuAppendTo === "parent" ? getParentElement() : menuAppendTo, isVisible: isOpen});
    });
  }
};
DropdownWithContext.displayName = "DropdownWithContext";
DropdownWithContext.currentId = 0;
DropdownWithContext.defaultProps = {
  className: "",
  dropdownItems: [],
  isOpen: false,
  isPlain: false,
  isGrouped: false,
  position: DropdownPosition.left,
  direction: DropdownDirection.down,
  onSelect: () => void 0,
  autoFocus: true,
  menuAppendTo: "inline"
};
var Dropdown = (_a) => {
  var {
    onSelect,
    ref,
    ouiaId,
    ouiaSafe,
    alignments,
    contextProps
  } = _a, props = __rest(_a, ["onSelect", "ref", "ouiaId", "ouiaSafe", "alignments", "contextProps"]);
  return react.createElement(DropdownContext.Provider, {value: Object.assign({onSelect: (event) => onSelect && onSelect(event), toggleTextClass: styles$4.dropdownToggleText, toggleIconClass: styles$4.dropdownToggleImage, toggleIndicatorClass: styles$4.dropdownToggleIcon, menuClass: styles$4.dropdownMenu, itemClass: styles$4.dropdownMenuItem, toggleClass: styles$4.dropdownToggle, baseClass: styles$4.dropdown, baseComponent: "div", sectionClass: styles$4.dropdownGroup, sectionTitleClass: styles$4.dropdownGroupTitle, sectionComponent: "section", disabledClass: styles$4.modifiers.disabled, plainTextClass: styles$4.modifiers.text, ouiaId: useOUIAId(Dropdown.displayName, ouiaId), ouiaSafe, ouiaComponentType: Dropdown.displayName, alignments}, contextProps)}, react.createElement(DropdownWithContext, Object.assign({}, props)));
};
Dropdown.displayName = "Dropdown";
var InternalDropdownItem = class extends react.Component {
  constructor() {
    super(...arguments);
    this.ref = react.createRef();
    this.additionalRef = react.createRef();
    this.getInnerNode = (node) => node && node.childNodes && node.childNodes.length ? node.childNodes[0] : node;
    this.onKeyDown = (event) => {
      const innerIndex = event.target === this.ref.current ? 0 : 1;
      if (!this.props.customChild) {
        event.preventDefault();
      }
      if (event.key === "ArrowUp") {
        this.props.context.keyHandler(this.props.index, innerIndex, KEYHANDLER_DIRECTION.UP);
      } else if (event.key === "ArrowDown") {
        this.props.context.keyHandler(this.props.index, innerIndex, KEYHANDLER_DIRECTION.DOWN);
      } else if (event.key === "ArrowRight") {
        this.props.context.keyHandler(this.props.index, innerIndex, KEYHANDLER_DIRECTION.RIGHT);
      } else if (event.key === "ArrowLeft") {
        this.props.context.keyHandler(this.props.index, innerIndex, KEYHANDLER_DIRECTION.LEFT);
      } else if (event.key === "Enter" || event.key === " ") {
        event.target.click();
        this.props.enterTriggersArrowDown && this.props.context.keyHandler(this.props.index, innerIndex, KEYHANDLER_DIRECTION.DOWN);
      }
    };
    this.componentRef = (element) => {
      this.ref.current = element;
      const {component} = this.props;
      const ref = component.ref;
      if (ref) {
        if (typeof ref === "function") {
          ref(element);
        } else {
          ref.current = element;
        }
      }
    };
  }
  componentDidMount() {
    const {context: context2, index: index3, isDisabled, role, customChild, autoFocus} = this.props;
    const customRef = customChild ? this.getInnerNode(this.ref.current) : this.ref.current;
    context2.sendRef(index3, [customRef, customChild ? customRef : this.additionalRef.current], isDisabled, role === "separator");
    autoFocus && setTimeout(() => customRef.focus());
  }
  componentDidUpdate() {
    const {context: context2, index: index3, isDisabled, role, customChild} = this.props;
    const customRef = customChild ? this.getInnerNode(this.ref.current) : this.ref.current;
    context2.sendRef(index3, [customRef, customChild ? customRef : this.additionalRef.current], isDisabled, role === "separator");
  }
  extendAdditionalChildRef() {
    const {additionalChild} = this.props;
    return react.cloneElement(additionalChild, {
      ref: this.additionalRef
    });
  }
  render() {
    const _a = this.props, {className, children: children2, isHovered, context: context2, onClick, component, role, isDisabled, isAriaDisabled, isPlainText, index: index3, href, tooltip: tooltip2, tooltipProps, id: id3, componentID, listItemClassName, additionalChild, customChild, enterTriggersArrowDown, icon, autoFocus, styleChildren, description, inoperableEvents} = _a, additionalProps = __rest(_a, ["className", "children", "isHovered", "context", "onClick", "component", "role", "isDisabled", "isAriaDisabled", "isPlainText", "index", "href", "tooltip", "tooltipProps", "id", "componentID", "listItemClassName", "additionalChild", "customChild", "enterTriggersArrowDown", "icon", "autoFocus", "styleChildren", "description", "inoperableEvents"]);
    let classes = css(icon && styles$4.modifiers.icon, isAriaDisabled && styles$4.modifiers.ariaDisabled, className);
    if (component === "a") {
      additionalProps["aria-disabled"] = isDisabled || isAriaDisabled;
    } else if (component === "button") {
      additionalProps["aria-disabled"] = isDisabled || isAriaDisabled;
      additionalProps.type = additionalProps.type || "button";
    }
    const renderWithTooltip = (childNode) => tooltip2 ? react.createElement(Tooltip, Object.assign({content: tooltip2}, tooltipProps), childNode) : childNode;
    const renderClonedComponent = (element) => react.cloneElement(element, Object.assign(Object.assign({}, styleChildren && {
      className: css(element.props.className, classes)
    }), this.props.role !== "separator" && {ref: this.componentRef}));
    const renderDefaultComponent = (tag) => {
      const Component = tag;
      const componentContent = description ? react.createElement(react.Fragment, null, react.createElement("div", {className: styles$4.dropdownMenuItemMain}, icon && react.createElement("span", {className: css(styles$4.dropdownMenuItemIcon)}, icon), children2), react.createElement("div", {className: styles$4.dropdownMenuItemDescription}, description)) : react.createElement(react.Fragment, null, icon && react.createElement("span", {className: css(styles$4.dropdownMenuItemIcon)}, icon), children2);
      return react.createElement(Component, Object.assign({}, additionalProps, isDisabled || isAriaDisabled ? preventedEvents(inoperableEvents) : null, {href, ref: this.ref, className: classes, id: componentID}), componentContent);
    };
    return react.createElement(DropdownContext.Consumer, null, ({onSelect, itemClass, disabledClass, plainTextClass}) => {
      if (this.props.role !== "separator") {
        classes = css(classes, isDisabled && disabledClass, isPlainText && plainTextClass, itemClass, description && styles$4.modifiers.description);
      }
      if (customChild) {
        return react.cloneElement(customChild, {
          ref: this.ref,
          onKeyDown: this.onKeyDown
        });
      }
      return react.createElement("li", {className: listItemClassName || null, role, onKeyDown: this.onKeyDown, onClick: (event) => {
        if (!isDisabled && !isAriaDisabled) {
          onClick(event);
          onSelect(event);
        }
      }, id: id3}, renderWithTooltip(react.isValidElement(component) ? renderClonedComponent(component) : renderDefaultComponent(component)), additionalChild && this.extendAdditionalChildRef());
    });
  }
};
InternalDropdownItem.displayName = "InternalDropdownItem";
InternalDropdownItem.defaultProps = {
  className: "",
  isHovered: false,
  component: "a",
  role: "none",
  isDisabled: false,
  isPlainText: false,
  tooltipProps: {},
  onClick: (event) => void 0,
  index: -1,
  context: {
    keyHandler: () => {
    },
    sendRef: () => {
    }
  },
  enterTriggersArrowDown: false,
  icon: null,
  styleChildren: true,
  description: null,
  inoperableEvents: ["onClick", "onKeyPress"]
};
var DropdownItem = (_a) => {
  var {
    children: children2,
    className,
    component = "a",
    isDisabled = false,
    isAriaDisabled = false,
    isPlainText = false,
    isHovered = false,
    href,
    tooltip: tooltip2,
    tooltipProps = {},
    listItemClassName,
    onClick,
    ref,
    additionalChild,
    customChild,
    tabIndex = -1,
    icon = null,
    autoFocus,
    description = null,
    styleChildren,
    ouiaId,
    ouiaSafe
  } = _a, props = __rest(_a, ["children", "className", "component", "isDisabled", "isAriaDisabled", "isPlainText", "isHovered", "href", "tooltip", "tooltipProps", "listItemClassName", "onClick", "ref", "additionalChild", "customChild", "tabIndex", "icon", "autoFocus", "description", "styleChildren", "ouiaId", "ouiaSafe"]);
  const ouiaProps = useOUIAProps(DropdownItem.displayName, ouiaId, ouiaSafe);
  return react.createElement(DropdownArrowContext.Consumer, null, (context2) => react.createElement(InternalDropdownItem, Object.assign({context: context2, role: "menuitem", tabIndex, className, component, isDisabled, isAriaDisabled, isPlainText, isHovered, href, tooltip: tooltip2, tooltipProps, listItemClassName, onClick, additionalChild, customChild, icon, autoFocus, styleChildren, description}, ouiaProps, props), children2));
};
DropdownItem.displayName = "DropdownItem";
var divider = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    divider: "pf-c-divider",
    modifiers: {
      vertical: "pf-m-vertical",
      insetNone: "pf-m-inset-none",
      insetXs: "pf-m-inset-xs",
      insetSm: "pf-m-inset-sm",
      insetMd: "pf-m-inset-md",
      insetLg: "pf-m-inset-lg",
      insetXl: "pf-m-inset-xl",
      inset_2xl: "pf-m-inset-2xl",
      inset_3xl: "pf-m-inset-3xl",
      insetNoneOnSm: "pf-m-inset-none-on-sm",
      insetXsOnSm: "pf-m-inset-xs-on-sm",
      insetSmOnSm: "pf-m-inset-sm-on-sm",
      insetMdOnSm: "pf-m-inset-md-on-sm",
      insetLgOnSm: "pf-m-inset-lg-on-sm",
      insetXlOnSm: "pf-m-inset-xl-on-sm",
      inset_2xlOnSm: "pf-m-inset-2xl-on-sm",
      inset_3xlOnSm: "pf-m-inset-3xl-on-sm",
      insetNoneOnMd: "pf-m-inset-none-on-md",
      insetXsOnMd: "pf-m-inset-xs-on-md",
      insetSmOnMd: "pf-m-inset-sm-on-md",
      insetMdOnMd: "pf-m-inset-md-on-md",
      insetLgOnMd: "pf-m-inset-lg-on-md",
      insetXlOnMd: "pf-m-inset-xl-on-md",
      inset_2xlOnMd: "pf-m-inset-2xl-on-md",
      inset_3xlOnMd: "pf-m-inset-3xl-on-md",
      insetNoneOnLg: "pf-m-inset-none-on-lg",
      insetXsOnLg: "pf-m-inset-xs-on-lg",
      insetSmOnLg: "pf-m-inset-sm-on-lg",
      insetMdOnLg: "pf-m-inset-md-on-lg",
      insetLgOnLg: "pf-m-inset-lg-on-lg",
      insetXlOnLg: "pf-m-inset-xl-on-lg",
      inset_2xlOnLg: "pf-m-inset-2xl-on-lg",
      inset_3xlOnLg: "pf-m-inset-3xl-on-lg",
      insetNoneOnXl: "pf-m-inset-none-on-xl",
      insetXsOnXl: "pf-m-inset-xs-on-xl",
      insetSmOnXl: "pf-m-inset-sm-on-xl",
      insetMdOnXl: "pf-m-inset-md-on-xl",
      insetLgOnXl: "pf-m-inset-lg-on-xl",
      insetXlOnXl: "pf-m-inset-xl-on-xl",
      inset_2xlOnXl: "pf-m-inset-2xl-on-xl",
      inset_3xlOnXl: "pf-m-inset-3xl-on-xl",
      insetNoneOn_2xl: "pf-m-inset-none-on-2xl",
      insetXsOn_2xl: "pf-m-inset-xs-on-2xl",
      insetSmOn_2xl: "pf-m-inset-sm-on-2xl",
      insetMdOn_2xl: "pf-m-inset-md-on-2xl",
      insetLgOn_2xl: "pf-m-inset-lg-on-2xl",
      insetXlOn_2xl: "pf-m-inset-xl-on-2xl",
      inset_2xlOn_2xl: "pf-m-inset-2xl-on-2xl",
      inset_3xlOn_2xl: "pf-m-inset-3xl-on-2xl"
    }
  };
});
var styles$5 = /* @__PURE__ */ getDefaultExportFromCjs(divider);
var DividerVariant;
(function(DividerVariant2) {
  DividerVariant2["hr"] = "hr";
  DividerVariant2["li"] = "li";
  DividerVariant2["div"] = "div";
})(DividerVariant || (DividerVariant = {}));
var Divider = (_a) => {
  var {className, component = DividerVariant.hr, isVertical = false, inset} = _a, props = __rest(_a, ["className", "component", "isVertical", "inset"]);
  const Component = component;
  return react.createElement(Component, Object.assign({className: css(styles$5.divider, isVertical && styles$5.modifiers.vertical, formatBreakpointMods(inset, styles$5), className)}, component !== "hr" && {role: "separator"}, props));
};
Divider.displayName = "Divider";
var DropdownSeparator = (_a) => {
  var {
    className = "",
    ref,
    ouiaId,
    ouiaSafe
  } = _a, props = __rest(_a, ["className", "ref", "ouiaId", "ouiaSafe"]);
  const ouiaProps = useOUIAProps(DropdownSeparator.displayName, ouiaId, ouiaSafe);
  return react.createElement(DropdownArrowContext.Consumer, null, (context2) => react.createElement(InternalDropdownItem, Object.assign({}, props, {context: context2, component: react.createElement(Divider, {component: DividerVariant.div}), className, role: "separator"}, ouiaProps)));
};
DropdownSeparator.displayName = "DropdownSeparator";
var Toggle = class extends react.Component {
  constructor() {
    super(...arguments);
    this.buttonRef = react.createRef();
    this.componentDidMount = () => {
      document.addEventListener("click", this.onDocClick);
      document.addEventListener("touchstart", this.onDocClick);
      document.addEventListener("keydown", this.onEscPress);
    };
    this.componentWillUnmount = () => {
      document.removeEventListener("click", this.onDocClick);
      document.removeEventListener("touchstart", this.onDocClick);
      document.removeEventListener("keydown", this.onEscPress);
    };
    this.onDocClick = (event) => {
      const {isOpen, parentRef, onToggle, getMenuRef} = this.props;
      const menuRef = getMenuRef && getMenuRef();
      const clickedOnToggle = parentRef && parentRef.current && parentRef.current.contains(event.target);
      const clickedWithinMenu = menuRef && menuRef.contains && menuRef.contains(event.target);
      if (isOpen && !(clickedOnToggle || clickedWithinMenu)) {
        onToggle(false, event);
      }
    };
    this.onEscPress = (event) => {
      const {parentRef, getMenuRef} = this.props;
      const keyCode = event.keyCode || event.which;
      const menuRef = getMenuRef && getMenuRef();
      const escFromToggle = parentRef && parentRef.current && parentRef.current.contains(event.target);
      const escFromWithinMenu = menuRef && menuRef.contains && menuRef.contains(event.target);
      if (this.props.isOpen && (keyCode === KEY_CODES.ESCAPE_KEY || event.key === "Tab") && (escFromToggle || escFromWithinMenu)) {
        this.props.onToggle(false, event);
        this.buttonRef.current.focus();
      }
    };
    this.onKeyDown = (event) => {
      if (event.key === "Tab" && !this.props.isOpen) {
        return;
      }
      if ((event.key === "Tab" || event.key === "Enter" || event.key === " ") && this.props.isOpen) {
        if (!this.props.bubbleEvent) {
          event.stopPropagation();
        }
        event.preventDefault();
        this.props.onToggle(!this.props.isOpen, event);
      } else if ((event.key === "Enter" || event.key === " " || event.key === "ArrowDown") && !this.props.isOpen) {
        if (!this.props.bubbleEvent) {
          event.stopPropagation();
        }
        event.preventDefault();
        this.props.onToggle(!this.props.isOpen, event);
        this.props.onEnter();
      }
    };
  }
  render() {
    const _a = this.props, {
      className,
      children: children2,
      isOpen,
      isDisabled,
      isPlain,
      isPrimary,
      isSplitButton,
      onToggle,
      "aria-haspopup": ariaHasPopup,
      isActive,
      bubbleEvent,
      onEnter,
      parentRef,
      getMenuRef,
      id: id3,
      type
    } = _a, props = __rest(_a, ["className", "children", "isOpen", "isDisabled", "isPlain", "isPrimary", "isSplitButton", "onToggle", "aria-haspopup", "isActive", "bubbleEvent", "onEnter", "parentRef", "getMenuRef", "id", "type"]);
    return react.createElement(DropdownContext.Consumer, null, ({toggleClass}) => react.createElement("button", Object.assign({}, props, {id: id3, ref: this.buttonRef, className: css(isSplitButton ? styles$4.dropdownToggleButton : toggleClass || styles$4.dropdownToggle, isActive && styles$4.modifiers.active, isPlain && styles$4.modifiers.plain, isPrimary && styles$4.modifiers.primary, className), type: type || "button", onClick: (event) => onToggle(!isOpen, event), "aria-expanded": isOpen, "aria-haspopup": ariaHasPopup, onKeyDown: (event) => this.onKeyDown(event), disabled: isDisabled}), children2));
  }
};
Toggle.displayName = "Toggle";
Toggle.defaultProps = {
  className: "",
  isOpen: false,
  isActive: false,
  isDisabled: false,
  isPlain: false,
  isPrimary: false,
  isSplitButton: false,
  onToggle: () => {
  },
  onEnter: () => {
  },
  bubbleEvent: false
};
var EllipsisVIconConfig = {
  name: "EllipsisVIcon",
  height: 512,
  width: 192,
  svgPath: "M96 184c39.8 0 72 32.2 72 72s-32.2 72-72 72-72-32.2-72-72 32.2-72 72-72zM24 80c0 39.8 32.2 72 72 72s72-32.2 72-72S135.8 8 96 8 24 40.2 24 80zm0 352c0 39.8 32.2 72 72 72s72-32.2 72-72-32.2-72-72-72-72 32.2-72 72z",
  yOffset: 0,
  xOffset: 0
};
var EllipsisVIcon = createIcon(EllipsisVIconConfig);
var KebabToggle = (_a) => {
  var {
    id: id3 = "",
    children: children2 = null,
    className = "",
    isOpen = false,
    "aria-label": ariaLabel = "Actions",
    parentRef = null,
    getMenuRef = null,
    isActive = false,
    isPlain = false,
    isDisabled = false,
    bubbleEvent = false,
    onToggle = () => void 0,
    ref
  } = _a, props = __rest(_a, ["id", "children", "className", "isOpen", "aria-label", "parentRef", "getMenuRef", "isActive", "isPlain", "isDisabled", "bubbleEvent", "onToggle", "ref"]);
  return react.createElement(Toggle, Object.assign({id: id3, className, isOpen, "aria-label": ariaLabel, parentRef, getMenuRef, isActive, isPlain, isDisabled, onToggle, bubbleEvent}, props), react.createElement(EllipsisVIcon, null));
};
KebabToggle.displayName = "KebabToggle";
var StarIconConfig = {
  name: "StarIcon",
  height: 512,
  width: 576,
  svgPath: "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z",
  yOffset: 0,
  xOffset: 0
};
var StarIcon = createIcon(StarIconConfig);
var check = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    check: "pf-c-check",
    checkBody: "pf-c-check__body",
    checkDescription: "pf-c-check__description",
    checkInput: "pf-c-check__input",
    checkLabel: "pf-c-check__label",
    modifiers: {
      standalone: "pf-m-standalone",
      disabled: "pf-m-disabled"
    }
  };
});
var checkStyles = /* @__PURE__ */ getDefaultExportFromCjs(check);
var defaultOnChange = () => {
};
var Checkbox = class extends react.Component {
  constructor(props) {
    super(props);
    this.handleChange = (event) => {
      this.props.onChange(event.currentTarget.checked, event);
    };
    this.state = {
      ouiaStateId: getDefaultOUIAId(Checkbox.displayName)
    };
  }
  render() {
    const _a = this.props, {"aria-label": ariaLabel, className, onChange, isValid, isDisabled, isChecked, label: label2, checked, defaultChecked, description, body, ouiaId, ouiaSafe} = _a, props = __rest(_a, ["aria-label", "className", "onChange", "isValid", "isDisabled", "isChecked", "label", "checked", "defaultChecked", "description", "body", "ouiaId", "ouiaSafe"]);
    if (!props.id) {
      console.error("Checkbox:", "id is required to make input accessible");
    }
    const checkedProps = {};
    if ([true, false].includes(checked) || isChecked === true) {
      checkedProps.checked = checked || isChecked;
    }
    if (onChange !== defaultOnChange) {
      checkedProps.checked = isChecked;
    }
    if ([false, true].includes(defaultChecked)) {
      checkedProps.defaultChecked = defaultChecked;
    }
    checkedProps.checked = checkedProps.checked === null ? false : checkedProps.checked;
    return react.createElement("div", {className: css(checkStyles.check, !label2 && checkStyles.modifiers.standalone, className)}, react.createElement("input", Object.assign({}, props, {className: css(checkStyles.checkInput), type: "checkbox", onChange: this.handleChange, "aria-invalid": !isValid, "aria-label": ariaLabel, disabled: isDisabled, ref: (elem) => elem && (elem.indeterminate = isChecked === null)}, checkedProps, getOUIAProps(Checkbox.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe))), label2 && react.createElement("label", {className: css(checkStyles.checkLabel, isDisabled && checkStyles.modifiers.disabled), htmlFor: props.id}, label2), description && react.createElement("span", {className: css(checkStyles.checkDescription)}, description), body && react.createElement("span", {className: css(checkStyles.checkBody)}, body));
  }
};
Checkbox.displayName = "Checkbox";
Checkbox.defaultProps = {
  className: "",
  isValid: true,
  isDisabled: false,
  isChecked: false,
  onChange: defaultOnChange,
  ouiaSafe: true
};
var AngleDownIconConfig = {
  name: "AngleDownIcon",
  height: 512,
  width: 320,
  svgPath: "M143 352.3L7 216.3c-9.4-9.4-9.4-24.6 0-33.9l22.6-22.6c9.4-9.4 24.6-9.4 33.9 0l96.4 96.4 96.4-96.4c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9l-136 136c-9.2 9.4-24.4 9.4-33.8 0z",
  yOffset: 0,
  xOffset: 0
};
var AngleDownIcon = createIcon(AngleDownIconConfig);
var GripVerticalIconConfig = {
  name: "GripVerticalIcon",
  height: 512,
  width: 320,
  svgPath: "M96 32H32C14.33 32 0 46.33 0 64v64c0 17.67 14.33 32 32 32h64c17.67 0 32-14.33 32-32V64c0-17.67-14.33-32-32-32zm0 160H32c-17.67 0-32 14.33-32 32v64c0 17.67 14.33 32 32 32h64c17.67 0 32-14.33 32-32v-64c0-17.67-14.33-32-32-32zm0 160H32c-17.67 0-32 14.33-32 32v64c0 17.67 14.33 32 32 32h64c17.67 0 32-14.33 32-32v-64c0-17.67-14.33-32-32-32zM288 32h-64c-17.67 0-32 14.33-32 32v64c0 17.67 14.33 32 32 32h64c17.67 0 32-14.33 32-32V64c0-17.67-14.33-32-32-32zm0 160h-64c-17.67 0-32 14.33-32 32v64c0 17.67 14.33 32 32 32h64c17.67 0 32-14.33 32-32v-64c0-17.67-14.33-32-32-32zm0 160h-64c-17.67 0-32 14.33-32 32v64c0 17.67 14.33 32 32 32h64c17.67 0 32-14.33 32-32v-64c0-17.67-14.33-32-32-32z",
  yOffset: 0,
  xOffset: 0
};
var GripVerticalIcon = createIcon(GripVerticalIconConfig);
var popover = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    button: "pf-c-button",
    modifiers: {
      noPadding: "pf-m-no-padding",
      widthAuto: "pf-m-width-auto",
      top: "pf-m-top",
      topLeft: "pf-m-top-left",
      topRight: "pf-m-top-right",
      bottom: "pf-m-bottom",
      bottomLeft: "pf-m-bottom-left",
      bottomRight: "pf-m-bottom-right",
      left: "pf-m-left",
      leftTop: "pf-m-left-top",
      leftBottom: "pf-m-left-bottom",
      right: "pf-m-right",
      rightTop: "pf-m-right-top",
      rightBottom: "pf-m-right-bottom"
    },
    popover: "pf-c-popover",
    popoverArrow: "pf-c-popover__arrow",
    popoverBody: "pf-c-popover__body",
    popoverContent: "pf-c-popover__content",
    popoverFooter: "pf-c-popover__footer",
    title: "pf-c-title"
  };
});
var styles$6 = /* @__PURE__ */ getDefaultExportFromCjs(popover);
var PopoverContent = (_a) => {
  var {className = null, children: children2} = _a, props = __rest(_a, ["className", "children"]);
  return react.createElement("div", Object.assign({className: css(styles$6.popoverContent, className)}, props), children2);
};
PopoverContent.displayName = "PopoverContent";
var PopoverBody = (_a) => {
  var {children: children2, id: id3} = _a, props = __rest(_a, ["children", "id"]);
  return react.createElement("div", Object.assign({className: css(styles$6.popoverBody), id: id3}, props), children2);
};
PopoverBody.displayName = "PopoverBody";
var PopoverHeader = (_a) => {
  var {children: children2, id: id3} = _a, props = __rest(_a, ["children", "id"]);
  return react.createElement(Title, Object.assign({headingLevel: "h6", size: TitleSizes.md, id: id3}, props), children2);
};
PopoverHeader.displayName = "PopoverHeader";
var PopoverFooter = (_a) => {
  var {children: children2, className = ""} = _a, props = __rest(_a, ["children", "className"]);
  return react.createElement("footer", Object.assign({className: css(styles$6.popoverFooter, className)}, props), children2);
};
PopoverFooter.displayName = "PopoverFooter";
var PopoverCloseButton = (_a) => {
  var {onClose = () => void 0} = _a, props = __rest(_a, ["onClose"]);
  const [closeButtonElement, setCloseButtonElement] = react.useState(null);
  react.useEffect(() => {
    closeButtonElement && closeButtonElement.addEventListener("click", onClose, false);
    return () => {
      closeButtonElement && closeButtonElement.removeEventListener("click", onClose, false);
    };
  }, [closeButtonElement]);
  return react.createElement(FindRefWrapper, {onFoundRef: (foundRef) => setCloseButtonElement(foundRef)}, react.createElement(Button, Object.assign({variant: "plain", "aria-label": true}, props, {style: {pointerEvents: "auto"}}), react.createElement(TimesIcon, null)));
};
PopoverCloseButton.displayName = "PopoverCloseButton";
var PopoverArrow = (_a) => {
  var {className = ""} = _a, props = __rest(_a, ["className"]);
  return react.createElement("div", Object.assign({className: css(styles$6.popoverArrow, className)}, props));
};
PopoverArrow.displayName = "PopoverArrow";
var c_popover_MaxWidth = {
  name: "--pf-c-popover--MaxWidth",
  value: "none",
  var: "var(--pf-c-popover--MaxWidth)"
};
var c_popover_MinWidth = {
  name: "--pf-c-popover--MinWidth",
  value: "auto",
  var: "var(--pf-c-popover--MinWidth)"
};
var PopoverPosition;
(function(PopoverPosition2) {
  PopoverPosition2["auto"] = "auto";
  PopoverPosition2["top"] = "top";
  PopoverPosition2["bottom"] = "bottom";
  PopoverPosition2["left"] = "left";
  PopoverPosition2["right"] = "right";
})(PopoverPosition || (PopoverPosition = {}));
var Popover = (_a) => {
  var {
    children: children2,
    position: position2 = "top",
    enableFlip = true,
    className = "",
    isVisible = null,
    shouldClose = () => null,
    shouldOpen = () => null,
    "aria-label": ariaLabel = "",
    bodyContent,
    headerContent = null,
    footerContent = null,
    appendTo = () => document.body,
    hideOnOutsideClick = true,
    onHide = () => null,
    onHidden = () => null,
    onShow = () => null,
    onShown = () => null,
    onMount = () => null,
    zIndex = 9999,
    minWidth = c_popover_MinWidth && c_popover_MinWidth.value,
    maxWidth = c_popover_MaxWidth && c_popover_MaxWidth.value,
    closeBtnAriaLabel = "Close",
    showClose = true,
    distance = 25,
    flipBehavior = ["top", "right", "bottom", "left", "top", "right", "bottom"],
    animationDuration = 300,
    id: id3,
    withFocusTrap: propWithFocusTrap,
    boundary,
    tippyProps,
    reference: reference2,
    hasNoPadding = false,
    hasAutoWidth = false
  } = _a, rest = __rest(_a, ["children", "position", "enableFlip", "className", "isVisible", "shouldClose", "shouldOpen", "aria-label", "bodyContent", "headerContent", "footerContent", "appendTo", "hideOnOutsideClick", "onHide", "onHidden", "onShow", "onShown", "onMount", "zIndex", "minWidth", "maxWidth", "closeBtnAriaLabel", "showClose", "distance", "flipBehavior", "animationDuration", "id", "withFocusTrap", "boundary", "tippyProps", "reference", "hasNoPadding", "hasAutoWidth"]);
  const uniqueId2 = id3 || getUniqueId();
  const triggerManually = isVisible !== null;
  const [visible, setVisible] = react.useState(false);
  const [opacity, setOpacity] = react.useState(0);
  const [focusTrapActive, setFocusTrapActive] = react.useState(Boolean(propWithFocusTrap));
  const transitionTimerRef = react.useRef(null);
  const showTimerRef = react.useRef(null);
  const hideTimerRef = react.useRef(null);
  react.useEffect(() => {
    onMount();
  }, []);
  react.useEffect(() => {
    if (triggerManually) {
      if (isVisible) {
        show();
      } else {
        hide2();
      }
    }
  }, [isVisible, triggerManually]);
  const show = (withFocusTrap) => {
    onShow();
    if (transitionTimerRef.current) {
      clearTimeout(transitionTimerRef.current);
    }
    if (hideTimerRef.current) {
      clearTimeout(hideTimerRef.current);
    }
    showTimerRef.current = setTimeout(() => {
      setVisible(true);
      setOpacity(1);
      propWithFocusTrap !== false && withFocusTrap && setFocusTrapActive(true);
      onShown();
    }, 0);
  };
  const hide2 = () => {
    onHide();
    if (showTimerRef.current) {
      clearTimeout(showTimerRef.current);
    }
    hideTimerRef.current = setTimeout(() => {
      setOpacity(0);
      setFocusTrapActive(false);
      transitionTimerRef.current = setTimeout(() => {
        setVisible(false);
        onHidden();
      }, animationDuration);
    }, 0);
  };
  const positionModifiers = {
    top: styles$6.modifiers.top,
    bottom: styles$6.modifiers.bottom,
    left: styles$6.modifiers.left,
    right: styles$6.modifiers.right
  };
  const hasCustomMinWidth = minWidth !== c_popover_MinWidth.value;
  const hasCustomMaxWidth = maxWidth !== c_popover_MaxWidth.value;
  const onDocumentKeyDown = (event) => {
    if (event.keyCode === KEY_CODES.ESCAPE_KEY && visible) {
      if (triggerManually) {
        shouldClose(null, hide2, event);
      } else {
        hide2();
      }
    }
  };
  const onDocumentClick = (event, triggerElement, popperElement) => {
    if (hideOnOutsideClick && visible) {
      const isChild = popperElement && popperElement.contains(event.target);
      if (isChild) {
        return;
      }
      if (triggerManually) {
        shouldClose(null, hide2, event);
      } else {
        hide2();
      }
    }
  };
  const onTriggerEnter = (event) => {
    if (event.keyCode === KEY_CODES.ENTER) {
      if (!visible) {
        if (triggerManually) {
          shouldOpen(show, event);
        } else {
          show(true);
        }
      } else {
        if (triggerManually) {
          shouldClose(null, hide2, event);
        } else {
          hide2();
        }
      }
    }
  };
  const onTriggerClick = (event) => {
    if (triggerManually) {
      if (visible) {
        shouldClose(null, hide2, event);
      } else {
        shouldOpen(show, event);
      }
    } else {
      if (visible) {
        hide2();
      } else {
        show();
      }
    }
  };
  const onContentMouseDown = () => {
    if (focusTrapActive) {
      setFocusTrapActive(false);
    }
  };
  const closePopover = (event) => {
    event.stopPropagation();
    if (triggerManually) {
      shouldClose(null, hide2, event);
    } else {
      hide2();
    }
  };
  const content2 = react.createElement(FocusTrap, Object.assign({active: focusTrapActive, focusTrapOptions: {
    returnFocusOnDeactivate: true,
    clickOutsideDeactivates: true,
    fallbackFocus: () => {
      let node = null;
      if (document && document.activeElement) {
        node = document.activeElement;
      }
      return node;
    }
  }, preventScrollOnDeactivate: true, className: css(styles$6.popover, hasNoPadding && styles$6.modifiers.noPadding, hasAutoWidth && styles$6.modifiers.widthAuto, className), role: "dialog", "aria-modal": "true", "aria-label": headerContent ? void 0 : ariaLabel, "aria-labelledby": headerContent ? `popover-${uniqueId2}-header` : void 0, "aria-describedby": `popover-${uniqueId2}-body`, onMouseDown: onContentMouseDown, style: {
    minWidth: hasCustomMinWidth ? minWidth : null,
    maxWidth: hasCustomMaxWidth ? maxWidth : null,
    opacity,
    transition: getOpacityTransition(animationDuration)
  }}, rest), react.createElement(PopoverArrow, null), react.createElement(PopoverContent, null, showClose && react.createElement(PopoverCloseButton, {onClose: closePopover, "aria-label": closeBtnAriaLabel}), headerContent && react.createElement(PopoverHeader, {id: `popover-${uniqueId2}-header`}, typeof headerContent === "function" ? headerContent(hide2) : headerContent), react.createElement(PopoverBody, {id: `popover-${uniqueId2}-body`}, typeof bodyContent === "function" ? bodyContent(hide2) : bodyContent), footerContent && react.createElement(PopoverFooter, {id: `popover-${uniqueId2}-footer`}, typeof footerContent === "function" ? footerContent(hide2) : footerContent)));
  return react.createElement(Popper, {trigger: children2, reference: reference2, popper: content2, popperMatchesTriggerWidth: false, appendTo, isVisible: visible, positionModifiers, distance, placement: position2, onTriggerClick, onTriggerEnter, onDocumentClick, onDocumentKeyDown, enableFlip, zIndex, flipBehavior});
};
Popover.displayName = "Popover";
var emptyState = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    button: "pf-c-button",
    emptyState: "pf-c-empty-state",
    emptyStateBody: "pf-c-empty-state__body",
    emptyStateContent: "pf-c-empty-state__content",
    emptyStateIcon: "pf-c-empty-state__icon",
    emptyStatePrimary: "pf-c-empty-state__primary",
    emptyStateSecondary: "pf-c-empty-state__secondary",
    modifiers: {
      xs: "pf-m-xs",
      sm: "pf-m-sm",
      lg: "pf-m-lg",
      xl: "pf-m-xl",
      fullHeight: "pf-m-full-height",
      primary: "pf-m-primary",
      overpassFont: "pf-m-overpass-font"
    },
    title: "pf-c-title"
  };
});
var styles$7 = /* @__PURE__ */ getDefaultExportFromCjs(emptyState);
var EmptyStateVariant;
(function(EmptyStateVariant2) {
  EmptyStateVariant2["xs"] = "xs";
  EmptyStateVariant2["small"] = "small";
  EmptyStateVariant2["large"] = "large";
  EmptyStateVariant2["xl"] = "xl";
  EmptyStateVariant2["full"] = "full";
})(EmptyStateVariant || (EmptyStateVariant = {}));
var EmptyState = (_a) => {
  var {children: children2, className = "", variant = EmptyStateVariant.full, isFullHeight} = _a, props = __rest(_a, ["children", "className", "variant", "isFullHeight"]);
  return react.createElement("div", Object.assign({className: css(styles$7.emptyState, variant === "xs" && styles$7.modifiers.xs, variant === "small" && styles$7.modifiers.sm, variant === "large" && styles$7.modifiers.lg, variant === "xl" && styles$7.modifiers.xl, isFullHeight && styles$7.modifiers.fullHeight, className)}, props), react.createElement("div", {className: css(styles$7.emptyStateContent)}, children2));
};
EmptyState.displayName = "EmptyState";
var inlineEdit = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    button: "pf-c-button",
    inlineEdit: "pf-c-inline-edit",
    inlineEditAction: "pf-c-inline-edit__action",
    inlineEditEditableText: "pf-c-inline-edit__editable-text",
    inlineEditGroup: "pf-c-inline-edit__group",
    inlineEditInput: "pf-c-inline-edit__input",
    inlineEditLabel: "pf-c-inline-edit__label",
    inlineEditValue: "pf-c-inline-edit__value",
    modifiers: {
      iconGroup: "pf-m-icon-group",
      footer: "pf-m-footer",
      column: "pf-m-column",
      valid: "pf-m-valid",
      plain: "pf-m-plain",
      actionGroup: "pf-m-action-group",
      enableEditable: "pf-m-enable-editable",
      inlineEditable: "pf-m-inline-editable",
      enable: "pf-m-enable",
      bold: "pf-m-bold"
    }
  };
});
var inlineStyles = /* @__PURE__ */ getDefaultExportFromCjs(inlineEdit);

// build/_snowpack/pkg/common/plus-icon-7ff8d8a6.js
var AngleRightIconConfig = {
  name: "AngleRightIcon",
  height: 512,
  width: 256,
  svgPath: "M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34z",
  yOffset: 0,
  xOffset: 0
};
var AngleRightIcon = createIcon(AngleRightIconConfig);
var CheckCircleIconConfig = {
  name: "CheckCircleIcon",
  height: 512,
  width: 512,
  svgPath: "M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z",
  yOffset: 0,
  xOffset: 0
};
var CheckCircleIcon = createIcon(CheckCircleIconConfig);
var ExclamationCircleIconConfig = {
  name: "ExclamationCircleIcon",
  height: 512,
  width: 512,
  svgPath: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z",
  yOffset: 0,
  xOffset: 0
};
var ExclamationCircleIcon = createIcon(ExclamationCircleIconConfig);
var InfoCircleIconConfig = {
  name: "InfoCircleIcon",
  height: 512,
  width: 512,
  svgPath: "M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z",
  yOffset: 0,
  xOffset: 0
};
var InfoCircleIcon = createIcon(InfoCircleIconConfig);
var CaretDownIconConfig = {
  name: "CaretDownIcon",
  height: 512,
  width: 320,
  svgPath: "M31.3 192h257.3c17.8 0 26.7 21.5 14.1 34.1L174.1 354.8c-7.8 7.8-20.5 7.8-28.3 0L17.2 226.1C4.6 213.5 13.5 192 31.3 192z",
  yOffset: 0,
  xOffset: 0
};
var CaretDownIcon = createIcon(CaretDownIconConfig);
var SearchIconConfig = {
  name: "SearchIcon",
  height: 512,
  width: 512,
  svgPath: "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z",
  yOffset: 0,
  xOffset: 0
};
var SearchIcon = createIcon(SearchIconConfig);
var PlusIconConfig = {
  name: "PlusIcon",
  height: 512,
  width: 448,
  svgPath: "M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z",
  yOffset: 0,
  xOffset: 0
};
var PlusIcon = createIcon(PlusIconConfig);

// build/_snowpack/pkg/common/index-ad697a84.js
var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location2, propFullName, secret) {
    if (secret === ReactPropTypesSecret_1) {
      return;
    }
    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
var propTypes = createCommonjsModule(function(module2) {
  {
    module2.exports = factoryWithThrowingShims();
  }
});

// build/_snowpack/pkg/@patternfly/react-core.js
var backdrop = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    backdrop: "pf-c-backdrop",
    backdropOpen: "pf-c-backdrop__open"
  };
});
var styles2 = /* @__PURE__ */ getDefaultExportFromCjs(backdrop);
var currentId2 = 0;
var GenerateId = class extends react.Component {
  constructor() {
    super(...arguments);
    this.id = `${this.props.prefix}${currentId2++}`;
  }
  render() {
    return this.props.children(this.id);
  }
};
GenerateId.displayName = "GenerateId";
GenerateId.defaultProps = {
  prefix: "pf-random-id-"
};
var ASTERISK = "*";
var content = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    content: "pf-c-content",
    modifiers: {
      visited: "pf-m-visited",
      overpassFont: "pf-m-overpass-font"
    }
  };
});
var styles$12 = /* @__PURE__ */ getDefaultExportFromCjs(content);
var Backdrop = (_a) => {
  var {children: children2 = null, className = ""} = _a, props = __rest(_a, ["children", "className"]);
  return react.createElement("div", Object.assign({}, props, {className: css(styles2.backdrop, className)}), children2);
};
Backdrop.displayName = "Backdrop";
var alert2 = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    alert: "pf-c-alert",
    alertAction: "pf-c-alert__action",
    alertActionGroup: "pf-c-alert__action-group",
    alertDescription: "pf-c-alert__description",
    alertIcon: "pf-c-alert__icon",
    alertTitle: "pf-c-alert__title",
    button: "pf-c-button",
    modifiers: {
      success: "pf-m-success",
      danger: "pf-m-danger",
      warning: "pf-m-warning",
      info: "pf-m-info",
      inline: "pf-m-inline",
      truncate: "pf-m-truncate",
      overpassFont: "pf-m-overpass-font"
    }
  };
});
var styles$22 = /* @__PURE__ */ getDefaultExportFromCjs(alert2);
var accessibility = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    hidden: "pf-u-hidden",
    hiddenOnLg: "pf-u-hidden-on-lg",
    hiddenOnMd: "pf-u-hidden-on-md",
    hiddenOnSm: "pf-u-hidden-on-sm",
    hiddenOnXl: "pf-u-hidden-on-xl",
    hiddenOn_2xl: "pf-u-hidden-on-2xl",
    screenReader: "pf-u-screen-reader",
    screenReaderOnLg: "pf-u-screen-reader-on-lg",
    screenReaderOnMd: "pf-u-screen-reader-on-md",
    screenReaderOnSm: "pf-u-screen-reader-on-sm",
    screenReaderOnXl: "pf-u-screen-reader-on-xl",
    screenReaderOn_2xl: "pf-u-screen-reader-on-2xl",
    visible: "pf-u-visible",
    visibleOnLg: "pf-u-visible-on-lg",
    visibleOnMd: "pf-u-visible-on-md",
    visibleOnSm: "pf-u-visible-on-sm",
    visibleOnXl: "pf-u-visible-on-xl",
    visibleOn_2xl: "pf-u-visible-on-2xl"
  };
});
var a11yStyles = /* @__PURE__ */ getDefaultExportFromCjs(accessibility);
var ExclamationTriangleIconConfig = {
  name: "ExclamationTriangleIcon",
  height: 512,
  width: 576,
  svgPath: "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z",
  yOffset: 0,
  xOffset: 0
};
var ExclamationTriangleIcon = createIcon(ExclamationTriangleIconConfig);
var BellIconConfig = {
  name: "BellIcon",
  height: 1024,
  width: 896,
  svgPath: "M448,0 C465.333333,0 480.333333,6.33333333 493,19 C505.666667,31.6666667 512,46.6666667 512,64 L512,106 L514.23,106.45 C587.89,121.39 648.48,157.24 696,214 C744,271.333333 768,338.666667 768,416 C768,500 780,568.666667 804,622 C818.666667,652.666667 841.333333,684 872,716 C873.773676,718.829136 875.780658,721.505113 878,724 C890,737.333333 896,752.333333 896,769 C896,785.666667 890,800.333333 878,813 C866,825.666667 850.666667,832 832,832 L63.3,832 C44.9533333,831.84 29.8533333,825.506667 18,813 C6,800.333333 0,785.666667 0,769 C0,752.333333 6,737.333333 18,724 L24,716 L25.06,714.9 C55.1933333,683.28 77.5066667,652.313333 92,622 C116,568.666667 128,500 128,416 C128,338.666667 152,271.333333 200,214 C248,156.666667 309.333333,120.666667 384,106 L384,63.31 C384.166667,46.27 390.5,31.5 403,19 C415.666667,6.33333333 430.666667,0 448,0 Z M576,896 L576,897.08 C575.74,932.6 563.073333,962.573333 538,987 C512.666667,1011.66667 482.666667,1024 448,1024 C413.333333,1024 383.333333,1011.66667 358,987 C332.666667,962.333333 320,932 320,896 L576,896 Z",
  yOffset: 0,
  xOffset: 0
};
var BellIcon = createIcon(BellIconConfig);
var variantIcons = {
  success: CheckCircleIcon,
  danger: ExclamationCircleIcon,
  warning: ExclamationTriangleIcon,
  info: InfoCircleIcon,
  default: BellIcon
};
var AlertIcon = (_a) => {
  var {variant, customIcon, className = ""} = _a, props = __rest(_a, ["variant", "customIcon", "className"]);
  const Icon = variantIcons[variant];
  return react.createElement("div", Object.assign({}, props, {className: css(styles$22.alertIcon, className)}), customIcon || react.createElement(Icon, null));
};
var AlertContext = react.createContext(null);
var c_alert__title_max_lines = {
  name: "--pf-c-alert__title--max-lines",
  value: "1",
  var: "var(--pf-c-alert__title--max-lines)"
};
var AlertVariant;
(function(AlertVariant2) {
  AlertVariant2["success"] = "success";
  AlertVariant2["danger"] = "danger";
  AlertVariant2["warning"] = "warning";
  AlertVariant2["info"] = "info";
  AlertVariant2["default"] = "default";
})(AlertVariant || (AlertVariant = {}));
var Alert = (_a) => {
  var {variant = AlertVariant.default, isInline = false, isLiveRegion = false, variantLabel = `${capitalize(variant)} alert:`, "aria-label": ariaLabel = `${capitalize(variant)} Alert`, actionClose, actionLinks, title: title3, children: children2 = "", className = "", ouiaId, ouiaSafe = true, timeout: timeout2 = false, timeoutAnimation = 3e3, onTimeout = () => {
  }, truncateTitle = 0, tooltipPosition, customIcon, onMouseEnter = () => {
  }, onMouseLeave = () => {
  }} = _a, props = __rest(_a, ["variant", "isInline", "isLiveRegion", "variantLabel", "aria-label", "actionClose", "actionLinks", "title", "children", "className", "ouiaId", "ouiaSafe", "timeout", "timeoutAnimation", "onTimeout", "truncateTitle", "tooltipPosition", "customIcon", "onMouseEnter", "onMouseLeave"]);
  const ouiaProps = useOUIAProps(Alert.displayName, ouiaId, ouiaSafe, variant);
  const getHeadingContent = react.createElement(react.Fragment, null, react.createElement("span", {className: css(a11yStyles.screenReader)}, variantLabel), title3);
  const titleRef = react.useRef(null);
  const divRef = react.useRef();
  const [isTooltipVisible, setIsTooltipVisible] = react.useState(false);
  react.useEffect(() => {
    if (!titleRef.current || !truncateTitle) {
      return;
    }
    titleRef.current.style.setProperty(c_alert__title_max_lines.name, truncateTitle.toString());
    const showTooltip = titleRef.current && titleRef.current.offsetHeight < titleRef.current.scrollHeight;
    if (isTooltipVisible !== showTooltip) {
      setIsTooltipVisible(showTooltip);
    }
  }, [titleRef, truncateTitle, isTooltipVisible]);
  const [timedOut, setTimedOut] = react.useState(false);
  const [timedOutAnimation, setTimedOutAnimation] = react.useState(true);
  const [isMouseOver, setIsMouseOver] = react.useState();
  const [containsFocus, setContainsFocus] = react.useState();
  const dismissed = timedOut && timedOutAnimation && !isMouseOver && !containsFocus;
  react.useEffect(() => {
    timeout2 = timeout2 === true ? 8e3 : Number(timeout2);
    if (timeout2 > 0) {
      const timer2 = setTimeout(() => setTimedOut(true), timeout2);
      return () => clearTimeout(timer2);
    }
  }, []);
  react.useEffect(() => {
    const onDocumentFocus = () => {
      if (divRef.current) {
        if (divRef.current.contains(document.activeElement)) {
          setContainsFocus(true);
          setTimedOutAnimation(false);
        } else if (containsFocus) {
          setContainsFocus(false);
        }
      }
    };
    document.addEventListener("focus", onDocumentFocus, true);
    return () => document.removeEventListener("focus", onDocumentFocus, true);
  }, [containsFocus]);
  react.useEffect(() => {
    if (containsFocus === false || isMouseOver === false) {
      const timer2 = setTimeout(() => setTimedOutAnimation(true), timeoutAnimation);
      return () => clearTimeout(timer2);
    }
  }, [containsFocus, isMouseOver]);
  react.useEffect(() => {
    dismissed && onTimeout();
  }, [dismissed]);
  const myOnMouseEnter = (ev) => {
    setIsMouseOver(true);
    setTimedOutAnimation(false);
    onMouseEnter(ev);
  };
  const myOnMouseLeave = (ev) => {
    setIsMouseOver(false);
    onMouseLeave(ev);
  };
  if (dismissed) {
    return null;
  }
  const Title2 = react.createElement("h4", Object.assign({}, isTooltipVisible && {tabIndex: 0}, {ref: titleRef, className: css(styles$22.alertTitle, truncateTitle && styles$22.modifiers.truncate)}), getHeadingContent);
  return react.createElement("div", Object.assign({ref: divRef, className: css(styles$22.alert, isInline && styles$22.modifiers.inline, styles$22.modifiers[variant], className), "aria-label": ariaLabel}, ouiaProps, isLiveRegion && {
    "aria-live": "polite",
    "aria-atomic": "false"
  }, {onMouseEnter: myOnMouseEnter, onMouseLeave: myOnMouseLeave}, props), react.createElement(AlertIcon, {variant, customIcon}), isTooltipVisible ? react.createElement(Tooltip, {content: getHeadingContent, position: tooltipPosition}, Title2) : Title2, actionClose && react.createElement(AlertContext.Provider, {value: {title: title3, variantLabel}}, react.createElement("div", {className: css(styles$22.alertAction)}, actionClose)), children2 && react.createElement("div", {className: css(styles$22.alertDescription)}, children2), actionLinks && react.createElement("div", {className: css(styles$22.alertActionGroup)}, actionLinks));
};
Alert.displayName = "Alert";
var AlertActionCloseButton = (_a) => {
  var {
    className = "",
    onClose = () => void 0,
    "aria-label": ariaLabel = "",
    variantLabel
  } = _a, props = __rest(_a, ["className", "onClose", "aria-label", "variantLabel"]);
  return react.createElement(AlertContext.Consumer, null, ({title: title3, variantLabel: alertVariantLabel}) => react.createElement(Button, Object.assign({variant: ButtonVariant.plain, onClick: onClose, "aria-label": ariaLabel === "" ? `Close ${variantLabel || alertVariantLabel} alert: ${title3}` : ariaLabel}, props), react.createElement(TimesIcon, null)));
};
AlertActionCloseButton.displayName = "AlertActionCloseButton";
var AlertActionLink = (_a) => {
  var {className = "", children: children2} = _a, props = __rest(_a, ["className", "children"]);
  return react.createElement(Button, Object.assign({variant: ButtonVariant.link, isInline: true, className}, props), children2);
};
AlertActionLink.displayName = "AlertActionLink";
var alertGroup = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    alertGroup: "pf-c-alert-group",
    modifiers: {
      toast: "pf-m-toast"
    }
  };
});
var styles$32 = /* @__PURE__ */ getDefaultExportFromCjs(alertGroup);
var AlertGroupInline = (_a) => {
  var {className, children: children2, isToast, isLiveRegion} = _a, rest = __rest(_a, ["className", "children", "isToast", "isLiveRegion"]);
  return react.createElement("ul", Object.assign({"aria-live": isLiveRegion ? "polite" : null, "aria-atomic": isLiveRegion ? false : null, className: css(styles$32.alertGroup, className, isToast ? styles$32.modifiers.toast : "")}, rest), react.Children.toArray(children2).map((Alert2, index3) => react.createElement("li", {key: index3}, Alert2)));
};
AlertGroupInline.displayName = "AlertGroupInline";
var AlertGroup = class extends react.Component {
  constructor() {
    super(...arguments);
    this.state = {
      container: void 0
    };
  }
  componentDidMount() {
    const container = document.createElement("div");
    const target = this.getTargetElement();
    this.setState({container});
    target.appendChild(container);
  }
  componentWillUnmount() {
    const target = this.getTargetElement();
    if (this.state.container) {
      target.removeChild(this.state.container);
    }
  }
  getTargetElement() {
    const appendTo = this.props.appendTo;
    if (typeof appendTo === "function") {
      return appendTo();
    }
    return appendTo || document.body;
  }
  render() {
    const _a = this.props, {className, children: children2, isToast, isLiveRegion} = _a, props = __rest(_a, ["className", "children", "isToast", "isLiveRegion"]);
    const alertGroup2 = react.createElement(AlertGroupInline, Object.assign({className, isToast, isLiveRegion}, props), children2);
    if (!this.props.isToast) {
      return alertGroup2;
    }
    const container = this.state.container;
    if (!canUseDOM || !container) {
      return null;
    }
    return reactDom.createPortal(alertGroup2, container);
  }
};
AlertGroup.displayName = "AlertGroup";
var formControl = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    formControl: "pf-c-form-control",
    modifiers: {
      success: "pf-m-success",
      expanded: "pf-m-expanded",
      icon: "pf-m-icon",
      warning: "pf-m-warning",
      search: "pf-m-search",
      calendar: "pf-m-calendar",
      clock: "pf-m-clock",
      placeholder: "pf-m-placeholder",
      resizeVertical: "pf-m-resize-vertical",
      resizeHorizontal: "pf-m-resize-horizontal"
    }
  };
});
var formStyles = /* @__PURE__ */ getDefaultExportFromCjs(formControl);
var DropdownGroup = ({children: children2 = null, className = "", label: label2 = ""}) => react.createElement(DropdownContext.Consumer, null, ({sectionClass, sectionTitleClass, sectionComponent}) => {
  const SectionComponent = sectionComponent;
  return react.createElement(SectionComponent, {className: css(sectionClass, className)}, label2 && react.createElement("h1", {className: css(sectionTitleClass), "aria-hidden": true}, label2), react.createElement("ul", {role: "none"}, children2));
});
DropdownGroup.displayName = "DropdownGroup";
var badge = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    badge: "pf-c-badge",
    modifiers: {
      read: "pf-m-read",
      unread: "pf-m-unread"
    }
  };
});
var badgeStyles = /* @__PURE__ */ getDefaultExportFromCjs(badge);
var Badge = (_a) => {
  var {isRead = false, className = "", children: children2 = ""} = _a, props = __rest(_a, ["isRead", "className", "children"]);
  return react.createElement("span", Object.assign({}, props, {className: css(badgeStyles.badge, isRead ? badgeStyles.modifiers.read : badgeStyles.modifiers.unread, className)}), children2);
};
Badge.displayName = "Badge";
var DropdownToggle = (_a) => {
  var {
    id: id3 = "",
    children: children2 = null,
    className = "",
    isOpen = false,
    parentRef = null,
    getMenuRef = null,
    isDisabled = false,
    isPlain = false,
    isPrimary = false,
    isActive = false,
    onToggle = (_isOpen) => void 0,
    icon = null,
    toggleIndicator: ToggleIndicator = CaretDownIcon,
    splitButtonItems,
    splitButtonVariant = "checkbox",
    "aria-haspopup": ariaHasPopup,
    ouiaId,
    ouiaSafe,
    ref
  } = _a, props = __rest(_a, ["id", "children", "className", "isOpen", "parentRef", "getMenuRef", "isDisabled", "isPlain", "isPrimary", "isActive", "onToggle", "icon", "toggleIndicator", "splitButtonItems", "splitButtonVariant", "aria-haspopup", "ouiaId", "ouiaSafe", "ref"]);
  const ouiaProps = useOUIAProps(DropdownToggle.displayName, ouiaId, ouiaSafe);
  const toggle = react.createElement(DropdownContext.Consumer, null, ({toggleTextClass, toggleIndicatorClass, toggleIconClass}) => react.createElement(Toggle, Object.assign({}, props, {id: id3, className, isOpen, parentRef, getMenuRef, isActive, isDisabled, isPlain, isPrimary, onToggle, "aria-haspopup": ariaHasPopup}, ouiaProps, splitButtonItems && {isSplitButton: true, "aria-label": props["aria-label"] || "Select"}), icon && react.createElement("span", {className: css(toggleIconClass)}, icon), children2 && react.createElement("span", {className: ToggleIndicator && css(toggleTextClass)}, children2), ToggleIndicator && react.createElement("span", {className: css(!splitButtonItems && toggleIndicatorClass)}, react.createElement(ToggleIndicator, null))));
  if (splitButtonItems) {
    return react.createElement("div", {className: css(styles$4.dropdownToggle, styles$4.modifiers.splitButton, splitButtonVariant === "action" && styles$4.modifiers.action, isDisabled && styles$4.modifiers.disabled)}, splitButtonItems, toggle);
  }
  return toggle;
};
DropdownToggle.displayName = "DropdownToggle";
var ApplicationLauncherSeparator = (_a) => {
  var props = __rest(_a, ["children"]);
  return react.createElement(DropdownSeparator, Object.assign({}, props));
};
ApplicationLauncherSeparator.displayName = "ApplicationLauncherSeparator";
var createRenderableFavorites = (items, isGrouped, favorites, isEnterTriggersArrowDown) => {
  if (isGrouped) {
    const favoriteItems = [];
    items.forEach((group) => {
      if (favorites.length > 0) {
        return group.props.children && group.props.children.filter((item) => favorites.includes(item.props.id)).map((item) => {
          if (isEnterTriggersArrowDown) {
            return favoriteItems.push(react.cloneElement(item, {
              isFavorite: true,
              enterTriggersArrowDown: isEnterTriggersArrowDown,
              id: `favorite-${item.props.id}`
            }));
          } else {
            return favoriteItems.push(react.cloneElement(item, {isFavorite: true, id: `favorite-${item.props.id}`}));
          }
        });
      }
    });
    return favoriteItems;
  }
  return items.filter((item) => favorites.includes(item.props.id)).map((item) => react.cloneElement(item, {isFavorite: true, enterTriggersArrowDown: isEnterTriggersArrowDown}));
};
var extendItemsWithFavorite = (items, isGrouped, favorites) => {
  if (isGrouped) {
    return items.map((group) => react.cloneElement(group, {
      children: react.Children.map(group.props.children, (item) => {
        if (item.type === ApplicationLauncherSeparator || item.type === Divider) {
          return item;
        }
        return react.cloneElement(item, {
          isFavorite: favorites.some((favoriteId) => favoriteId === item.props.id || `favorite-${favoriteId}` === item.props.id)
        });
      })
    }));
  }
  return items.map((item) => react.cloneElement(item, {
    isFavorite: favorites.some((favoriteId) => favoriteId === item.props.id)
  }));
};
var avatar = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    avatar: "pf-c-avatar",
    modifiers: {
      light: "pf-m-light",
      dark: "pf-m-dark"
    }
  };
});
var styles$42 = /* @__PURE__ */ getDefaultExportFromCjs(avatar);
var Avatar = (_a) => {
  var {className = "", src = "", alt, border} = _a, props = __rest(_a, ["className", "src", "alt", "border"]);
  return react.createElement("img", Object.assign({src, alt, className: css(styles$42.avatar, border === "light" && styles$42.modifiers.light, border === "dark" && styles$42.modifiers.dark, className)}, props));
};
Avatar.displayName = "Avatar";
var Brand = (_a) => {
  var {className = "", src = "", alt} = _a, props = __rest(_a, ["className", "src", "alt"]);
  return react.createElement("img", Object.assign({}, props, {className: css("pf-c-brand", className), src, alt}));
};
Brand.displayName = "Brand";
var breadcrumb = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    breadcrumb: "pf-c-breadcrumb",
    breadcrumbDropdown: "pf-c-breadcrumb__dropdown",
    breadcrumbHeading: "pf-c-breadcrumb__heading",
    breadcrumbItem: "pf-c-breadcrumb__item",
    breadcrumbItemDivider: "pf-c-breadcrumb__item-divider",
    breadcrumbLink: "pf-c-breadcrumb__link",
    breadcrumbList: "pf-c-breadcrumb__list",
    dropdownToggle: "pf-c-dropdown__toggle",
    modifiers: {
      current: "pf-m-current",
      overpassFont: "pf-m-overpass-font"
    }
  };
});
var styles$52 = /* @__PURE__ */ getDefaultExportFromCjs(breadcrumb);
var Breadcrumb = (_a) => {
  var {children: children2 = null, className = "", "aria-label": ariaLabel = "Breadcrumb", ouiaId, ouiaSafe = true} = _a, props = __rest(_a, ["children", "className", "aria-label", "ouiaId", "ouiaSafe"]);
  const ouiaProps = useOUIAProps(Breadcrumb.displayName, ouiaId, ouiaSafe);
  return react.createElement("nav", Object.assign({}, props, {"aria-label": ariaLabel, className: css(styles$52.breadcrumb, className)}, ouiaProps), react.createElement("ol", {className: styles$52.breadcrumbList}, react.Children.map(children2, (child, index3) => {
    const showDivider = index3 > 0;
    if (react.isValidElement(child)) {
      return react.cloneElement(child, {showDivider});
    }
    return child;
  })));
};
Breadcrumb.displayName = "Breadcrumb";
var BreadcrumbItem = (_a) => {
  var {children: children2 = null, className: classNameProp = "", to = null, isActive = false, isDropdown = false, showDivider, target = null, component = "a", render: render4 = null} = _a, props = __rest(_a, ["children", "className", "to", "isActive", "isDropdown", "showDivider", "target", "component", "render"]);
  const Component = component;
  const ariaCurrent = isActive ? "page" : void 0;
  const className = css(styles$52.breadcrumbLink, isActive && styles$52.modifiers.current);
  return react.createElement("li", Object.assign({}, props, {className: css(styles$52.breadcrumbItem, classNameProp)}), showDivider && react.createElement("span", {className: styles$52.breadcrumbItemDivider}, react.createElement(AngleRightIcon, null)), component === "button" && react.createElement("button", {className, "aria-current": ariaCurrent, type: "button"}, children2), isDropdown && react.createElement("span", {className: css(styles$52.breadcrumbDropdown)}, children2), render4 && render4({className, ariaCurrent}), to && !render4 && react.createElement(Component, {href: to, target, className, "aria-current": ariaCurrent}, children2), !to && component !== "button" && !isDropdown && children2);
};
BreadcrumbItem.displayName = "BreadcrumbItem";
var TextInputTypes;
(function(TextInputTypes2) {
  TextInputTypes2["text"] = "text";
  TextInputTypes2["date"] = "date";
  TextInputTypes2["datetimeLocal"] = "datetime-local";
  TextInputTypes2["email"] = "email";
  TextInputTypes2["month"] = "month";
  TextInputTypes2["number"] = "number";
  TextInputTypes2["password"] = "password";
  TextInputTypes2["search"] = "search";
  TextInputTypes2["tel"] = "tel";
  TextInputTypes2["time"] = "time";
  TextInputTypes2["url"] = "url";
})(TextInputTypes || (TextInputTypes = {}));
var TextInputBase = class extends react.Component {
  constructor(props) {
    super(props);
    this.inputRef = react.createRef();
    this.handleChange = (event) => {
      if (this.props.onChange) {
        this.props.onChange(event.currentTarget.value, event);
      }
    };
    this.handleResize = () => {
      const inputRef = this.props.innerRef || this.inputRef;
      if (inputRef && inputRef.current) {
        trimLeft(inputRef.current, String(this.props.value));
      }
    };
    this.restoreText = () => {
      const inputRef = this.props.innerRef || this.inputRef;
      inputRef.current.value = String(this.props.value);
      inputRef.current.scrollLeft = inputRef.current.scrollWidth;
    };
    this.onFocus = (event) => {
      const {isLeftTruncated, onFocus} = this.props;
      if (isLeftTruncated) {
        this.restoreText();
      }
      onFocus && onFocus(event);
    };
    this.onBlur = (event) => {
      const {isLeftTruncated, onBlur} = this.props;
      if (isLeftTruncated) {
        this.handleResize();
      }
      onBlur && onBlur(event);
    };
    if (!props.id && !props["aria-label"] && !props["aria-labelledby"]) {
      console.error("Text input:", "Text input requires either an id or aria-label to be specified");
    }
    this.state = {
      ouiaStateId: getDefaultOUIAId(TextInputBase.displayName)
    };
  }
  componentDidMount() {
    if (this.props.isLeftTruncated) {
      this.handleResize();
      if (canUseDOM) {
        window.addEventListener("resize", debounce(this.handleResize, 250));
      }
    }
  }
  componentWillUnmount() {
    if (this.props.isLeftTruncated) {
      if (canUseDOM) {
        window.removeEventListener("resize", debounce(this.handleResize, 250));
      }
    }
  }
  render() {
    const _a = this.props, {
      innerRef,
      className,
      type,
      value,
      validated,
      onChange,
      onFocus,
      onBlur,
      isLeftTruncated,
      isReadOnly,
      isRequired,
      isDisabled,
      iconVariant,
      customIconUrl,
      customIconDimensions,
      ouiaId,
      ouiaSafe
    } = _a, props = __rest(_a, ["innerRef", "className", "type", "value", "validated", "onChange", "onFocus", "onBlur", "isLeftTruncated", "isReadOnly", "isRequired", "isDisabled", "iconVariant", "customIconUrl", "customIconDimensions", "ouiaId", "ouiaSafe"]);
    const customIconStyle = {};
    if (customIconUrl) {
      customIconStyle.backgroundImage = `url('${customIconUrl}')`;
    }
    if (customIconDimensions) {
      customIconStyle.backgroundSize = customIconDimensions;
    }
    return react.createElement("input", Object.assign({}, props, {onFocus: this.onFocus, onBlur: this.onBlur, className: css(formStyles.formControl, validated === ValidatedOptions.success && formStyles.modifiers.success, validated === ValidatedOptions.warning && formStyles.modifiers.warning, (iconVariant && iconVariant !== "search" || customIconUrl) && formStyles.modifiers.icon, iconVariant && formStyles.modifiers[iconVariant], className), onChange: this.handleChange, type, value, "aria-invalid": props["aria-invalid"] ? props["aria-invalid"] : validated === ValidatedOptions.error, required: isRequired, disabled: isDisabled, readOnly: isReadOnly, ref: innerRef || this.inputRef}, (customIconUrl || customIconDimensions) && {style: customIconStyle}, getOUIAProps(TextInput.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe)));
  }
};
TextInputBase.displayName = "TextInputBase";
TextInputBase.defaultProps = {
  "aria-label": null,
  className: "",
  isRequired: false,
  validated: "default",
  isDisabled: false,
  isReadOnly: false,
  type: TextInputTypes.text,
  isLeftTruncated: false,
  onChange: () => void 0,
  ouiaSafe: true
};
var TextInput = react.forwardRef((props, ref) => react.createElement(TextInputBase, Object.assign({}, props, {innerRef: ref})));
TextInput.displayName = "TextInput";
var select = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    check: "pf-c-check",
    checkLabel: "pf-c-check__label",
    chipGroup: "pf-c-chip-group",
    divider: "pf-c-divider",
    formControl: "pf-c-form-control",
    modifiers: {
      invalid: "pf-m-invalid",
      success: "pf-m-success",
      warning: "pf-m-warning",
      disabled: "pf-m-disabled",
      active: "pf-m-active",
      expanded: "pf-m-expanded",
      plain: "pf-m-plain",
      typeahead: "pf-m-typeahead",
      top: "pf-m-top",
      alignRight: "pf-m-align-right",
      favorite: "pf-m-favorite",
      favoriteAction: "pf-m-favorite-action",
      focus: "pf-m-focus",
      link: "pf-m-link",
      action: "pf-m-action",
      selected: "pf-m-selected",
      description: "pf-m-description",
      load: "pf-m-load",
      loading: "pf-m-loading"
    },
    select: "pf-c-select",
    selectListItem: "pf-c-select__list-item",
    selectMenu: "pf-c-select__menu",
    selectMenuFieldset: "pf-c-select__menu-fieldset",
    selectMenuFooter: "pf-c-select__menu-footer",
    selectMenuGroup: "pf-c-select__menu-group",
    selectMenuGroupTitle: "pf-c-select__menu-group-title",
    selectMenuItem: "pf-c-select__menu-item",
    selectMenuItemActionIcon: "pf-c-select__menu-item-action-icon",
    selectMenuItemCount: "pf-c-select__menu-item-count",
    selectMenuItemDescription: "pf-c-select__menu-item-description",
    selectMenuItemIcon: "pf-c-select__menu-item-icon",
    selectMenuItemMain: "pf-c-select__menu-item-main",
    selectMenuItemMatch: "pf-c-select__menu-item--match",
    selectMenuItemRow: "pf-c-select__menu-item-row",
    selectMenuItemText: "pf-c-select__menu-item-text",
    selectMenuSearch: "pf-c-select__menu-search",
    selectMenuWrapper: "pf-c-select__menu-wrapper",
    selectToggle: "pf-c-select__toggle",
    selectToggleArrow: "pf-c-select__toggle-arrow",
    selectToggleBadge: "pf-c-select__toggle-badge",
    selectToggleButton: "pf-c-select__toggle-button",
    selectToggleClear: "pf-c-select__toggle-clear",
    selectToggleIcon: "pf-c-select__toggle-icon",
    selectToggleStatusIcon: "pf-c-select__toggle-status-icon",
    selectToggleText: "pf-c-select__toggle-text",
    selectToggleTypeahead: "pf-c-select__toggle-typeahead",
    selectToggleWrapper: "pf-c-select__toggle-wrapper"
  };
});
var styles$62 = /* @__PURE__ */ getDefaultExportFromCjs(select);
var TimesCircleIconConfig = {
  name: "TimesCircleIcon",
  height: 512,
  width: 512,
  svgPath: "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z",
  yOffset: 0,
  xOffset: 0
};
var TimesCircleIcon = createIcon(TimesCircleIconConfig);
var form = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    form: "pf-c-form",
    formActions: "pf-c-form__actions",
    formFieldGroup: "pf-c-form__field-group",
    formFieldGroupBody: "pf-c-form__field-group-body",
    formFieldGroupHeader: "pf-c-form__field-group-header",
    formFieldGroupHeaderActions: "pf-c-form__field-group-header-actions",
    formFieldGroupHeaderDescription: "pf-c-form__field-group-header-description",
    formFieldGroupHeaderMain: "pf-c-form__field-group-header-main",
    formFieldGroupHeaderTitle: "pf-c-form__field-group-header-title",
    formFieldGroupHeaderTitleText: "pf-c-form__field-group-header-title-text",
    formFieldGroupToggle: "pf-c-form__field-group-toggle",
    formFieldGroupToggleButton: "pf-c-form__field-group-toggle-button",
    formFieldGroupToggleIcon: "pf-c-form__field-group-toggle-icon",
    formFieldset: "pf-c-form__fieldset",
    formGroup: "pf-c-form__group",
    formGroupControl: "pf-c-form__group-control",
    formGroupLabel: "pf-c-form__group-label",
    formGroupLabelHelp: "pf-c-form__group-label-help",
    formGroupLabelInfo: "pf-c-form__group-label-info",
    formGroupLabelMain: "pf-c-form__group-label-main",
    formHelperText: "pf-c-form__helper-text",
    formHelperTextIcon: "pf-c-form__helper-text-icon",
    formLabel: "pf-c-form__label",
    formLabelRequired: "pf-c-form__label-required",
    formLabelText: "pf-c-form__label-text",
    formSection: "pf-c-form__section",
    formSectionTitle: "pf-c-form__section-title",
    modifiers: {
      horizontal: "pf-m-horizontal",
      alignRight: "pf-m-align-right",
      noPaddingTop: "pf-m-no-padding-top",
      limitWidth: "pf-m-limit-width",
      action: "pf-m-action",
      info: "pf-m-info",
      disabled: "pf-m-disabled",
      inline: "pf-m-inline",
      stack: "pf-m-stack",
      error: "pf-m-error",
      success: "pf-m-success",
      warning: "pf-m-warning",
      inactive: "pf-m-inactive",
      hidden: "pf-m-hidden",
      expanded: "pf-m-expanded"
    }
  };
});
var formStyles$1 = /* @__PURE__ */ getDefaultExportFromCjs(form);
var SelectContext = react.createContext(null);
var SelectProvider = SelectContext.Provider;
var SelectConsumer = SelectContext.Consumer;
var SelectVariant;
(function(SelectVariant2) {
  SelectVariant2["single"] = "single";
  SelectVariant2["checkbox"] = "checkbox";
  SelectVariant2["typeahead"] = "typeahead";
  SelectVariant2["typeaheadMulti"] = "typeaheadmulti";
})(SelectVariant || (SelectVariant = {}));
var SelectDirection;
(function(SelectDirection2) {
  SelectDirection2["up"] = "up";
  SelectDirection2["down"] = "down";
})(SelectDirection || (SelectDirection = {}));
var KeyTypes = {
  Tab: "Tab",
  Space: " ",
  Escape: "Escape",
  Enter: "Enter",
  ArrowUp: "ArrowUp",
  ArrowDown: "ArrowDown",
  ArrowLeft: "ArrowLeft",
  ArrowRight: "ArrowRight"
};
var SelectOption = class extends react.Component {
  constructor() {
    super(...arguments);
    this.ref = react.createRef();
    this.liRef = react.createRef();
    this.favoriteRef = react.createRef();
    this.onKeyDown = (event, innerIndex, onEnter, isCheckbox) => {
      const {index: index3, keyHandler: keyHandler2, isLastOptionBeforeFooter} = this.props;
      let isLastItemBeforeFooter = false;
      if (isLastOptionBeforeFooter !== void 0) {
        isLastItemBeforeFooter = isLastOptionBeforeFooter(index3);
      }
      if (event.key === KeyTypes.Tab) {
        if (isCheckbox && !isLastItemBeforeFooter) {
          if (event.shiftKey) {
            keyHandler2(index3, innerIndex, "up");
          } else {
            keyHandler2(index3, innerIndex, "down");
          }
          event.stopPropagation();
        } else {
          keyHandler2(index3, innerIndex, "tab");
        }
      }
      event.preventDefault();
      if (event.key === KeyTypes.ArrowUp) {
        keyHandler2(index3, innerIndex, "up");
      } else if (event.key === KeyTypes.ArrowDown) {
        keyHandler2(index3, innerIndex, "down");
      } else if (event.key === KeyTypes.ArrowLeft) {
        keyHandler2(index3, innerIndex, "left");
      } else if (event.key === KeyTypes.ArrowRight) {
        keyHandler2(index3, innerIndex, "right");
      } else if (event.key === KeyTypes.Enter) {
        if (onEnter !== void 0) {
          onEnter();
        } else {
          this.ref.current.click();
        }
      }
    };
  }
  componentDidMount() {
    this.props.sendRef(this.props.isDisabled ? null : this.ref.current, this.props.isDisabled ? null : this.favoriteRef.current, this.props.isDisabled ? null : this.liRef.current, this.props.index);
  }
  componentDidUpdate() {
    this.props.sendRef(this.props.isDisabled ? null : this.ref.current, this.props.isDisabled ? null : this.favoriteRef.current, this.props.isDisabled ? null : this.liRef.current, this.props.index);
  }
  render() {
    const _a = this.props, {
      children: children2,
      className,
      id: id3,
      description,
      itemCount,
      value,
      onClick,
      isDisabled,
      isPlaceholder,
      isNoResultsOption,
      isSelected,
      isChecked,
      isFocused,
      sendRef,
      keyHandler: keyHandler2,
      index: index3,
      component,
      inputId,
      isFavorite,
      ariaIsFavoriteLabel = "starred",
      ariaIsNotFavoriteLabel = "not starred",
      isLoad,
      isLoading,
      setViewMoreNextIndex,
      isLastOptionBeforeFooter
    } = _a, props = __rest(_a, ["children", "className", "id", "description", "itemCount", "value", "onClick", "isDisabled", "isPlaceholder", "isNoResultsOption", "isSelected", "isChecked", "isFocused", "sendRef", "keyHandler", "index", "component", "inputId", "isFavorite", "ariaIsFavoriteLabel", "ariaIsNotFavoriteLabel", "isLoad", "isLoading", "setViewMoreNextIndex", "isLastOptionBeforeFooter"]);
    const Component = component;
    if (!id3 && isFavorite !== null) {
      console.error("Please provide an id to use the favorites feature.");
    }
    const generatedId = id3 || getUniqueId("select-option");
    const favoriteButton = (onFavorite) => react.createElement("button", {className: css(styles$62.selectMenuItem, styles$62.modifiers.action, styles$62.modifiers.favoriteAction), "aria-label": isFavorite ? ariaIsFavoriteLabel : ariaIsNotFavoriteLabel, onClick: () => {
      onFavorite(generatedId.replace("favorite-", ""), isFavorite);
    }, onKeyDown: (event) => {
      this.onKeyDown(event, 1, () => onFavorite(generatedId.replace("favorite-", "")));
    }, ref: this.favoriteRef}, react.createElement("span", {className: css(styles$62.selectMenuItemActionIcon)}, react.createElement(StarIcon, null)));
    const itemDisplay = itemCount ? react.createElement("span", {className: css(styles$62.selectMenuItemRow)}, react.createElement("span", {className: css(styles$62.selectMenuItemText)}, children2 || value && value.toString && value.toString()), react.createElement("span", {className: css(styles$62.selectMenuItemCount)}, itemCount)) : children2 || value.toString();
    const onViewMoreClick = (event) => {
      setViewMoreNextIndex();
      onClick(event);
    };
    return react.createElement(SelectConsumer, null, ({onSelect, onClose, variant, inputIdPrefix, onFavorite}) => react.createElement(react.Fragment, null, variant !== SelectVariant.checkbox && react.createElement("li", {id: generatedId, role: "presentation", className: css(isLoading && styles$62.selectListItem, !isLoad && !isLoading && styles$62.selectMenuWrapper, isFavorite && styles$62.modifiers.favorite, isFocused && styles$62.modifiers.focus, isLoading && styles$62.modifiers.loading), ref: this.liRef}, isLoading && children2, !isLoading && react.createElement(react.Fragment, null, react.createElement(Component, Object.assign({}, props, {className: css(styles$62.selectMenuItem, isLoad && styles$62.modifiers.load, isSelected && styles$62.modifiers.selected, isDisabled && styles$62.modifiers.disabled, description && styles$62.modifiers.description, isFavorite !== null && styles$62.modifiers.link, className), onClick: (event) => {
      if (isLoad) {
        onViewMoreClick(event);
        event.stopPropagation();
      } else if (!isDisabled && !isLoading) {
        onClick(event);
        onSelect(event, value, isPlaceholder);
        onClose();
      }
    }, role: "option", "aria-selected": isSelected || null, ref: this.ref, onKeyDown: (event) => {
      this.onKeyDown(event, 0);
    }, type: "button"}), description && react.createElement(react.Fragment, null, react.createElement("span", {className: css(styles$62.selectMenuItemMain)}, itemDisplay, isSelected && react.createElement("span", {className: css(styles$62.selectMenuItemIcon)}, react.createElement(CheckIcon, {"aria-hidden": true}))), react.createElement("span", {className: css(styles$62.selectMenuItemDescription)}, description)), !description && react.createElement(react.Fragment, null, itemDisplay, isSelected && react.createElement("span", {className: css(styles$62.selectMenuItemIcon)}, react.createElement(CheckIcon, {"aria-hidden": true})))), isFavorite !== null && id3 && favoriteButton(onFavorite))), variant === SelectVariant.checkbox && isLoad && react.createElement("button", {className: css(styles$62.selectMenuItem, styles$62.modifiers.load, isFocused && styles$62.modifiers.focus, className), onKeyDown: (event) => {
      this.onKeyDown(event, 0, void 0, true);
    }, onClick: (event) => {
      onViewMoreClick(event);
      event.stopPropagation();
    }, ref: this.ref}, children2 || value && value.toString && value.toString()), variant === SelectVariant.checkbox && isLoading && react.createElement("div", {className: css(styles$62.selectListItem, isLoading && styles$62.modifiers.loading, className)}, children2), variant === SelectVariant.checkbox && !isNoResultsOption && !isLoading && !isLoad && react.createElement("label", Object.assign({}, props, {className: css(checkStyles.check, styles$62.selectMenuItem, isDisabled && styles$62.modifiers.disabled, description && styles$62.modifiers.description, className), onKeyDown: (event) => {
      this.onKeyDown(event, 0, void 0, true);
    }}), react.createElement("input", {id: inputId || `${inputIdPrefix}-${value.toString()}`, className: css(checkStyles.checkInput), type: "checkbox", onChange: (event) => {
      if (!isDisabled) {
        onClick(event);
        onSelect(event, value);
      }
    }, ref: this.ref, checked: isChecked || false, disabled: isDisabled}), react.createElement("span", {className: css(checkStyles.checkLabel, isDisabled && styles$62.modifiers.disabled)}, itemDisplay), description && react.createElement("div", {className: css(checkStyles.checkDescription)}, description)), variant === SelectVariant.checkbox && isNoResultsOption && !isLoading && !isLoad && react.createElement("div", null, react.createElement(Component, Object.assign({}, props, {className: css(styles$62.selectMenuItem, isSelected && styles$62.modifiers.selected, isDisabled && styles$62.modifiers.disabled, className), role: "option", "aria-selected": isSelected || null, ref: this.ref, onKeyDown: (event) => {
      this.onKeyDown(event, 0, void 0, true);
    }, type: "button"}), itemDisplay))));
  }
};
SelectOption.displayName = "SelectOption";
SelectOption.defaultProps = {
  className: "",
  value: "",
  index: 0,
  isDisabled: false,
  isPlaceholder: false,
  isSelected: false,
  isChecked: false,
  isNoResultsOption: false,
  component: "button",
  onClick: () => {
  },
  sendRef: () => {
  },
  keyHandler: () => {
  },
  inputId: "",
  isFavorite: null,
  isLoad: false,
  isLoading: false,
  setViewMoreNextIndex: () => {
  },
  isLastOptionBeforeFooter: () => false
};
var SelectGroup = (_a) => {
  var {children: children2 = [], className = "", label: label2 = "", titleId = ""} = _a, props = __rest(_a, ["children", "className", "label", "titleId"]);
  return react.createElement(SelectConsumer, null, ({variant}) => react.createElement("div", Object.assign({}, props, {className: css(styles$62.selectMenuGroup, className)}), react.createElement("div", {className: css(styles$62.selectMenuGroupTitle), id: titleId, "aria-hidden": true}, label2), variant === SelectVariant.checkbox ? children2 : react.createElement("ul", {role: "listbox"}, children2)));
};
SelectGroup.displayName = "SelectGroup";
var SelectMenuWithRef = class extends react.Component {
  extendChildren(randomId) {
    const {children: children2, hasInlineFilter, isGrouped} = this.props;
    const childrenArray = children2;
    let index3 = hasInlineFilter ? 1 : 0;
    if (isGrouped) {
      return react.Children.map(childrenArray, (group) => {
        if (group.type === SelectGroup) {
          return react.cloneElement(group, {
            titleId: group.props.label && group.props.label.replace(/\W/g, "-"),
            children: react.Children.map(group.props.children, (option) => this.cloneOption(option, index3++, randomId))
          });
        } else {
          return this.cloneOption(group, index3++, randomId);
        }
      });
    }
    return react.Children.map(childrenArray, (child) => this.cloneOption(child, index3++, randomId));
  }
  cloneOption(child, index3, randomId) {
    const {selected, sendRef, keyHandler: keyHandler2} = this.props;
    const isSelected = this.checkForValue(child.props.value, selected);
    if (child.type === Divider) {
      return child;
    }
    return react.cloneElement(child, {
      inputId: `${randomId}-${index3}`,
      isSelected,
      sendRef,
      keyHandler: keyHandler2,
      index: index3
    });
  }
  checkForValue(valueToCheck, options) {
    if (!options || !valueToCheck) {
      return false;
    }
    const isSelectOptionObject = typeof valueToCheck !== "string" && valueToCheck.toString && valueToCheck.compareTo;
    if (Array.isArray(options)) {
      if (isSelectOptionObject) {
        return options.some((option) => option.compareTo(valueToCheck));
      } else {
        return options.includes(valueToCheck);
      }
    } else {
      if (isSelectOptionObject) {
        return options.compareTo(valueToCheck);
      } else {
        return options === valueToCheck;
      }
    }
  }
  extendCheckboxChildren(children2) {
    const {isGrouped, checked, sendRef, keyHandler: keyHandler2, hasInlineFilter, isLastOptionBeforeFooter} = this.props;
    let index3 = hasInlineFilter ? 1 : 0;
    if (isGrouped) {
      return react.Children.map(children2, (group) => {
        if (group.type === SelectOption || group.type === Divider) {
          return group;
        }
        return react.cloneElement(group, {
          titleId: group.props.label && group.props.label.replace(/\W/g, "-"),
          children: group.props.children ? react.createElement("fieldset", {"aria-labelledby": group.props.label && group.props.label.replace(/\W/g, "-"), className: css(styles$62.selectMenuFieldset)}, react.Children.map(group.props.children, (option) => option.type === Divider ? option : react.cloneElement(option, {
            isChecked: this.checkForValue(option.props.value, checked),
            sendRef,
            keyHandler: keyHandler2,
            index: index3++
          }))) : null
        });
      });
    }
    return react.Children.map(children2, (child) => child.type === Divider ? child : react.cloneElement(child, {
      isChecked: this.checkForValue(child.props.value, checked),
      sendRef,
      keyHandler: keyHandler2,
      index: index3++,
      isLastOptionBeforeFooter
    }));
  }
  renderSelectMenu({variant, inputIdPrefix}) {
    const _a = this.props, {children: children2, isCustomContent, className, isExpanded, openedOnEnter, selected, checked, isGrouped, sendRef, keyHandler: keyHandler2, maxHeight, noResultsFoundText, createText, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, hasInlineFilter, innerRef, footer, footerRef} = _a, props = __rest(_a, ["children", "isCustomContent", "className", "isExpanded", "openedOnEnter", "selected", "checked", "isGrouped", "sendRef", "keyHandler", "maxHeight", "noResultsFoundText", "createText", "aria-label", "aria-labelledby", "hasInlineFilter", "innerRef", "footer", "footerRef"]);
    let Component = "div";
    const variantProps = Object.assign({ref: innerRef, className: css(!footer ? styles$62.selectMenu : "pf-c-select__menu-list", className)}, maxHeight && {style: {maxHeight, overflow: "auto"}});
    const extendedChildren = () => variant === SelectVariant.checkbox ? this.extendCheckboxChildren(children2) : this.extendChildren(inputIdPrefix);
    if (isCustomContent) {
      variantProps.children = children2;
    } else if (hasInlineFilter) {
      if (react.Children.count(children2) === 0) {
        variantProps.children = react.createElement("fieldset", {className: css(styles$62.selectMenuFieldset)});
      } else {
        variantProps.children = react.createElement("fieldset", {"aria-label": ariaLabel, "aria-labelledby": !ariaLabel && ariaLabelledBy || null, className: css(formStyles$1.formFieldset)}, children2.shift(), extendedChildren());
      }
    } else {
      variantProps.children = extendedChildren();
      if (!isGrouped) {
        Component = "ul";
        variantProps.role = "listbox";
        variantProps["aria-label"] = ariaLabel;
        variantProps["aria-labelledby"] = !ariaLabel && ariaLabelledBy || null;
      }
    }
    return react.createElement(react.Fragment, null, react.createElement(Component, Object.assign({}, variantProps, props)), footer && react.createElement("div", {className: css(styles$62.selectMenuFooter), ref: footerRef}, footer));
  }
  render() {
    return react.createElement(SelectConsumer, null, (context2) => this.renderSelectMenu(context2));
  }
};
SelectMenuWithRef.displayName = "SelectMenu";
SelectMenuWithRef.defaultProps = {
  className: "",
  isExpanded: false,
  isGrouped: false,
  openedOnEnter: false,
  selected: "",
  maxHeight: "",
  sendRef: () => {
  },
  keyHandler: () => {
  },
  isCustomContent: false,
  hasInlineFilter: false,
  isLastOptionBeforeFooter: () => {
  }
};
var SelectMenu = react.forwardRef((props, ref) => react.createElement(SelectMenuWithRef, Object.assign({innerRef: ref}, props), props.children));
var SelectToggle = class extends react.Component {
  constructor(props) {
    super(props);
    this.onDocClick = (event) => {
      const {parentRef, menuRef, isOpen, onToggle, onClose} = this.props;
      const clickedOnToggle = parentRef && parentRef.current && parentRef.current.contains(event.target);
      const clickedWithinMenu = menuRef && menuRef.current && menuRef.current.contains && menuRef.current.contains(event.target);
      if (isOpen && !(clickedOnToggle || clickedWithinMenu)) {
        onToggle(false);
        onClose();
      }
    };
    this.findTabbableFooterElements = () => {
      const tabbable3 = this.props.footerRef.current.querySelectorAll("input, button, select, textarea, a[href]");
      const list3 = Array.prototype.filter.call(tabbable3, function(item) {
        return item.tabIndex >= "0";
      });
      return list3;
    };
    this.handleGlobalKeys = (event) => {
      const {parentRef, menuRef, hasFooter, isOpen, variant: variant2, onToggle, onClose} = this.props;
      const escFromToggle = parentRef && parentRef.current && parentRef.current.contains(event.target);
      const escFromWithinMenu = menuRef && menuRef.current && menuRef.current.contains && menuRef.current.contains(event.target);
      if (isOpen && event.key === KeyTypes.Tab && (variant2 === SelectVariant.typeahead || variant2 === SelectVariant.typeaheadMulti)) {
        this.props.handleTypeaheadKeys("tab");
        event.preventDefault();
        return;
      }
      if (isOpen && event.key === KeyTypes.Tab && hasFooter) {
        const tabbableItems = this.findTabbableFooterElements();
        if (tabbableItems.length <= 0) {
          onToggle(false);
          onClose();
          this.toggle.current.focus();
          return;
        } else {
          const currentElementIndex = tabbableItems.findIndex((item) => item === document.activeElement);
          if (currentElementIndex === -1) {
            tabbableItems[0].focus();
            return;
          }
          if (event.shiftKey) {
            return;
          }
          if (currentElementIndex + 1 < tabbableItems.length) {
            tabbableItems[currentElementIndex + 1].focus();
          } else {
            onToggle(false);
            onClose();
            this.toggle.current.focus();
          }
          event.preventDefault();
          return;
        }
      }
      if (isOpen && (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) && (escFromToggle || escFromWithinMenu)) {
        onToggle(false);
        onClose();
        this.toggle.current.focus();
      }
    };
    this.onKeyDown = (event) => {
      const {isOpen, onToggle, variant: variant2, onClose, onEnter, handleTypeaheadKeys} = this.props;
      if (variant2 === SelectVariant.typeahead || variant2 === SelectVariant.typeaheadMulti) {
        if (event.key === KeyTypes.ArrowDown || event.key === KeyTypes.ArrowUp) {
          handleTypeaheadKeys(event.key === KeyTypes.ArrowDown && "down" || event.key === KeyTypes.ArrowUp && "up");
          event.preventDefault();
        } else if (event.key === KeyTypes.Enter) {
          if (isOpen) {
            handleTypeaheadKeys("enter");
          } else {
            onToggle(!isOpen);
          }
        }
      }
      if (variant2 === SelectVariant.typeahead || variant2 === SelectVariant.typeaheadMulti || event.key === KeyTypes.Tab && !isOpen || event.key !== KeyTypes.Enter && event.key !== KeyTypes.Space) {
        return;
      }
      event.preventDefault();
      if ((event.key === KeyTypes.Tab || event.key === KeyTypes.Enter || event.key === KeyTypes.Space) && isOpen) {
        onToggle(!isOpen);
        onClose();
        this.toggle.current.focus();
      } else if ((event.key === KeyTypes.Enter || event.key === KeyTypes.Space) && !isOpen) {
        onToggle(!isOpen);
        onEnter();
      }
    };
    const {variant} = props;
    const isTypeahead = variant === SelectVariant.typeahead || variant === SelectVariant.typeaheadMulti;
    this.toggle = isTypeahead ? react.createRef() : react.createRef();
  }
  componentDidMount() {
    document.addEventListener("click", this.onDocClick);
    document.addEventListener("touchstart", this.onDocClick);
    document.addEventListener("keydown", this.handleGlobalKeys);
  }
  componentWillUnmount() {
    document.removeEventListener("click", this.onDocClick);
    document.removeEventListener("touchstart", this.onDocClick);
    document.removeEventListener("keydown", this.handleGlobalKeys);
  }
  render() {
    const _a = this.props, {className, children: children2, isOpen, isActive, isPlain, isDisabled, variant, onToggle, onEnter, onClose, onClickTypeaheadToggleButton, handleTypeaheadKeys, parentRef, menuRef, id: id3, type, hasClearButton, "aria-labelledby": ariaLabelledBy, "aria-label": ariaLabel, hasFooter, footerRef} = _a, props = __rest(_a, ["className", "children", "isOpen", "isActive", "isPlain", "isDisabled", "variant", "onToggle", "onEnter", "onClose", "onClickTypeaheadToggleButton", "handleTypeaheadKeys", "parentRef", "menuRef", "id", "type", "hasClearButton", "aria-labelledby", "aria-label", "hasFooter", "footerRef"]);
    const isTypeahead = variant === SelectVariant.typeahead || variant === SelectVariant.typeaheadMulti || hasClearButton;
    const toggleProps = {
      id: id3,
      "aria-labelledby": ariaLabelledBy,
      "aria-expanded": isOpen,
      "aria-haspopup": variant !== SelectVariant.checkbox && "listbox" || null
    };
    return react.createElement(react.Fragment, null, !isTypeahead && react.createElement("button", Object.assign({}, props, toggleProps, {
      ref: this.toggle,
      type,
      className: css(styles$62.selectToggle, isDisabled && styles$62.modifiers.disabled, isPlain && styles$62.modifiers.plain, isActive && styles$62.modifiers.active, className),
      onClick: (_event) => {
        onToggle(!isOpen);
        if (isOpen) {
          onClose();
        }
      },
      onKeyDown: this.onKeyDown,
      disabled: isDisabled
    }), children2, react.createElement("span", {className: css(styles$62.selectToggleArrow)}, react.createElement(CaretDownIcon, null))), isTypeahead && react.createElement("div", Object.assign({}, props, {
      ref: this.toggle,
      className: css(styles$62.selectToggle, isDisabled && styles$62.modifiers.disabled, isPlain && styles$62.modifiers.plain, isTypeahead && styles$62.modifiers.typeahead, className),
      onClick: (_event) => {
        if (!isDisabled) {
          onToggle(!isOpen);
        }
      },
      onKeyDown: this.onKeyDown
    }), children2, react.createElement("button", Object.assign({}, toggleProps, {type, className: css(buttonStyles.button, styles$62.selectToggleButton, styles$62.modifiers.plain), "aria-label": ariaLabel, onClick: (_event) => {
      onToggle(!isOpen);
      if (isOpen) {
        onClose();
      }
      onClickTypeaheadToggleButton();
    }}, (variant === SelectVariant.typeahead || variant === SelectVariant.typeaheadMulti) && {
      tabIndex: -1
    }, {disabled: isDisabled}), react.createElement(CaretDownIcon, {className: css(styles$62.selectToggleArrow)}))));
  }
};
SelectToggle.displayName = "SelectToggle";
SelectToggle.defaultProps = {
  className: "",
  isOpen: false,
  isActive: false,
  isPlain: false,
  isDisabled: false,
  hasClearButton: false,
  hasFooter: false,
  variant: "single",
  "aria-labelledby": "",
  "aria-label": "",
  type: "button",
  onToggle: () => {
  },
  onEnter: () => {
  },
  onClose: () => {
  },
  onClickTypeaheadToggleButton: () => {
  }
};
var chipGroup = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    chipGroup: "pf-c-chip-group",
    chipGroupClose: "pf-c-chip-group__close",
    chipGroupLabel: "pf-c-chip-group__label",
    chipGroupList: "pf-c-chip-group__list",
    chipGroupListItem: "pf-c-chip-group__list-item",
    chipGroupMain: "pf-c-chip-group__main",
    modifiers: {
      category: "pf-m-category"
    }
  };
});
var styles$72 = /* @__PURE__ */ getDefaultExportFromCjs(chipGroup);
var chip = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    badge: "pf-c-badge",
    button: "pf-c-button",
    chip: "pf-c-chip",
    chipIcon: "pf-c-chip__icon",
    chipText: "pf-c-chip__text",
    modifiers: {
      overflow: "pf-m-overflow",
      draggable: "pf-m-draggable"
    }
  };
});
var styles$8 = /* @__PURE__ */ getDefaultExportFromCjs(chip);
var Chip = class extends react.Component {
  constructor(props) {
    super(props);
    this.span = react.createRef();
    this.renderOverflowChip = () => {
      const {children: children2, className, onClick, ouiaId} = this.props;
      const Component = this.props.component;
      return react.createElement(Component, Object.assign({onClick, className: css(styles$8.chip, styles$8.modifiers.overflow, className)}, this.props.component === "button" ? {type: "button"} : {}, getOUIAProps("OverflowChip", ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId)), react.createElement("span", {className: css(styles$8.chipText)}, children2));
    };
    this.renderChip = (randomId) => {
      const {children: children2, tooltipPosition} = this.props;
      if (this.state.isTooltipVisible) {
        return react.createElement(Tooltip, {position: tooltipPosition, content: children2}, this.renderInnerChip(randomId));
      }
      return this.renderInnerChip(randomId);
    };
    this.state = {
      isTooltipVisible: false,
      ouiaStateId: getDefaultOUIAId(Chip.displayName)
    };
  }
  componentDidMount() {
    this.setState({
      isTooltipVisible: Boolean(this.span.current && this.span.current.offsetWidth < this.span.current.scrollWidth)
    });
  }
  renderInnerChip(id3) {
    const {children: children2, className, onClick, closeBtnAriaLabel, isReadOnly, component, ouiaId} = this.props;
    const Component = component;
    return react.createElement(Component, Object.assign({className: css(styles$8.chip, className)}, this.state.isTooltipVisible && {tabIndex: 0}, getOUIAProps(Chip.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId)), react.createElement("span", {ref: this.span, className: css(styles$8.chipText), id: id3}, children2), !isReadOnly && react.createElement(Button, {onClick, variant: "plain", "aria-label": closeBtnAriaLabel, id: `remove_${id3}`, "aria-labelledby": `remove_${id3} ${id3}`, ouiaId: ouiaId || closeBtnAriaLabel}, react.createElement(TimesIcon, {"aria-hidden": "true"})));
  }
  render() {
    const {isOverflowChip} = this.props;
    return react.createElement(GenerateId, null, (randomId) => isOverflowChip ? this.renderOverflowChip() : this.renderChip(this.props.id || randomId));
  }
};
Chip.displayName = "Chip";
Chip.defaultProps = {
  closeBtnAriaLabel: "close",
  className: "",
  isOverflowChip: false,
  isReadOnly: false,
  tooltipPosition: "top",
  onClick: (_e) => void 0,
  component: "div"
};
var ChipGroup = class extends react.Component {
  constructor(props) {
    super(props);
    this.headingRef = react.createRef();
    this.toggleCollapse = () => {
      this.setState((prevState) => ({
        isOpen: !prevState.isOpen,
        isTooltipVisible: Boolean(this.headingRef.current && this.headingRef.current.offsetWidth < this.headingRef.current.scrollWidth)
      }));
    };
    this.state = {
      isOpen: this.props.defaultIsOpen,
      isTooltipVisible: false
    };
  }
  componentDidMount() {
    this.setState({
      isTooltipVisible: Boolean(this.headingRef.current && this.headingRef.current.offsetWidth < this.headingRef.current.scrollWidth)
    });
  }
  renderLabel(id3) {
    const {categoryName, tooltipPosition} = this.props;
    const {isTooltipVisible} = this.state;
    return isTooltipVisible ? react.createElement(Tooltip, {position: tooltipPosition, content: categoryName}, react.createElement("span", {tabIndex: 0, ref: this.headingRef, className: css(styles$72.chipGroupLabel), id: id3, "aria-label": categoryName}, react.createElement("span", {"aria-hidden": "true"}, categoryName))) : react.createElement("span", {ref: this.headingRef, className: css(styles$72.chipGroupLabel), "aria-hidden": "true", id: id3}, categoryName);
  }
  render() {
    const _a = this.props, {
      categoryName,
      children: children2,
      className,
      isClosable,
      closeBtnAriaLabel,
      "aria-label": ariaLabel,
      onClick,
      onOverflowChipClick,
      numChips,
      expandedText,
      collapsedText,
      ouiaId,
      defaultIsOpen,
      tooltipPosition
    } = _a, rest = __rest(_a, ["categoryName", "children", "className", "isClosable", "closeBtnAriaLabel", "aria-label", "onClick", "onOverflowChipClick", "numChips", "expandedText", "collapsedText", "ouiaId", "defaultIsOpen", "tooltipPosition"]);
    const {isOpen} = this.state;
    const numChildren = react.Children.count(children2);
    const collapsedTextResult = fillTemplate(collapsedText, {
      remaining: react.Children.count(children2) - numChips
    });
    const renderChipGroup = (id3) => {
      const chipArray = !isOpen ? react.Children.toArray(children2).slice(0, numChips) : react.Children.toArray(children2);
      return react.createElement("div", Object.assign({className: css(styles$72.chipGroup, className, categoryName && styles$72.modifiers.category)}, getOUIAProps(ChipGroup.displayName, ouiaId)), react.createElement("div", {className: css(styles$72.chipGroupMain)}, categoryName && this.renderLabel(id3), react.createElement("ul", Object.assign({className: css(styles$72.chipGroupList)}, categoryName && {"aria-labelledby": id3}, !categoryName && {"aria-label": ariaLabel}, {role: "list"}, rest), chipArray.map((child, i3) => react.createElement("li", {className: css(styles$72.chipGroupListItem), key: i3}, child)), numChildren > numChips && react.createElement("li", {className: css(styles$72.chipGroupListItem)}, react.createElement(Chip, {isOverflowChip: true, onClick: (event) => {
        this.toggleCollapse();
        onOverflowChipClick(event);
      }, component: "button"}, isOpen ? expandedText : collapsedTextResult)))), isClosable && react.createElement("div", {className: css(styles$72.chipGroupClose)}, react.createElement(Button, {variant: "plain", "aria-label": closeBtnAriaLabel, onClick, id: `remove_group_${id3}`, "aria-labelledby": `remove_group_${id3} ${id3}`, ouiaId: ouiaId || closeBtnAriaLabel}, react.createElement(TimesCircleIcon, {"aria-hidden": "true"}))));
    };
    return numChildren === 0 ? null : react.createElement(GenerateId, null, (randomId) => renderChipGroup(this.props.id || randomId));
  }
};
ChipGroup.displayName = "ChipGroup";
ChipGroup.defaultProps = {
  expandedText: "Show Less",
  collapsedText: "${remaining} more",
  categoryName: "",
  defaultIsOpen: false,
  numChips: 3,
  isClosable: false,
  onClick: (_e) => void 0,
  onOverflowChipClick: (_e) => void 0,
  closeBtnAriaLabel: "Close chip group",
  tooltipPosition: "top",
  "aria-label": "Chip group category"
};
var currentId$1 = 0;
var Select = class extends react.Component {
  constructor() {
    super(...arguments);
    this.parentRef = react.createRef();
    this.menuComponentRef = react.createRef();
    this.filterRef = react.createRef();
    this.clearRef = react.createRef();
    this.inputRef = react.createRef();
    this.refCollection = [[]];
    this.optionContainerRefCollection = [];
    this.footerRef = react.createRef();
    this.state = {
      focusFirstOption: false,
      typeaheadInputValue: null,
      typeaheadFilteredChildren: react.Children.toArray(this.props.children),
      favoritesGroup: [],
      typeaheadCurrIndex: -1,
      typeaheadStoredIndex: -1,
      creatableValue: "",
      tabbedIntoFavoritesMenu: false,
      ouiaStateId: getDefaultOUIAId(Select.displayName, this.props.variant),
      viewMoreNextIndex: -1
    };
    this.getTypeaheadActiveChild = (typeaheadCurrIndex) => this.refCollection[typeaheadCurrIndex] ? this.refCollection[typeaheadCurrIndex][0] : null;
    this.componentDidUpdate = (prevProps, prevState) => {
      if (this.props.hasInlineFilter) {
        this.refCollection[0][0] = this.filterRef.current;
      }
      if (!prevState.focusFirstOption && this.state.focusFirstOption && !this.props.customContent) {
        const firstRef = this.refCollection.find((ref) => ref !== null);
        if (firstRef && firstRef[0]) {
          firstRef[0].focus();
        }
      }
      if (this.state.viewMoreNextIndex !== -1 && this.refCollection.length > this.state.viewMoreNextIndex && this.props.loadingVariant !== "spinner") {
        this.refCollection[this.state.viewMoreNextIndex][0].focus();
      }
      if (prevProps.children.length !== this.props.children.length || prevProps.children.some((child, index3) => {
        if (child.props && this.props.children[index3].props) {
          return child.props.value !== this.props.children[index3].props.value;
        } else {
          return child === this.props.children[index3];
        }
      })) {
        this.updateTypeAheadFilteredChildren(prevState.typeaheadInputValue || "", null);
      }
      if (this.props.onFavorite && (this.props.favorites.length !== prevProps.favorites.length || this.state.typeaheadFilteredChildren !== prevState.typeaheadFilteredChildren)) {
        const tempRenderableChildren = this.props.variant === "typeahead" || this.props.variant === "typeaheadmulti" ? this.state.typeaheadFilteredChildren : this.props.children;
        const renderableFavorites = createRenderableFavorites(tempRenderableChildren, this.props.isGrouped, this.props.favorites);
        const favoritesGroup = renderableFavorites.length ? [
          react.createElement(SelectGroup, {key: "favorites", label: this.props.favoritesLabel}, renderableFavorites),
          react.createElement(Divider, {key: "favorites-group-divider"})
        ] : [];
        this.setState({favoritesGroup});
      }
    };
    this.onEnter = () => {
      this.setState({focusFirstOption: true});
    };
    this.onToggle = (isExpanded) => {
      const {isInputValuePersisted, onSelect, onToggle, hasInlineFilter} = this.props;
      if (!isExpanded && isInputValuePersisted && onSelect) {
        onSelect(void 0, this.inputRef.current ? this.inputRef.current.value : "");
      }
      if (isExpanded && hasInlineFilter) {
        this.setState({
          focusFirstOption: true
        });
      }
      onToggle(isExpanded);
    };
    this.onClose = () => {
      this.setState({
        focusFirstOption: false,
        typeaheadInputValue: null,
        typeaheadFilteredChildren: react.Children.toArray(this.props.children),
        typeaheadCurrIndex: -1,
        tabbedIntoFavoritesMenu: false
      });
    };
    this.onChange = (e3) => {
      if (e3.target.value.toString() !== "" && !this.props.isOpen) {
        this.onToggle(true);
      }
      if (this.props.onTypeaheadInputChanged) {
        this.props.onTypeaheadInputChanged(e3.target.value.toString());
      }
      this.setState({
        typeaheadCurrIndex: -1,
        typeaheadInputValue: e3.target.value,
        creatableValue: e3.target.value
      });
      this.updateTypeAheadFilteredChildren(e3.target.value.toString(), e3);
      this.refCollection = [[]];
    };
    this.updateTypeAheadFilteredChildren = (typeaheadInputValue, e3) => {
      let typeaheadFilteredChildren;
      const {onFilter, isCreatable, onCreateOption, createText, noResultsFoundText, children: children2, isGrouped} = this.props;
      if (onFilter) {
        typeaheadFilteredChildren = onFilter(e3, e3 ? e3.target.value : typeaheadInputValue) || children2;
      } else {
        let input;
        try {
          input = new RegExp(typeaheadInputValue.toString(), "i");
        } catch (err) {
          input = new RegExp(typeaheadInputValue.toString().replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "i");
        }
        const childrenArray = react.Children.toArray(children2);
        if (isGrouped) {
          const childFilter = (child) => child.props.value && child.props.value.toString && this.getDisplay(child.props.value.toString(), "text").search(input) === 0;
          typeaheadFilteredChildren = typeaheadInputValue.toString() !== "" ? react.Children.map(children2, (group) => {
            if (group.type === SelectGroup) {
              const filteredGroupChildren = react.Children.toArray(group.props.children).filter(childFilter);
              if (filteredGroupChildren.length > 0) {
                return react.cloneElement(group, {
                  titleId: group.props.label && group.props.label.replace(/\W/g, "-"),
                  children: filteredGroupChildren
                });
              }
            } else {
              return react.Children.toArray(group).filter(childFilter);
            }
          }) : childrenArray;
        } else {
          typeaheadFilteredChildren = typeaheadInputValue.toString() !== "" ? childrenArray.filter((child) => {
            const valueToCheck = child.props.value;
            if (!valueToCheck) {
              return true;
            }
            const isSelectOptionObject = typeof valueToCheck !== "string" && valueToCheck.toString && valueToCheck.compareTo;
            if (isSelectOptionObject) {
              return valueToCheck.compareTo(typeaheadInputValue);
            } else {
              return this.getDisplay(child.props.value.toString(), "text").search(input) === 0;
            }
          }) : childrenArray;
        }
      }
      if (!typeaheadFilteredChildren) {
        typeaheadFilteredChildren = [];
      }
      if (typeaheadFilteredChildren.length === 0) {
        !isCreatable && typeaheadFilteredChildren.push(react.createElement(SelectOption, {isDisabled: true, key: 0, value: noResultsFoundText, isNoResultsOption: true}));
      }
      if (isCreatable && typeaheadInputValue !== "") {
        const newValue = typeaheadInputValue;
        typeaheadFilteredChildren.push(react.createElement(SelectOption, {key: 0, value: newValue, onClick: () => onCreateOption && onCreateOption(newValue)}, createText, ' "', newValue, '"'));
      }
      this.setState({
        typeaheadFilteredChildren
      });
    };
    this.onClick = (_e) => {
      if (!this.props.isOpen) {
        this.onToggle(true);
      }
    };
    this.clearSelection = (_e) => {
      this.setState({
        typeaheadInputValue: null,
        typeaheadFilteredChildren: react.Children.toArray(this.props.children),
        typeaheadCurrIndex: -1
      });
    };
    this.sendRef = (optionRef, favoriteRef, optionContainerRef, index3) => {
      this.refCollection[index3] = [optionRef, favoriteRef];
      this.optionContainerRefCollection[index3] = optionContainerRef;
    };
    this.handleMenuKeys = (index3, innerIndex, position2) => {
      keyHandler(index3, innerIndex, position2, this.refCollection, this.refCollection);
      if (this.props.variant === SelectVariant.typeahead || this.props.variant === SelectVariant.typeaheadMulti) {
        if (position2 !== "tab") {
          this.handleTypeaheadKeys(position2);
        }
      }
    };
    this.moveFocus = (nextIndex, updateCurrentIndex = true) => {
      const {isCreatable, createText} = this.props;
      const hasDescriptionElm = Boolean(this.refCollection[nextIndex][0] && this.refCollection[nextIndex][0].classList.contains("pf-m-description"));
      const optionTextElm = hasDescriptionElm ? this.refCollection[nextIndex][0].firstElementChild : this.refCollection[nextIndex][0];
      let typeaheadInputValue = "";
      if (isCreatable && optionTextElm.innerText.includes(createText)) {
        typeaheadInputValue = this.state.creatableValue;
      } else if (optionTextElm) {
        typeaheadInputValue = optionTextElm.innerText;
      }
      this.setState((prevState) => ({
        typeaheadCurrIndex: updateCurrentIndex ? nextIndex : prevState.typeaheadCurrIndex,
        typeaheadStoredIndex: nextIndex,
        typeaheadInputValue
      }));
    };
    this.handleTypeaheadKeys = (position2) => {
      const {isOpen, onFavorite} = this.props;
      const {typeaheadCurrIndex, tabbedIntoFavoritesMenu, typeaheadStoredIndex} = this.state;
      const typeaheadActiveChild = this.getTypeaheadActiveChild(typeaheadCurrIndex);
      if (isOpen) {
        if (position2 === "enter") {
          if (typeaheadActiveChild || this.refCollection[0] && this.refCollection[0][0]) {
            this.setState({
              typeaheadInputValue: typeaheadActiveChild && typeaheadActiveChild.innerText || this.refCollection[0][0].innerText
            });
            if (typeaheadActiveChild) {
              typeaheadActiveChild.click();
            } else {
              this.refCollection[0][0].click();
            }
          }
        } else if (position2 === "tab") {
          if (onFavorite) {
            if (this.inputRef.current === document.activeElement) {
              let indexForFocus = 0;
              if (typeaheadCurrIndex !== -1) {
                indexForFocus = typeaheadCurrIndex;
              } else if (typeaheadStoredIndex !== -1) {
                indexForFocus = typeaheadStoredIndex;
              }
              if (this.refCollection[indexForFocus] !== null && this.refCollection[indexForFocus][0] !== null) {
                this.refCollection[indexForFocus][0].focus();
              } else {
                this.clearRef.current.focus();
              }
              this.setState({
                tabbedIntoFavoritesMenu: true,
                typeaheadCurrIndex: -1
              });
            } else {
              this.inputRef.current.focus();
              this.setState({tabbedIntoFavoritesMenu: false});
            }
          } else {
            this.onToggle(false);
          }
        } else if (!tabbedIntoFavoritesMenu) {
          if (this.refCollection[0][0] === null) {
            return;
          }
          let nextIndex;
          if (typeaheadCurrIndex === -1 && position2 === "down") {
            nextIndex = 0;
          } else if (typeaheadCurrIndex === -1 && position2 === "up") {
            nextIndex = this.refCollection.length - 1;
          } else if (position2 !== "left" && position2 !== "right") {
            nextIndex = getNextIndex(typeaheadCurrIndex, position2, this.refCollection);
          } else {
            nextIndex = typeaheadCurrIndex;
          }
          if (this.refCollection[nextIndex] === null) {
            return;
          }
          this.moveFocus(nextIndex);
        } else {
          const nextIndex = this.refCollection.findIndex((ref) => ref !== void 0 && (ref[0] === document.activeElement || ref[1] === document.activeElement));
          this.moveFocus(nextIndex);
        }
      }
    };
    this.onClickTypeaheadToggleButton = () => {
      if (this.inputRef && this.inputRef.current) {
        this.inputRef.current.focus();
      }
    };
    this.getDisplay = (value, type = "node") => {
      if (!value) {
        return;
      }
      const item = this.props.isGrouped ? react.Children.toArray(this.props.children).reduce((acc, curr) => [...acc, ...react.Children.toArray(curr.props.children)], []).find((child) => child.props.value.toString() === value.toString()) : react.Children.toArray(this.props.children).find((child) => child.props.value && child.props.value.toString() === value.toString());
      if (item) {
        if (item && item.props.children) {
          if (type === "node") {
            return item.props.children;
          }
          return this.findText(item);
        }
        return item.props.value.toString();
      }
      return value.toString();
    };
    this.findText = (item) => {
      if (typeof item === "string") {
        return item;
      } else if (!react.isValidElement(item)) {
        return "";
      } else {
        const multi = [];
        react.Children.toArray(item.props.children).forEach((child) => multi.push(this.findText(child)));
        return multi.join("");
      }
    };
    this.generateSelectedBadge = () => {
      const {customBadgeText, selections} = this.props;
      if (customBadgeText !== null) {
        return customBadgeText;
      }
      if (Array.isArray(selections) && selections.length > 0) {
        return selections.length;
      }
      return null;
    };
    this.setVieMoreNextIndex = () => {
      this.setState({viewMoreNextIndex: this.refCollection.length - 1});
    };
    this.isLastOptionBeforeFooter = (index3) => this.props.footer && index3 === this.refCollection.length - 1 ? true : false;
  }
  extendTypeaheadChildren(typeaheadCurrIndex, favoritesGroup) {
    const {isGrouped, onFavorite} = this.props;
    const typeaheadChildren = favoritesGroup ? favoritesGroup.concat(this.state.typeaheadFilteredChildren) : this.state.typeaheadFilteredChildren;
    const activeElement = this.optionContainerRefCollection[typeaheadCurrIndex];
    let typeaheadActiveChild = this.getTypeaheadActiveChild(typeaheadCurrIndex);
    if (typeaheadActiveChild && typeaheadActiveChild.classList.contains("pf-m-description")) {
      typeaheadActiveChild = typeaheadActiveChild.firstElementChild;
    }
    this.refCollection = [[]];
    this.optionContainerRefCollection = [];
    if (isGrouped) {
      return react.Children.map(typeaheadChildren, (group) => {
        if (group.type === Divider) {
          return group;
        } else if (group.type === SelectGroup && onFavorite) {
          return react.cloneElement(group, {
            titleId: group.props.label && group.props.label.replace(/\W/g, "-"),
            children: react.Children.map(group.props.children, (child) => child.type === Divider ? child : react.cloneElement(child, {
              isFocused: activeElement && (activeElement.id === child.props.id || this.props.isCreatable && typeaheadActiveChild.innerText === `{createText} "${group.props.value}"`)
            }))
          });
        } else if (group.type === SelectGroup) {
          return react.cloneElement(group, {
            titleId: group.props.label && group.props.label.replace(/\W/g, "-"),
            children: react.Children.map(group.props.children, (child) => child.type === Divider ? child : react.cloneElement(child, {
              isFocused: typeaheadActiveChild && (typeaheadActiveChild.innerText === child.props.value.toString() || this.props.isCreatable && typeaheadActiveChild.innerText === `{createText} "${child.props.value}"`)
            }))
          });
        } else {
          return react.cloneElement(group, {
            isFocused: typeaheadActiveChild && (typeaheadActiveChild.innerText === group.props.value.toString() || this.props.isCreatable && typeaheadActiveChild.innerText === `{createText} "${group.props.value}"`)
          });
        }
      });
    }
    return typeaheadChildren.map((child) => {
      const childElement = child;
      return childElement.type.displayName === "Divider" ? child : react.cloneElement(child, {
        isFocused: typeaheadActiveChild && (typeaheadActiveChild.innerText === child.props.value.toString() || this.props.isCreatable && typeaheadActiveChild.innerText === `{createText} "${child.props.value}"`)
      });
    });
  }
  render() {
    const _a = this.props, {
      children: children2,
      chipGroupProps,
      chipGroupComponent,
      className,
      customContent,
      variant,
      direction,
      onSelect,
      onClear,
      toggleId: toggleId2,
      isOpen,
      isGrouped,
      isPlain,
      isDisabled,
      validated,
      selections: selectionsProp,
      typeAheadAriaLabel,
      clearSelectionsAriaLabel,
      toggleAriaLabel,
      removeSelectionAriaLabel,
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledBy,
      "aria-describedby": ariaDescribedby,
      "aria-invalid": ariaInvalid,
      placeholderText,
      width: width2,
      maxHeight,
      toggleIcon,
      ouiaId,
      ouiaSafe,
      hasInlineFilter,
      isCheckboxSelectionBadgeHidden,
      inlineFilterPlaceholderText,
      onFilter,
      onTypeaheadInputChanged,
      onCreateOption,
      isCreatable,
      onToggle,
      createText,
      noResultsFoundText,
      customBadgeText,
      inputIdPrefix,
      isInputValuePersisted,
      menuAppendTo,
      favorites,
      onFavorite,
      favoritesLabel,
      footer,
      loadingVariant
    } = _a, props = __rest(_a, ["children", "chipGroupProps", "chipGroupComponent", "className", "customContent", "variant", "direction", "onSelect", "onClear", "toggleId", "isOpen", "isGrouped", "isPlain", "isDisabled", "validated", "selections", "typeAheadAriaLabel", "clearSelectionsAriaLabel", "toggleAriaLabel", "removeSelectionAriaLabel", "aria-label", "aria-labelledby", "aria-describedby", "aria-invalid", "placeholderText", "width", "maxHeight", "toggleIcon", "ouiaId", "ouiaSafe", "hasInlineFilter", "isCheckboxSelectionBadgeHidden", "inlineFilterPlaceholderText", "onFilter", "onTypeaheadInputChanged", "onCreateOption", "isCreatable", "onToggle", "createText", "noResultsFoundText", "customBadgeText", "inputIdPrefix", "isInputValuePersisted", "menuAppendTo", "favorites", "onFavorite", "favoritesLabel", "footer", "loadingVariant"]);
    const {focusFirstOption: openedOnEnter, typeaheadCurrIndex, typeaheadInputValue, typeaheadFilteredChildren, favoritesGroup} = this.state;
    const selectToggleId = toggleId2 || `pf-select-toggle-id-${currentId$1++}`;
    const selections = Array.isArray(selectionsProp) ? selectionsProp : [selectionsProp];
    const hasAnySelections = Boolean(selections[0] && selections[0] !== "");
    const typeaheadActiveChild = this.getTypeaheadActiveChild(typeaheadCurrIndex);
    let childPlaceholderText = null;
    let renderableItems = [];
    if (onFavorite) {
      let tempExtendedChildren = children2;
      if (variant === "typeahead" || variant === "typeaheadmulti") {
        tempExtendedChildren = this.extendTypeaheadChildren(typeaheadCurrIndex, favoritesGroup);
      } else if (onFavorite) {
        tempExtendedChildren = favoritesGroup.concat(children2);
      }
      renderableItems = extendItemsWithFavorite(tempExtendedChildren, isGrouped, favorites);
    } else {
      renderableItems = children2;
    }
    if (!customContent) {
      if (!hasAnySelections && !placeholderText) {
        const childPlaceholder = react.Children.toArray(children2).filter((child) => child.props.isPlaceholder === true);
        childPlaceholderText = childPlaceholder[0] && this.getDisplay(childPlaceholder[0].props.value, "node") || children2[0] && this.getDisplay(children2[0].props.value, "node");
      }
    }
    if (isOpen) {
      if (renderableItems.find((item) => {
        var _a2;
        return ((_a2 = item) === null || _a2 === void 0 ? void 0 : _a2.key) === "loading";
      }) === void 0) {
        if (loadingVariant === "spinner") {
          renderableItems.push(react.createElement(SelectOption, {isLoading: true, key: "loading", value: "loading"}, react.createElement(Spinner, {size: "lg"})));
        } else if (loadingVariant === null || loadingVariant === void 0 ? void 0 : loadingVariant.text) {
          renderableItems.push(react.createElement(SelectOption, {isLoad: true, key: "loading", value: loadingVariant.text, setViewMoreNextIndex: this.setVieMoreNextIndex, onClick: loadingVariant === null || loadingVariant === void 0 ? void 0 : loadingVariant.onClick}));
        }
      }
    }
    const hasOnClear = onClear !== Select.defaultProps.onClear;
    const clearBtn = react.createElement("button", {className: css(buttonStyles.button, buttonStyles.modifiers.plain, styles$62.selectToggleClear), onClick: (e3) => {
      this.clearSelection(e3);
      onClear(e3);
    }, "aria-label": clearSelectionsAriaLabel, type: "button", disabled: isDisabled, ref: this.clearRef, onKeyDown: (event) => {
      if (event.key === KeyTypes.Enter) {
        this.clearRef.current.click();
      }
    }}, react.createElement(TimesCircleIcon, {"aria-hidden": true}));
    let selectedChips = null;
    if (variant === SelectVariant.typeaheadMulti) {
      selectedChips = chipGroupComponent ? chipGroupComponent : react.createElement(ChipGroup, Object.assign({}, chipGroupProps), selections && selections.map((item) => react.createElement(Chip, {key: item, onClick: (e3) => onSelect(e3, item), closeBtnAriaLabel: removeSelectionAriaLabel}, this.getDisplay(item, "node"))));
    }
    if (hasInlineFilter) {
      const filterBox = react.createElement(react.Fragment, null, react.createElement("div", {key: "inline-filter", className: css(styles$62.selectMenuSearch)}, react.createElement("input", {key: "inline-filter-input", type: "search", className: css(formStyles.formControl, formStyles.modifiers.search), onChange: this.onChange, placeholder: inlineFilterPlaceholderText, onKeyDown: (event) => {
        if (event.key === KeyTypes.ArrowUp) {
          this.handleMenuKeys(0, 0, "up");
          event.preventDefault();
        } else if (event.key === KeyTypes.ArrowDown) {
          this.handleMenuKeys(0, 0, "down");
          event.preventDefault();
        } else if (event.key === KeyTypes.ArrowLeft) {
          this.handleMenuKeys(0, 0, "left");
          event.preventDefault();
        } else if (event.key === KeyTypes.ArrowRight) {
          this.handleMenuKeys(0, 0, "right");
          event.preventDefault();
        } else if (event.key === KeyTypes.Tab && variant === SelectVariant.checkbox) {
          if (event.shiftKey) {
            this.handleMenuKeys(0, 0, "up");
          } else {
            this.handleMenuKeys(0, 0, "down");
          }
          event.stopPropagation();
          event.preventDefault();
        }
      }, ref: this.filterRef, autoComplete: "off"})), react.createElement(Divider, {key: "inline-filter-divider"}));
      renderableItems = [filterBox, ...typeaheadFilteredChildren].map((option, index3) => react.cloneElement(option, {key: index3}));
    }
    let variantProps;
    let variantChildren;
    if (customContent) {
      variantProps = {
        selected: selections,
        openedOnEnter,
        isCustomContent: true
      };
      variantChildren = customContent;
    } else {
      switch (variant) {
        case "single":
          variantProps = {
            selected: selections[0],
            hasInlineFilter,
            openedOnEnter
          };
          variantChildren = renderableItems;
          break;
        case "checkbox":
          variantProps = {
            checked: selections,
            isGrouped,
            hasInlineFilter,
            openedOnEnter
          };
          variantChildren = renderableItems;
          break;
        case "typeahead":
          variantProps = {
            selected: selections[0],
            openedOnEnter
          };
          variantChildren = onFavorite ? renderableItems : this.extendTypeaheadChildren(typeaheadCurrIndex);
          if (variantChildren.length === 0) {
            variantChildren.push(react.createElement(SelectOption, {isDisabled: true, key: 0, value: noResultsFoundText, isNoResultsOption: true}));
          }
          break;
        case "typeaheadmulti":
          variantProps = {
            selected: selections,
            openedOnEnter
          };
          variantChildren = onFavorite ? renderableItems : this.extendTypeaheadChildren(typeaheadCurrIndex);
          if (variantChildren.length === 0) {
            variantChildren.push(react.createElement(SelectOption, {isDisabled: true, key: 0, value: noResultsFoundText, isNoResultsOption: true}));
          }
          break;
      }
    }
    const innerMenu = react.createElement(SelectMenu, Object.assign({}, props, {isGrouped, selected: selections}, variantProps, {openedOnEnter, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, sendRef: this.sendRef, keyHandler: this.handleMenuKeys, maxHeight, ref: this.menuComponentRef, footer, footerRef: this.footerRef, isLastOptionBeforeFooter: this.isLastOptionBeforeFooter}), variantChildren);
    const menuContainer = footer ? react.createElement("div", {className: css(styles$62.selectMenu)}, " ", innerMenu, " ") : innerMenu;
    const popperContainer = react.createElement("div", Object.assign({className: css(styles$62.select, isOpen && styles$62.modifiers.expanded, validated === ValidatedOptions.success && styles$62.modifiers.success, validated === ValidatedOptions.warning && styles$62.modifiers.warning, validated === ValidatedOptions.error && styles$62.modifiers.invalid, direction === SelectDirection.up && styles$62.modifiers.top, className)}, width2 && {style: {width: width2}}, validated !== ValidatedOptions.default && {"aria-describedby": ariaDescribedby}, validated !== ValidatedOptions.default && {"aria-invalid": ariaInvalid}), isOpen && menuContainer);
    const mainContainer = react.createElement("div", Object.assign({className: css(styles$62.select, isOpen && styles$62.modifiers.expanded, validated === ValidatedOptions.success && styles$62.modifiers.success, validated === ValidatedOptions.warning && styles$62.modifiers.warning, validated === ValidatedOptions.error && styles$62.modifiers.invalid, direction === SelectDirection.up && styles$62.modifiers.top, className), ref: this.parentRef}, getOUIAProps(Select.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe), width2 && {style: {width: width2}}, validated !== ValidatedOptions.default && {"aria-describedby": ariaDescribedby}, validated !== ValidatedOptions.default && {"aria-invalid": ariaInvalid}), react.createElement(SelectToggle, Object.assign({id: selectToggleId, parentRef: this.parentRef, menuRef: this.menuComponentRef}, footer && {footerRef: this.footerRef}, {isOpen, isPlain, onToggle: this.onToggle, onEnter: this.onEnter, onClose: this.onClose, variant, "aria-labelledby": `${ariaLabelledBy || ""} ${selectToggleId}`, "aria-label": toggleAriaLabel, handleTypeaheadKeys: this.handleTypeaheadKeys, isDisabled, hasClearButton: hasOnClear, hasFooter: footer !== void 0, onClickTypeaheadToggleButton: this.onClickTypeaheadToggleButton}), customContent && react.createElement("div", {className: css(styles$62.selectToggleWrapper)}, toggleIcon && react.createElement("span", {className: css(styles$62.selectToggleIcon)}, toggleIcon), react.createElement("span", {className: css(styles$62.selectToggleText)}, placeholderText)), variant === SelectVariant.single && !customContent && react.createElement(react.Fragment, null, react.createElement("div", {className: css(styles$62.selectToggleWrapper)}, toggleIcon && react.createElement("span", {className: css(styles$62.selectToggleIcon)}, toggleIcon), react.createElement("span", {className: css(styles$62.selectToggleText)}, this.getDisplay(selections[0], "node") || placeholderText || childPlaceholderText)), hasOnClear && hasAnySelections && clearBtn), variant === SelectVariant.checkbox && !customContent && react.createElement(react.Fragment, null, react.createElement("div", {className: css(styles$62.selectToggleWrapper)}, toggleIcon && react.createElement("span", {className: css(styles$62.selectToggleIcon)}, toggleIcon), react.createElement("span", {className: css(styles$62.selectToggleText)}, placeholderText), !isCheckboxSelectionBadgeHidden && hasAnySelections && react.createElement("div", {className: css(styles$62.selectToggleBadge)}, react.createElement("span", {className: css(badgeStyles.badge, badgeStyles.modifiers.read)}, this.generateSelectedBadge()))), hasOnClear && hasAnySelections && clearBtn), variant === SelectVariant.typeahead && !customContent && react.createElement(react.Fragment, null, react.createElement("div", {className: css(styles$62.selectToggleWrapper)}, toggleIcon && react.createElement("span", {className: css(styles$62.selectToggleIcon)}, toggleIcon), react.createElement("input", {className: css(formStyles.formControl, styles$62.selectToggleTypeahead), "aria-activedescendant": typeaheadActiveChild && typeaheadActiveChild.id, id: `${selectToggleId}-select-typeahead`, "aria-label": typeAheadAriaLabel, placeholder: placeholderText, value: typeaheadInputValue !== null ? typeaheadInputValue : this.getDisplay(selections[0], "text") || "", type: "text", onClick: this.onClick, onChange: this.onChange, autoComplete: "off", disabled: isDisabled, ref: this.inputRef})), hasOnClear && (selections[0] || typeaheadInputValue) && clearBtn), variant === SelectVariant.typeaheadMulti && !customContent && react.createElement(react.Fragment, null, react.createElement("div", {className: css(styles$62.selectToggleWrapper)}, toggleIcon && react.createElement("span", {className: css(styles$62.selectToggleIcon)}, toggleIcon), selections && Array.isArray(selections) && selections.length > 0 && selectedChips, react.createElement("input", {className: css(formStyles.formControl, styles$62.selectToggleTypeahead), "aria-activedescendant": typeaheadActiveChild && typeaheadActiveChild.id, id: `${selectToggleId}-select-multi-typeahead-typeahead`, "aria-label": typeAheadAriaLabel, "aria-invalid": validated === ValidatedOptions.error, placeholder: placeholderText, value: typeaheadInputValue !== null ? typeaheadInputValue : "", type: "text", onChange: this.onChange, onClick: this.onClick, autoComplete: "off", disabled: isDisabled, ref: this.inputRef})), hasOnClear && (selections && selections.length > 0 || typeaheadInputValue) && clearBtn), validated === ValidatedOptions.success && react.createElement("span", {className: css(styles$62.selectToggleStatusIcon)}, react.createElement(CheckCircleIcon, {"aria-hidden": "true"})), validated === ValidatedOptions.error && react.createElement("span", {className: css(styles$62.selectToggleStatusIcon)}, react.createElement(ExclamationCircleIcon, {"aria-hidden": "true"})), validated === ValidatedOptions.warning && react.createElement("span", {className: css(styles$62.selectToggleStatusIcon)}, react.createElement(ExclamationTriangleIcon, {"aria-hidden": "true"}))), isOpen && menuAppendTo === "inline" && menuContainer);
    const getParentElement = () => {
      if (this.parentRef && this.parentRef.current) {
        return this.parentRef.current.parentElement;
      }
      return null;
    };
    return react.createElement(GenerateId, null, (randomId) => react.createElement(SelectContext.Provider, {value: {onSelect, onFavorite, onClose: this.onClose, variant, inputIdPrefix: inputIdPrefix || randomId}}, menuAppendTo === "inline" ? mainContainer : react.createElement(Popper, {trigger: mainContainer, popper: popperContainer, direction, appendTo: menuAppendTo === "parent" ? getParentElement() : menuAppendTo, isVisible: isOpen})));
  }
};
Select.displayName = "Select";
Select.defaultProps = {
  children: [],
  className: "",
  direction: SelectDirection.down,
  toggleId: null,
  isOpen: false,
  isGrouped: false,
  isPlain: false,
  isDisabled: false,
  isCreatable: false,
  validated: "default",
  "aria-label": "",
  "aria-labelledby": "",
  "aria-describedby": "",
  "aria-invalid": false,
  typeAheadAriaLabel: "",
  clearSelectionsAriaLabel: "Clear all",
  toggleAriaLabel: "Options menu",
  removeSelectionAriaLabel: "Remove",
  selections: [],
  createText: "Create",
  placeholderText: "",
  noResultsFoundText: "No results found",
  variant: SelectVariant.single,
  width: "",
  onClear: () => void 0,
  onCreateOption: () => void 0,
  toggleIcon: null,
  onFilter: null,
  onTypeaheadInputChanged: null,
  customContent: null,
  hasInlineFilter: false,
  inlineFilterPlaceholderText: null,
  customBadgeText: null,
  inputIdPrefix: "",
  menuAppendTo: "inline",
  favorites: [],
  favoritesLabel: "Favorites",
  ouiaSafe: true,
  chipGroupComponent: null,
  isInputValuePersisted: false
};
var card = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    card: "pf-c-card",
    cardActions: "pf-c-card__actions",
    cardBody: "pf-c-card__body",
    cardExpandableContent: "pf-c-card__expandable-content",
    cardFooter: "pf-c-card__footer",
    cardHeader: "pf-c-card__header",
    cardHeaderToggle: "pf-c-card__header-toggle",
    cardHeaderToggleIcon: "pf-c-card__header-toggle-icon",
    cardTitle: "pf-c-card__title",
    divider: "pf-c-divider",
    modifiers: {
      hoverable: "pf-m-hoverable",
      selectable: "pf-m-selectable",
      selected: "pf-m-selected",
      compact: "pf-m-compact",
      displayLg: "pf-m-display-lg",
      flat: "pf-m-flat",
      plain: "pf-m-plain",
      rounded: "pf-m-rounded",
      expanded: "pf-m-expanded",
      fullHeight: "pf-m-full-height",
      toggleRight: "pf-m-toggle-right",
      noOffset: "pf-m-no-offset",
      noFill: "pf-m-no-fill",
      overpassFont: "pf-m-overpass-font"
    }
  };
});
var styles$9 = /* @__PURE__ */ getDefaultExportFromCjs(card);
var CardContext = react.createContext({
  cardId: "",
  isExpanded: false
});
var Card = (_a) => {
  var {children: children2 = null, id: id3 = "", className = "", component = "article", isHoverable = false, isCompact = false, isSelectable = false, isSelected = false, isFlat = false, isExpanded = false, isRounded = false, isLarge = false, isFullHeight = false, isPlain = false, ouiaId, ouiaSafe = true} = _a, props = __rest(_a, ["children", "id", "className", "component", "isHoverable", "isCompact", "isSelectable", "isSelected", "isFlat", "isExpanded", "isRounded", "isLarge", "isFullHeight", "isPlain", "ouiaId", "ouiaSafe"]);
  const Component = component;
  const ouiaProps = useOUIAProps(Card.displayName, ouiaId, ouiaSafe);
  if (isCompact && isLarge) {
    console.warn("Card: Cannot use isCompact with isLarge. Defaulting to isCompact");
    isLarge = false;
  }
  return react.createElement(CardContext.Provider, {value: {
    cardId: id3,
    isExpanded
  }}, react.createElement(Component, Object.assign({id: id3, className: css(styles$9.card, isHoverable && styles$9.modifiers.hoverable, isCompact && styles$9.modifiers.compact, isSelectable && styles$9.modifiers.selectable, isSelected && isSelectable && styles$9.modifiers.selected, isExpanded && styles$9.modifiers.expanded, isFlat && styles$9.modifiers.flat, isRounded && styles$9.modifiers.rounded, isLarge && styles$9.modifiers.displayLg, isFullHeight && styles$9.modifiers.fullHeight, isPlain && styles$9.modifiers.plain, className), tabIndex: isSelectable ? "0" : void 0}, props, ouiaProps), children2));
};
Card.displayName = "Card";
var CardActions = (_a) => {
  var {children: children2 = null, className = "", hasNoOffset = false} = _a, props = __rest(_a, ["children", "className", "hasNoOffset"]);
  return react.createElement("div", Object.assign({className: css(styles$9.cardActions, hasNoOffset && styles$9.modifiers.noOffset, className)}, props), children2);
};
CardActions.displayName = "CardActions";
var CardBody = (_a) => {
  var {children: children2 = null, className = "", component = "div", isFilled = true} = _a, props = __rest(_a, ["children", "className", "component", "isFilled"]);
  const Component = component;
  return react.createElement(Component, Object.assign({className: css(styles$9.cardBody, !isFilled && styles$9.modifiers.noFill, className)}, props), children2);
};
CardBody.displayName = "CardBody";
var CardFooter = (_a) => {
  var {children: children2 = null, className = "", component = "div"} = _a, props = __rest(_a, ["children", "className", "component"]);
  const Component = component;
  return react.createElement(Component, Object.assign({className: css(styles$9.cardFooter, className)}, props), children2);
};
CardFooter.displayName = "CardFooter";
var CardTitle = (_a) => {
  var {children: children2 = null, className = "", component = "div"} = _a, props = __rest(_a, ["children", "className", "component"]);
  const Component = component;
  return react.createElement(Component, Object.assign({className: css(styles$9.cardTitle, className)}, props), children2);
};
CardTitle.displayName = "CardTitle";
var CardHeader = (_a) => {
  var {children: children2 = null, className = "", id: id3, onExpand, toggleButtonProps, isToggleRightAligned} = _a, props = __rest(_a, ["children", "className", "id", "onExpand", "toggleButtonProps", "isToggleRightAligned"]);
  return react.createElement(CardContext.Consumer, null, ({cardId}) => {
    const cardHeaderToggle = react.createElement("div", {className: css(styles$9.cardHeaderToggle)}, react.createElement(Button, Object.assign({variant: "plain", type: "button", onClick: (evt) => {
      onExpand(evt, cardId);
    }}, toggleButtonProps), react.createElement("span", {className: css(styles$9.cardHeaderToggleIcon)}, react.createElement(AngleRightIcon, {"aria-hidden": "true"}))));
    return react.createElement("div", Object.assign({className: css(styles$9.cardHeader, isToggleRightAligned && styles$9.modifiers.toggleRight, className), id: id3}, props), onExpand && !isToggleRightAligned && cardHeaderToggle, children2, onExpand && isToggleRightAligned && cardHeaderToggle);
  });
};
CardHeader.displayName = "CardHeader";
var clipboardCopy = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    button: "pf-c-button",
    clipboardCopy: "pf-c-clipboard-copy",
    clipboardCopyActions: "pf-c-clipboard-copy__actions",
    clipboardCopyActionsItem: "pf-c-clipboard-copy__actions-item",
    clipboardCopyExpandableContent: "pf-c-clipboard-copy__expandable-content",
    clipboardCopyGroup: "pf-c-clipboard-copy__group",
    clipboardCopyText: "pf-c-clipboard-copy__text",
    clipboardCopyToggleIcon: "pf-c-clipboard-copy__toggle-icon",
    modifiers: {
      expanded: "pf-m-expanded",
      inline: "pf-m-inline",
      block: "pf-m-block",
      code: "pf-m-code"
    }
  };
});
var styles$a = /* @__PURE__ */ getDefaultExportFromCjs(clipboardCopy);
var CopyIconConfig = {
  name: "CopyIcon",
  height: 512,
  width: 448,
  svgPath: "M320 448v40c0 13.255-10.745 24-24 24H24c-13.255 0-24-10.745-24-24V120c0-13.255 10.745-24 24-24h72v296c0 30.879 25.121 56 56 56h168zm0-344V0H152c-13.255 0-24 10.745-24 24v368c0 13.255 10.745 24 24 24h272c13.255 0 24-10.745 24-24V128H344c-13.2 0-24-10.8-24-24zm120.971-31.029L375.029 7.029A24 24 0 0 0 358.059 0H352v96h96v-6.059a24 24 0 0 0-7.029-16.97z",
  yOffset: 0,
  xOffset: 0
};
var CopyIcon = createIcon(CopyIconConfig);
var ClipboardCopyButton = (_a) => {
  var {onClick, exitDelay = 0, entryDelay = 300, maxWidth = "100px", position: position2 = "top", "aria-label": ariaLabel = "Copyable input", id: id3, textId, children: children2, variant = "control"} = _a, props = __rest(_a, ["onClick", "exitDelay", "entryDelay", "maxWidth", "position", "aria-label", "id", "textId", "children", "variant"]);
  return react.createElement(Tooltip, {trigger: "mouseenter focus click", exitDelay, entryDelay, maxWidth, position: position2, content: react.createElement("div", null, children2)}, react.createElement(Button, Object.assign({type: "button", variant, onClick, "aria-label": ariaLabel, id: id3, "aria-labelledby": `${id3} ${textId}`}, props), react.createElement(CopyIcon, null)));
};
ClipboardCopyButton.displayName = "ClipboardCopyButton";
var ClipboardCopyToggle = (_a) => {
  var {onClick, id: id3, textId, contentId, isExpanded = false} = _a, props = __rest(_a, ["onClick", "id", "textId", "contentId", "isExpanded"]);
  return react.createElement(Button, Object.assign({type: "button", variant: "control", onClick, id: id3, "aria-labelledby": `${id3} ${textId}`, "aria-controls": `${id3} ${contentId}`, "aria-expanded": isExpanded}, props), isExpanded ? react.createElement(AngleDownIcon, {"aria-hidden": "true"}) : react.createElement(AngleRightIcon, {"aria-hidden": "true"}));
};
ClipboardCopyToggle.displayName = "ClipboardCopyToggle";
var ClipboardCopyExpanded = class extends react.Component {
  constructor(props) {
    super(props);
  }
  render() {
    const _a = this.props, {className, children: children2, onChange, isReadOnly, isCode} = _a, props = __rest(_a, ["className", "children", "onChange", "isReadOnly", "isCode"]);
    return react.createElement("div", Object.assign({suppressContentEditableWarning: true, className: css(styles$a.clipboardCopyExpandableContent, className), onInput: (e3) => onChange(e3.target.innerText, e3), contentEditable: !isReadOnly}, props), isCode ? react.createElement("pre", null, children2) : children2);
  }
};
ClipboardCopyExpanded.displayName = "ClipboardCopyExpanded";
ClipboardCopyExpanded.defaultProps = {
  onChange: () => void 0,
  className: "",
  isReadOnly: false,
  isCode: false
};
var clipboardCopyFunc = (event, text) => {
  const clipboard = event.currentTarget.parentElement;
  const el = document.createElement("textarea");
  el.value = text.toString();
  clipboard.appendChild(el);
  el.select();
  document.execCommand("copy");
  clipboard.removeChild(el);
};
var ClipboardCopyVariant;
(function(ClipboardCopyVariant2) {
  ClipboardCopyVariant2["inline"] = "inline";
  ClipboardCopyVariant2["expansion"] = "expansion";
  ClipboardCopyVariant2["inlineCompact"] = "inline-compact";
})(ClipboardCopyVariant || (ClipboardCopyVariant = {}));
var ClipboardCopy = class extends react.Component {
  constructor(props) {
    super(props);
    this.timer = null;
    this.componentDidUpdate = (prevProps, prevState) => {
      if (prevProps.children !== this.props.children) {
        this.updateText(this.props.children);
      }
    };
    this.expandContent = (_event) => {
      this.setState((prevState) => ({
        expanded: !prevState.expanded
      }));
    };
    this.updateText = (text) => {
      this.setState({text});
      this.props.onChange(text);
    };
    this.render = () => {
      const _a = this.props, {
        isExpanded,
        onChange,
        isReadOnly,
        isCode,
        isBlock,
        exitDelay,
        maxWidth,
        entryDelay,
        switchDelay,
        onCopy,
        hoverTip,
        clickTip,
        textAriaLabel,
        toggleAriaLabel,
        variant,
        position: position2,
        className,
        additionalActions
      } = _a, divProps = __rest(_a, ["isExpanded", "onChange", "isReadOnly", "isCode", "isBlock", "exitDelay", "maxWidth", "entryDelay", "switchDelay", "onCopy", "hoverTip", "clickTip", "textAriaLabel", "toggleAriaLabel", "variant", "position", "className", "additionalActions"]);
      const textIdPrefix = "text-input-";
      const toggleIdPrefix = "toggle-";
      const contentIdPrefix = "content-";
      return react.createElement("div", Object.assign({className: css(styles$a.clipboardCopy, variant === "inline-compact" && styles$a.modifiers.inline, isBlock && styles$a.modifiers.block, this.state.expanded && styles$a.modifiers.expanded, className)}, divProps), variant === "inline-compact" && react.createElement(GenerateId, {prefix: ""}, (id3) => react.createElement(react.Fragment, null, !isCode && react.createElement("span", {className: css(styles$a.clipboardCopyText), id: `${textIdPrefix}${id3}`}, this.state.text), isCode && react.createElement("code", {className: css(styles$a.clipboardCopyText, styles$a.modifiers.code), id: `${textIdPrefix}${id3}`}, this.state.text), react.createElement("span", {className: css(styles$a.clipboardCopyActions)}, react.createElement("span", {className: css(styles$a.clipboardCopyActionsItem)}, react.createElement(ClipboardCopyButton, {variant: "plain", exitDelay, entryDelay, maxWidth, position: position2, id: `copy-button-${id3}`, textId: `text-input-${id3}`, "aria-label": hoverTip, onClick: (event) => {
        if (this.timer) {
          window.clearTimeout(this.timer);
          this.setState({copied: false});
        }
        onCopy(event, this.state.text);
        this.setState({copied: true}, () => {
          this.timer = window.setTimeout(() => {
            this.setState({copied: false});
            this.timer = null;
          }, switchDelay);
        });
      }}, this.state.copied ? clickTip : hoverTip)), additionalActions && additionalActions))), variant !== "inline-compact" && react.createElement(GenerateId, {prefix: ""}, (id3) => react.createElement(react.Fragment, null, react.createElement("div", {className: css(styles$a.clipboardCopyGroup)}, variant === "expansion" && react.createElement(ClipboardCopyToggle, {isExpanded: this.state.expanded, onClick: this.expandContent, id: `${toggleIdPrefix}${id3}`, textId: `${textIdPrefix}${id3}`, contentId: `${contentIdPrefix}${id3}`, "aria-label": toggleAriaLabel}), react.createElement(TextInput, {isReadOnly: isReadOnly || this.state.expanded, onChange: this.updateText, value: this.state.text, id: `text-input-${id3}`, "aria-label": textAriaLabel}), react.createElement(ClipboardCopyButton, {exitDelay, entryDelay, maxWidth, position: position2, id: `copy-button-${id3}`, textId: `text-input-${id3}`, "aria-label": hoverTip, onClick: (event) => {
        if (this.timer) {
          window.clearTimeout(this.timer);
          this.setState({copied: false});
        }
        onCopy(event, this.state.text);
        this.setState({copied: true}, () => {
          this.timer = window.setTimeout(() => {
            this.setState({copied: false});
            this.timer = null;
          }, switchDelay);
        });
      }}, this.state.copied ? clickTip : hoverTip)), this.state.expanded && react.createElement(ClipboardCopyExpanded, {isReadOnly, isCode, id: `content-${id3}`, onChange: this.updateText}, this.state.text))));
    };
    this.state = {
      text: this.props.children,
      expanded: this.props.isExpanded,
      copied: false
    };
  }
};
ClipboardCopy.displayName = "ClipboardCopy";
ClipboardCopy.defaultProps = {
  hoverTip: "Copy to clipboard",
  clickTip: "Successfully copied to clipboard!",
  isReadOnly: false,
  isExpanded: false,
  isCode: false,
  variant: "inline",
  position: TooltipPosition.top,
  maxWidth: "150px",
  exitDelay: 1600,
  entryDelay: 300,
  switchDelay: 2e3,
  onCopy: clipboardCopyFunc,
  onChange: () => void 0,
  textAriaLabel: "Copyable input",
  toggleAriaLabel: "Show content",
  additionalActions: null
};
var contextSelector = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    contextSelector: "pf-c-context-selector",
    contextSelectorMenu: "pf-c-context-selector__menu",
    contextSelectorMenuFooter: "pf-c-context-selector__menu-footer",
    contextSelectorMenuList: "pf-c-context-selector__menu-list",
    contextSelectorMenuListItem: "pf-c-context-selector__menu-list-item",
    contextSelectorMenuSearch: "pf-c-context-selector__menu-search",
    contextSelectorToggle: "pf-c-context-selector__toggle",
    contextSelectorToggleIcon: "pf-c-context-selector__toggle-icon",
    contextSelectorToggleText: "pf-c-context-selector__toggle-text",
    modifiers: {
      fullHeight: "pf-m-full-height",
      active: "pf-m-active",
      expanded: "pf-m-expanded",
      plain: "pf-m-plain",
      text: "pf-m-text",
      disabled: "pf-m-disabled"
    }
  };
});
var styles$b = /* @__PURE__ */ getDefaultExportFromCjs(contextSelector);
var ContextSelectorToggle = class extends react.Component {
  constructor() {
    super(...arguments);
    this.toggle = react.createRef();
    this.componentDidMount = () => {
      document.addEventListener("mousedown", this.onDocClick);
      document.addEventListener("touchstart", this.onDocClick);
      document.addEventListener("keydown", this.onEscPress);
    };
    this.componentWillUnmount = () => {
      document.removeEventListener("mousedown", this.onDocClick);
      document.removeEventListener("touchstart", this.onDocClick);
      document.removeEventListener("keydown", this.onEscPress);
    };
    this.onDocClick = (event) => {
      const {isOpen, parentRef, onToggle} = this.props;
      if (isOpen && parentRef && !parentRef.contains(event.target)) {
        onToggle(null, false);
        this.toggle.current.focus();
      }
    };
    this.onEscPress = (event) => {
      const {isOpen, parentRef, onToggle} = this.props;
      const keyCode = event.keyCode || event.which;
      if (isOpen && keyCode === KEY_CODES.ESCAPE_KEY && parentRef && parentRef.contains(event.target)) {
        onToggle(null, false);
        this.toggle.current.focus();
      }
    };
    this.onKeyDown = (event) => {
      const {isOpen, onToggle, onEnter} = this.props;
      if (event.keyCode === KEY_CODES.TAB && !isOpen || event.key !== KEY_CODES.ENTER) {
        return;
      }
      event.preventDefault();
      if ((event.keyCode === KEY_CODES.TAB || event.keyCode === KEY_CODES.ENTER || event.key !== KEY_CODES.SPACE) && isOpen) {
        onToggle(null, !isOpen);
      } else if ((event.keyCode === KEY_CODES.ENTER || event.key === " ") && !isOpen) {
        onToggle(null, !isOpen);
        onEnter();
      }
    };
  }
  render() {
    const _a = this.props, {
      className,
      toggleText,
      isOpen,
      onToggle,
      id: id3,
      isActive,
      onEnter,
      parentRef
    } = _a, props = __rest(_a, ["className", "toggleText", "isOpen", "onToggle", "id", "isActive", "onEnter", "parentRef"]);
    return react.createElement("button", Object.assign({}, props, {id: id3, ref: this.toggle, className: css(styles$b.contextSelectorToggle, isActive && styles$b.modifiers.active, className), type: "button", onClick: (event) => onToggle(event, !isOpen), "aria-expanded": isOpen, onKeyDown: this.onKeyDown}), react.createElement("span", {className: css(styles$b.contextSelectorToggleText)}, toggleText), react.createElement("span", {className: css(styles$b.contextSelectorToggleIcon)}, react.createElement(CaretDownIcon, {"aria-hidden": true})));
  }
};
ContextSelectorToggle.displayName = "ContextSelectorToggle";
ContextSelectorToggle.defaultProps = {
  className: "",
  toggleText: "",
  isOpen: false,
  onEnter: () => void 0,
  parentRef: null,
  isActive: false,
  onToggle: (event, value) => void 0
};
var ContextSelectorMenuList = class extends react.Component {
  constructor() {
    super(...arguments);
    this.refsCollection = [];
    this.sendRef = (index3, ref) => {
      this.refsCollection[index3] = ref;
    };
    this.render = () => {
      const _a = this.props, {className, isOpen, children: children2} = _a, props = __rest(_a, ["className", "isOpen", "children"]);
      return react.createElement("ul", Object.assign({className: css(styles$b.contextSelectorMenuList, className), hidden: !isOpen, role: "menu"}, props), this.extendChildren());
    };
  }
  extendChildren() {
    return react.Children.map(this.props.children, (child, index3) => react.cloneElement(child, {
      sendRef: this.sendRef,
      index: index3
    }));
  }
};
ContextSelectorMenuList.displayName = "ContextSelectorMenuList";
ContextSelectorMenuList.defaultProps = {
  children: null,
  className: "",
  isOpen: true
};
var ContextSelectorContext = react.createContext({
  onSelect: (event, value) => void 0
});
var inputGroup = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    formControl: "pf-c-form-control",
    inputGroup: "pf-c-input-group",
    inputGroupText: "pf-c-input-group__text",
    modifiers: {
      plain: "pf-m-plain"
    }
  };
});
var styles$c = /* @__PURE__ */ getDefaultExportFromCjs(inputGroup);
var FormSelect = class extends react.Component {
  constructor(props) {
    super(props);
    this.handleChange = (event) => {
      this.props.onChange(event.currentTarget.value, event);
    };
    if (!props.id && !props["aria-label"]) {
      console.error("FormSelect requires either an id or aria-label to be specified");
    }
    this.state = {
      ouiaStateId: getDefaultOUIAId(FormSelect.displayName, props.validated)
    };
  }
  render() {
    const _a = this.props, {children: children2, className, value, validated, isDisabled, isRequired, ouiaId, ouiaSafe} = _a, props = __rest(_a, ["children", "className", "value", "validated", "isDisabled", "isRequired", "ouiaId", "ouiaSafe"]);
    const selectedOption = react.Children.toArray(children2).find((option) => option.props.value === value);
    const isSelectedPlaceholder = selectedOption && selectedOption.props.isPlaceholder;
    return react.createElement("select", Object.assign({}, props, {className: css(formStyles.formControl, className, validated === ValidatedOptions.success && formStyles.modifiers.success, validated === ValidatedOptions.warning && formStyles.modifiers.warning, isSelectedPlaceholder && formStyles.modifiers.placeholder), "aria-invalid": validated === ValidatedOptions.error}, getOUIAProps(FormSelect.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe), {onChange: this.handleChange, disabled: isDisabled, required: isRequired, value}), children2);
  }
};
FormSelect.displayName = "FormSelect";
FormSelect.defaultProps = {
  className: "",
  value: "",
  validated: "default",
  isDisabled: false,
  isRequired: false,
  onBlur: () => void 0,
  onFocus: () => void 0,
  onChange: () => void 0,
  ouiaSafe: true
};
var c_form_control_textarea_Height = {
  name: "--pf-c-form-control--textarea--Height",
  value: "auto",
  var: "var(--pf-c-form-control--textarea--Height)"
};
var TextAreResizeOrientation;
(function(TextAreResizeOrientation2) {
  TextAreResizeOrientation2["horizontal"] = "horizontal";
  TextAreResizeOrientation2["vertical"] = "vertical";
  TextAreResizeOrientation2["both"] = "both";
})(TextAreResizeOrientation || (TextAreResizeOrientation = {}));
var TextAreaBase = class extends react.Component {
  constructor(props) {
    super(props);
    this.handleChange = (event) => {
      const field = event.currentTarget;
      if (this.props.autoResize && canUseDOM) {
        field.style.setProperty(c_form_control_textarea_Height.name, "inherit");
        const computed = window.getComputedStyle(field);
        const height = parseInt(computed.getPropertyValue("border-top-width")) + parseInt(computed.getPropertyValue("padding-top")) + field.scrollHeight + parseInt(computed.getPropertyValue("padding-bottom")) + parseInt(computed.getPropertyValue("border-bottom-width"));
        field.style.setProperty(c_form_control_textarea_Height.name, `${height}px`);
      }
      if (this.props.onChange) {
        this.props.onChange(field.value, event);
      }
    };
    if (!props.id && !props["aria-label"]) {
      console.error("TextArea: TextArea requires either an id or aria-label to be specified");
    }
  }
  render() {
    const _a = this.props, {
      className,
      value,
      validated,
      isRequired,
      isDisabled,
      isReadOnly,
      resizeOrientation,
      innerRef,
      readOnly,
      disabled,
      autoResize,
      onChange
    } = _a, props = __rest(_a, ["className", "value", "validated", "isRequired", "isDisabled", "isReadOnly", "resizeOrientation", "innerRef", "readOnly", "disabled", "autoResize", "onChange"]);
    const orientation = `resize${capitalize(resizeOrientation)}`;
    return react.createElement("textarea", Object.assign({className: css(formStyles.formControl, className, resizeOrientation !== TextAreResizeOrientation.both && formStyles.modifiers[orientation], validated === ValidatedOptions.success && formStyles.modifiers.success, validated === ValidatedOptions.warning && formStyles.modifiers.warning), onChange: this.handleChange}, typeof this.props.defaultValue !== "string" && {value}, {"aria-invalid": validated === ValidatedOptions.error, required: isRequired, disabled: isDisabled || disabled, readOnly: isReadOnly || readOnly, ref: innerRef}, props));
  }
};
TextAreaBase.displayName = "TextArea";
TextAreaBase.defaultProps = {
  innerRef: react.createRef(),
  className: "",
  isRequired: false,
  isDisabled: false,
  validated: "default",
  resizeOrientation: "both",
  "aria-label": null
};
var TextArea = react.forwardRef((props, ref) => react.createElement(TextAreaBase, Object.assign({}, props, {innerRef: ref})));
TextArea.displayName = "TextArea";
var InputGroup = (_a) => {
  var {className = "", children: children2} = _a, props = __rest(_a, ["className", "children"]);
  const formCtrls = [FormSelect, TextArea, TextInput].map((comp) => comp.displayName);
  const idItem = react.Children.toArray(children2).find((child) => !formCtrls.includes(child.type.displayName) && child.props.id);
  return react.createElement("div", Object.assign({className: css(styles$c.inputGroup, className)}, props), idItem ? react.Children.map(children2, (child) => formCtrls.includes(child.type.displayName) ? react.cloneElement(child, {"aria-describedby": idItem.props.id}) : child) : children2);
};
InputGroup.displayName = "InputGroup";
var currentId$2 = 0;
var newId = currentId$2++;
var ContextSelector = class extends react.Component {
  constructor(props) {
    super(props);
    this.parentRef = react.createRef();
    this.onEnterPressed = (event) => {
      if (event.charCode === KEY_CODES.ENTER) {
        this.props.onSearchButtonClick();
      }
    };
    this.state = {
      ouiaStateId: getDefaultOUIAId(ContextSelector.displayName)
    };
  }
  render() {
    const toggleId2 = `pf-context-selector-toggle-id-${newId}`;
    const screenReaderLabelId = `pf-context-selector-label-id-${newId}`;
    const searchButtonId = `pf-context-selector-search-button-id-${newId}`;
    const _a = this.props, {children: children2, className, isOpen, onToggle, onSelect, screenReaderLabel, toggleText, searchButtonAriaLabel, searchInputValue, onSearchInputChange, searchInputPlaceholder, onSearchButtonClick, menuAppendTo, ouiaId, ouiaSafe, footer} = _a, props = __rest(_a, ["children", "className", "isOpen", "onToggle", "onSelect", "screenReaderLabel", "toggleText", "searchButtonAriaLabel", "searchInputValue", "onSearchInputChange", "searchInputPlaceholder", "onSearchButtonClick", "menuAppendTo", "ouiaId", "ouiaSafe", "footer"]);
    const menuContainer = react.createElement("div", {className: css(styles$b.contextSelectorMenu)}, isOpen && react.createElement(FocusTrap, {focusTrapOptions: {clickOutsideDeactivates: true}}, react.createElement("div", {className: css(styles$b.contextSelectorMenuSearch)}, react.createElement(InputGroup, null, react.createElement(TextInput, {value: searchInputValue, type: "search", placeholder: searchInputPlaceholder, onChange: onSearchInputChange, onKeyPress: this.onEnterPressed, "aria-labelledby": searchButtonId}), react.createElement(Button, {variant: ButtonVariant.control, "aria-label": searchButtonAriaLabel, id: searchButtonId, onClick: onSearchButtonClick}, react.createElement(SearchIcon, {"aria-hidden": "true"})))), react.createElement(ContextSelectorContext.Provider, {value: {onSelect}}, react.createElement(ContextSelectorMenuList, {isOpen}, children2)), footer));
    const popperContainer = react.createElement("div", Object.assign({className: css(styles$b.contextSelector, isOpen && styles$b.modifiers.expanded, className), ref: this.parentRef}, props), isOpen && menuContainer);
    const mainContainer = react.createElement("div", Object.assign({className: css(styles$b.contextSelector, isOpen && styles$b.modifiers.expanded, className), ref: this.parentRef}, getOUIAProps(ContextSelector.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe), props), screenReaderLabel && react.createElement("span", {id: screenReaderLabelId, hidden: true}, screenReaderLabel), react.createElement(ContextSelectorToggle, {onToggle, isOpen, toggleText, id: toggleId2, parentRef: this.parentRef.current, "aria-labelledby": `${screenReaderLabelId} ${toggleId2}`}), isOpen && menuAppendTo === "inline" && menuContainer);
    const getParentElement = () => {
      if (this.parentRef && this.parentRef.current) {
        return this.parentRef.current.parentElement;
      }
      return null;
    };
    return menuAppendTo === "inline" ? mainContainer : react.createElement(Popper, {trigger: mainContainer, popper: popperContainer, appendTo: menuAppendTo === "parent" ? getParentElement() : menuAppendTo, isVisible: isOpen});
  }
};
ContextSelector.displayName = "ContextSelector";
ContextSelector.defaultProps = {
  children: null,
  className: "",
  isOpen: false,
  onToggle: () => void 0,
  onSelect: () => void 0,
  screenReaderLabel: "",
  toggleText: "",
  searchButtonAriaLabel: "Search menu items",
  searchInputValue: "",
  onSearchInputChange: () => void 0,
  searchInputPlaceholder: "Search",
  onSearchButtonClick: () => void 0,
  menuAppendTo: "inline",
  ouiaSafe: true,
  footer: null
};
var ContextSelectorItem = class extends react.Component {
  constructor() {
    super(...arguments);
    this.ref = react.createRef();
  }
  componentDidMount() {
    this.props.sendRef(this.props.index, this.ref.current);
  }
  render() {
    const _a = this.props, {className, children: children2, onClick, isDisabled, index: index3, sendRef} = _a, props = __rest(_a, ["className", "children", "onClick", "isDisabled", "index", "sendRef"]);
    return react.createElement(ContextSelectorContext.Consumer, null, ({onSelect}) => react.createElement("li", {role: "none"}, react.createElement("button", Object.assign({className: css(styles$b.contextSelectorMenuListItem, className), ref: this.ref, onClick: (event) => {
      if (!isDisabled) {
        onClick(event);
        onSelect(event, children2);
      }
    }, disabled: isDisabled}, props), children2)));
  }
};
ContextSelectorItem.displayName = "ContextSelectorItem";
ContextSelectorItem.defaultProps = {
  children: null,
  className: "",
  isDisabled: false,
  onClick: () => void 0,
  index: void 0,
  sendRef: () => {
  }
};
var dataList = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    dataList: "pf-c-data-list",
    dataListAction: "pf-c-data-list__action",
    dataListCell: "pf-c-data-list__cell",
    dataListCheck: "pf-c-data-list__check",
    dataListExpandableContent: "pf-c-data-list__expandable-content",
    dataListExpandableContentBody: "pf-c-data-list__expandable-content-body",
    dataListItem: "pf-c-data-list__item",
    dataListItemAction: "pf-c-data-list__item-action",
    dataListItemContent: "pf-c-data-list__item-content",
    dataListItemControl: "pf-c-data-list__item-control",
    dataListItemDraggableButton: "pf-c-data-list__item-draggable-button",
    dataListItemDraggableIcon: "pf-c-data-list__item-draggable-icon",
    dataListItemRow: "pf-c-data-list__item-row",
    dataListText: "pf-c-data-list__text",
    dataListToggle: "pf-c-data-list__toggle",
    dataListToggleIcon: "pf-c-data-list__toggle-icon",
    modifiers: {
      hidden: "pf-m-hidden",
      hiddenOnSm: "pf-m-hidden-on-sm",
      visibleOnSm: "pf-m-visible-on-sm",
      hiddenOnMd: "pf-m-hidden-on-md",
      visibleOnMd: "pf-m-visible-on-md",
      hiddenOnLg: "pf-m-hidden-on-lg",
      visibleOnLg: "pf-m-visible-on-lg",
      hiddenOnXl: "pf-m-hidden-on-xl",
      visibleOnXl: "pf-m-visible-on-xl",
      hiddenOn_2xl: "pf-m-hidden-on-2xl",
      visibleOn_2xl: "pf-m-visible-on-2xl",
      icon: "pf-m-icon",
      alignRight: "pf-m-align-right",
      noFill: "pf-m-no-fill",
      flex_2: "pf-m-flex-2",
      flex_3: "pf-m-flex-3",
      flex_4: "pf-m-flex-4",
      flex_5: "pf-m-flex-5",
      gridNone: "pf-m-grid-none",
      gridSm: "pf-m-grid-sm",
      gridMd: "pf-m-grid-md",
      gridLg: "pf-m-grid-lg",
      gridXl: "pf-m-grid-xl",
      grid_2xl: "pf-m-grid-2xl",
      compact: "pf-m-compact",
      dragOver: "pf-m-drag-over",
      truncate: "pf-m-truncate",
      breakWord: "pf-m-break-word",
      nowrap: "pf-m-nowrap",
      selectable: "pf-m-selectable",
      selected: "pf-m-selected",
      ghostRow: "pf-m-ghost-row",
      expanded: "pf-m-expanded",
      disabled: "pf-m-disabled",
      noPadding: "pf-m-no-padding"
    }
  };
});
var styles$d = /* @__PURE__ */ getDefaultExportFromCjs(dataList);
var dataListGrid = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    dataList: "pf-c-data-list",
    dataListCell: "pf-c-data-list__cell",
    dataListExpandableContent: "pf-c-data-list__expandable-content",
    dataListItemContent: "pf-c-data-list__item-content",
    modifiers: {
      icon: "pf-m-icon",
      alignRight: "pf-m-align-right",
      noFill: "pf-m-no-fill",
      flex_2: "pf-m-flex-2",
      flex_3: "pf-m-flex-3",
      flex_4: "pf-m-flex-4",
      flex_5: "pf-m-flex-5",
      gridNone: "pf-m-grid-none",
      gridSm: "pf-m-grid-sm",
      gridMd: "pf-m-grid-md",
      gridLg: "pf-m-grid-lg",
      gridXl: "pf-m-grid-xl",
      grid_2xl: "pf-m-grid-2xl"
    }
  };
});
var stylesGrid = /* @__PURE__ */ getDefaultExportFromCjs(dataListGrid);
var gridBreakpointClasses = {
  none: stylesGrid.modifiers.gridNone,
  always: "pf-m-grid",
  sm: stylesGrid.modifiers.gridSm,
  md: stylesGrid.modifiers.gridMd,
  lg: stylesGrid.modifiers.gridLg,
  xl: stylesGrid.modifiers.gridXl,
  "2xl": stylesGrid.modifiers.grid_2xl
};
var DataListWrapModifier;
(function(DataListWrapModifier2) {
  DataListWrapModifier2["nowrap"] = "nowrap";
  DataListWrapModifier2["truncate"] = "truncate";
  DataListWrapModifier2["breakWord"] = "breakWord";
})(DataListWrapModifier || (DataListWrapModifier = {}));
var DataListContext = react.createContext({
  isSelectable: false
});
var moveItem = (arr, i1, toIndex) => {
  const fromIndex = arr.indexOf(i1);
  if (fromIndex === toIndex) {
    return arr;
  }
  const temp = arr.splice(fromIndex, 1);
  arr.splice(toIndex, 0, temp[0]);
  return arr;
};
var DataList = class extends react.Component {
  constructor() {
    super(...arguments);
    this.dragFinished = false;
    this.arrayCopy = react.Children.toArray(this.props.children);
    this.ref = react.createRef();
    this.state = {
      tempItemOrder: [],
      draggedItemId: null,
      draggingToItemIndex: null,
      dragging: false
    };
    this.getIndex = (id3) => Array.from(this.ref.current.children).findIndex((item) => item.id === id3);
    this.move = (itemOrder) => {
      const ulNode = this.ref.current;
      const nodes = Array.from(ulNode.children);
      if (nodes.map((node) => node.id).every((id3, i3) => id3 === itemOrder[i3])) {
        return;
      }
      while (ulNode.firstChild) {
        ulNode.removeChild(ulNode.lastChild);
      }
      itemOrder.forEach((id3) => {
        ulNode.appendChild(nodes.find((n4) => n4.id === id3));
      });
    };
    this.dragStart0 = (el) => {
      const {onDragStart} = this.props;
      const draggedItemId = el.id;
      el.classList.add(styles$d.modifiers.ghostRow);
      el.setAttribute("aria-pressed", "true");
      this.setState({
        draggedItemId,
        dragging: true
      });
      onDragStart && onDragStart(draggedItemId);
    };
    this.dragStart = (evt) => {
      evt.dataTransfer.effectAllowed = "move";
      evt.dataTransfer.setData("text/plain", evt.currentTarget.id);
      this.dragStart0(evt.currentTarget);
    };
    this.onDragCancel = () => {
      this.move(this.props.itemOrder);
      Array.from(this.ref.current.children).forEach((el) => {
        el.classList.remove(styles$d.modifiers.ghostRow);
        el.classList.remove(styles$d.modifiers.dragOver);
        el.setAttribute("aria-pressed", "false");
      });
      this.setState({
        draggedItemId: null,
        draggingToItemIndex: null,
        dragging: false
      });
      if (this.props.onDragCancel) {
        this.props.onDragCancel();
      }
    };
    this.dragLeave = (evt) => {
      if (!this.isValidDrop(evt)) {
        this.move(this.props.itemOrder);
        this.setState({
          draggingToItemIndex: null
        });
      }
    };
    this.dragEnd0 = (el) => {
      el.classList.remove(styles$d.modifiers.ghostRow);
      el.classList.remove(styles$d.modifiers.dragOver);
      el.setAttribute("aria-pressed", "false");
      this.setState({
        draggedItemId: null,
        draggingToItemIndex: null,
        dragging: false
      });
    };
    this.dragEnd = (evt) => {
      this.dragEnd0(evt.target);
    };
    this.isValidDrop = (evt) => {
      const ulRect = this.ref.current.getBoundingClientRect();
      return evt.clientX > ulRect.x && evt.clientX < ulRect.x + ulRect.width && evt.clientY > ulRect.y && evt.clientY < ulRect.y + ulRect.height;
    };
    this.drop = (evt) => {
      if (this.isValidDrop(evt)) {
        this.props.onDragFinish(this.state.tempItemOrder);
      } else {
        this.onDragCancel();
      }
    };
    this.dragOver0 = (id3) => {
      const draggingToItemIndex = Array.from(this.ref.current.children).findIndex((item) => item.id === id3);
      if (draggingToItemIndex !== this.state.draggingToItemIndex) {
        const tempItemOrder = moveItem([...this.props.itemOrder], this.state.draggedItemId, draggingToItemIndex);
        this.move(tempItemOrder);
        this.setState({
          draggingToItemIndex,
          tempItemOrder
        });
      }
    };
    this.dragOver = (evt) => {
      evt.preventDefault();
      const curListItem = evt.target.closest("li");
      if (!curListItem || !this.ref.current.contains(curListItem) || curListItem.id === this.state.draggedItemId) {
        return null;
      } else {
        this.dragOver0(curListItem.id);
      }
    };
    this.handleDragButtonKeys = (evt) => {
      const {dragging} = this.state;
      if (evt.key !== " " && evt.key !== "Escape" && evt.key !== "Enter" && evt.key !== "ArrowUp" && evt.key !== "ArrowDown") {
        if (dragging) {
          evt.preventDefault();
        }
        return;
      }
      evt.preventDefault();
      const dragItem = evt.target.closest("li");
      if (evt.key === " " || evt.key === "Enter" && !dragging) {
        this.dragStart0(dragItem);
      } else if (dragging) {
        if (evt.key === "Escape" || evt.key === "Enter") {
          this.setState({
            dragging: false
          });
          this.dragFinished = true;
          if (evt.key === "Enter") {
            this.dragEnd0(dragItem);
            this.props.onDragFinish(this.state.tempItemOrder);
          } else {
            this.onDragCancel();
          }
        } else if (evt.key === "ArrowUp") {
          const nextSelection = dragItem.previousSibling;
          if (nextSelection) {
            this.dragOver0(nextSelection.id);
            dragItem.querySelector(`.${styles$d.dataListItemDraggableButton}`).focus();
          }
        } else if (evt.key === "ArrowDown") {
          const nextSelection = dragItem.nextSibling;
          if (nextSelection) {
            this.dragOver0(nextSelection.id);
            dragItem.querySelector(`.${styles$d.dataListItemDraggableButton}`).focus();
          }
        }
      }
    };
  }
  componentDidUpdate(oldProps) {
    if (this.dragFinished) {
      this.dragFinished = false;
      this.setState({
        tempItemOrder: [...this.props.itemOrder],
        draggedItemId: null,
        dragging: false
      });
    }
    if (oldProps.itemOrder !== this.props.itemOrder) {
      this.move(this.props.itemOrder);
    }
  }
  render() {
    const _a = this.props, {
      className,
      children: children2,
      onSelectDataListItem,
      selectedDataListItemId,
      isCompact,
      wrapModifier,
      onDragStart,
      onDragMove,
      onDragCancel,
      onDragFinish,
      gridBreakpoint,
      itemOrder
    } = _a, props = __rest(_a, ["className", "children", "onSelectDataListItem", "selectedDataListItemId", "isCompact", "wrapModifier", "onDragStart", "onDragMove", "onDragCancel", "onDragFinish", "gridBreakpoint", "itemOrder"]);
    const {dragging} = this.state;
    const isSelectable = onSelectDataListItem !== void 0;
    const isDraggable = onDragFinish !== void 0;
    const updateSelectedDataListItem = (id3) => {
      onSelectDataListItem(id3);
    };
    const dragProps = isDraggable && {
      onDragOver: this.dragOver,
      onDrop: this.dragOver,
      onDragLeave: this.dragLeave
    };
    return react.createElement(DataListContext.Provider, {value: {
      isSelectable,
      selectedDataListItemId,
      updateSelectedDataListItem,
      isDraggable,
      dragStart: this.dragStart,
      dragEnd: this.dragEnd,
      drop: this.drop,
      dragKeyHandler: this.handleDragButtonKeys
    }}, react.createElement("ul", Object.assign({className: css(styles$d.dataList, isCompact && styles$d.modifiers.compact, gridBreakpointClasses[gridBreakpoint], wrapModifier && styles$d.modifiers[wrapModifier], dragging && styles$d.modifiers.dragOver, className), style: props.style}, props, dragProps, {ref: this.ref}), children2));
  }
};
DataList.displayName = "DataList";
DataList.defaultProps = {
  children: null,
  className: "",
  selectedDataListItemId: "",
  isCompact: false,
  gridBreakpoint: "md",
  wrapModifier: null
};
var DataListAction = (_a) => {
  var {
    children: children2,
    className,
    visibility,
    id: id3,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    isPlainButtonAction
  } = _a, props = __rest(_a, ["children", "className", "visibility", "id", "aria-label", "aria-labelledby", "isPlainButtonAction"]);
  return react.createElement("div", Object.assign({className: css(styles$d.dataListItemAction, formatBreakpointMods(visibility, styles$d), className)}, props), isPlainButtonAction ? react.createElement("div", {className: css(styles$d.dataListAction)}, children2) : children2);
};
DataListAction.displayName = "DataListAction";
var DataListCell = (_a) => {
  var {children: children2 = null, className = "", width: width2 = 1, isFilled = true, alignRight = false, isIcon = false, wrapModifier = null} = _a, props = __rest(_a, ["children", "className", "width", "isFilled", "alignRight", "isIcon", "wrapModifier"]);
  return react.createElement("div", Object.assign({className: css(styles$d.dataListCell, width2 > 1 && styles$d.modifiers[`flex_${width2}`], !isFilled && styles$d.modifiers.noFill, alignRight && styles$d.modifiers.alignRight, isIcon && styles$d.modifiers.icon, className, wrapModifier && styles$d.modifiers[wrapModifier])}, props), children2);
};
DataListCell.displayName = "DataListCell";
var DataListCheck = (_a) => {
  var {
    className = "",
    onChange = (checked2, event) => {
    },
    isValid = true,
    isDisabled = false,
    isChecked = null,
    checked = null,
    otherControls = false
  } = _a, props = __rest(_a, ["className", "onChange", "isValid", "isDisabled", "isChecked", "checked", "otherControls"]);
  const check2 = react.createElement("div", {className: css(styles$d.dataListCheck)}, react.createElement("input", Object.assign({}, props, {type: "checkbox", onChange: (event) => onChange(event.currentTarget.checked, event), "aria-invalid": !isValid, disabled: isDisabled, checked: isChecked || checked})));
  return react.createElement(react.Fragment, null, !otherControls && react.createElement("div", {className: css(styles$d.dataListItemControl, className)}, check2), otherControls && check2);
};
DataListCheck.displayName = "DataListCheck";
var DataListControl = (_a) => {
  var {children: children2, className = ""} = _a, props = __rest(_a, ["children", "className"]);
  return react.createElement("div", Object.assign({className: css(styles$d.dataListItemControl, className)}, props), children2);
};
DataListControl.displayName = "DataListControl";
var DataListDragButton = (_a) => {
  var {className = "", isDisabled = false} = _a, props = __rest(_a, ["className", "isDisabled"]);
  return react.createElement(DataListContext.Consumer, null, ({dragKeyHandler}) => react.createElement("button", Object.assign({className: css(styles$d.dataListItemDraggableButton, isDisabled && styles$d.modifiers.disabled, className), onKeyDown: dragKeyHandler, type: "button", disabled: isDisabled}, props), react.createElement("span", {className: css(styles$d.dataListItemDraggableIcon)}, react.createElement(GripVerticalIcon, null))));
};
DataListDragButton.displayName = "DataListDragButton";
function findDataListDragButton(node) {
  if (!react.isValidElement(node)) {
    return null;
  }
  if (node.type === DataListDragButton) {
    return node;
  }
  if (node.props.children) {
    for (const child of react.Children.toArray(node.props.children)) {
      const button2 = findDataListDragButton(child);
      if (button2) {
        return button2;
      }
    }
  }
  return null;
}
var DataListItem = class extends react.Component {
  render() {
    const _a = this.props, {children: children2, isExpanded, className, id: id3, "aria-labelledby": ariaLabelledBy} = _a, props = __rest(_a, ["children", "isExpanded", "className", "id", "aria-labelledby"]);
    return react.createElement(DataListContext.Consumer, null, ({isSelectable, selectedDataListItemId, updateSelectedDataListItem, isDraggable, dragStart, dragEnd, drop}) => {
      const selectDataListItem = (event) => {
        let target = event.target;
        while (event.currentTarget !== target) {
          if ("onclick" in target && target.onclick || target.parentNode.classList.contains(styles$d.dataListItemAction) || target.parentNode.classList.contains(styles$d.dataListItemControl)) {
            return;
          } else {
            target = target.parentNode;
          }
        }
        updateSelectedDataListItem(id3);
      };
      const onKeyDown = (event) => {
        if (event.key === KeyTypes.Enter) {
          updateSelectedDataListItem(id3);
        }
      };
      const dragButton = findDataListDragButton(children2);
      const dragProps = isDraggable && {
        draggable: dragButton ? !dragButton.props.isDisabled : true,
        onDrop: drop,
        onDragEnd: dragEnd,
        onDragStart: dragStart
      };
      return react.createElement("li", Object.assign({id: id3, className: css(styles$d.dataListItem, isExpanded && styles$d.modifiers.expanded, isSelectable && styles$d.modifiers.selectable, selectedDataListItemId && selectedDataListItemId === id3 && styles$d.modifiers.selected, className), "aria-labelledby": ariaLabelledBy}, isSelectable && {tabIndex: 0, onClick: selectDataListItem, onKeyDown}, isSelectable && selectedDataListItemId === id3 && {"aria-selected": true}, props, dragProps), react.Children.map(children2, (child) => react.isValidElement(child) && react.cloneElement(child, {
        rowid: ariaLabelledBy
      })));
    });
  }
};
DataListItem.displayName = "DataListItem";
DataListItem.defaultProps = {
  isExpanded: false,
  className: "",
  id: "",
  children: null,
  "aria-labelledby": ""
};
var DataListItemCells = (_a) => {
  var {
    className = "",
    dataListCells,
    rowid = ""
  } = _a, props = __rest(_a, ["className", "dataListCells", "rowid"]);
  return react.createElement("div", Object.assign({className: css(styles$d.dataListItemContent, className)}, props), dataListCells);
};
DataListItemCells.displayName = "DataListItemCells";
var DataListItemRow = (_a) => {
  var {children: children2, className = "", rowid = "", wrapModifier = null} = _a, props = __rest(_a, ["children", "className", "rowid", "wrapModifier"]);
  return react.createElement("div", Object.assign({className: css(styles$d.dataListItemRow, className, wrapModifier && styles$d.modifiers[wrapModifier])}, props), react.Children.map(children2, (child) => react.isValidElement(child) && react.cloneElement(child, {
    rowid
  })));
};
DataListItemRow.displayName = "DataListItemRow";
var DataListToggle = (_a) => {
  var {className = "", isExpanded = false, "aria-controls": ariaControls = "", "aria-label": ariaLabel = "Details", rowid = "", id: id3} = _a, props = __rest(_a, ["className", "isExpanded", "aria-controls", "aria-label", "rowid", "id"]);
  return react.createElement("div", Object.assign({className: css(styles$d.dataListItemControl, className)}, props), react.createElement("div", {className: css(styles$d.dataListToggle)}, react.createElement(Button, {id: id3, variant: ButtonVariant.plain, "aria-controls": ariaControls !== "" && ariaControls, "aria-label": ariaLabel, "aria-labelledby": ariaLabel !== "Details" ? null : `${rowid} ${id3}`, "aria-expanded": isExpanded}, react.createElement("div", {className: css(styles$d.dataListToggleIcon)}, react.createElement(AngleRightIcon, null)))));
};
DataListToggle.displayName = "DataListToggle";
var descriptionList = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    descriptionList: "pf-c-description-list",
    descriptionListDescription: "pf-c-description-list__description",
    descriptionListGroup: "pf-c-description-list__group",
    descriptionListTerm: "pf-c-description-list__term",
    descriptionListText: "pf-c-description-list__text",
    modifiers: {
      inlineGrid: "pf-m-inline-grid",
      autoColumnWidths: "pf-m-auto-column-widths",
      autoFit: "pf-m-auto-fit",
      helpText: "pf-m-help-text",
      "1Col": "pf-m-1-col",
      "2Col": "pf-m-2-col",
      "3Col": "pf-m-3-col",
      horizontal: "pf-m-horizontal",
      vertical: "pf-m-vertical",
      "1ColOnSm": "pf-m-1-col-on-sm",
      "2ColOnSm": "pf-m-2-col-on-sm",
      "3ColOnSm": "pf-m-3-col-on-sm",
      horizontalOnSm: "pf-m-horizontal-on-sm",
      verticalOnSm: "pf-m-vertical-on-sm",
      "1ColOnMd": "pf-m-1-col-on-md",
      "2ColOnMd": "pf-m-2-col-on-md",
      "3ColOnMd": "pf-m-3-col-on-md",
      horizontalOnMd: "pf-m-horizontal-on-md",
      verticalOnMd: "pf-m-vertical-on-md",
      "1ColOnLg": "pf-m-1-col-on-lg",
      "2ColOnLg": "pf-m-2-col-on-lg",
      "3ColOnLg": "pf-m-3-col-on-lg",
      horizontalOnLg: "pf-m-horizontal-on-lg",
      verticalOnLg: "pf-m-vertical-on-lg",
      "1ColOnXl": "pf-m-1-col-on-xl",
      "2ColOnXl": "pf-m-2-col-on-xl",
      "3ColOnXl": "pf-m-3-col-on-xl",
      horizontalOnXl: "pf-m-horizontal-on-xl",
      verticalOnXl: "pf-m-vertical-on-xl",
      "1ColOn_2xl": "pf-m-1-col-on-2xl",
      "2ColOn_2xl": "pf-m-2-col-on-2xl",
      "3ColOn_2xl": "pf-m-3-col-on-2xl",
      horizontalOn_2xl: "pf-m-horizontal-on-2xl",
      verticalOn_2xl: "pf-m-vertical-on-2xl"
    }
  };
});
var styles$e = /* @__PURE__ */ getDefaultExportFromCjs(descriptionList);
var setAutoFitMinModifiers = (autoFitMinModifier) => {
  const prefix2 = "--pf-c-description-list--GridTemplateColumns--min";
  const mods = autoFitMinModifier;
  return Object.keys(mods || {}).reduce((acc, curr) => curr === "default" ? Object.assign(Object.assign({}, acc), {[prefix2]: mods[curr]}) : Object.assign(Object.assign({}, acc), {[`${prefix2}-on-${curr}`]: mods[curr]}), {});
};
var DescriptionList = (_a) => {
  var {className = "", children: children2 = null, isHorizontal = false, isAutoColumnWidths, isAutoFit, isInlineGrid, columnModifier, autoFitMinModifier, orientation, style} = _a, props = __rest(_a, ["className", "children", "isHorizontal", "isAutoColumnWidths", "isAutoFit", "isInlineGrid", "columnModifier", "autoFitMinModifier", "orientation", "style"]);
  return react.createElement("dl", Object.assign({className: css(styles$e.descriptionList, isHorizontal && styles$e.modifiers.horizontal, isAutoColumnWidths && styles$e.modifiers.autoColumnWidths, isAutoFit && styles$e.modifiers.autoFit, formatBreakpointMods(columnModifier, styles$e), formatBreakpointMods(orientation, styles$e), isInlineGrid && styles$e.modifiers.inlineGrid, className), style: autoFitMinModifier || style ? Object.assign(Object.assign({}, isAutoFit ? setAutoFitMinModifiers(autoFitMinModifier) : {}), style) : void 0}, props), children2);
};
DescriptionList.displayName = "DescriptionList";
var DescriptionListDescription = (_a) => {
  var {children: children2 = null, className} = _a, props = __rest(_a, ["children", "className"]);
  return react.createElement("dd", Object.assign({className: css(styles$e.descriptionListDescription, className)}, props), react.createElement("div", {className: "pf-c-description-list__text"}, children2));
};
DescriptionListDescription.displayName = "DescriptionListDescription";
var DescriptionListGroup = ({className, children: children2}) => react.createElement("div", {className: css(styles$e.descriptionListGroup, className)}, children2);
DescriptionListGroup.displayName = "DescriptionListGroup";
var DescriptionListTerm = (_a) => {
  var {children: children2, className} = _a, props = __rest(_a, ["children", "className"]);
  return react.createElement("dt", Object.assign({className: css(styles$e.descriptionListTerm, className)}, props), react.createElement("span", {className: css(styles$e.descriptionListText)}, children2));
};
DescriptionListTerm.displayName = "DescriptionListTerm";
var drawer = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    drawer: "pf-c-drawer",
    drawerActions: "pf-c-drawer__actions",
    drawerBody: "pf-c-drawer__body",
    drawerClose: "pf-c-drawer__close",
    drawerContent: "pf-c-drawer__content",
    drawerHead: "pf-c-drawer__head",
    drawerMain: "pf-c-drawer__main",
    drawerPanel: "pf-c-drawer__panel",
    drawerPanelMain: "pf-c-drawer__panel-main",
    drawerSection: "pf-c-drawer__section",
    drawerSplitter: "pf-c-drawer__splitter",
    drawerSplitterHandle: "pf-c-drawer__splitter-handle",
    modifiers: {
      panelBottom: "pf-m-panel-bottom",
      inline: "pf-m-inline",
      noBorder: "pf-m-no-border",
      resizable: "pf-m-resizable",
      static: "pf-m-static",
      panelLeft: "pf-m-panel-left",
      expanded: "pf-m-expanded",
      resizing: "pf-m-resizing",
      noBackground: "pf-m-no-background",
      light_200: "pf-m-light-200",
      noPadding: "pf-m-no-padding",
      padding: "pf-m-padding",
      vertical: "pf-m-vertical",
      width_25: "pf-m-width-25",
      width_33: "pf-m-width-33",
      width_50: "pf-m-width-50",
      width_66: "pf-m-width-66",
      width_75: "pf-m-width-75",
      width_100: "pf-m-width-100",
      width_25OnLg: "pf-m-width-25-on-lg",
      width_33OnLg: "pf-m-width-33-on-lg",
      width_50OnLg: "pf-m-width-50-on-lg",
      width_66OnLg: "pf-m-width-66-on-lg",
      width_75OnLg: "pf-m-width-75-on-lg",
      width_100OnLg: "pf-m-width-100-on-lg",
      width_25OnXl: "pf-m-width-25-on-xl",
      width_33OnXl: "pf-m-width-33-on-xl",
      width_50OnXl: "pf-m-width-50-on-xl",
      width_66OnXl: "pf-m-width-66-on-xl",
      width_75OnXl: "pf-m-width-75-on-xl",
      width_100OnXl: "pf-m-width-100-on-xl",
      width_25On_2xl: "pf-m-width-25-on-2xl",
      width_33On_2xl: "pf-m-width-33-on-2xl",
      width_50On_2xl: "pf-m-width-50-on-2xl",
      width_66On_2xl: "pf-m-width-66-on-2xl",
      width_75On_2xl: "pf-m-width-75-on-2xl",
      width_100On_2xl: "pf-m-width-100-on-2xl",
      inlineOnLg: "pf-m-inline-on-lg",
      staticOnLg: "pf-m-static-on-lg",
      inlineOnXl: "pf-m-inline-on-xl",
      staticOnXl: "pf-m-static-on-xl",
      inlineOn_2xl: "pf-m-inline-on-2xl",
      staticOn_2xl: "pf-m-static-on-2xl"
    },
    pageMain: "pf-c-page__main"
  };
});
var styles$f = /* @__PURE__ */ getDefaultExportFromCjs(drawer);
var DrawerColorVariant;
(function(DrawerColorVariant2) {
  DrawerColorVariant2["default"] = "default";
  DrawerColorVariant2["light200"] = "light-200";
})(DrawerColorVariant || (DrawerColorVariant = {}));
var DrawerContext = react.createContext({
  isExpanded: false,
  isStatic: false,
  onExpand: () => {
  },
  position: "right",
  drawerRef: null
});
var Drawer = (_a) => {
  var {className = "", children: children2, isExpanded = false, isInline = false, isStatic = false, position: position2 = "right", onExpand = () => {
  }} = _a, props = __rest(_a, ["className", "children", "isExpanded", "isInline", "isStatic", "position", "onExpand"]);
  const drawerRef = react.useRef();
  return react.createElement(DrawerContext.Provider, {value: {isExpanded, isStatic, onExpand, position: position2, drawerRef}}, react.createElement("div", Object.assign({className: css(styles$f.drawer, isExpanded && styles$f.modifiers.expanded, isInline && styles$f.modifiers.inline, isStatic && styles$f.modifiers.static, position2 === "left" && styles$f.modifiers.panelLeft, position2 === "bottom" && styles$f.modifiers.panelBottom, className), ref: drawerRef}, props), children2));
};
Drawer.displayName = "Drawer";
var DrawerActions = (_a) => {
  var {
    className = "",
    children: children2
  } = _a, props = __rest(_a, ["className", "children"]);
  return react.createElement("div", Object.assign({className: css(styles$f.drawerActions, className)}, props), children2);
};
DrawerActions.displayName = "DrawerActions";
var DrawerCloseButton = (_a) => {
  var {
    className = "",
    onClose = () => void 0,
    "aria-label": ariaLabel = "Close drawer panel"
  } = _a, props = __rest(_a, ["className", "onClose", "aria-label"]);
  return react.createElement("div", Object.assign({className: css(styles$f.drawerClose, className)}, props), react.createElement(Button, {variant: "plain", onClick: onClose, "aria-label": ariaLabel}, react.createElement(TimesIcon, null)));
};
DrawerCloseButton.displayName = "DrawerCloseButton";
var DrawerMain = (_a) => {
  var {
    className = "",
    children: children2
  } = _a, props = __rest(_a, ["className", "children"]);
  return react.createElement("div", Object.assign({className: css(styles$f.drawerMain, className)}, props), children2);
};
DrawerMain.displayName = "DrawerMain";
var DrawerContent = (_a) => {
  var {
    className = "",
    children: children2,
    panelContent,
    colorVariant = DrawerColorVariant.default
  } = _a, props = __rest(_a, ["className", "children", "panelContent", "colorVariant"]);
  return react.createElement(DrawerMain, null, react.createElement("div", Object.assign({className: css(styles$f.drawerContent, colorVariant === DrawerColorVariant.light200 && styles$f.modifiers.light_200, className)}, props), children2), panelContent);
};
DrawerContent.displayName = "DrawerContent";
var DrawerContentBody = (_a) => {
  var {
    className = "",
    children: children2,
    hasPadding = false
  } = _a, props = __rest(_a, ["className", "children", "hasPadding"]);
  return react.createElement("div", Object.assign({className: css(styles$f.drawerBody, hasPadding && styles$f.modifiers.padding, className)}, props), children2);
};
DrawerContentBody.displayName = "DrawerContentBody";
var DrawerPanelBody = (_a) => {
  var {
    className = "",
    children: children2,
    hasNoPadding = false
  } = _a, props = __rest(_a, ["className", "children", "hasNoPadding"]);
  return react.createElement("div", Object.assign({className: css(styles$f.drawerBody, hasNoPadding && styles$f.modifiers.noPadding, className)}, props), children2);
};
DrawerPanelBody.displayName = "DrawerPanelBody";
var DrawerHead = (_a) => {
  var {
    className = "",
    children: children2,
    hasNoPadding = false
  } = _a, props = __rest(_a, ["className", "children", "hasNoPadding"]);
  return react.createElement(DrawerPanelBody, {hasNoPadding}, react.createElement("div", Object.assign({className: css(styles$f.drawerHead, className)}, props), children2));
};
DrawerHead.displayName = "DrawerHead";
var isResizing = null;
var newSize = 0;
var DrawerPanelContent = (_a) => {
  var {className = "", id: id3, children: children2, hasNoBorder = false, isResizable = false, onResize, minSize, defaultSize, maxSize, increment = 5, resizeAriaLabel = "Resize", resizeAriaDescribedBy = "Press space to begin resizing, and use the arrow keys to grow or shrink the panel. Press enter or escape to finish resizing.", widths, colorVariant = DrawerColorVariant.default} = _a, props = __rest(_a, ["className", "id", "children", "hasNoBorder", "isResizable", "onResize", "minSize", "defaultSize", "maxSize", "increment", "resizeAriaLabel", "resizeAriaDescribedBy", "widths", "colorVariant"]);
  const panel = react.useRef();
  const {position: position2, isExpanded, isStatic, onExpand, drawerRef} = react.useContext(DrawerContext);
  const hidden = isStatic ? false : !isExpanded;
  const [isExpandedInternal, setIsExpandedInternal] = react.useState(!hidden);
  let currWidth = 0;
  let panelRect;
  let right2;
  let left2;
  let bottom2;
  let setInitialVals = true;
  react.useEffect(() => {
    if (!isStatic && isExpanded) {
      setIsExpandedInternal(isExpanded);
    }
  }, [isStatic, isExpanded]);
  const handleTouchStart = (e3) => {
    e3.stopPropagation();
    document.addEventListener("touchmove", callbackTouchMove, {passive: false});
    document.addEventListener("touchend", callbackTouchEnd);
    isResizing = true;
  };
  const handleMousedown = (e3) => {
    e3.stopPropagation();
    e3.preventDefault();
    document.addEventListener("mousemove", callbackMouseMove);
    document.addEventListener("mouseup", callbackMouseUp);
    drawerRef.current.classList.add(css(styles$f.modifiers.resizing));
    isResizing = true;
    setInitialVals = true;
  };
  const handleMouseMove = (e3) => {
    const mousePos = position2 === "bottom" ? e3.clientY : e3.clientX;
    handleControlMove(e3, mousePos);
  };
  const handleTouchMove = (e3) => {
    e3.preventDefault();
    e3.stopImmediatePropagation();
    const touchPos = position2 === "bottom" ? e3.touches[0].clientY : e3.touches[0].clientX;
    handleControlMove(e3, touchPos);
  };
  const handleControlMove = (e3, controlPosition) => {
    e3.stopPropagation();
    if (!isResizing) {
      return;
    }
    if (setInitialVals) {
      panelRect = panel.current.getBoundingClientRect();
      right2 = panelRect.right;
      left2 = panelRect.left;
      bottom2 = panelRect.bottom;
      setInitialVals = false;
    }
    const mousePos = controlPosition;
    let newSize2 = 0;
    if (position2 === "right") {
      newSize2 = right2 - mousePos;
    } else if (position2 === "left") {
      newSize2 = mousePos - left2;
    } else {
      newSize2 = bottom2 - mousePos;
    }
    if (position2 === "bottom") {
      panel.current.style.overflowAnchor = "none";
    }
    panel.current.style.setProperty("--pf-c-drawer__panel--md--FlexBasis", newSize2 + "px");
    currWidth = newSize2;
  };
  const handleMouseup = () => {
    if (!isResizing) {
      return;
    }
    drawerRef.current.classList.remove(css(styles$f.modifiers.resizing));
    isResizing = false;
    onResize && onResize(currWidth, id3);
    setInitialVals = true;
    document.removeEventListener("mousemove", callbackMouseMove);
    document.removeEventListener("mouseup", callbackMouseUp);
  };
  const handleTouchEnd = (e3) => {
    e3.stopPropagation();
    if (!isResizing) {
      return;
    }
    isResizing = false;
    onResize && onResize(currWidth, id3);
    document.removeEventListener("touchmove", callbackTouchMove);
    document.removeEventListener("touchend", callbackTouchEnd);
  };
  const callbackMouseMove = react.useCallback(handleMouseMove, []);
  const callbackTouchEnd = react.useCallback(handleTouchEnd, []);
  const callbackTouchMove = react.useCallback(handleTouchMove, []);
  const callbackMouseUp = react.useCallback(handleMouseup, []);
  const handleKeys = (e3) => {
    const key = e3.key;
    if (key !== " " && key !== "Escape" && key !== "Enter" && key !== "ArrowUp" && key !== "ArrowDown" && key !== "ArrowLeft" && key !== "ArrowRight") {
      if (isResizing) {
        e3.preventDefault();
      }
      return;
    }
    e3.preventDefault();
    if (key === " " || key === "Escape" || key === "Enter") {
      if (key === " ") {
        isResizing = true;
      } else {
        isResizing = false;
        onResize && onResize(currWidth, id3);
      }
      const panelRect2 = panel.current.getBoundingClientRect();
      newSize = position2 === "bottom" ? panelRect2.height : panelRect2.width;
    }
    if (isResizing) {
      let delta = 0;
      if (key === "ArrowRight") {
        delta = position2 === "left" ? increment : -increment;
      } else if (key === "ArrowLeft") {
        delta = position2 === "left" ? -increment : increment;
      } else if (key === "ArrowUp") {
        delta = increment;
      } else if (key === "ArrowDown") {
        delta = -increment;
      }
      newSize = newSize + delta;
      if (position2 === "bottom") {
        panel.current.style.overflowAnchor = "none";
      }
      panel.current.style.setProperty("--pf-c-drawer__panel--md--FlexBasis", newSize + "px");
      currWidth = newSize;
    }
  };
  const boundaryCssVars = {};
  if (defaultSize) {
    boundaryCssVars["--pf-c-drawer__panel--md--FlexBasis"] = defaultSize;
  }
  if (minSize) {
    boundaryCssVars["--pf-c-drawer__panel--md--FlexBasis--min"] = minSize;
  }
  if (maxSize) {
    boundaryCssVars["--pf-c-drawer__panel--md--FlexBasis--max"] = maxSize;
  }
  return react.createElement("div", Object.assign({id: id3, className: css(styles$f.drawerPanel, isResizable && styles$f.modifiers.resizable, hasNoBorder && styles$f.modifiers.noBorder, formatBreakpointMods(widths, styles$f), colorVariant === DrawerColorVariant.light200 && styles$f.modifiers.light_200, className), ref: panel, onTransitionEnd: (ev) => {
    if (!hidden && ev.nativeEvent.propertyName === "transform") {
      onExpand();
    }
    setIsExpandedInternal(!hidden);
  }, hidden}, (defaultSize || minSize || maxSize) && {
    style: boundaryCssVars
  }, props), isExpandedInternal && react.createElement(react.Fragment, null, isResizable && react.createElement(react.Fragment, null, react.createElement("div", {className: css(styles$f.drawerSplitter, position2 !== "bottom" && styles$f.modifiers.vertical), role: "separator", tabIndex: 0, "aria-orientation": position2 === "bottom" ? "horizontal" : "vertical", "aria-label": resizeAriaLabel, "aria-describedby": resizeAriaDescribedBy, onMouseDown: handleMousedown, onKeyDown: handleKeys, onTouchStart: handleTouchStart}, react.createElement("div", {className: css(styles$f.drawerSplitterHandle), "aria-hidden": true})), react.createElement("div", {className: css(styles$f.drawerPanelMain)}, children2)), !isResizable && children2));
};
DrawerPanelContent.displayName = "DrawerPanelContent";
var AngleDoubleLeftIconConfig = {
  name: "AngleDoubleLeftIcon",
  height: 512,
  width: 448,
  svgPath: "M223.7 239l136-136c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9L319.9 256l96.4 96.4c9.4 9.4 9.4 24.6 0 33.9L393.7 409c-9.4 9.4-24.6 9.4-33.9 0l-136-136c-9.5-9.4-9.5-24.6-.1-34zm-192 34l136 136c9.4 9.4 24.6 9.4 33.9 0l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9L127.9 256l96.4-96.4c9.4-9.4 9.4-24.6 0-33.9L201.7 103c-9.4-9.4-24.6-9.4-33.9 0l-136 136c-9.5 9.4-9.5 24.6-.1 34z",
  yOffset: 0,
  xOffset: 0
};
var AngleDoubleLeftIcon = createIcon(AngleDoubleLeftIconConfig);
var AngleLeftIconConfig = {
  name: "AngleLeftIcon",
  height: 512,
  width: 256,
  svgPath: "M31.7 239l136-136c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9L127.9 256l96.4 96.4c9.4 9.4 9.4 24.6 0 33.9L201.7 409c-9.4 9.4-24.6 9.4-33.9 0l-136-136c-9.5-9.4-9.5-24.6-.1-34z",
  yOffset: 0,
  xOffset: 0
};
var AngleLeftIcon = createIcon(AngleLeftIconConfig);
var AngleDoubleRightIconConfig = {
  name: "AngleDoubleRightIcon",
  height: 512,
  width: 448,
  svgPath: "M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34zm192-34l-136-136c-9.4-9.4-24.6-9.4-33.9 0l-22.6 22.6c-9.4 9.4-9.4 24.6 0 33.9l96.4 96.4-96.4 96.4c-9.4 9.4-9.4 24.6 0 33.9l22.6 22.6c9.4 9.4 24.6 9.4 33.9 0l136-136c9.4-9.2 9.4-24.4 0-33.8z",
  yOffset: 0,
  xOffset: 0
};
var AngleDoubleRightIcon = createIcon(AngleDoubleRightIconConfig);
var EmptyStateBody = (_a) => {
  var {children: children2, className = ""} = _a, props = __rest(_a, ["children", "className"]);
  return react.createElement("div", Object.assign({className: css(styles$7.emptyStateBody, className)}, props), children2);
};
EmptyStateBody.displayName = "EmptyStateBody";
var EmptyStateIcon = (_a) => {
  var {className = "", icon: IconComponent, component: AnyComponent, variant = "icon"} = _a, props = __rest(_a, ["className", "icon", "component", "variant"]);
  const classNames2 = css(styles$7.emptyStateIcon, className);
  return variant === "icon" ? react.createElement(IconComponent, Object.assign({className: classNames2}, props, {"aria-hidden": "true"})) : react.createElement("div", {className: classNames2}, react.createElement(AnyComponent, null));
};
EmptyStateIcon.displayName = "EmptyStateIcon";
var EmptyStateSecondaryActions = (_a) => {
  var {children: children2 = null, className = ""} = _a, props = __rest(_a, ["children", "className"]);
  return react.createElement("div", Object.assign({className: css(styles$7.emptyStateSecondary, className)}, props), children2);
};
EmptyStateSecondaryActions.displayName = "EmptyStateSecondaryActions";
var expandableSection = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    expandableSection: "pf-c-expandable-section",
    expandableSectionContent: "pf-c-expandable-section__content",
    expandableSectionToggle: "pf-c-expandable-section__toggle",
    expandableSectionToggleIcon: "pf-c-expandable-section__toggle-icon",
    expandableSectionToggleText: "pf-c-expandable-section__toggle-text",
    modifiers: {
      expanded: "pf-m-expanded",
      detached: "pf-m-detached",
      limitWidth: "pf-m-limit-width",
      displayLg: "pf-m-display-lg",
      active: "pf-m-active",
      expandTop: "pf-m-expand-top",
      overpassFont: "pf-m-overpass-font"
    }
  };
});
var styles$g = /* @__PURE__ */ getDefaultExportFromCjs(expandableSection);
var ExpandableSection = class extends react.Component {
  constructor(props) {
    super(props);
    this.state = {
      isExpanded: props.isExpanded
    };
  }
  calculateToggleText(toggleText, toggleTextExpanded, toggleTextCollapsed, propOrStateIsExpanded) {
    if (propOrStateIsExpanded && toggleTextExpanded !== "") {
      return toggleTextExpanded;
    }
    if (!propOrStateIsExpanded && toggleTextCollapsed !== "") {
      return toggleTextCollapsed;
    }
    return toggleText;
  }
  render() {
    const _a = this.props, {
      onToggle: onToggleProp,
      isActive,
      className,
      toggleText,
      toggleTextExpanded,
      toggleTextCollapsed,
      children: children2,
      isExpanded,
      isDetached: isDetached2,
      displaySize,
      isWidthLimited,
      contentId
    } = _a, props = __rest(_a, ["onToggle", "isActive", "className", "toggleText", "toggleTextExpanded", "toggleTextCollapsed", "children", "isExpanded", "isDetached", "displaySize", "isWidthLimited", "contentId"]);
    let onToggle = onToggleProp;
    let propOrStateIsExpanded = isExpanded;
    if (isExpanded === void 0) {
      propOrStateIsExpanded = this.state.isExpanded;
      onToggle = (isOpen) => {
        this.setState({isExpanded: isOpen}, () => onToggleProp(this.state.isExpanded));
      };
    }
    const computedToggleText = this.calculateToggleText(toggleText, toggleTextExpanded, toggleTextCollapsed, propOrStateIsExpanded);
    return react.createElement("div", Object.assign({}, props, {className: css(styles$g.expandableSection, propOrStateIsExpanded && styles$g.modifiers.expanded, isActive && styles$g.modifiers.active, isDetached2 && styles$g.modifiers.detached, displaySize === "large" && styles$g.modifiers.displayLg, isWidthLimited && styles$g.modifiers.limitWidth, className)}), !isDetached2 && react.createElement("button", {className: css(styles$g.expandableSectionToggle), type: "button", "aria-expanded": propOrStateIsExpanded, onClick: () => onToggle(!propOrStateIsExpanded)}, react.createElement("span", {className: css(styles$g.expandableSectionToggleIcon)}, react.createElement(AngleRightIcon, {"aria-hidden": true})), react.createElement("span", {className: css(styles$g.expandableSectionToggleText)}, computedToggleText)), react.createElement("div", {className: css(styles$g.expandableSectionContent), hidden: !propOrStateIsExpanded, id: contentId}, children2));
  }
};
ExpandableSection.displayName = "ExpandableSection";
ExpandableSection.defaultProps = {
  className: "",
  toggleText: "",
  toggleTextExpanded: "",
  toggleTextCollapsed: "",
  onToggle: (isExpanded) => void 0,
  isActive: false,
  isDetached: false,
  displaySize: "default",
  isWidthLimited: false,
  contentId: ""
};
var fileUpload = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    button: "pf-c-button",
    fileUpload: "pf-c-file-upload",
    fileUploadFileDetails: "pf-c-file-upload__file-details",
    fileUploadFileDetailsSpinner: "pf-c-file-upload__file-details-spinner",
    fileUploadFileSelect: "pf-c-file-upload__file-select",
    formControl: "pf-c-form-control",
    modifiers: {
      dragHover: "pf-m-drag-hover",
      loading: "pf-m-loading",
      control: "pf-m-control"
    }
  };
});
var styles$h = /* @__PURE__ */ getDefaultExportFromCjs(fileUpload);
var fileReaderType;
(function(fileReaderType2) {
  fileReaderType2["text"] = "text";
  fileReaderType2["dataURL"] = "dataURL";
})(fileReaderType || (fileReaderType = {}));
function readFile(fileHandle, type) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = () => reject(reader.error);
    if (type === fileReaderType.text) {
      reader.readAsText(fileHandle);
    } else if (type === fileReaderType.dataURL) {
      reader.readAsDataURL(fileHandle);
    } else {
      reject("unknown type");
    }
  });
}
var FileUploadField = (_a) => {
  var {id: id3, type, value = "", filename = "", onChange = () => {
  }, onBrowseButtonClick = () => {
  }, onClearButtonClick = () => {
  }, onTextAreaClick, className = "", isDisabled = false, isReadOnly = false, isLoading = false, spinnerAriaValueText, isRequired = false, isDragActive = false, validated = "default", "aria-label": ariaLabel = "File upload", filenamePlaceholder = "Drag a file here or browse to upload", filenameAriaLabel = filename ? "Read only filename" : filenamePlaceholder, browseButtonText = "Browse...", clearButtonText = "Clear", isClearButtonDisabled = !filename && !value, containerRef = null, allowEditingUploadedText = false, hideDefaultPreview = false, children: children2 = null} = _a, props = __rest(_a, ["id", "type", "value", "filename", "onChange", "onBrowseButtonClick", "onClearButtonClick", "onTextAreaClick", "className", "isDisabled", "isReadOnly", "isLoading", "spinnerAriaValueText", "isRequired", "isDragActive", "validated", "aria-label", "filenamePlaceholder", "filenameAriaLabel", "browseButtonText", "clearButtonText", "isClearButtonDisabled", "containerRef", "allowEditingUploadedText", "hideDefaultPreview", "children"]);
  const onTextAreaChange = (newValue, event) => {
    onChange(newValue, filename, event);
  };
  return react.createElement("div", Object.assign({className: css(styles$h.fileUpload, isDragActive && styles$h.modifiers.dragHover, isLoading && styles$h.modifiers.loading, className), ref: containerRef}, props), react.createElement("div", {className: styles$h.fileUploadFileSelect}, react.createElement(InputGroup, null, react.createElement(TextInput, {isReadOnly: true, isDisabled, id: `${id3}-filename`, name: `${id3}-filename`, "aria-label": filenameAriaLabel, placeholder: filenamePlaceholder, "aria-describedby": `${id3}-browse-button`, value: filename}), react.createElement(Button, {id: `${id3}-browse-button`, variant: ButtonVariant.control, onClick: onBrowseButtonClick, isDisabled}, browseButtonText), react.createElement(Button, {variant: ButtonVariant.control, isDisabled: isDisabled || isClearButtonDisabled, onClick: onClearButtonClick}, clearButtonText))), react.createElement("div", {className: styles$h.fileUploadFileDetails}, !hideDefaultPreview && type === fileReaderType.text && react.createElement(TextArea, {readOnly: isReadOnly || !!filename && !allowEditingUploadedText, disabled: isDisabled, isRequired, resizeOrientation: TextAreResizeOrientation.vertical, validated, id: id3, name: id3, "aria-label": ariaLabel, value, onChange: onTextAreaChange, onClick: onTextAreaClick}), isLoading && react.createElement("div", {className: styles$h.fileUploadFileDetailsSpinner}, react.createElement(Spinner, {size: spinnerSize.lg, "aria-valuetext": spinnerAriaValueText}))), children2);
};
FileUploadField.displayName = "FileUploadField";
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _23 = {label: 0, sent: function() {
    if (t4[0] & 1)
      throw t4[1];
    return t4[1];
  }, trys: [], ops: []}, f3, y4, t4, g3;
  return g3 = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
    return this;
  }), g3;
  function verb(n4) {
    return function(v3) {
      return step([n4, v3]);
    };
  }
  function step(op) {
    if (f3)
      throw new TypeError("Generator is already executing.");
    while (_23)
      try {
        if (f3 = 1, y4 && (t4 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t4 = y4["return"]) && t4.call(y4), 0) : y4.next) && !(t4 = t4.call(y4, op[1])).done)
          return t4;
        if (y4 = 0, t4)
          op = [op[0] & 2, t4.value];
        switch (op[0]) {
          case 0:
          case 1:
            t4 = op;
            break;
          case 4:
            _23.label++;
            return {value: op[1], done: false};
          case 5:
            _23.label++;
            y4 = op[1];
            op = [0];
            continue;
          case 7:
            op = _23.ops.pop();
            _23.trys.pop();
            continue;
          default:
            if (!(t4 = _23.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _23 = 0;
              continue;
            }
            if (op[0] === 3 && (!t4 || op[1] > t4[0] && op[1] < t4[3])) {
              _23.label = op[1];
              break;
            }
            if (op[0] === 6 && _23.label < t4[1]) {
              _23.label = t4[1];
              t4 = op;
              break;
            }
            if (t4 && _23.label < t4[2]) {
              _23.label = t4[2];
              _23.ops.push(op);
              break;
            }
            if (t4[2])
              _23.ops.pop();
            _23.trys.pop();
            continue;
        }
        op = body.call(thisArg, _23);
      } catch (e3) {
        op = [6, e3];
        y4 = 0;
      } finally {
        f3 = t4 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {value: op[0] ? op[1] : void 0, done: true};
  }
}
function __read(o, n4) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i3 = m3.call(o), r4, ar = [], e3;
  try {
    while ((n4 === void 0 || n4-- > 0) && !(r4 = i3.next()).done)
      ar.push(r4.value);
  } catch (error2) {
    e3 = {error: error2};
  } finally {
    try {
      if (r4 && !r4.done && (m3 = i3["return"]))
        m3.call(i3);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i3 = 0; i3 < arguments.length; i3++)
    ar = ar.concat(__read(arguments[i3]));
  return ar;
}
var COMMON_MIME_TYPES = new Map([
  ["avi", "video/avi"],
  ["gif", "image/gif"],
  ["ico", "image/x-icon"],
  ["jpeg", "image/jpeg"],
  ["jpg", "image/jpeg"],
  ["mkv", "video/x-matroska"],
  ["mov", "video/quicktime"],
  ["mp4", "video/mp4"],
  ["pdf", "application/pdf"],
  ["png", "image/png"],
  ["zip", "application/zip"],
  ["doc", "application/msword"],
  ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"]
]);
function toFileWithPath(file, path) {
  var f3 = withMimeType(file);
  if (typeof f3.path !== "string") {
    var webkitRelativePath = file.webkitRelativePath;
    Object.defineProperty(f3, "path", {
      value: typeof path === "string" ? path : typeof webkitRelativePath === "string" && webkitRelativePath.length > 0 ? webkitRelativePath : file.name,
      writable: false,
      configurable: false,
      enumerable: true
    });
  }
  return f3;
}
function withMimeType(file) {
  var name = file.name;
  var hasExtension = name && name.lastIndexOf(".") !== -1;
  if (hasExtension && !file.type) {
    var ext = name.split(".").pop().toLowerCase();
    var type = COMMON_MIME_TYPES.get(ext);
    if (type) {
      Object.defineProperty(file, "type", {
        value: type,
        writable: false,
        configurable: false,
        enumerable: true
      });
    }
  }
  return file;
}
var FILES_TO_IGNORE = [
  ".DS_Store",
  "Thumbs.db"
];
function fromEvent(evt) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a) {
      return [2, isDragEvt(evt) && evt.dataTransfer ? getDataTransferFiles(evt.dataTransfer, evt.type) : getInputFiles(evt)];
    });
  });
}
function isDragEvt(value) {
  return !!value.dataTransfer;
}
function getInputFiles(evt) {
  var files = isInput3(evt.target) ? evt.target.files ? fromList(evt.target.files) : [] : [];
  return files.map(function(file) {
    return toFileWithPath(file);
  });
}
function isInput3(value) {
  return value !== null;
}
function getDataTransferFiles(dt, type) {
  return __awaiter(this, void 0, void 0, function() {
    var items, files;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          if (!dt.items)
            return [3, 2];
          items = fromList(dt.items).filter(function(item) {
            return item.kind === "file";
          });
          if (type !== "drop") {
            return [2, items];
          }
          return [4, Promise.all(items.map(toFilePromises))];
        case 1:
          files = _a.sent();
          return [2, noIgnoredFiles(flatten(files))];
        case 2:
          return [2, noIgnoredFiles(fromList(dt.files).map(function(file) {
            return toFileWithPath(file);
          }))];
      }
    });
  });
}
function noIgnoredFiles(files) {
  return files.filter(function(file) {
    return FILES_TO_IGNORE.indexOf(file.name) === -1;
  });
}
function fromList(items) {
  var files = [];
  for (var i3 = 0; i3 < items.length; i3++) {
    var file = items[i3];
    files.push(file);
  }
  return files;
}
function toFilePromises(item) {
  if (typeof item.webkitGetAsEntry !== "function") {
    return fromDataTransferItem(item);
  }
  var entry = item.webkitGetAsEntry();
  if (entry && entry.isDirectory) {
    return fromDirEntry(entry);
  }
  return fromDataTransferItem(item);
}
function flatten(items) {
  return items.reduce(function(acc, files) {
    return __spread(acc, Array.isArray(files) ? flatten(files) : [files]);
  }, []);
}
function fromDataTransferItem(item) {
  var file = item.getAsFile();
  if (!file) {
    return Promise.reject(item + " is not a File");
  }
  var fwp = toFileWithPath(file);
  return Promise.resolve(fwp);
}
function fromEntry(entry) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a) {
      return [2, entry.isDirectory ? fromDirEntry(entry) : fromFileEntry(entry)];
    });
  });
}
function fromDirEntry(entry) {
  var reader = entry.createReader();
  return new Promise(function(resolve, reject) {
    var entries = [];
    function readEntries() {
      var _this = this;
      reader.readEntries(function(batch2) {
        return __awaiter(_this, void 0, void 0, function() {
          var files, err_1, items;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!!batch2.length)
                  return [3, 5];
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, Promise.all(entries)];
              case 2:
                files = _a.sent();
                resolve(files);
                return [3, 4];
              case 3:
                err_1 = _a.sent();
                reject(err_1);
                return [3, 4];
              case 4:
                return [3, 6];
              case 5:
                items = Promise.all(batch2.map(fromEntry));
                entries.push(items);
                readEntries();
                _a.label = 6;
              case 6:
                return [2];
            }
          });
        });
      }, function(err) {
        reject(err);
      });
    }
    readEntries();
  });
}
function fromFileEntry(entry) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a) {
      return [2, new Promise(function(resolve, reject) {
        entry.file(function(file) {
          var fwp = toFileWithPath(file, entry.fullPath);
          resolve(fwp);
        }, function(err) {
          reject(err);
        });
      })];
    });
  });
}
var dist = createCommonjsModule(function(module2) {
  module2.exports = function(t4) {
    function n4(e3) {
      if (r4[e3])
        return r4[e3].exports;
      var o = r4[e3] = {i: e3, l: false, exports: {}};
      return t4[e3].call(o.exports, o, o.exports, n4), o.l = true, o.exports;
    }
    var r4 = {};
    return n4.m = t4, n4.c = r4, n4.d = function(t5, r5, e3) {
      n4.o(t5, r5) || Object.defineProperty(t5, r5, {configurable: false, enumerable: true, get: e3});
    }, n4.n = function(t5) {
      var r5 = t5 && t5.__esModule ? function() {
        return t5.default;
      } : function() {
        return t5;
      };
      return n4.d(r5, "a", r5), r5;
    }, n4.o = function(t5, n5) {
      return Object.prototype.hasOwnProperty.call(t5, n5);
    }, n4.p = "", n4(n4.s = 13);
  }([function(t4, n4) {
    var r4 = t4.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
    typeof __g == "number" && (__g = r4);
  }, function(t4, n4) {
    t4.exports = function(t5) {
      return typeof t5 == "object" ? t5 !== null : typeof t5 == "function";
    };
  }, function(t4, n4) {
    var r4 = t4.exports = {version: "2.5.0"};
    typeof __e == "number" && (__e = r4);
  }, function(t4, n4, r4) {
    t4.exports = !r4(4)(function() {
      return Object.defineProperty({}, "a", {get: function() {
        return 7;
      }}).a != 7;
    });
  }, function(t4, n4) {
    t4.exports = function(t5) {
      try {
        return !!t5();
      } catch (t6) {
        return true;
      }
    };
  }, function(t4, n4) {
    var r4 = {}.toString;
    t4.exports = function(t5) {
      return r4.call(t5).slice(8, -1);
    };
  }, function(t4, n4, r4) {
    var e3 = r4(32)("wks"), o = r4(9), i3 = r4(0).Symbol, u = typeof i3 == "function";
    (t4.exports = function(t5) {
      return e3[t5] || (e3[t5] = u && i3[t5] || (u ? i3 : o)("Symbol." + t5));
    }).store = e3;
  }, function(t4, n4, r4) {
    var e3 = r4(0), o = r4(2), i3 = r4(8), u = r4(22), c4 = r4(10), f3 = function(t5, n5, r5) {
      var a2, s2, p3, l3, v3 = t5 & f3.F, y4 = t5 & f3.G, h3 = t5 & f3.S, d3 = t5 & f3.P, x3 = t5 & f3.B, g3 = y4 ? e3 : h3 ? e3[n5] || (e3[n5] = {}) : (e3[n5] || {}).prototype, m3 = y4 ? o : o[n5] || (o[n5] = {}), b3 = m3.prototype || (m3.prototype = {});
      y4 && (r5 = n5);
      for (a2 in r5)
        s2 = !v3 && g3 && g3[a2] !== void 0, p3 = (s2 ? g3 : r5)[a2], l3 = x3 && s2 ? c4(p3, e3) : d3 && typeof p3 == "function" ? c4(Function.call, p3) : p3, g3 && u(g3, a2, p3, t5 & f3.U), m3[a2] != p3 && i3(m3, a2, l3), d3 && b3[a2] != p3 && (b3[a2] = p3);
    };
    e3.core = o, f3.F = 1, f3.G = 2, f3.S = 4, f3.P = 8, f3.B = 16, f3.W = 32, f3.U = 64, f3.R = 128, t4.exports = f3;
  }, function(t4, n4, r4) {
    var e3 = r4(16), o = r4(21);
    t4.exports = r4(3) ? function(t5, n5, r5) {
      return e3.f(t5, n5, o(1, r5));
    } : function(t5, n5, r5) {
      return t5[n5] = r5, t5;
    };
  }, function(t4, n4) {
    var r4 = 0, e3 = Math.random();
    t4.exports = function(t5) {
      return "Symbol(".concat(t5 === void 0 ? "" : t5, ")_", (++r4 + e3).toString(36));
    };
  }, function(t4, n4, r4) {
    var e3 = r4(24);
    t4.exports = function(t5, n5, r5) {
      if (e3(t5), n5 === void 0)
        return t5;
      switch (r5) {
        case 1:
          return function(r6) {
            return t5.call(n5, r6);
          };
        case 2:
          return function(r6, e4) {
            return t5.call(n5, r6, e4);
          };
        case 3:
          return function(r6, e4, o) {
            return t5.call(n5, r6, e4, o);
          };
      }
      return function() {
        return t5.apply(n5, arguments);
      };
    };
  }, function(t4, n4) {
    t4.exports = function(t5) {
      if (t5 == void 0)
        throw TypeError("Can't call method on  " + t5);
      return t5;
    };
  }, function(t4, n4, r4) {
    var e3 = r4(28), o = Math.min;
    t4.exports = function(t5) {
      return t5 > 0 ? o(e3(t5), 9007199254740991) : 0;
    };
  }, function(t4, n4, r4) {
    n4.__esModule = true, n4.default = function(t5, n5) {
      if (t5 && n5) {
        var r5 = Array.isArray(n5) ? n5 : n5.split(","), e3 = t5.name || "", o = t5.type || "", i3 = o.replace(/\/.*$/, "");
        return r5.some(function(t6) {
          var n6 = t6.trim();
          return n6.charAt(0) === "." ? e3.toLowerCase().endsWith(n6.toLowerCase()) : n6.endsWith("/*") ? i3 === n6.replace(/\/.*$/, "") : o === n6;
        });
      }
      return true;
    }, r4(14), r4(34);
  }, function(t4, n4, r4) {
    r4(15), t4.exports = r4(2).Array.some;
  }, function(t4, n4, r4) {
    var e3 = r4(7), o = r4(25)(3);
    e3(e3.P + e3.F * !r4(33)([].some, true), "Array", {some: function(t5) {
      return o(this, t5, arguments[1]);
    }});
  }, function(t4, n4, r4) {
    var e3 = r4(17), o = r4(18), i3 = r4(20), u = Object.defineProperty;
    n4.f = r4(3) ? Object.defineProperty : function(t5, n5, r5) {
      if (e3(t5), n5 = i3(n5, true), e3(r5), o)
        try {
          return u(t5, n5, r5);
        } catch (t6) {
        }
      if ("get" in r5 || "set" in r5)
        throw TypeError("Accessors not supported!");
      return "value" in r5 && (t5[n5] = r5.value), t5;
    };
  }, function(t4, n4, r4) {
    var e3 = r4(1);
    t4.exports = function(t5) {
      if (!e3(t5))
        throw TypeError(t5 + " is not an object!");
      return t5;
    };
  }, function(t4, n4, r4) {
    t4.exports = !r4(3) && !r4(4)(function() {
      return Object.defineProperty(r4(19)("div"), "a", {get: function() {
        return 7;
      }}).a != 7;
    });
  }, function(t4, n4, r4) {
    var e3 = r4(1), o = r4(0).document, i3 = e3(o) && e3(o.createElement);
    t4.exports = function(t5) {
      return i3 ? o.createElement(t5) : {};
    };
  }, function(t4, n4, r4) {
    var e3 = r4(1);
    t4.exports = function(t5, n5) {
      if (!e3(t5))
        return t5;
      var r5, o;
      if (n5 && typeof (r5 = t5.toString) == "function" && !e3(o = r5.call(t5)))
        return o;
      if (typeof (r5 = t5.valueOf) == "function" && !e3(o = r5.call(t5)))
        return o;
      if (!n5 && typeof (r5 = t5.toString) == "function" && !e3(o = r5.call(t5)))
        return o;
      throw TypeError("Can't convert object to primitive value");
    };
  }, function(t4, n4) {
    t4.exports = function(t5, n5) {
      return {enumerable: !(1 & t5), configurable: !(2 & t5), writable: !(4 & t5), value: n5};
    };
  }, function(t4, n4, r4) {
    var e3 = r4(0), o = r4(8), i3 = r4(23), u = r4(9)("src"), c4 = Function.toString, f3 = ("" + c4).split("toString");
    r4(2).inspectSource = function(t5) {
      return c4.call(t5);
    }, (t4.exports = function(t5, n5, r5, c5) {
      var a2 = typeof r5 == "function";
      a2 && (i3(r5, "name") || o(r5, "name", n5)), t5[n5] !== r5 && (a2 && (i3(r5, u) || o(r5, u, t5[n5] ? "" + t5[n5] : f3.join(String(n5)))), t5 === e3 ? t5[n5] = r5 : c5 ? t5[n5] ? t5[n5] = r5 : o(t5, n5, r5) : (delete t5[n5], o(t5, n5, r5)));
    })(Function.prototype, "toString", function() {
      return typeof this == "function" && this[u] || c4.call(this);
    });
  }, function(t4, n4) {
    var r4 = {}.hasOwnProperty;
    t4.exports = function(t5, n5) {
      return r4.call(t5, n5);
    };
  }, function(t4, n4) {
    t4.exports = function(t5) {
      if (typeof t5 != "function")
        throw TypeError(t5 + " is not a function!");
      return t5;
    };
  }, function(t4, n4, r4) {
    var e3 = r4(10), o = r4(26), i3 = r4(27), u = r4(12), c4 = r4(29);
    t4.exports = function(t5, n5) {
      var r5 = t5 == 1, f3 = t5 == 2, a2 = t5 == 3, s2 = t5 == 4, p3 = t5 == 6, l3 = t5 == 5 || p3, v3 = n5 || c4;
      return function(n6, c5, y4) {
        for (var h3, d3, x3 = i3(n6), g3 = o(x3), m3 = e3(c5, y4, 3), b3 = u(g3.length), _23 = 0, w3 = r5 ? v3(n6, b3) : f3 ? v3(n6, 0) : void 0; b3 > _23; _23++)
          if ((l3 || _23 in g3) && (h3 = g3[_23], d3 = m3(h3, _23, x3), t5)) {
            if (r5)
              w3[_23] = d3;
            else if (d3)
              switch (t5) {
                case 3:
                  return true;
                case 5:
                  return h3;
                case 6:
                  return _23;
                case 2:
                  w3.push(h3);
              }
            else if (s2)
              return false;
          }
        return p3 ? -1 : a2 || s2 ? s2 : w3;
      };
    };
  }, function(t4, n4, r4) {
    var e3 = r4(5);
    t4.exports = Object("z").propertyIsEnumerable(0) ? Object : function(t5) {
      return e3(t5) == "String" ? t5.split("") : Object(t5);
    };
  }, function(t4, n4, r4) {
    var e3 = r4(11);
    t4.exports = function(t5) {
      return Object(e3(t5));
    };
  }, function(t4, n4) {
    var r4 = Math.ceil, e3 = Math.floor;
    t4.exports = function(t5) {
      return isNaN(t5 = +t5) ? 0 : (t5 > 0 ? e3 : r4)(t5);
    };
  }, function(t4, n4, r4) {
    var e3 = r4(30);
    t4.exports = function(t5, n5) {
      return new (e3(t5))(n5);
    };
  }, function(t4, n4, r4) {
    var e3 = r4(1), o = r4(31), i3 = r4(6)("species");
    t4.exports = function(t5) {
      var n5;
      return o(t5) && (n5 = t5.constructor, typeof n5 != "function" || n5 !== Array && !o(n5.prototype) || (n5 = void 0), e3(n5) && (n5 = n5[i3]) === null && (n5 = void 0)), n5 === void 0 ? Array : n5;
    };
  }, function(t4, n4, r4) {
    var e3 = r4(5);
    t4.exports = Array.isArray || function(t5) {
      return e3(t5) == "Array";
    };
  }, function(t4, n4, r4) {
    var e3 = r4(0), o = e3["__core-js_shared__"] || (e3["__core-js_shared__"] = {});
    t4.exports = function(t5) {
      return o[t5] || (o[t5] = {});
    };
  }, function(t4, n4, r4) {
    var e3 = r4(4);
    t4.exports = function(t5, n5) {
      return !!t5 && e3(function() {
        n5 ? t5.call(null, function() {
        }, 1) : t5.call(null);
      });
    };
  }, function(t4, n4, r4) {
    r4(35), t4.exports = r4(2).String.endsWith;
  }, function(t4, n4, r4) {
    var e3 = r4(7), o = r4(12), i3 = r4(36), u = "".endsWith;
    e3(e3.P + e3.F * r4(38)("endsWith"), "String", {endsWith: function(t5) {
      var n5 = i3(this, t5, "endsWith"), r5 = arguments.length > 1 ? arguments[1] : void 0, e4 = o(n5.length), c4 = r5 === void 0 ? e4 : Math.min(o(r5), e4), f3 = String(t5);
      return u ? u.call(n5, f3, c4) : n5.slice(c4 - f3.length, c4) === f3;
    }});
  }, function(t4, n4, r4) {
    var e3 = r4(37), o = r4(11);
    t4.exports = function(t5, n5, r5) {
      if (e3(n5))
        throw TypeError("String#" + r5 + " doesn't accept regex!");
      return String(o(t5));
    };
  }, function(t4, n4, r4) {
    var e3 = r4(1), o = r4(5), i3 = r4(6)("match");
    t4.exports = function(t5) {
      var n5;
      return e3(t5) && ((n5 = t5[i3]) !== void 0 ? !!n5 : o(t5) == "RegExp");
    };
  }, function(t4, n4, r4) {
    var e3 = r4(6)("match");
    t4.exports = function(t5) {
      var n5 = /./;
      try {
        "/./"[t5](n5);
      } catch (r5) {
        try {
          return n5[e3] = false, !"/./"[t5](n5);
        } catch (t6) {
        }
      }
      return true;
    };
  }]);
});
var accepts = /* @__PURE__ */ getDefaultExportFromCjs(dist);
var supportMultiple = typeof document !== "undefined" && document && document.createElement ? "multiple" in document.createElement("input") : true;
function fileAccepted(file, accept) {
  return file.type === "application/x-moz-file" || accepts(file, accept);
}
function fileMatchSize(file, maxSize, minSize) {
  return file.size <= maxSize && file.size >= minSize;
}
function allFilesAccepted(files, accept) {
  return files.every(function(file) {
    return fileAccepted(file, accept);
  });
}
function isPropagationStopped(evt) {
  if (typeof evt.isPropagationStopped === "function") {
    return evt.isPropagationStopped();
  } else if (typeof evt.cancelBubble !== "undefined") {
    return evt.cancelBubble;
  }
  return false;
}
function isDefaultPrevented(evt) {
  if (typeof evt.defaultPrevented !== "undefined") {
    return evt.defaultPrevented;
  } else if (typeof evt.isDefaultPrevented === "function") {
    return evt.isDefaultPrevented();
  }
  return false;
}
function isDragDataWithFiles(evt) {
  if (!evt.dataTransfer) {
    return true;
  }
  return Array.prototype.some.call(evt.dataTransfer.types, function(type) {
    return type === "Files" || type === "application/x-moz-file";
  });
}
function onDocumentDragOver(evt) {
  evt.preventDefault();
}
function isIe(userAgent) {
  return userAgent.indexOf("MSIE") !== -1 || userAgent.indexOf("Trident/") !== -1;
}
function isEdge(userAgent) {
  return userAgent.indexOf("Edge/") !== -1;
}
function isIeOrEdge() {
  var userAgent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.navigator.userAgent;
  return isIe(userAgent) || isEdge(userAgent);
}
function composeEventHandlers() {
  for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return function(event) {
    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    return fns.some(function(fn) {
      fn && fn.apply(void 0, [event].concat(args));
      return event.defaultPrevented;
    });
  };
}
var _extends = Object.assign || function(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3];
    for (var key in source2) {
      if (Object.prototype.hasOwnProperty.call(source2, key)) {
        target[key] = source2[key];
      }
    }
  }
  return target;
};
var _createClass = function() {
  function defineProperties(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties(obj, keys2) {
  var target = {};
  for (var i3 in obj) {
    if (keys2.indexOf(i3) >= 0)
      continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i3))
      continue;
    target[i3] = obj[i3];
  }
  return target;
}
function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i3 = 0, arr2 = Array(arr.length); i3 < arr.length; i3++) {
      arr2[i3] = arr[i3];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, enumerable: false, writable: true, configurable: true}});
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Dropzone = function(_React$Component) {
  _inherits(Dropzone2, _React$Component);
  function Dropzone2() {
    var _ref;
    var _temp, _this, _ret;
    _classCallCheck(this, Dropzone2);
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Dropzone2.__proto__ || Object.getPrototypeOf(Dropzone2)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      draggedFiles: [],
      acceptedFiles: [],
      rejectedFiles: []
    }, _this.isFileDialogActive = false, _this.onDocumentDrop = function(evt) {
      if (_this.node && _this.node.contains(evt.target)) {
        return;
      }
      evt.preventDefault();
      _this.dragTargets = [];
    }, _this.onDragStart = function(evt) {
      evt.persist();
      if (_this.props.onDragStart && isDragDataWithFiles(evt)) {
        _this.props.onDragStart.call(_this, evt);
      }
    }, _this.onDragEnter = function(evt) {
      evt.preventDefault();
      if (_this.dragTargets.indexOf(evt.target) === -1) {
        _this.dragTargets.push(evt.target);
      }
      evt.persist();
      if (isDragDataWithFiles(evt)) {
        Promise.resolve(_this.props.getDataTransferItems(evt)).then(function(draggedFiles) {
          if (isPropagationStopped(evt)) {
            return;
          }
          _this.setState({
            draggedFiles,
            isDragActive: true
          });
        });
        if (_this.props.onDragEnter) {
          _this.props.onDragEnter.call(_this, evt);
        }
      }
    }, _this.onDragOver = function(evt) {
      evt.preventDefault();
      evt.persist();
      if (evt.dataTransfer) {
        evt.dataTransfer.dropEffect = "copy";
      }
      if (_this.props.onDragOver && isDragDataWithFiles(evt)) {
        _this.props.onDragOver.call(_this, evt);
      }
      return false;
    }, _this.onDragLeave = function(evt) {
      evt.preventDefault();
      evt.persist();
      _this.dragTargets = _this.dragTargets.filter(function(el) {
        return el !== evt.target && _this.node.contains(el);
      });
      if (_this.dragTargets.length > 0) {
        return;
      }
      _this.setState({
        isDragActive: false,
        draggedFiles: []
      });
      if (_this.props.onDragLeave && isDragDataWithFiles(evt)) {
        _this.props.onDragLeave.call(_this, evt);
      }
    }, _this.onDrop = function(evt) {
      var _this$props = _this.props, onDrop = _this$props.onDrop, onDropAccepted = _this$props.onDropAccepted, onDropRejected = _this$props.onDropRejected, multiple = _this$props.multiple, accept = _this$props.accept, getDataTransferItems = _this$props.getDataTransferItems;
      evt.preventDefault();
      evt.persist();
      _this.dragTargets = [];
      _this.isFileDialogActive = false;
      _this.draggedFiles = null;
      _this.setState({
        isDragActive: false,
        draggedFiles: []
      });
      if (isDragDataWithFiles(evt)) {
        Promise.resolve(getDataTransferItems(evt)).then(function(fileList) {
          var acceptedFiles = [];
          var rejectedFiles = [];
          if (isPropagationStopped(evt)) {
            return;
          }
          fileList.forEach(function(file) {
            if (fileAccepted(file, accept) && fileMatchSize(file, _this.props.maxSize, _this.props.minSize)) {
              acceptedFiles.push(file);
            } else {
              rejectedFiles.push(file);
            }
          });
          if (!multiple && acceptedFiles.length > 1) {
            rejectedFiles.push.apply(rejectedFiles, _toConsumableArray(acceptedFiles.splice(0)));
          }
          _this.setState({acceptedFiles, rejectedFiles}, function() {
            if (onDrop) {
              onDrop.call(_this, acceptedFiles, rejectedFiles, evt);
            }
            if (rejectedFiles.length > 0 && onDropRejected) {
              onDropRejected.call(_this, rejectedFiles, evt);
            }
            if (acceptedFiles.length > 0 && onDropAccepted) {
              onDropAccepted.call(_this, acceptedFiles, evt);
            }
          });
        });
      }
    }, _this.onClick = function(evt) {
      var onClick = _this.props.onClick;
      if (onClick) {
        onClick.call(_this, evt);
      }
      if (!isDefaultPrevented(evt)) {
        evt.stopPropagation();
        if (isIeOrEdge()) {
          setTimeout(_this.open, 0);
        } else {
          _this.open();
        }
      }
    }, _this.onInputElementClick = function(evt) {
      evt.stopPropagation();
    }, _this.onFileDialogCancel = function() {
      var onFileDialogCancel = _this.props.onFileDialogCancel;
      if (_this.isFileDialogActive) {
        setTimeout(function() {
          if (_this.input != null) {
            var files = _this.input.files;
            if (!files.length) {
              _this.isFileDialogActive = false;
              if (typeof onFileDialogCancel === "function") {
                onFileDialogCancel();
              }
            }
          }
        }, 300);
      }
    }, _this.onFocus = function(evt) {
      var onFocus = _this.props.onFocus;
      if (onFocus) {
        onFocus.call(_this, evt);
      }
      if (!isDefaultPrevented(evt)) {
        _this.setState({isFocused: true});
      }
    }, _this.onBlur = function(evt) {
      var onBlur = _this.props.onBlur;
      if (onBlur) {
        onBlur.call(_this, evt);
      }
      if (!isDefaultPrevented(evt)) {
        _this.setState({isFocused: false});
      }
    }, _this.onKeyDown = function(evt) {
      var onKeyDown = _this.props.onKeyDown;
      if (!_this.node.isEqualNode(evt.target)) {
        return;
      }
      if (onKeyDown) {
        onKeyDown.call(_this, evt);
      }
      if (!isDefaultPrevented(evt) && (evt.keyCode === 32 || evt.keyCode === 13)) {
        evt.preventDefault();
        _this.open();
      }
    }, _this.composeHandler = function(handler) {
      if (_this.props.disabled) {
        return null;
      }
      return handler;
    }, _this.getRootProps = function() {
      var _extends22;
      var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var _ref2$refKey = _ref2.refKey, refKey = _ref2$refKey === void 0 ? "ref" : _ref2$refKey, onKeyDown = _ref2.onKeyDown, onFocus = _ref2.onFocus, onBlur = _ref2.onBlur, onClick = _ref2.onClick, onDragStart = _ref2.onDragStart, onDragEnter = _ref2.onDragEnter, onDragOver = _ref2.onDragOver, onDragLeave = _ref2.onDragLeave, onDrop = _ref2.onDrop, rest = _objectWithoutProperties(_ref2, ["refKey", "onKeyDown", "onFocus", "onBlur", "onClick", "onDragStart", "onDragEnter", "onDragOver", "onDragLeave", "onDrop"]);
      return _extends((_extends22 = {
        onKeyDown: _this.composeHandler(onKeyDown ? composeEventHandlers(onKeyDown, _this.onKeyDown) : _this.onKeyDown),
        onFocus: _this.composeHandler(onFocus ? composeEventHandlers(onFocus, _this.onFocus) : _this.onFocus),
        onBlur: _this.composeHandler(onBlur ? composeEventHandlers(onBlur, _this.onBlur) : _this.onBlur),
        onClick: _this.composeHandler(onClick ? composeEventHandlers(onClick, _this.onClick) : _this.onClick),
        onDragStart: _this.composeHandler(onDragStart ? composeEventHandlers(onDragStart, _this.onDragStart) : _this.onDragStart),
        onDragEnter: _this.composeHandler(onDragEnter ? composeEventHandlers(onDragEnter, _this.onDragEnter) : _this.onDragEnter),
        onDragOver: _this.composeHandler(onDragOver ? composeEventHandlers(onDragOver, _this.onDragOver) : _this.onDragOver),
        onDragLeave: _this.composeHandler(onDragLeave ? composeEventHandlers(onDragLeave, _this.onDragLeave) : _this.onDragLeave),
        onDrop: _this.composeHandler(onDrop ? composeEventHandlers(onDrop, _this.onDrop) : _this.onDrop)
      }, _defineProperty2(_extends22, refKey, _this.setNodeRef), _defineProperty2(_extends22, "tabIndex", _this.props.disabled ? -1 : 0), _extends22), rest);
    }, _this.getInputProps = function() {
      var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var _ref3$refKey = _ref3.refKey, refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey, onChange = _ref3.onChange, onClick = _ref3.onClick, rest = _objectWithoutProperties(_ref3, ["refKey", "onChange", "onClick"]);
      var _this$props2 = _this.props, accept = _this$props2.accept, multiple = _this$props2.multiple, name = _this$props2.name;
      var inputProps = _defineProperty2({
        accept,
        type: "file",
        style: {display: "none"},
        multiple: supportMultiple && multiple,
        onChange: composeEventHandlers(onChange, _this.onDrop),
        onClick: composeEventHandlers(onClick, _this.onInputElementClick),
        autoComplete: "off",
        tabIndex: -1
      }, refKey, _this.setInputRef);
      if (name && name.length) {
        inputProps.name = name;
      }
      return _extends({}, inputProps, rest);
    }, _this.setNodeRef = function(node) {
      _this.node = node;
    }, _this.setInputRef = function(input) {
      _this.input = input;
    }, _this.open = function() {
      _this.isFileDialogActive = true;
      if (_this.input) {
        _this.input.value = null;
        _this.input.click();
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }
  _createClass(Dropzone2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var preventDropOnDocument = this.props.preventDropOnDocument;
      this.dragTargets = [];
      if (preventDropOnDocument) {
        document.addEventListener("dragover", onDocumentDragOver, false);
        document.addEventListener("drop", this.onDocumentDrop, false);
      }
      window.addEventListener("focus", this.onFileDialogCancel, false);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var preventDropOnDocument = this.props.preventDropOnDocument;
      if (preventDropOnDocument) {
        document.removeEventListener("dragover", onDocumentDragOver);
        document.removeEventListener("drop", this.onDocumentDrop);
      }
      window.removeEventListener("focus", this.onFileDialogCancel, false);
    }
  }, {
    key: "render",
    value: function render4() {
      var _props = this.props, children2 = _props.children, multiple = _props.multiple, disabled = _props.disabled;
      var _state = this.state, isDragActive = _state.isDragActive, isFocused = _state.isFocused, draggedFiles = _state.draggedFiles, acceptedFiles = _state.acceptedFiles, rejectedFiles = _state.rejectedFiles;
      var filesCount = draggedFiles.length;
      var isMultipleAllowed = multiple || filesCount <= 1;
      var isDragAccept = filesCount > 0 && allFilesAccepted(draggedFiles, this.props.accept);
      var isDragReject = filesCount > 0 && (!isDragAccept || !isMultipleAllowed);
      return children2({
        isDragActive,
        isDragAccept,
        isDragReject,
        draggedFiles,
        acceptedFiles,
        rejectedFiles,
        isFocused: isFocused && !disabled,
        getRootProps: this.getRootProps,
        getInputProps: this.getInputProps,
        open: this.open
      });
    }
  }]);
  return Dropzone2;
}(react.Component);
Dropzone.propTypes = {
  accept: propTypes.oneOfType([propTypes.string, propTypes.arrayOf(propTypes.string)]),
  children: propTypes.func,
  disabled: propTypes.bool,
  preventDropOnDocument: propTypes.bool,
  multiple: propTypes.bool,
  name: propTypes.string,
  maxSize: propTypes.number,
  minSize: propTypes.number,
  getDataTransferItems: propTypes.func,
  onClick: propTypes.func,
  onFocus: propTypes.func,
  onBlur: propTypes.func,
  onKeyDown: propTypes.func,
  onDrop: propTypes.func,
  onDropAccepted: propTypes.func,
  onDropRejected: propTypes.func,
  onDragStart: propTypes.func,
  onDragEnter: propTypes.func,
  onDragOver: propTypes.func,
  onDragLeave: propTypes.func,
  onFileDialogCancel: propTypes.func
};
Dropzone.defaultProps = {
  preventDropOnDocument: true,
  disabled: false,
  multiple: true,
  maxSize: Infinity,
  minSize: 0,
  getDataTransferItems: fromEvent
};
var FileUpload = (_a) => {
  var {id: id3, type, value = type === fileReaderType.text || type === fileReaderType.dataURL ? "" : null, filename = "", children: children2 = null, onChange = () => {
  }, onReadStarted = () => {
  }, onReadFinished = () => {
  }, onReadFailed = () => {
  }, onClick = (event) => event.preventDefault(), dropzoneProps = {}} = _a, props = __rest(_a, ["id", "type", "value", "filename", "children", "onChange", "onReadStarted", "onReadFinished", "onReadFailed", "onClick", "dropzoneProps"]);
  const onDropAccepted = (acceptedFiles, event) => {
    if (acceptedFiles.length > 0) {
      const fileHandle = acceptedFiles[0];
      if (type === fileReaderType.text || type === fileReaderType.dataURL) {
        onChange("", fileHandle.name, event);
        onReadStarted(fileHandle);
        readFile(fileHandle, type).then((data) => {
          onReadFinished(fileHandle);
          onChange(data, fileHandle.name, event);
        }).catch((error2) => {
          onReadFailed(error2, fileHandle);
          onReadFinished(fileHandle);
          onChange("", "", event);
        });
      } else {
        onChange(fileHandle, fileHandle.name, event);
      }
    }
    dropzoneProps.onDropAccepted && dropzoneProps.onDropAccepted(acceptedFiles, event);
  };
  const onDropRejected = (rejectedFiles, event) => {
    if (rejectedFiles.length > 0) {
      onChange("", rejectedFiles[0].name, event);
    }
    dropzoneProps.onDropRejected && dropzoneProps.onDropRejected(rejectedFiles, event);
  };
  const onClearButtonClick = (event) => {
    onChange("", "", event);
  };
  return react.createElement(Dropzone, Object.assign({multiple: false}, dropzoneProps, {onDropAccepted, onDropRejected}), ({getRootProps, getInputProps, isDragActive, open: open2}) => react.createElement(FileUploadField, Object.assign({}, getRootProps(Object.assign(Object.assign({}, props), {refKey: "containerRef", onClick: (event) => event.preventDefault()})), {tabIndex: null, id: id3, type, filename, value, onChange, isDragActive, onBrowseButtonClick: open2, onClearButtonClick, onTextAreaClick: onClick}), react.createElement("input", Object.assign({}, getInputProps())), children2));
};
FileUpload.displayName = "FileUpload";
var ActionGroup = (_a) => {
  var {children: children2 = null, className = ""} = _a, props = __rest(_a, ["children", "className"]);
  const customClassName = css(formStyles$1.formGroup, formStyles$1.modifiers.action, className);
  const formActionsComponent = react.createElement("div", {className: css(formStyles$1.formActions)}, children2);
  return react.createElement("div", Object.assign({}, props, {className: customClassName}), react.createElement("div", {className: css(formStyles$1.formGroupControl)}, formActionsComponent));
};
ActionGroup.displayName = "ActionGroup";
var Form = (_a) => {
  var {children: children2 = null, className = "", isHorizontal = false, isWidthLimited = false} = _a, props = __rest(_a, ["children", "className", "isHorizontal", "isWidthLimited"]);
  return react.createElement("form", Object.assign({noValidate: true}, props, {className: css(formStyles$1.form, isHorizontal && formStyles$1.modifiers.horizontal, isWidthLimited && formStyles$1.modifiers.limitWidth, className)}), children2);
};
Form.displayName = "Form";
var FormGroup = (_a) => {
  var {children: children2 = null, className = "", label: label2, labelInfo, labelIcon, isRequired = false, validated = "default", isInline = false, hasNoPaddingTop = false, isStack = false, helperText, isHelperTextBeforeField = false, helperTextInvalid, helperTextIcon, helperTextInvalidIcon, fieldId} = _a, props = __rest(_a, ["children", "className", "label", "labelInfo", "labelIcon", "isRequired", "validated", "isInline", "hasNoPaddingTop", "isStack", "helperText", "isHelperTextBeforeField", "helperTextInvalid", "helperTextIcon", "helperTextInvalidIcon", "fieldId"]);
  const validHelperText = typeof helperText !== "string" ? helperText : react.createElement("div", {className: css(formStyles$1.formHelperText, validated === ValidatedOptions.success && formStyles$1.modifiers.success, validated === ValidatedOptions.warning && formStyles$1.modifiers.warning), id: `${fieldId}-helper`, "aria-live": "polite"}, helperTextIcon && react.createElement("span", {className: css(formStyles$1.formHelperTextIcon)}, helperTextIcon), helperText);
  const inValidHelperText = typeof helperTextInvalid !== "string" ? helperTextInvalid : react.createElement("div", {className: css(formStyles$1.formHelperText, formStyles$1.modifiers.error), id: `${fieldId}-helper`, "aria-live": "polite"}, helperTextInvalidIcon && react.createElement("span", {className: css(formStyles$1.formHelperTextIcon)}, helperTextInvalidIcon), helperTextInvalid);
  const showValidHelperTxt = (validationType) => validationType !== ValidatedOptions.error && helperText ? validHelperText : "";
  const helperTextToDisplay = validated === ValidatedOptions.error && helperTextInvalid ? inValidHelperText : showValidHelperTxt(validated);
  const labelContent = react.createElement(react.Fragment, null, react.createElement("label", {className: css(formStyles$1.formLabel), htmlFor: fieldId}, react.createElement("span", {className: css(formStyles$1.formLabelText)}, label2), isRequired && react.createElement("span", {className: css(formStyles$1.formLabelRequired), "aria-hidden": "true"}, " ", ASTERISK)), " ", react.isValidElement(labelIcon) && labelIcon);
  return react.createElement("div", Object.assign({}, props, {className: css(formStyles$1.formGroup, className)}), label2 && react.createElement("div", {className: css(formStyles$1.formGroupLabel, labelInfo && formStyles$1.modifiers.info, hasNoPaddingTop && formStyles$1.modifiers.noPaddingTop)}, labelInfo && react.createElement(react.Fragment, null, react.createElement("div", {className: css(formStyles$1.formGroupLabelMain)}, labelContent), react.createElement("div", {className: css(formStyles$1.formGroupLabelInfo)}, labelInfo)), !labelInfo && labelContent), react.createElement("div", {className: css(formStyles$1.formGroupControl, isInline && formStyles$1.modifiers.inline, isStack && formStyles$1.modifiers.stack)}, isHelperTextBeforeField && helperTextToDisplay, children2, !isHelperTextBeforeField && helperTextToDisplay));
};
FormGroup.displayName = "FormGroup";
var MinusIconConfig = {
  name: "MinusIcon",
  height: 512,
  width: 448,
  svgPath: "M416 208H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z",
  yOffset: 0,
  xOffset: 0
};
var MinusIcon = createIcon(MinusIconConfig);
var jumpLinks = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    jumpLinks: "pf-c-jump-links",
    jumpLinksHeader: "pf-c-jump-links__header",
    jumpLinksItem: "pf-c-jump-links__item",
    jumpLinksLabel: "pf-c-jump-links__label",
    jumpLinksLink: "pf-c-jump-links__link",
    jumpLinksLinkText: "pf-c-jump-links__link-text",
    jumpLinksList: "pf-c-jump-links__list",
    jumpLinksMain: "pf-c-jump-links__main",
    jumpLinksToggle: "pf-c-jump-links__toggle",
    jumpLinksToggleIcon: "pf-c-jump-links__toggle-icon",
    modifiers: {
      center: "pf-m-center",
      vertical: "pf-m-vertical",
      expandable: "pf-m-expandable",
      nonExpandable: "pf-m-non-expandable",
      expandableOnSm: "pf-m-expandable-on-sm",
      nonExpandableOnSm: "pf-m-non-expandable-on-sm",
      expandableOnMd: "pf-m-expandable-on-md",
      nonExpandableOnMd: "pf-m-non-expandable-on-md",
      expandableOnLg: "pf-m-expandable-on-lg",
      nonExpandableOnLg: "pf-m-non-expandable-on-lg",
      expandableOnXl: "pf-m-expandable-on-xl",
      nonExpandableOnXl: "pf-m-non-expandable-on-xl",
      expandableOn_2xl: "pf-m-expandable-on-2xl",
      nonExpandableOn_2xl: "pf-m-non-expandable-on-2xl",
      expanded: "pf-m-expanded",
      current: "pf-m-current",
      toggle: "pf-m-toggle"
    }
  };
});
var styles$i = /* @__PURE__ */ getDefaultExportFromCjs(jumpLinks);
var sidebar = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    modifiers: {
      gutter: "pf-m-gutter",
      panelRight: "pf-m-panel-right",
      stack: "pf-m-stack",
      split: "pf-m-split",
      sticky: "pf-m-sticky",
      static: "pf-m-static",
      noBackground: "pf-m-no-background",
      widthDefault: "pf-m-width-default",
      width_25: "pf-m-width-25",
      width_33: "pf-m-width-33",
      width_50: "pf-m-width-50",
      width_66: "pf-m-width-66",
      width_75: "pf-m-width-75",
      width_100: "pf-m-width-100",
      widthDefaultOnSm: "pf-m-width-default-on-sm",
      width_25OnSm: "pf-m-width-25-on-sm",
      width_33OnSm: "pf-m-width-33-on-sm",
      width_50OnSm: "pf-m-width-50-on-sm",
      width_66OnSm: "pf-m-width-66-on-sm",
      width_75OnSm: "pf-m-width-75-on-sm",
      width_100OnSm: "pf-m-width-100-on-sm",
      widthDefaultOnMd: "pf-m-width-default-on-md",
      width_25OnMd: "pf-m-width-25-on-md",
      width_33OnMd: "pf-m-width-33-on-md",
      width_50OnMd: "pf-m-width-50-on-md",
      width_66OnMd: "pf-m-width-66-on-md",
      width_75OnMd: "pf-m-width-75-on-md",
      width_100OnMd: "pf-m-width-100-on-md",
      widthDefaultOnLg: "pf-m-width-default-on-lg",
      width_25OnLg: "pf-m-width-25-on-lg",
      width_33OnLg: "pf-m-width-33-on-lg",
      width_50OnLg: "pf-m-width-50-on-lg",
      width_66OnLg: "pf-m-width-66-on-lg",
      width_75OnLg: "pf-m-width-75-on-lg",
      width_100OnLg: "pf-m-width-100-on-lg",
      widthDefaultOnXl: "pf-m-width-default-on-xl",
      width_25OnXl: "pf-m-width-25-on-xl",
      width_33OnXl: "pf-m-width-33-on-xl",
      width_50OnXl: "pf-m-width-50-on-xl",
      width_66OnXl: "pf-m-width-66-on-xl",
      width_75OnXl: "pf-m-width-75-on-xl",
      width_100OnXl: "pf-m-width-100-on-xl",
      widthDefaultOn_2xl: "pf-m-width-default-on-2xl",
      width_25On_2xl: "pf-m-width-25-on-2xl",
      width_33On_2xl: "pf-m-width-33-on-2xl",
      width_50On_2xl: "pf-m-width-50-on-2xl",
      width_66On_2xl: "pf-m-width-66-on-2xl",
      width_75On_2xl: "pf-m-width-75-on-2xl",
      width_100On_2xl: "pf-m-width-100-on-2xl"
    },
    sidebar: "pf-c-sidebar",
    sidebarContent: "pf-c-sidebar__content",
    sidebarMain: "pf-c-sidebar__main",
    sidebarPanel: "pf-c-sidebar__panel"
  };
});
var styles$j = /* @__PURE__ */ getDefaultExportFromCjs(sidebar);
var JumpLinksList = (_a) => {
  var {children: children2, className} = _a, props = __rest(_a, ["children", "className"]);
  return react.createElement("ul", Object.assign({className: css(styles$i.jumpLinksList, className)}, props), children2);
};
JumpLinksList.displayName = "JumpLinksList";
var JumpLinksItem = (_a) => {
  var {
    isActive,
    href,
    node,
    children: children2,
    onClick,
    className
  } = _a, props = __rest(_a, ["isActive", "href", "node", "children", "onClick", "className"]);
  const childrenArr = react.Children.toArray(children2);
  const sublists = childrenArr.filter((child) => child.type === JumpLinksList);
  children2 = childrenArr.filter((child) => child.type !== JumpLinksList);
  return react.createElement("li", Object.assign({className: css(styles$i.jumpLinksItem, isActive && styles$i.modifiers.current, className)}, props), react.createElement("a", {className: styles$i.jumpLinksLink, href, onClick}, react.createElement("span", {className: styles$i.jumpLinksLinkText}, children2)), sublists);
};
JumpLinksItem.displayName = "JumpLinksItem";
var c_jump_links__toggle_Display = {
  name: "--pf-c-jump-links__toggle--Display",
  value: "none",
  var: "var(--pf-c-jump-links__toggle--Display)"
};
var getScrollItems = (children2, res) => {
  react.Children.forEach(children2, (child) => {
    if (canUseDOM && document.getElementById && document.querySelector && child.type === JumpLinksItem) {
      const scrollNode = child.props.node || child.props.href;
      if (typeof scrollNode === "string") {
        if (scrollNode.startsWith("#")) {
          res.push(document.getElementById(scrollNode.substr(1)));
        } else {
          res.push(document.querySelector(scrollNode));
        }
      } else if (scrollNode instanceof HTMLElement) {
        res.push(scrollNode);
      }
    }
    if ([react.Fragment, JumpLinksList, JumpLinksItem].includes(child.type)) {
      getScrollItems(child.props.children, res);
    }
  });
  return res;
};
function isResponsive(jumpLinks2) {
  return jumpLinks2 && getComputedStyle(jumpLinks2).getPropertyValue(c_jump_links__toggle_Display.name).includes("block");
}
var JumpLinks = (_a) => {
  var {isCentered, isVertical, children: children2, label: label2, "aria-label": ariaLabel = typeof label2 === "string" ? label2 : null, scrollableSelector, activeIndex: activeIndexProp = 0, offset: offset2 = 0, expandable: expandable2, isExpanded: isExpandedProp = false, alwaysShowLabel = true, toggleAriaLabel = "Toggle jump links", className} = _a, props = __rest(_a, ["isCentered", "isVertical", "children", "label", "aria-label", "scrollableSelector", "activeIndex", "offset", "expandable", "isExpanded", "alwaysShowLabel", "toggleAriaLabel", "className"]);
  const hasScrollSpy = Boolean(scrollableSelector);
  const [scrollItems, setScrollItems] = react.useState(hasScrollSpy ? getScrollItems(children2, []) : []);
  const [activeIndex, setActiveIndex] = react.useState(activeIndexProp);
  const [isExpanded, setIsExpanded] = react.useState(isExpandedProp);
  react.useEffect(() => setIsExpanded(isExpandedProp), [isExpandedProp]);
  const navRef = react.useRef();
  if (hasScrollSpy) {
    react.useEffect(() => {
      if (!canUseDOM) {
        return;
      }
      const scrollableElement = document.querySelector(scrollableSelector);
      if (!(scrollableElement instanceof HTMLElement)) {
        return;
      }
      function scrollSpy() {
        const scrollPosition = Math.ceil(scrollableElement.scrollTop + offset2);
        window.requestAnimationFrame(() => {
          let newScrollItems = scrollItems;
          if (!newScrollItems[0] || newScrollItems.includes(null) || newScrollItems[0].offsetParent !== null) {
            newScrollItems = getScrollItems(children2, []);
            setScrollItems(newScrollItems);
          }
          const scrollElements = newScrollItems.map((e3, index3) => ({
            y: e3 ? e3.offsetTop : null,
            index: index3
          })).filter(({y: y4}) => y4 !== null).sort((e1, e22) => e22.y - e1.y);
          for (const {y: y4, index: index3} of scrollElements) {
            if (scrollPosition >= y4) {
              return setActiveIndex(index3);
            }
          }
        });
      }
      if (scrollableElement) {
        scrollSpy();
        scrollableElement.addEventListener("scroll", scrollSpy);
      }
      return () => scrollableElement.removeEventListener("scroll", scrollSpy);
    }, [scrollItems, hasScrollSpy]);
  }
  let jumpLinkIndex = 0;
  const cloneChildren = (children3) => !hasScrollSpy ? children3 : react.Children.map(children3, (child) => {
    if (child.type === JumpLinksItem) {
      const {onClick: onClickProp, isActive: isActiveProp} = child.props;
      const itemIndex = jumpLinkIndex++;
      const scrollItem = scrollItems[itemIndex];
      return react.cloneElement(child, {
        onClick(ev) {
          let newScrollItems;
          if (!scrollItem) {
            newScrollItems = getScrollItems(children3, []);
            setScrollItems(newScrollItems);
          }
          const newScrollItem = scrollItem || newScrollItems[itemIndex];
          if (newScrollItem) {
            const scrollableElement = document.querySelector(scrollableSelector);
            if (scrollableElement instanceof HTMLElement) {
              if (isResponsive(navRef.current)) {
                if (navRef.current) {
                  navRef.current.classList.remove(styles$i.modifiers.expanded);
                }
                let stickyParent = navRef.current && navRef.current.parentElement;
                while (stickyParent && !stickyParent.classList.contains(styles$j.modifiers.sticky)) {
                  stickyParent = stickyParent.parentElement;
                }
                setIsExpanded(false);
                if (stickyParent) {
                  offset2 += stickyParent.scrollHeight;
                }
              }
              scrollableElement.scrollTo(0, newScrollItem.offsetTop - offset2);
            }
            newScrollItem.focus();
            ev.preventDefault();
          }
          if (onClickProp) {
            onClickProp(ev);
          }
        },
        isActive: isActiveProp || activeIndex === itemIndex,
        children: cloneChildren(child.props.children)
      });
    } else if (child.type === react.Fragment) {
      return cloneChildren(child.props.children);
    } else if (child.type === JumpLinksList) {
      return react.cloneElement(child, {children: cloneChildren(child.props.children)});
    }
    return child;
  });
  return react.createElement("nav", Object.assign({className: css(styles$i.jumpLinks, isCentered && styles$i.modifiers.center, isVertical && styles$i.modifiers.vertical, formatBreakpointMods(expandable2, styles$i), isExpanded && styles$i.modifiers.expanded, className), "aria-label": ariaLabel, ref: navRef}, props), react.createElement("div", {className: styles$i.jumpLinksMain}, react.createElement("div", {className: styles$i.jumpLinksHeader}, expandable2 && react.createElement("div", {className: styles$i.jumpLinksToggle}, react.createElement(Button, {variant: "plain", onClick: () => setIsExpanded(!isExpanded), "aria-label": toggleAriaLabel, "aria-expanded": isExpanded}, react.createElement("span", {className: styles$i.jumpLinksToggleIcon}, react.createElement(AngleRightIcon, null)))), label2 && react.createElement("div", {className: css(styles$i.jumpLinksLabel, expandable2 && !alwaysShowLabel && styles$i.modifiers.toggle)}, label2)), react.createElement("ul", {className: styles$i.jumpLinksList}, cloneChildren(children2))));
};
JumpLinks.displayName = "JumpLinks";
var label = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    button: "pf-c-button",
    label: "pf-c-label",
    labelContent: "pf-c-label__content",
    labelIcon: "pf-c-label__icon",
    labelText: "pf-c-label__text",
    modifiers: {
      blue: "pf-m-blue",
      green: "pf-m-green",
      orange: "pf-m-orange",
      red: "pf-m-red",
      purple: "pf-m-purple",
      cyan: "pf-m-cyan",
      outline: "pf-m-outline",
      overflow: "pf-m-overflow",
      editableActive: "pf-m-editable-active"
    }
  };
});
var styles$k = /* @__PURE__ */ getDefaultExportFromCjs(label);
var labelGroup = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    button: "pf-c-button",
    labelGroup: "pf-c-label-group",
    labelGroupClose: "pf-c-label-group__close",
    labelGroupLabel: "pf-c-label-group__label",
    labelGroupList: "pf-c-label-group__list",
    labelGroupListItem: "pf-c-label-group__list-item",
    labelGroupMain: "pf-c-label-group__main",
    labelGroupTextarea: "pf-c-label-group__textarea",
    modifiers: {
      category: "pf-m-category",
      vertical: "pf-m-vertical",
      editable: "pf-m-editable",
      textarea: "pf-m-textarea"
    }
  };
});
var styles$l = /* @__PURE__ */ getDefaultExportFromCjs(labelGroup);
var colorStyles = {
  blue: styles$k.modifiers.blue,
  cyan: styles$k.modifiers.cyan,
  green: styles$k.modifiers.green,
  orange: styles$k.modifiers.orange,
  purple: styles$k.modifiers.purple,
  red: styles$k.modifiers.red,
  grey: ""
};
var Label = (_a) => {
  var {children: children2, className = "", color: color2 = "grey", variant = "filled", isEditable = false, editableProps, isTruncated = false, tooltipPosition, icon, onClose, onEditCancel, onEditComplete, closeBtn, closeBtnProps, href, isOverflowLabel, render: render4} = _a, props = __rest(_a, ["children", "className", "color", "variant", "isEditable", "editableProps", "isTruncated", "tooltipPosition", "icon", "onClose", "onEditCancel", "onEditComplete", "closeBtn", "closeBtnProps", "href", "isOverflowLabel", "render"]);
  const [isEditableActive, setIsEditableActive] = react.useState(false);
  const editableDivRef = react.createRef();
  react.useEffect(() => {
    document.addEventListener("click", onDocClick);
    document.addEventListener("keydown", onKeyDown);
    return () => {
      document.removeEventListener("click", onDocClick);
      document.removeEventListener("keydown", onKeyDown);
    };
  });
  const onDocClick = (event) => {
    if (isEditableActive && editableDivRef && editableDivRef.current && !editableDivRef.current.contains(event.target)) {
      onEditComplete && onEditComplete(editableDivRef.current.textContent);
      setIsEditableActive(false);
    }
  };
  const onKeyDown = (event) => {
    const key = event.key;
    if (!editableDivRef || !editableDivRef.current || !editableDivRef.current.contains(event.target)) {
      return;
    }
    if (isEditableActive && (key === "Enter" || key === "Tab")) {
      event.preventDefault();
      event.stopImmediatePropagation();
      onEditComplete && onEditComplete(editableDivRef.current.textContent);
      setIsEditableActive(false);
    }
    if (isEditableActive && key === "Escape") {
      event.preventDefault();
      event.stopImmediatePropagation();
      editableDivRef.current.textContent = children2;
      onEditCancel && onEditCancel(children2);
      setIsEditableActive(false);
    }
    if (!isEditableActive && key === "Enter") {
      event.preventDefault();
      event.stopImmediatePropagation();
      setIsEditableActive(true);
      const el = event.target;
      const range2 = document.createRange();
      const sel = window.getSelection();
      range2.selectNodeContents(el);
      range2.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range2);
    }
  };
  const LabelComponent = isOverflowLabel ? "button" : "span";
  const Component = href ? "a" : "span";
  const button2 = closeBtn ? closeBtn : react.createElement(Button, Object.assign({type: "button", variant: "plain", onClick: onClose}, Object.assign({"aria-label": "label-close-button"}, closeBtnProps)), react.createElement(TimesIcon, null));
  const textRef = react.createRef();
  const componentRef = react.useRef();
  const [isTooltipVisible, setIsTooltipVisible] = react.useState(false);
  useIsomorphicLayoutEffect(() => {
    setIsTooltipVisible(textRef.current && textRef.current.offsetWidth < textRef.current.scrollWidth);
  }, []);
  let content2 = react.createElement(react.Fragment, null, icon && react.createElement("span", {className: css(styles$k.labelIcon)}, icon), isTruncated && react.createElement("span", {ref: textRef, className: css(styles$k.labelText)}, children2), !isTruncated && children2);
  if (isEditable) {
    content2 = react.createElement(react.Fragment, null, react.createElement("div", {className: css(inlineStyles.inlineEdit)}, react.createElement("div", Object.assign({tabIndex: 0, ref: editableDivRef, className: css(inlineStyles.inlineEditEditableText), role: "textbox"}, isEditableActive && {contentEditable: true}, {suppressContentEditableWarning: true}, editableProps), children2)));
  }
  let labelComponentChild = react.createElement(Component, Object.assign({className: css(styles$k.labelContent)}, href && {href}), content2);
  if (render4) {
    labelComponentChild = react.createElement(react.Fragment, null, isTooltipVisible && react.createElement(Tooltip, {reference: componentRef, content: children2, position: tooltipPosition}), render4({
      className: styles$k.labelContent,
      content: content2,
      componentRef
    }));
  } else if (isTooltipVisible) {
    labelComponentChild = react.createElement(Tooltip, {content: children2, position: tooltipPosition}, react.createElement(Component, Object.assign({className: css(styles$k.labelContent)}, href && {href}), content2));
  }
  return react.createElement(LabelComponent, Object.assign({}, props, {className: css(styles$k.label, colorStyles[color2], variant === "outline" && styles$k.modifiers.outline, isOverflowLabel && styles$k.modifiers.overflow, isEditable && styles$l.modifiers.editable, isEditableActive && styles$k.modifiers.editableActive, className)}, isEditable && {
    onClick: (evt) => {
      const isEvtFromButton = evt.target.closest("button");
      if (isEvtFromButton !== null) {
        return;
      }
      setIsEditableActive(true);
      editableDivRef.current.focus();
    }
  }), labelComponentChild, onClose && button2);
};
Label.displayName = "Label";
var list = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    list: "pf-c-list",
    listItem: "pf-c-list__item",
    listItemIcon: "pf-c-list__item-icon",
    modifiers: {
      iconLg: "pf-m-icon-lg",
      plain: "pf-m-plain",
      inline: "pf-m-inline",
      bordered: "pf-m-bordered"
    }
  };
});
var styles$m = /* @__PURE__ */ getDefaultExportFromCjs(list);
var OrderType;
(function(OrderType2) {
  OrderType2["number"] = "1";
  OrderType2["lowercaseLetter"] = "a";
  OrderType2["uppercaseLetter"] = "A";
  OrderType2["lowercaseRomanNumber"] = "i";
  OrderType2["uppercaseRomanNumber"] = "I";
})(OrderType || (OrderType = {}));
var ListVariant;
(function(ListVariant2) {
  ListVariant2["inline"] = "inline";
})(ListVariant || (ListVariant = {}));
var ListComponent;
(function(ListComponent2) {
  ListComponent2["ol"] = "ol";
  ListComponent2["ul"] = "ul";
})(ListComponent || (ListComponent = {}));
var List = (_a) => {
  var {className = "", children: children2 = null, variant = null, isBordered = false, isPlain = false, iconSize = "default", type = OrderType.number, ref = null, component = ListComponent.ul} = _a, props = __rest(_a, ["className", "children", "variant", "isBordered", "isPlain", "iconSize", "type", "ref", "component"]);
  return component === ListComponent.ol ? react.createElement("ol", Object.assign({ref, type}, props, {className: css(styles$m.list, variant && styles$m.modifiers[variant], isBordered && styles$m.modifiers.bordered, isPlain && styles$m.modifiers.plain, iconSize && iconSize === "large" && styles$m.modifiers.iconLg, className)}), children2) : react.createElement("ul", Object.assign({ref}, props, {className: css(styles$m.list, variant && styles$m.modifiers[variant], isBordered && styles$m.modifiers.bordered, isPlain && styles$m.modifiers.plain, iconSize && iconSize === "large" && styles$m.modifiers.iconLg, className)}), children2);
};
List.displayName = "List";
var ListItem = (_a) => {
  var {icon = null, children: children2 = null} = _a, props = __rest(_a, ["icon", "children"]);
  return react.createElement("li", Object.assign({className: css(icon && styles$m.listItem)}, props), icon && react.createElement("span", {className: css(styles$m.listItemIcon)}, icon), children2);
};
ListItem.displayName = "ListItem";
var modalBox = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    button: "pf-c-button",
    modalBox: "pf-c-modal-box",
    modalBoxBody: "pf-c-modal-box__body",
    modalBoxDescription: "pf-c-modal-box__description",
    modalBoxFooter: "pf-c-modal-box__footer",
    modalBoxHeader: "pf-c-modal-box__header",
    modalBoxHeaderMain: "pf-c-modal-box__header-main",
    modalBoxTitle: "pf-c-modal-box__title",
    modalBoxTitleIcon: "pf-c-modal-box__title-icon",
    modalBoxTitleText: "pf-c-modal-box__title-text",
    modifiers: {
      sm: "pf-m-sm",
      md: "pf-m-md",
      lg: "pf-m-lg",
      alignTop: "pf-m-align-top",
      danger: "pf-m-danger",
      warning: "pf-m-warning",
      success: "pf-m-success",
      default: "pf-m-default",
      info: "pf-m-info",
      help: "pf-m-help",
      icon: "pf-m-icon"
    }
  };
});
var modalStyles = /* @__PURE__ */ getDefaultExportFromCjs(modalBox);
var ModalBoxBody = (_a) => {
  var {children: children2 = null, className = ""} = _a, props = __rest(_a, ["children", "className"]);
  return react.createElement("div", Object.assign({}, props, {className: css(modalStyles.modalBoxBody, className)}), children2);
};
ModalBoxBody.displayName = "ModalBoxBody";
var ModalBoxCloseButton = (_a) => {
  var {className = "", onClose = () => void 0} = _a, props = __rest(_a, ["className", "onClose"]);
  return react.createElement(Button, Object.assign({className, variant: "plain", onClick: onClose, "aria-label": "Close"}, props), react.createElement(TimesIcon, null));
};
ModalBoxCloseButton.displayName = "ModalBoxCloseButton";
var c_modal_box_m_align_top_spacer = {
  name: "--pf-c-modal-box--m-align-top--spacer",
  value: "0.5rem",
  var: "var(--pf-c-modal-box--m-align-top--spacer)"
};
var ModalBox = (_a) => {
  var {children: children2, className = "", variant = "default", position: position2, positionOffset, "aria-labelledby": ariaLabelledby, "aria-label": ariaLabel = "", "aria-describedby": ariaDescribedby, style} = _a, props = __rest(_a, ["children", "className", "variant", "position", "positionOffset", "aria-labelledby", "aria-label", "aria-describedby", "style"]);
  if (positionOffset) {
    style = style || {};
    style[c_modal_box_m_align_top_spacer.name] = positionOffset;
  }
  return react.createElement("div", Object.assign({}, props, {role: "dialog", "aria-label": ariaLabel || null, "aria-labelledby": ariaLabelledby || null, "aria-describedby": ariaDescribedby, "aria-modal": "true", className: css(modalStyles.modalBox, className, position2 === "top" && modalStyles.modifiers.alignTop, variant === "large" && modalStyles.modifiers.lg, variant === "small" && modalStyles.modifiers.sm, variant === "medium" && modalStyles.modifiers.md), style}), children2);
};
ModalBox.displayName = "ModalBox";
var ModalBoxFooter = (_a) => {
  var {children: children2 = null, className = ""} = _a, props = __rest(_a, ["children", "className"]);
  return react.createElement("footer", Object.assign({}, props, {className: css(modalStyles.modalBoxFooter, className)}), children2);
};
ModalBoxFooter.displayName = "ModalBoxFooter";
var ModalBoxDescription = (_a) => {
  var {children: children2 = null, className = "", id: id3 = ""} = _a, props = __rest(_a, ["children", "className", "id"]);
  return react.createElement("div", Object.assign({}, props, {id: id3, className: css(modalStyles.modalBoxDescription, className)}), children2);
};
ModalBoxDescription.displayName = "ModalBoxDescription";
var ModalBoxHeader = (_a) => {
  var {children: children2 = null, className = "", help = null} = _a, props = __rest(_a, ["children", "className", "help"]);
  return react.createElement("header", Object.assign({className: css(modalStyles.modalBoxHeader, help && modalStyles.modifiers.help, className)}, props), help && react.createElement(react.Fragment, null, react.createElement("div", {className: css(modalStyles.modalBoxHeaderMain)}, children2), react.createElement("div", {className: "pf-c-modal-box__header-help"}, help)), !help && children2);
};
ModalBoxHeader.displayName = "ModalBoxHeader";
var isVariantIcon = (icon) => ["success", "danger", "warning", "info", "default"].includes(icon);
var ModalBoxTitle = (_a) => {
  var {className = "", id: id3, title: title3, titleIconVariant, titleLabel = ""} = _a, props = __rest(_a, ["className", "id", "title", "titleIconVariant", "titleLabel"]);
  const [isTooltipVisible, setIsTooltipVisible] = react.useState(false);
  const h1 = react.useRef();
  const label2 = titleLabel || (isVariantIcon(titleIconVariant) ? `${capitalize(titleIconVariant)} alert:` : titleLabel);
  const variantIcons2 = {
    success: react.createElement(CheckCircleIcon, null),
    danger: react.createElement(ExclamationCircleIcon, null),
    warning: react.createElement(ExclamationTriangleIcon, null),
    info: react.createElement(InfoCircleIcon, null),
    default: react.createElement(BellIcon, null)
  };
  const CustomIcon = !isVariantIcon(titleIconVariant) && titleIconVariant;
  useIsomorphicLayoutEffect(() => {
    setIsTooltipVisible(h1.current && h1.current.offsetWidth < h1.current.scrollWidth);
  }, []);
  const content2 = react.createElement("h1", Object.assign({id: id3, ref: h1, className: css(modalStyles.modalBoxTitle, titleIconVariant && modalStyles.modifiers.icon, className)}, props), titleIconVariant && react.createElement("span", {className: css(modalStyles.modalBoxTitleIcon)}, isVariantIcon(titleIconVariant) ? variantIcons2[titleIconVariant] : react.createElement(CustomIcon, null)), label2 && react.createElement("span", {className: css(a11yStyles.screenReader)}, label2), react.createElement("span", {className: css(modalStyles.modalBoxTitleText)}, title3));
  return isTooltipVisible ? react.createElement(Tooltip, {content: title3, isVisible: true}, content2) : content2;
};
ModalBoxTitle.displayName = "ModalBoxTitle";
var ModalContent = (_a) => {
  var {children: children2, className = "", isOpen = false, header = null, help = null, description = null, title: title3 = "", titleIconVariant = null, titleLabel = "", "aria-label": ariaLabel = "", "aria-describedby": ariaDescribedby, "aria-labelledby": ariaLabelledby, showClose = true, footer = null, actions: actions2 = [], onClose = () => void 0, variant = "default", position: position2, positionOffset, width: width2 = -1, boxId, labelId, descriptorId, disableFocusTrap = false, hasNoBodyWrapper = false, ouiaId, ouiaSafe = true} = _a, props = __rest(_a, ["children", "className", "isOpen", "header", "help", "description", "title", "titleIconVariant", "titleLabel", "aria-label", "aria-describedby", "aria-labelledby", "showClose", "footer", "actions", "onClose", "variant", "position", "positionOffset", "width", "boxId", "labelId", "descriptorId", "disableFocusTrap", "hasNoBodyWrapper", "ouiaId", "ouiaSafe"]);
  if (!isOpen) {
    return null;
  }
  const modalBoxHeader = header ? react.createElement(ModalBoxHeader, {help}, header) : title3 && react.createElement(ModalBoxHeader, {help}, react.createElement(ModalBoxTitle, {title: title3, titleIconVariant, titleLabel, id: labelId}), description && react.createElement(ModalBoxDescription, {id: descriptorId}, description));
  const modalBoxFooter = footer ? react.createElement(ModalBoxFooter, null, footer) : actions2.length > 0 && react.createElement(ModalBoxFooter, null, actions2);
  const modalBody = hasNoBodyWrapper ? children2 : react.createElement(ModalBoxBody, Object.assign({}, props, !description && !ariaDescribedby && {id: descriptorId}), children2);
  const boxStyle = width2 === -1 ? {} : {width: width2};
  const ariaLabelledbyFormatted = () => {
    if (ariaLabelledby === null) {
      return null;
    }
    const idRefList = [];
    if ((ariaLabel && boxId) !== "") {
      idRefList.push(ariaLabel && boxId);
    }
    if (ariaLabelledby) {
      idRefList.push(ariaLabelledby);
    }
    if (title3) {
      idRefList.push(labelId);
    }
    return idRefList.join(" ");
  };
  const modalBox2 = react.createElement(ModalBox, Object.assign({id: boxId, style: boxStyle, className: css(className, isVariantIcon(titleIconVariant) && modalStyles.modifiers[titleIconVariant]), variant, position: position2, positionOffset, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledbyFormatted(), "aria-describedby": ariaDescribedby || (hasNoBodyWrapper ? null : descriptorId)}, getOUIAProps(ModalContent.displayName, ouiaId, ouiaSafe)), showClose && react.createElement(ModalBoxCloseButton, {onClose}), modalBoxHeader, modalBody, modalBoxFooter);
  return react.createElement(Backdrop, null, react.createElement(FocusTrap, {active: !disableFocusTrap, focusTrapOptions: {clickOutsideDeactivates: true}, className: css(styles.bullseye)}, modalBox2));
};
ModalContent.displayName = "ModalContent";
var ModalVariant;
(function(ModalVariant2) {
  ModalVariant2["small"] = "small";
  ModalVariant2["medium"] = "medium";
  ModalVariant2["large"] = "large";
  ModalVariant2["default"] = "default";
})(ModalVariant || (ModalVariant = {}));
var Modal = class extends react.Component {
  constructor(props) {
    super(props);
    this.boxId = "";
    this.labelId = "";
    this.descriptorId = "";
    this.handleEscKeyClick = (event) => {
      const {onEscapePress} = this.props;
      if (event.keyCode === KEY_CODES.ESCAPE_KEY && this.props.isOpen) {
        onEscapePress ? onEscapePress(event) : this.props.onClose();
      }
    };
    this.getElement = (appendTo) => {
      if (typeof appendTo === "function") {
        return appendTo();
      }
      return appendTo || document.body;
    };
    this.toggleSiblingsFromScreenReaders = (hide2) => {
      const {appendTo} = this.props;
      const target = this.getElement(appendTo);
      const bodyChildren = target.children;
      for (const child of Array.from(bodyChildren)) {
        if (child !== this.state.container) {
          hide2 ? child.setAttribute("aria-hidden", "" + hide2) : child.removeAttribute("aria-hidden");
        }
      }
    };
    this.isEmpty = (value) => value === null || value === void 0 || value === "";
    const boxIdNum = Modal.currentId++;
    const labelIdNum = boxIdNum + 1;
    const descriptorIdNum = boxIdNum + 2;
    this.boxId = props.id || `pf-modal-part-${boxIdNum}`;
    this.labelId = `pf-modal-part-${labelIdNum}`;
    this.descriptorId = `pf-modal-part-${descriptorIdNum}`;
    this.state = {
      container: void 0,
      ouiaStateId: getDefaultOUIAId(Modal.displayName, props.variant)
    };
  }
  componentDidMount() {
    const {appendTo, title: title3, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, hasNoBodyWrapper, header} = this.props;
    const target = this.getElement(appendTo);
    const container = document.createElement("div");
    this.setState({container});
    target.appendChild(container);
    target.addEventListener("keydown", this.handleEscKeyClick, false);
    if (this.props.isOpen) {
      target.classList.add(css(styles2.backdropOpen));
    } else {
      target.classList.remove(css(styles2.backdropOpen));
    }
    if (this.isEmpty(title3) && this.isEmpty(ariaLabel) && this.isEmpty(ariaLabelledby)) {
      console.error("Modal: Specify at least one of: title, aria-label, aria-labelledby.");
    }
    if (this.isEmpty(ariaLabel) && this.isEmpty(ariaLabelledby) && (hasNoBodyWrapper || header)) {
      console.error("Modal: When using hasNoBodyWrapper or setting a custom header, ensure you assign an accessible name to the the modal container with aria-label or aria-labelledby.");
    }
  }
  componentDidUpdate() {
    const {appendTo} = this.props;
    const target = this.getElement(appendTo);
    if (this.props.isOpen) {
      target.classList.add(css(styles2.backdropOpen));
      this.toggleSiblingsFromScreenReaders(true);
    } else {
      target.classList.remove(css(styles2.backdropOpen));
      this.toggleSiblingsFromScreenReaders(false);
    }
  }
  componentWillUnmount() {
    const {appendTo} = this.props;
    const target = this.getElement(appendTo);
    if (this.state.container) {
      target.removeChild(this.state.container);
    }
    target.removeEventListener("keydown", this.handleEscKeyClick, false);
    target.classList.remove(css(styles2.backdropOpen));
  }
  render() {
    const _a = this.props, {
      appendTo,
      onEscapePress,
      "aria-labelledby": ariaLabelledby,
      "aria-label": ariaLabel,
      "aria-describedby": ariaDescribedby,
      title: title3,
      titleIconVariant,
      titleLabel,
      ouiaId,
      ouiaSafe
    } = _a, props = __rest(_a, ["appendTo", "onEscapePress", "aria-labelledby", "aria-label", "aria-describedby", "title", "titleIconVariant", "titleLabel", "ouiaId", "ouiaSafe"]);
    const {container} = this.state;
    if (!canUseDOM || !container) {
      return null;
    }
    return reactDom.createPortal(react.createElement(ModalContent, Object.assign({}, props, {boxId: this.boxId, labelId: this.labelId, descriptorId: this.descriptorId, title: title3, titleIconVariant, titleLabel, "aria-label": ariaLabel, "aria-describedby": ariaDescribedby, "aria-labelledby": ariaLabelledby, ouiaId: ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe})), container);
  }
};
Modal.displayName = "Modal";
Modal.currentId = 0;
Modal.defaultProps = {
  className: "",
  isOpen: false,
  title: "",
  titleIconVariant: null,
  titleLabel: "",
  "aria-label": "",
  showClose: true,
  "aria-describedby": "",
  "aria-labelledby": "",
  id: void 0,
  actions: [],
  onClose: () => void 0,
  variant: "default",
  hasNoBodyWrapper: false,
  appendTo: () => document.body,
  ouiaSafe: true
};
var nav = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    divider: "pf-c-divider",
    modifiers: {
      horizontal: "pf-m-horizontal",
      tertiary: "pf-m-tertiary",
      horizontalSubnav: "pf-m-horizontal-subnav",
      light: "pf-m-light",
      scrollable: "pf-m-scrollable",
      expandable: "pf-m-expandable",
      current: "pf-m-current",
      expanded: "pf-m-expanded"
    },
    nav: "pf-c-nav",
    navItem: "pf-c-nav__item",
    navLink: "pf-c-nav__link",
    navList: "pf-c-nav__list",
    navScrollButton: "pf-c-nav__scroll-button",
    navSection: "pf-c-nav__section",
    navSectionTitle: "pf-c-nav__section-title",
    navSubnav: "pf-c-nav__subnav",
    navToggle: "pf-c-nav__toggle",
    navToggleIcon: "pf-c-nav__toggle-icon"
  };
});
var styles$n = /* @__PURE__ */ getDefaultExportFromCjs(nav);
var NavContext = react.createContext({});
var Nav = class extends react.Component {
  constructor() {
    super(...arguments);
    this.state = {
      isScrollable: false,
      ouiaStateId: getDefaultOUIAId(Nav.displayName, this.props.variant)
    };
  }
  onSelect(event, groupId, itemId, to, preventDefault, onClick) {
    if (preventDefault) {
      event.preventDefault();
    }
    this.props.onSelect({groupId, itemId, event, to});
    if (onClick) {
      onClick(event, itemId, groupId, to);
    }
  }
  onToggle(event, groupId, toggleValue) {
    this.props.onToggle({
      event,
      groupId,
      isExpanded: toggleValue
    });
  }
  render() {
    const _a = this.props, {
      "aria-label": ariaLabel,
      children: children2,
      className,
      onSelect,
      onToggle,
      theme,
      ouiaId,
      ouiaSafe,
      variant
    } = _a, props = __rest(_a, ["aria-label", "children", "className", "onSelect", "onToggle", "theme", "ouiaId", "ouiaSafe", "variant"]);
    const isHorizontal = ["horizontal", "tertiary"].includes(variant);
    return react.createElement(NavContext.Provider, {value: {
      onSelect: (event, groupId, itemId, to, preventDefault, onClick) => this.onSelect(event, groupId, itemId, to, preventDefault, onClick),
      onToggle: (event, groupId, expanded) => this.onToggle(event, groupId, expanded),
      updateIsScrollable: (isScrollable) => this.setState({isScrollable}),
      isHorizontal
    }}, react.createElement("nav", Object.assign({className: css(styles$n.nav, theme === "light" && styles$n.modifiers.light, isHorizontal && styles$n.modifiers.horizontal, variant === "tertiary" && styles$n.modifiers.tertiary, this.state.isScrollable && styles$n.modifiers.scrollable, className), "aria-label": ariaLabel || (variant === "tertiary" ? "Local" : "Global")}, getOUIAProps(Nav.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe), props), children2));
  }
};
Nav.displayName = "Nav";
Nav.defaultProps = {
  onSelect: () => void 0,
  onToggle: () => void 0,
  theme: "dark",
  ouiaSafe: true
};
var page = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    avatar: "pf-c-avatar",
    brand: "pf-c-brand",
    button: "pf-c-button",
    card: "pf-c-card",
    drawer: "pf-c-drawer",
    masthead: "pf-c-masthead",
    modifiers: {
      light: "pf-m-light",
      hidden: "pf-m-hidden",
      hiddenOnSm: "pf-m-hidden-on-sm",
      visibleOnSm: "pf-m-visible-on-sm",
      hiddenOnMd: "pf-m-hidden-on-md",
      visibleOnMd: "pf-m-visible-on-md",
      hiddenOnLg: "pf-m-hidden-on-lg",
      visibleOnLg: "pf-m-visible-on-lg",
      hiddenOnXl: "pf-m-hidden-on-xl",
      visibleOnXl: "pf-m-visible-on-xl",
      hiddenOn_2xl: "pf-m-hidden-on-2xl",
      visibleOn_2xl: "pf-m-visible-on-2xl",
      read: "pf-m-read",
      selected: "pf-m-selected",
      unread: "pf-m-unread",
      attention: "pf-m-attention",
      expanded: "pf-m-expanded",
      collapsed: "pf-m-collapsed",
      limitWidth: "pf-m-limit-width",
      alignCenter: "pf-m-align-center",
      stickyTop: "pf-m-sticky-top",
      stickyBottom: "pf-m-sticky-bottom",
      overflowScroll: "pf-m-overflow-scroll",
      shadowBottom: "pf-m-shadow-bottom",
      shadowTop: "pf-m-shadow-top",
      fill: "pf-m-fill",
      noFill: "pf-m-no-fill",
      dark_100: "pf-m-dark-100",
      dark_200: "pf-m-dark-200",
      padding: "pf-m-padding",
      noPadding: "pf-m-no-padding",
      paddingOnSm: "pf-m-padding-on-sm",
      noPaddingOnSm: "pf-m-no-padding-on-sm",
      paddingOnMd: "pf-m-padding-on-md",
      noPaddingOnMd: "pf-m-no-padding-on-md",
      paddingOnLg: "pf-m-padding-on-lg",
      noPaddingOnLg: "pf-m-no-padding-on-lg",
      paddingOnXl: "pf-m-padding-on-xl",
      noPaddingOnXl: "pf-m-no-padding-on-xl",
      paddingOn_2xl: "pf-m-padding-on-2xl",
      noPaddingOn_2xl: "pf-m-no-padding-on-2xl"
    },
    nav: "pf-c-nav",
    notificationBadge: "pf-c-notification-badge",
    page: "pf-c-page",
    pageDrawer: "pf-c-page__drawer",
    pageHeader: "pf-c-page__header",
    pageHeaderBrand: "pf-c-page__header-brand",
    pageHeaderBrandLink: "pf-c-page__header-brand-link",
    pageHeaderBrandToggle: "pf-c-page__header-brand-toggle",
    pageHeaderNav: "pf-c-page__header-nav",
    pageHeaderTools: "pf-c-page__header-tools",
    pageHeaderToolsGroup: "pf-c-page__header-tools-group",
    pageHeaderToolsItem: "pf-c-page__header-tools-item",
    pageMain: "pf-c-page__main",
    pageMainBody: "pf-c-page__main-body",
    pageMainBreadcrumb: "pf-c-page__main-breadcrumb",
    pageMainDrawer: "pf-c-page__main-drawer",
    pageMainGroup: "pf-c-page__main-group",
    pageMainNav: "pf-c-page__main-nav",
    pageMainSection: "pf-c-page__main-section",
    pageMainSubnav: "pf-c-page__main-subnav",
    pageMainTabs: "pf-c-page__main-tabs",
    pageMainWizard: "pf-c-page__main-wizard",
    pageSidebar: "pf-c-page__sidebar",
    pageSidebarBody: "pf-c-page__sidebar-body"
  };
});
var styles$o = /* @__PURE__ */ getDefaultExportFromCjs(page);
var global_breakpoint_xl = {
  name: "--pf-global--breakpoint--xl",
  value: "1200px",
  var: "var(--pf-global--breakpoint--xl)"
};
var PageGroup = (_a) => {
  var {className = "", children: children2, sticky, hasShadowTop = false, hasShadowBottom = false, hasOverflowScroll = false} = _a, props = __rest(_a, ["className", "children", "sticky", "hasShadowTop", "hasShadowBottom", "hasOverflowScroll"]);
  return react.createElement("div", Object.assign({}, props, {className: css(styles$o.pageMainGroup, sticky === "top" && styles$o.modifiers.stickyTop, sticky === "bottom" && styles$o.modifiers.stickyBottom, hasShadowTop && styles$o.modifiers.shadowTop, hasShadowBottom && styles$o.modifiers.shadowBottom, hasOverflowScroll && styles$o.modifiers.overflowScroll, className)}), children2);
};
PageGroup.displayName = "PageGroup";
var PageLayouts;
(function(PageLayouts2) {
  PageLayouts2["vertical"] = "vertical";
  PageLayouts2["horizontal"] = "horizontal";
})(PageLayouts || (PageLayouts = {}));
var PageContext = react.createContext({
  isManagedSidebar: false,
  isNavOpen: false,
  onNavToggle: () => null
});
var PageContextProvider = PageContext.Provider;
var PageContextConsumer = PageContext.Consumer;
var Page = class extends react.Component {
  constructor(props) {
    super(props);
    this.mainRef = react.createRef();
    this.getWindowWidth = () => canUseDOM ? window.innerWidth : 1200;
    this.isMobile = () => this.getWindowWidth() < Number.parseInt(global_breakpoint_xl.value, 10);
    this.resize = () => {
      const {onPageResize} = this.props;
      const mobileView = this.isMobile();
      if (onPageResize) {
        onPageResize({mobileView, windowSize: this.getWindowWidth()});
      }
      if (mobileView !== this.state.mobileView) {
        this.setState({mobileView});
      }
    };
    this.handleResize = debounce(this.resize, 250);
    this.handleMainClick = () => {
      if (this.isMobile() && this.state.mobileIsNavOpen && this.mainRef.current) {
        this.setState({mobileIsNavOpen: false});
      }
    };
    this.onNavToggleMobile = () => {
      this.setState((prevState) => ({
        mobileIsNavOpen: !prevState.mobileIsNavOpen
      }));
    };
    this.onNavToggleDesktop = () => {
      this.setState((prevState) => ({
        desktopIsNavOpen: !prevState.desktopIsNavOpen
      }));
    };
    const {isManagedSidebar, defaultManagedSidebarIsOpen} = props;
    const managedSidebarOpen = !isManagedSidebar ? true : defaultManagedSidebarIsOpen;
    this.state = {
      desktopIsNavOpen: managedSidebarOpen,
      mobileIsNavOpen: false,
      mobileView: false
    };
  }
  componentDidMount() {
    const {isManagedSidebar, onPageResize} = this.props;
    if (isManagedSidebar || onPageResize) {
      if (canUseDOM) {
        window.addEventListener("resize", this.handleResize);
      }
      const currentRef = this.mainRef.current;
      if (currentRef) {
        currentRef.addEventListener("mousedown", this.handleMainClick);
        currentRef.addEventListener("touchstart", this.handleMainClick);
      }
      this.resize();
    }
  }
  componentWillUnmount() {
    const {isManagedSidebar, onPageResize} = this.props;
    if (isManagedSidebar || onPageResize) {
      if (canUseDOM) {
        window.removeEventListener("resize", this.handleResize);
      }
      const currentRef = this.mainRef.current;
      if (currentRef) {
        currentRef.removeEventListener("mousedown", this.handleMainClick);
        currentRef.removeEventListener("touchstart", this.handleMainClick);
      }
    }
  }
  render() {
    const _a = this.props, {
      breadcrumb: breadcrumb2,
      isBreadcrumbWidthLimited,
      className,
      children: children2,
      header,
      sidebar: sidebar2,
      notificationDrawer,
      isNotificationDrawerExpanded,
      onNotificationDrawerExpand,
      isTertiaryNavWidthLimited,
      skipToContent,
      role,
      mainContainerId,
      isManagedSidebar,
      defaultManagedSidebarIsOpen,
      onPageResize,
      mainAriaLabel,
      mainTabIndex,
      tertiaryNav,
      isTertiaryNavGrouped,
      isBreadcrumbGrouped,
      additionalGroupedContent,
      groupProps
    } = _a, rest = __rest(_a, ["breadcrumb", "isBreadcrumbWidthLimited", "className", "children", "header", "sidebar", "notificationDrawer", "isNotificationDrawerExpanded", "onNotificationDrawerExpand", "isTertiaryNavWidthLimited", "skipToContent", "role", "mainContainerId", "isManagedSidebar", "defaultManagedSidebarIsOpen", "onPageResize", "mainAriaLabel", "mainTabIndex", "tertiaryNav", "isTertiaryNavGrouped", "isBreadcrumbGrouped", "additionalGroupedContent", "groupProps"]);
    const {mobileView, mobileIsNavOpen, desktopIsNavOpen} = this.state;
    const context2 = {
      isManagedSidebar,
      onNavToggle: mobileView ? this.onNavToggleMobile : this.onNavToggleDesktop,
      isNavOpen: mobileView ? mobileIsNavOpen : desktopIsNavOpen
    };
    let nav2 = null;
    if (tertiaryNav && isTertiaryNavWidthLimited) {
      nav2 = react.createElement("div", {className: css(styles$o.pageMainNav, styles$o.modifiers.limitWidth)}, react.createElement("div", {className: css(styles$o.pageMainBody)}, tertiaryNav));
    } else if (tertiaryNav) {
      nav2 = react.createElement("div", {className: css(styles$o.pageMainNav)}, tertiaryNav);
    }
    let crumb = null;
    if (breadcrumb2 && isBreadcrumbWidthLimited) {
      crumb = react.createElement("section", {className: css(styles$o.pageMainBreadcrumb, styles$o.modifiers.limitWidth)}, react.createElement("div", {className: css(styles$o.pageMainBody)}, breadcrumb2));
    } else if (breadcrumb2) {
      crumb = react.createElement("section", {className: css(styles$o.pageMainBreadcrumb)}, breadcrumb2);
    }
    const isGrouped = isTertiaryNavGrouped || isBreadcrumbGrouped || additionalGroupedContent;
    const group = isGrouped ? react.createElement(PageGroup, Object.assign({}, groupProps), isTertiaryNavGrouped && nav2, isBreadcrumbGrouped && crumb, additionalGroupedContent) : null;
    const main2 = react.createElement("main", {ref: this.mainRef, role, id: mainContainerId, className: css(styles$o.pageMain), tabIndex: mainTabIndex, "aria-label": mainAriaLabel}, group, !isTertiaryNavGrouped && nav2, !isBreadcrumbGrouped && crumb, children2);
    const panelContent = react.createElement(DrawerPanelContent, null, notificationDrawer);
    return react.createElement(PageContextProvider, {value: context2}, react.createElement("div", Object.assign({}, rest, {className: css(styles$o.page, className)}), skipToContent, header, sidebar2, notificationDrawer && react.createElement("div", {className: css(styles$o.pageDrawer)}, react.createElement(Drawer, {isExpanded: isNotificationDrawerExpanded, onExpand: onNotificationDrawerExpand}, react.createElement(DrawerContent, {panelContent}, react.createElement(DrawerContentBody, null, main2)))), !notificationDrawer && main2));
  }
};
Page.displayName = "Page";
Page.defaultProps = {
  isManagedSidebar: false,
  isBreadcrumbWidthLimited: false,
  defaultManagedSidebarIsOpen: true,
  onPageResize: () => null,
  mainTabIndex: -1,
  isNotificationDrawerExpanded: false,
  onNotificationDrawerExpand: () => null
};
var PageSidebarContext = react.createContext({
  isNavOpen: true
});
var PageSidebar = (_a) => {
  var {className = "", nav: nav2, isNavOpen = true, theme = "dark"} = _a, props = __rest(_a, ["className", "nav", "isNavOpen", "theme"]);
  return react.createElement(PageContextConsumer, null, ({isManagedSidebar, isNavOpen: managedIsNavOpen}) => {
    const navOpen = isManagedSidebar ? managedIsNavOpen : isNavOpen;
    return react.createElement("div", Object.assign({id: "page-sidebar", className: css(styles$o.pageSidebar, theme === "light" && styles$o.modifiers.light, navOpen && styles$o.modifiers.expanded, !navOpen && styles$o.modifiers.collapsed, className), "aria-hidden": !navOpen}, props), react.createElement("div", {className: css(styles$o.pageSidebarBody)}, react.createElement(PageSidebarContext.Provider, {value: {isNavOpen: navOpen}}, nav2)));
  });
};
PageSidebar.displayName = "PageSidebar";
var NavList = class extends react.Component {
  constructor() {
    super(...arguments);
    this.state = {
      scrollViewAtStart: false,
      scrollViewAtEnd: false
    };
    this.navList = react.createRef();
    this.handleScrollButtons = () => {
      const container = this.navList.current;
      if (container) {
        const scrollViewAtStart = isElementInView(container, container.firstChild, false);
        const scrollViewAtEnd = isElementInView(container, container.lastChild, false);
        this.setState({
          scrollViewAtStart,
          scrollViewAtEnd
        });
        this.context.updateIsScrollable(!scrollViewAtStart || !scrollViewAtEnd);
      }
    };
    this.scrollLeft = () => {
      const container = this.navList.current;
      if (container) {
        const childrenArr = Array.from(container.children);
        let firstElementInView;
        let lastElementOutOfView;
        for (let i3 = 0; i3 < childrenArr.length && !firstElementInView; i3++) {
          if (isElementInView(container, childrenArr[i3], false)) {
            firstElementInView = childrenArr[i3];
            lastElementOutOfView = childrenArr[i3 - 1];
          }
        }
        if (lastElementOutOfView) {
          container.scrollLeft -= lastElementOutOfView.scrollWidth;
        }
        this.handleScrollButtons();
      }
    };
    this.scrollRight = () => {
      const container = this.navList.current;
      if (container) {
        const childrenArr = Array.from(container.children);
        let lastElementInView;
        let firstElementOutOfView;
        for (let i3 = childrenArr.length - 1; i3 >= 0 && !lastElementInView; i3--) {
          if (isElementInView(container, childrenArr[i3], false)) {
            lastElementInView = childrenArr[i3];
            firstElementOutOfView = childrenArr[i3 + 1];
          }
        }
        if (firstElementOutOfView) {
          container.scrollLeft += firstElementOutOfView.scrollWidth;
        }
        this.handleScrollButtons();
      }
    };
  }
  componentDidMount() {
    if (canUseDOM) {
      window.addEventListener("resize", this.handleScrollButtons, false);
    }
    this.handleScrollButtons();
  }
  componentWillUnmount() {
    if (canUseDOM) {
      window.removeEventListener("resize", this.handleScrollButtons, false);
    }
  }
  render() {
    const _a = this.props, {children: children2, className, ariaLeftScroll, ariaRightScroll} = _a, props = __rest(_a, ["children", "className", "ariaLeftScroll", "ariaRightScroll"]);
    const {scrollViewAtStart, scrollViewAtEnd} = this.state;
    return react.createElement(NavContext.Consumer, null, ({isHorizontal}) => react.createElement(PageSidebarContext.Consumer, null, ({isNavOpen}) => react.createElement(react.Fragment, null, isHorizontal && react.createElement("button", {className: css(styles$n.navScrollButton), "aria-label": ariaLeftScroll, onClick: this.scrollLeft, disabled: scrollViewAtStart, tabIndex: isNavOpen ? null : -1}, react.createElement(AngleLeftIcon, null)), react.createElement("ul", Object.assign({ref: this.navList, className: css(styles$n.navList, className), onScroll: this.handleScrollButtons}, props), children2), isHorizontal && react.createElement("button", {className: css(styles$n.navScrollButton), "aria-label": ariaRightScroll, onClick: this.scrollRight, disabled: scrollViewAtEnd, tabIndex: isNavOpen ? null : -1}, react.createElement(AngleRightIcon, null)))));
  }
};
NavList.displayName = "NavList";
NavList.contextType = NavContext;
NavList.defaultProps = {
  ariaLeftScroll: "Scroll left",
  ariaRightScroll: "Scroll right"
};
var NavGroup = (_a) => {
  var {title: title3, children: children2 = null, className = "", id: id3 = getUniqueId()} = _a, props = __rest(_a, ["title", "children", "className", "id"]);
  return react.createElement("section", Object.assign({className: css(styles$n.navSection, className), "aria-labelledby": id3}, props), react.createElement("h2", {className: css(styles$n.navSectionTitle), id: id3}, title3), react.createElement("ul", {className: css(styles$n.navList, className)}, children2));
};
NavGroup.displayName = "NavGroup";
var NavItem = (_a) => {
  var {children: children2, styleChildren = true, className, to, isActive = false, groupId = null, itemId = null, preventDefault = false, onClick = null, component = "a", ouiaId, ouiaSafe} = _a, props = __rest(_a, ["children", "styleChildren", "className", "to", "isActive", "groupId", "itemId", "preventDefault", "onClick", "component", "ouiaId", "ouiaSafe"]);
  const Component = component;
  const {isNavOpen} = react.useContext(PageSidebarContext);
  const renderDefaultLink = (context2) => {
    const preventLinkDefault = preventDefault || !to;
    return react.createElement(Component, Object.assign({href: to, onClick: (e3) => context2.onSelect(e3, groupId, itemId, to, preventLinkDefault, onClick), className: css(styles$n.navLink, isActive && styles$n.modifiers.current, className), "aria-current": isActive ? "page" : null, tabIndex: isNavOpen ? null : "-1"}, props), children2);
  };
  const renderClonedChild = (context2, child) => react.cloneElement(child, Object.assign(Object.assign({onClick: (e3) => context2.onSelect(e3, groupId, itemId, to, preventDefault, onClick), "aria-current": isActive ? "page" : null}, styleChildren && {
    className: css(styles$n.navLink, isActive && styles$n.modifiers.current, child.props && child.props.className)
  }), {tabIndex: child.props.tabIndex || isNavOpen ? null : -1}));
  const ouiaProps = useOUIAProps(NavItem.displayName, ouiaId, ouiaSafe);
  return react.createElement("li", Object.assign({className: css(styles$n.navItem, className)}, ouiaProps), react.createElement(NavContext.Consumer, null, (context2) => react.isValidElement(children2) ? renderClonedChild(context2, children2) : renderDefaultLink(context2)));
};
NavItem.displayName = "NavItem";
var TextContent = (_a) => {
  var {children: children2 = null, className = "", isVisited = false} = _a, props = __rest(_a, ["children", "className", "isVisited"]);
  return react.createElement("div", Object.assign({}, props, {className: css(styles$12.content, isVisited && styles$12.modifiers.visited, className)}), children2);
};
TextContent.displayName = "TextContent";
var TextVariants;
(function(TextVariants2) {
  TextVariants2["h1"] = "h1";
  TextVariants2["h2"] = "h2";
  TextVariants2["h3"] = "h3";
  TextVariants2["h4"] = "h4";
  TextVariants2["h5"] = "h5";
  TextVariants2["h6"] = "h6";
  TextVariants2["p"] = "p";
  TextVariants2["a"] = "a";
  TextVariants2["small"] = "small";
  TextVariants2["blockquote"] = "blockquote";
  TextVariants2["pre"] = "pre";
})(TextVariants || (TextVariants = {}));
var Text = (_a) => {
  var {children: children2 = null, className = "", component = TextVariants.p, isVisitedLink = false, ouiaId, ouiaSafe = true} = _a, props = __rest(_a, ["children", "className", "component", "isVisitedLink", "ouiaId", "ouiaSafe"]);
  const Component = component;
  const ouiaProps = useOUIAProps(Text.displayName, ouiaId, ouiaSafe);
  return react.createElement(Component, Object.assign({}, ouiaProps, props, {"data-pf-content": true, className: css(isVisitedLink && component === TextVariants.a && styles$12.modifiers.visited, className)}), children2);
};
Text.displayName = "Text";
var optionsMenu = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    divider: "pf-c-divider",
    modifiers: {
      plain: "pf-m-plain",
      text: "pf-m-text",
      active: "pf-m-active",
      expanded: "pf-m-expanded",
      disabled: "pf-m-disabled",
      top: "pf-m-top",
      alignRight: "pf-m-align-right"
    },
    optionsMenu: "pf-c-options-menu",
    optionsMenuGroup: "pf-c-options-menu__group",
    optionsMenuGroupTitle: "pf-c-options-menu__group-title",
    optionsMenuMenu: "pf-c-options-menu__menu",
    optionsMenuMenuItem: "pf-c-options-menu__menu-item",
    optionsMenuMenuItemIcon: "pf-c-options-menu__menu-item-icon",
    optionsMenuToggle: "pf-c-options-menu__toggle",
    optionsMenuToggleButton: "pf-c-options-menu__toggle-button",
    optionsMenuToggleButtonIcon: "pf-c-options-menu__toggle-button-icon",
    optionsMenuToggleIcon: "pf-c-options-menu__toggle-icon",
    optionsMenuToggleText: "pf-c-options-menu__toggle-text"
  };
});
var styles$p = /* @__PURE__ */ getDefaultExportFromCjs(optionsMenu);
var global_breakpoint_md = {
  name: "--pf-global--breakpoint--md",
  value: "768px",
  var: "var(--pf-global--breakpoint--md)"
};
var global_breakpoint_lg = {
  name: "--pf-global--breakpoint--lg",
  value: "992px",
  var: "var(--pf-global--breakpoint--lg)"
};
var global_breakpoint_2xl = {
  name: "--pf-global--breakpoint--2xl",
  value: "1450px",
  var: "var(--pf-global--breakpoint--2xl)"
};
var BarsIconConfig = {
  name: "BarsIcon",
  height: 512,
  width: 448,
  svgPath: "M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z",
  yOffset: 0,
  xOffset: 0
};
var BarsIcon = createIcon(BarsIconConfig);
var PageHeader = (_a) => {
  var {className = "", logo = null, logoProps = null, logoComponent = "a", headerTools = null, topNav = null, isNavOpen = true, isManagedSidebar: deprecatedIsManagedSidebar = void 0, role = void 0, showNavToggle = false, onNavToggle = () => void 0, "aria-label": ariaLabel = "Global navigation", "aria-controls": ariaControls = null} = _a, props = __rest(_a, ["className", "logo", "logoProps", "logoComponent", "headerTools", "topNav", "isNavOpen", "isManagedSidebar", "role", "showNavToggle", "onNavToggle", "aria-label", "aria-controls"]);
  const LogoComponent = logoComponent;
  if ([false, true].includes(deprecatedIsManagedSidebar)) {
    console.warn("isManagedSidebar is deprecated in the PageHeader component. To make the sidebar toggle uncontrolled, pass this prop in the Page component");
  }
  return react.createElement(PageContextConsumer, null, ({isManagedSidebar, onNavToggle: managedOnNavToggle, isNavOpen: managedIsNavOpen}) => {
    const navToggle = isManagedSidebar ? managedOnNavToggle : onNavToggle;
    const navOpen = isManagedSidebar ? managedIsNavOpen : isNavOpen;
    return react.createElement("header", Object.assign({role, className: css(styles$o.pageHeader, className)}, props), (showNavToggle || logo) && react.createElement("div", {className: css(styles$o.pageHeaderBrand)}, showNavToggle && react.createElement("div", {className: css(styles$o.pageHeaderBrandToggle)}, react.createElement(Button, {id: "nav-toggle", onClick: navToggle, "aria-label": ariaLabel, "aria-controls": ariaControls, "aria-expanded": navOpen ? "true" : "false", variant: ButtonVariant.plain}, react.createElement(BarsIcon, null))), logo && react.createElement(LogoComponent, Object.assign({className: css(styles$o.pageHeaderBrandLink)}, logoProps), logo)), topNav && react.createElement("div", {className: css(styles$o.pageHeaderNav)}, topNav), headerTools);
  });
};
PageHeader.displayName = "PageHeader";
var PageSectionVariants;
(function(PageSectionVariants2) {
  PageSectionVariants2["default"] = "default";
  PageSectionVariants2["light"] = "light";
  PageSectionVariants2["dark"] = "dark";
  PageSectionVariants2["darker"] = "darker";
})(PageSectionVariants || (PageSectionVariants = {}));
var PageSectionTypes;
(function(PageSectionTypes2) {
  PageSectionTypes2["default"] = "default";
  PageSectionTypes2["nav"] = "nav";
  PageSectionTypes2["tabs"] = "tabs";
  PageSectionTypes2["wizard"] = "wizard";
})(PageSectionTypes || (PageSectionTypes = {}));
var variantType = {
  [PageSectionTypes.default]: styles$o.pageMainSection,
  [PageSectionTypes.nav]: styles$o.pageMainNav,
  [PageSectionTypes.tabs]: styles$o.pageMainTabs,
  [PageSectionTypes.wizard]: styles$o.pageMainWizard
};
var variantStyle = {
  [PageSectionVariants.default]: "",
  [PageSectionVariants.light]: styles$o.modifiers.light,
  [PageSectionVariants.dark]: styles$o.modifiers.dark_200,
  [PageSectionVariants.darker]: styles$o.modifiers.dark_100
};
var PageSection = (_a) => {
  var {className = "", children: children2, variant = "default", type = "default", padding, isFilled, isWidthLimited = false, sticky, hasShadowTop = false, hasShadowBottom = false, hasOverflowScroll = false} = _a, props = __rest(_a, ["className", "children", "variant", "type", "padding", "isFilled", "isWidthLimited", "sticky", "hasShadowTop", "hasShadowBottom", "hasOverflowScroll"]);
  return react.createElement("section", Object.assign({}, props, {className: css(variantType[type], formatBreakpointMods(padding, styles$o), variantStyle[variant], isFilled === false && styles$o.modifiers.noFill, isFilled === true && styles$o.modifiers.fill, isWidthLimited && styles$o.modifiers.limitWidth, sticky === "top" && styles$o.modifiers.stickyTop, sticky === "bottom" && styles$o.modifiers.stickyBottom, hasShadowTop && styles$o.modifiers.shadowTop, hasShadowBottom && styles$o.modifiers.shadowBottom, hasOverflowScroll && styles$o.modifiers.overflowScroll, className)}), isWidthLimited && react.createElement("div", {className: css(styles$o.pageMainBody)}, children2), !isWidthLimited && children2);
};
PageSection.displayName = "PageSection";
var PageHeaderTools = (_a) => {
  var {children: children2, className} = _a, props = __rest(_a, ["children", "className"]);
  return react.createElement("div", Object.assign({className: css(styles$o.pageHeaderTools, className)}, props), children2);
};
PageHeaderTools.displayName = "PageHeaderTools";
var PageHeaderToolsGroup = (_a) => {
  var {children: children2, className, visibility} = _a, props = __rest(_a, ["children", "className", "visibility"]);
  return react.createElement("div", Object.assign({className: css(styles$o.pageHeaderToolsGroup, formatBreakpointMods(visibility, styles$o), className)}, props), children2);
};
PageHeaderToolsGroup.displayName = "PageHeaderToolsGroup";
var PageHeaderToolsItem = ({children: children2, id: id3, className, visibility, isSelected}) => react.createElement("div", {className: css(styles$o.pageHeaderToolsItem, isSelected && styles$o.modifiers.selected, formatBreakpointMods(visibility, styles$o), className), id: id3}, children2);
PageHeaderToolsItem.displayName = "PageHeaderToolsItem";
var ToggleTemplate = ({firstIndex = 0, lastIndex = 0, itemCount = 0, itemsTitle = "items", ofWord = "of"}) => react.createElement(react.Fragment, null, react.createElement("b", null, firstIndex, " - ", lastIndex), " ", ofWord, " ", react.createElement("b", null, itemCount), " ", itemsTitle);
ToggleTemplate.displayName = "ToggleTemplate";
var pagination = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    button: "pf-c-button",
    formControl: "pf-c-form-control",
    modifiers: {
      bottom: "pf-m-bottom",
      static: "pf-m-static",
      first: "pf-m-first",
      last: "pf-m-last",
      sticky: "pf-m-sticky",
      compact: "pf-m-compact",
      displaySummary: "pf-m-display-summary",
      displayFull: "pf-m-display-full",
      displaySummaryOnSm: "pf-m-display-summary-on-sm",
      displayFullOnSm: "pf-m-display-full-on-sm",
      displaySummaryOnMd: "pf-m-display-summary-on-md",
      displayFullOnMd: "pf-m-display-full-on-md",
      displaySummaryOnLg: "pf-m-display-summary-on-lg",
      displayFullOnLg: "pf-m-display-full-on-lg",
      displaySummaryOnXl: "pf-m-display-summary-on-xl",
      displayFullOnXl: "pf-m-display-full-on-xl",
      displaySummaryOn_2xl: "pf-m-display-summary-on-2xl",
      displayFullOn_2xl: "pf-m-display-full-on-2xl"
    },
    optionsMenu: "pf-c-options-menu",
    optionsMenuToggle: "pf-c-options-menu__toggle",
    pagination: "pf-c-pagination",
    paginationNav: "pf-c-pagination__nav",
    paginationNavControl: "pf-c-pagination__nav-control",
    paginationNavPageSelect: "pf-c-pagination__nav-page-select",
    paginationTotalItems: "pf-c-pagination__total-items"
  };
});
var styles$q = /* @__PURE__ */ getDefaultExportFromCjs(pagination);
var Navigation = class extends react.Component {
  constructor(props) {
    super(props);
    this.handleNewPage = (_evt, newPage) => {
      const {perPage, onSetPage} = this.props;
      const startIdx = (newPage - 1) * perPage;
      const endIdx = newPage * perPage;
      return onSetPage(_evt, newPage, perPage, startIdx, endIdx);
    };
    this.state = {userInputPage: this.props.page};
  }
  static parseInteger(input, lastPage) {
    let inputPage = Number.parseInt(input, 10);
    if (!Number.isNaN(inputPage)) {
      inputPage = inputPage > lastPage ? lastPage : inputPage;
      inputPage = inputPage < 1 ? 1 : inputPage;
    }
    return inputPage;
  }
  onChange(event, lastPage) {
    const inputPage = Navigation.parseInteger(event.target.value, lastPage);
    this.setState({userInputPage: Number.isNaN(inputPage) ? event.target.value : inputPage});
  }
  onKeyDown(event, page2, lastPage, onPageInput) {
    if (event.keyCode === KEY_CODES.ENTER) {
      const inputPage = Navigation.parseInteger(this.state.userInputPage, lastPage);
      onPageInput(event, Number.isNaN(inputPage) ? page2 : inputPage);
      this.handleNewPage(event, Number.isNaN(inputPage) ? page2 : inputPage);
    }
  }
  componentDidUpdate(lastState) {
    if (this.props.page !== lastState.page && this.props.page <= this.props.lastPage && this.state.userInputPage !== this.props.page) {
      this.setState({userInputPage: this.props.page});
    }
  }
  render() {
    const _a = this.props, {
      page: page2,
      perPage,
      onSetPage,
      isDisabled,
      lastPage,
      firstPage,
      pagesTitle,
      toLastPage,
      toNextPage,
      toFirstPage,
      toPreviousPage,
      currPage,
      paginationTitle,
      ofWord,
      onNextClick,
      onPreviousClick,
      onFirstClick,
      onLastClick,
      onPageInput,
      className,
      isCompact
    } = _a, props = __rest(_a, ["page", "perPage", "onSetPage", "isDisabled", "lastPage", "firstPage", "pagesTitle", "toLastPage", "toNextPage", "toFirstPage", "toPreviousPage", "currPage", "paginationTitle", "ofWord", "onNextClick", "onPreviousClick", "onFirstClick", "onLastClick", "onPageInput", "className", "isCompact"]);
    const {userInputPage} = this.state;
    return react.createElement("nav", Object.assign({className: css(styles$q.paginationNav, className), "aria-label": paginationTitle}, props), !isCompact && react.createElement("div", {className: css(styles$q.paginationNavControl, styles$q.modifiers.first)}, react.createElement(Button, {variant: ButtonVariant.plain, isDisabled: isDisabled || page2 === firstPage || page2 === 0, "aria-label": toFirstPage, "data-action": "first", onClick: (event) => {
      onFirstClick(event, 1);
      this.handleNewPage(event, 1);
      this.setState({userInputPage: 1});
    }}, react.createElement(AngleDoubleLeftIcon, null))), react.createElement("div", {className: styles$q.paginationNavControl}, react.createElement(Button, {variant: ButtonVariant.plain, isDisabled: isDisabled || page2 === firstPage || page2 === 0, "data-action": "previous", onClick: (event) => {
      const newPage = page2 - 1 >= 1 ? page2 - 1 : 1;
      onPreviousClick(event, newPage);
      this.handleNewPage(event, newPage);
      this.setState({userInputPage: newPage});
    }, "aria-label": toPreviousPage}, react.createElement(AngleLeftIcon, null))), !isCompact && react.createElement("div", {className: styles$q.paginationNavPageSelect}, react.createElement("input", {className: css(styles$q.formControl), "aria-label": currPage, type: "number", disabled: isDisabled || page2 === firstPage && page2 === lastPage || page2 === 0, min: lastPage <= 0 && firstPage <= 0 ? 0 : 1, max: lastPage, value: userInputPage, onKeyDown: (event) => this.onKeyDown(event, page2, lastPage, onPageInput), onChange: (event) => this.onChange(event, lastPage)}), react.createElement("span", {"aria-hidden": "true"}, ofWord, " ", pagesTitle ? pluralize(lastPage, pagesTitle) : lastPage)), react.createElement("div", {className: styles$q.paginationNavControl}, react.createElement(Button, {variant: ButtonVariant.plain, isDisabled: isDisabled || page2 === lastPage, "aria-label": toNextPage, "data-action": "next", onClick: (event) => {
      const newPage = page2 + 1 <= lastPage ? page2 + 1 : lastPage;
      onNextClick(event, newPage);
      this.handleNewPage(event, newPage);
      this.setState({userInputPage: newPage});
    }}, react.createElement(AngleRightIcon, null))), !isCompact && react.createElement("div", {className: css(styles$q.paginationNavControl, styles$q.modifiers.last)}, react.createElement(Button, {variant: ButtonVariant.plain, isDisabled: isDisabled || page2 === lastPage, "aria-label": toLastPage, "data-action": "last", onClick: (event) => {
      onLastClick(event, lastPage);
      this.handleNewPage(event, lastPage);
      this.setState({userInputPage: lastPage});
    }}, react.createElement(AngleDoubleRightIcon, null))));
  }
};
Navigation.displayName = "Navigation";
Navigation.defaultProps = {
  className: "",
  isDisabled: false,
  isCompact: false,
  lastPage: 0,
  firstPage: 0,
  pagesTitle: "",
  toLastPage: "Go to last page",
  toNextPage: "Go to next page",
  toFirstPage: "Go to first page",
  toPreviousPage: "Go to previous page",
  currPage: "Current page",
  paginationTitle: "Pagination",
  ofWord: "of",
  onNextClick: () => void 0,
  onPreviousClick: () => void 0,
  onFirstClick: () => void 0,
  onLastClick: () => void 0,
  onPageInput: () => void 0
};
var toggleId = 0;
var OptionsToggle = ({
  itemsTitle = "items",
  optionsToggle = "Items per page",
  itemsPerPageTitle = "Items per page",
  firstIndex = 0,
  lastIndex = 0,
  itemCount = 0,
  widgetId = "",
  showToggle = true,
  onToggle = (_isOpen) => void 0,
  isOpen = false,
  isDisabled = false,
  parentRef = null,
  toggleTemplate: ToggleTemplate2 = "",
  onEnter = null
}) => react.createElement("div", {className: css(styles$p.optionsMenuToggle, isDisabled && styles$p.modifiers.disabled, styles$p.modifiers.plain, styles$p.modifiers.text)}, showToggle && react.createElement(react.Fragment, null, react.createElement("span", {className: css(styles$p.optionsMenuToggleText)}, typeof ToggleTemplate2 === "string" ? fillTemplate(ToggleTemplate2, {firstIndex, lastIndex, itemCount, itemsTitle}) : react.createElement(ToggleTemplate2, {firstIndex, lastIndex, itemCount, itemsTitle})), react.createElement(DropdownToggle, {onEnter, "aria-label": optionsToggle, onToggle, isDisabled: isDisabled || itemCount <= 0, isOpen, id: `${widgetId}-toggle-${toggleId++}`, className: styles$p.optionsMenuToggleButton, parentRef})));
OptionsToggle.displayName = "OptionsToggle";
var PaginationOptionsMenu = class extends react.Component {
  constructor(props) {
    super(props);
    this.parentRef = react.createRef();
    this.onToggle = (isOpen) => {
      this.setState({isOpen});
    };
    this.onSelect = () => {
      this.setState((prevState) => ({isOpen: !prevState.isOpen}));
    };
    this.handleNewPerPage = (_evt, newPerPage) => {
      const {page: page2, onPerPageSelect, itemCount, defaultToFullPage} = this.props;
      let newPage = page2;
      while (Math.ceil(itemCount / newPerPage) < newPage) {
        newPage--;
      }
      if (defaultToFullPage) {
        if (itemCount / newPerPage !== newPage) {
          while (newPage > 1 && itemCount - newPerPage * newPage < 0) {
            newPage--;
          }
        }
      }
      const startIdx = (newPage - 1) * newPerPage;
      const endIdx = newPage * newPerPage;
      return onPerPageSelect(_evt, newPerPage, newPage, startIdx, endIdx);
    };
    this.renderItems = () => {
      const {perPageOptions, perPage, perPageSuffix} = this.props;
      return perPageOptions.map(({value, title: title3}) => react.createElement(DropdownItem, {key: value, component: "button", "data-action": `per-page-${value}`, className: css(perPage === value && "pf-m-selected"), onClick: (event) => this.handleNewPerPage(event, value)}, title3, ` ${perPageSuffix}`, perPage === value && react.createElement("div", {className: css(styles$p.optionsMenuMenuItemIcon)}, react.createElement(CheckIcon, null))));
    };
    this.state = {
      isOpen: false
    };
  }
  render() {
    const {widgetId, isDisabled, itemsPerPageTitle, dropDirection, optionsToggle, perPageOptions, toggleTemplate, firstIndex, lastIndex, itemCount, itemsTitle} = this.props;
    const {isOpen} = this.state;
    return react.createElement(DropdownContext.Provider, {value: {
      id: widgetId,
      onSelect: this.onSelect,
      toggleIndicatorClass: styles$p.optionsMenuToggleButtonIcon,
      toggleTextClass: styles$p.optionsMenuToggleText,
      menuClass: styles$p.optionsMenuMenu,
      itemClass: styles$p.optionsMenuMenuItem,
      toggleClass: " ",
      baseClass: styles$p.optionsMenu,
      disabledClass: styles$p.modifiers.disabled,
      menuComponent: "ul",
      baseComponent: "div",
      ouiaComponentType: PaginationOptionsMenu.displayName
    }}, react.createElement(DropdownWithContext, {direction: dropDirection, isOpen, toggle: react.createElement(OptionsToggle, {optionsToggle, itemsPerPageTitle, showToggle: perPageOptions && perPageOptions.length > 0, onToggle: this.onToggle, isOpen, widgetId, firstIndex, lastIndex, itemCount, itemsTitle, toggleTemplate, parentRef: this.parentRef.current, isDisabled}), dropdownItems: this.renderItems(), isPlain: true}));
  }
};
PaginationOptionsMenu.displayName = "PaginationOptionsMenu";
PaginationOptionsMenu.defaultProps = {
  className: "",
  widgetId: "",
  isDisabled: false,
  dropDirection: DropdownDirection.down,
  perPageOptions: [],
  itemsPerPageTitle: "Items per page",
  perPageSuffix: "per page",
  optionsToggle: "Items per page",
  perPage: 0,
  firstIndex: 0,
  lastIndex: 0,
  defaultToFullPage: false,
  itemCount: 0,
  itemsTitle: "items",
  toggleTemplate: ({firstIndex, lastIndex, itemCount, itemsTitle}) => react.createElement(react.Fragment, null, react.createElement("b", null, firstIndex, " - ", lastIndex), " ", "of", react.createElement("b", null, itemCount), " ", itemsTitle),
  onPerPageSelect: () => null
};
var c_pagination__nav_page_select_c_form_control_width_chars = {
  name: "--pf-c-pagination__nav-page-select--c-form-control--width-chars",
  value: "2",
  var: "var(--pf-c-pagination__nav-page-select--c-form-control--width-chars)"
};
var PaginationVariant;
(function(PaginationVariant2) {
  PaginationVariant2["top"] = "top";
  PaginationVariant2["bottom"] = "bottom";
})(PaginationVariant || (PaginationVariant = {}));
var defaultPerPageOptions = [
  {
    title: "10",
    value: 10
  },
  {
    title: "20",
    value: 20
  },
  {
    title: "50",
    value: 50
  },
  {
    title: "100",
    value: 100
  }
];
var handleInputWidth = (lastPage, node) => {
  if (!node) {
    return;
  }
  const len2 = String(lastPage).length;
  if (len2 >= 3) {
    node.style.setProperty(c_pagination__nav_page_select_c_form_control_width_chars.name, `${len2}`);
  } else {
    node.style.setProperty(c_pagination__nav_page_select_c_form_control_width_chars.name, "2");
  }
};
var paginationId = 0;
var Pagination = class extends react.Component {
  constructor() {
    super(...arguments);
    this.paginationRef = react.createRef();
    this.state = {
      ouiaStateId: getDefaultOUIAId(Pagination.displayName, this.props.variant)
    };
  }
  getLastPage() {
    const {itemCount, perPage} = this.props;
    return Math.ceil(itemCount / perPage) || 0;
  }
  componentDidMount() {
    const node = this.paginationRef.current;
    handleInputWidth(this.getLastPage(), node);
  }
  componentDidUpdate(prevProps) {
    const node = this.paginationRef.current;
    if (prevProps.perPage !== this.props.perPage || prevProps.itemCount !== this.props.itemCount) {
      handleInputWidth(this.getLastPage(), node);
    }
  }
  render() {
    const _a = this.props, {children: children2, className, variant, isDisabled, isCompact, isStatic, isSticky, perPage, titles, firstPage, page: propPage, offset: offset2, defaultToFullPage, itemCount, itemsStart, itemsEnd, perPageOptions, dropDirection: dropDirectionProp, widgetId, toggleTemplate, onSetPage, onPerPageSelect, onFirstClick, onPreviousClick, onNextClick, onPageInput, onLastClick, ouiaId, ouiaSafe} = _a, props = __rest(_a, ["children", "className", "variant", "isDisabled", "isCompact", "isStatic", "isSticky", "perPage", "titles", "firstPage", "page", "offset", "defaultToFullPage", "itemCount", "itemsStart", "itemsEnd", "perPageOptions", "dropDirection", "widgetId", "toggleTemplate", "onSetPage", "onPerPageSelect", "onFirstClick", "onPreviousClick", "onNextClick", "onPageInput", "onLastClick", "ouiaId", "ouiaSafe"]);
    const dropDirection = dropDirectionProp || (variant === "bottom" && !isStatic ? "up" : "down");
    let page2 = propPage;
    if (!page2 && offset2) {
      page2 = Math.ceil(offset2 / perPage);
    }
    const lastPage = this.getLastPage();
    if (page2 < firstPage && itemCount > 0) {
      page2 = firstPage;
    } else if (page2 > lastPage) {
      page2 = lastPage;
    }
    const firstIndex = itemCount <= 0 ? 0 : (page2 - 1) * perPage + 1;
    let lastIndex;
    if (itemCount <= 0) {
      lastIndex = 0;
    } else {
      lastIndex = page2 === lastPage ? itemCount : page2 * perPage;
    }
    return react.createElement("div", Object.assign({ref: this.paginationRef, className: css(styles$q.pagination, variant === PaginationVariant.bottom && styles$q.modifiers.bottom, isCompact && styles$q.modifiers.compact, isStatic && styles$q.modifiers.static, isSticky && styles$q.modifiers.sticky, className), id: `${widgetId}-${paginationId++}`}, getOUIAProps(Pagination.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe), props), variant === PaginationVariant.top && react.createElement("div", {className: css(styles$q.paginationTotalItems)}, react.createElement(ToggleTemplate, {firstIndex, lastIndex, itemCount, itemsTitle: titles.items, ofWord: titles.ofWord})), react.createElement(PaginationOptionsMenu, {itemsPerPageTitle: titles.itemsPerPage, perPageSuffix: titles.perPageSuffix, itemsTitle: isCompact ? "" : titles.items, optionsToggle: titles.optionsToggle, perPageOptions, firstIndex: itemsStart !== null ? itemsStart : firstIndex, lastIndex: itemsEnd !== null ? itemsEnd : lastIndex, defaultToFullPage, itemCount, page: page2, perPage, lastPage, onPerPageSelect, dropDirection, widgetId, toggleTemplate, isDisabled}), react.createElement(Navigation, {pagesTitle: titles.page, toLastPage: titles.toLastPage, toPreviousPage: titles.toPreviousPage, toNextPage: titles.toNextPage, toFirstPage: titles.toFirstPage, currPage: titles.currPage, paginationTitle: titles.paginationTitle, ofWord: titles.ofWord, page: itemCount <= 0 ? 0 : page2, perPage, firstPage: itemsStart !== null ? itemsStart : 1, lastPage, onSetPage, onFirstClick, onPreviousClick, onNextClick, onLastClick, onPageInput, isDisabled, isCompact}), children2);
  }
};
Pagination.displayName = "Pagination";
Pagination.defaultProps = {
  children: null,
  className: "",
  variant: PaginationVariant.top,
  isDisabled: false,
  isCompact: false,
  isSticky: false,
  perPage: defaultPerPageOptions[0].value,
  titles: {
    items: "",
    page: "",
    itemsPerPage: "Items per page",
    perPageSuffix: "per page",
    toFirstPage: "Go to first page",
    toPreviousPage: "Go to previous page",
    toLastPage: "Go to last page",
    toNextPage: "Go to next page",
    optionsToggle: "Items per page",
    currPage: "Current page",
    paginationTitle: "Pagination",
    ofWord: "of"
  },
  firstPage: 1,
  page: 0,
  offset: 0,
  defaultToFullPage: false,
  itemsStart: null,
  itemsEnd: null,
  perPageOptions: defaultPerPageOptions,
  widgetId: "pagination-options-menu",
  toggleTemplate: ToggleTemplate,
  onSetPage: () => void 0,
  onPerPageSelect: () => void 0,
  onFirstClick: () => void 0,
  onPreviousClick: () => void 0,
  onNextClick: () => void 0,
  onPageInput: () => void 0,
  onLastClick: () => void 0,
  ouiaSafe: true
};
var radio = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    modifiers: {
      standalone: "pf-m-standalone",
      disabled: "pf-m-disabled"
    },
    radio: "pf-c-radio",
    radioBody: "pf-c-radio__body",
    radioDescription: "pf-c-radio__description",
    radioInput: "pf-c-radio__input",
    radioLabel: "pf-c-radio__label"
  };
});
var styles$r = /* @__PURE__ */ getDefaultExportFromCjs(radio);
var Radio = class extends react.Component {
  constructor(props) {
    super(props);
    this.handleChange = (event) => {
      this.props.onChange(event.currentTarget.checked, event);
    };
    if (!props.label && !props["aria-label"]) {
      console.error("Radio:", "Radio requires an aria-label to be specified");
    }
    this.state = {
      ouiaStateId: getDefaultOUIAId(Radio.displayName)
    };
  }
  render() {
    const _a = this.props, {
      "aria-label": ariaLabel,
      checked,
      className,
      defaultChecked,
      isLabelWrapped,
      isLabelBeforeButton,
      isChecked,
      isDisabled,
      isValid,
      label: label2,
      onChange,
      description,
      body,
      ouiaId,
      ouiaSafe = true
    } = _a, props = __rest(_a, ["aria-label", "checked", "className", "defaultChecked", "isLabelWrapped", "isLabelBeforeButton", "isChecked", "isDisabled", "isValid", "label", "onChange", "description", "body", "ouiaId", "ouiaSafe"]);
    if (!props.id) {
      console.error("Radio:", "id is required to make input accessible");
    }
    const inputRendered = react.createElement("input", Object.assign({}, props, {className: css(styles$r.radioInput), type: "radio", onChange: this.handleChange, "aria-invalid": !isValid, disabled: isDisabled, checked: checked || isChecked}, checked === void 0 && {defaultChecked}, !label2 && {"aria-label": ariaLabel}, getOUIAProps(Radio.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe)));
    let labelRendered = null;
    if (label2 && isLabelWrapped) {
      labelRendered = react.createElement("span", {className: css(styles$r.radioLabel, isDisabled && styles$r.modifiers.disabled)}, label2);
    } else if (label2) {
      labelRendered = react.createElement("label", {className: css(styles$r.radioLabel, isDisabled && styles$r.modifiers.disabled), htmlFor: props.id}, label2);
    }
    const descRender = description ? react.createElement("span", {className: css(styles$r.radioDescription)}, description) : null;
    const bodyRender = body ? react.createElement("span", {className: css(styles$r.radioBody)}, body) : null;
    const childrenRendered = isLabelBeforeButton ? react.createElement(react.Fragment, null, labelRendered, inputRendered, descRender, bodyRender) : react.createElement(react.Fragment, null, inputRendered, labelRendered, descRender, bodyRender);
    return isLabelWrapped ? react.createElement("label", {className: css(styles$r.radio, className), htmlFor: props.id}, childrenRendered) : react.createElement("div", {className: css(styles$r.radio, !label2 && styles$r.modifiers.standalone, className)}, childrenRendered);
  }
};
Radio.displayName = "Radio";
Radio.defaultProps = {
  className: "",
  isDisabled: false,
  isValid: true,
  onChange: () => {
  }
};
var _switch = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    modifiers: {
      reverse: "pf-m-reverse",
      off: "pf-m-off",
      on: "pf-m-on"
    },
    switch: "pf-c-switch",
    switchInput: "pf-c-switch__input",
    switchLabel: "pf-c-switch__label",
    switchToggle: "pf-c-switch__toggle",
    switchToggleIcon: "pf-c-switch__toggle-icon"
  };
});
var styles$s = /* @__PURE__ */ getDefaultExportFromCjs(_switch);
var Switch = class extends react.Component {
  constructor(props) {
    super(props);
    if (!props.label && !props["aria-label"]) {
      console.error("Switch: Switch requires either a label or an aria-label to be specified");
    }
    this.id = props.id || getUniqueId();
    this.state = {
      ouiaStateId: getDefaultOUIAId(Switch.displayName)
    };
  }
  render() {
    const _a = this.props, {
      id: id3,
      className,
      label: label2,
      labelOff,
      isChecked,
      isDisabled,
      onChange,
      isReversed,
      ouiaId,
      ouiaSafe
    } = _a, props = __rest(_a, ["id", "className", "label", "labelOff", "isChecked", "isDisabled", "onChange", "isReversed", "ouiaId", "ouiaSafe"]);
    const isAriaLabelledBy = props["aria-label"] === "";
    return react.createElement("label", Object.assign({className: css(styles$s.switch, isReversed && styles$s.modifiers.reverse, className), htmlFor: this.id}, getOUIAProps(Switch.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe)), react.createElement("input", Object.assign({id: this.id, className: css(styles$s.switchInput), type: "checkbox", onChange: (event) => onChange(event.target.checked, event), checked: isChecked, disabled: isDisabled, "aria-labelledby": isAriaLabelledBy ? `${this.id}-on` : null}, props)), label2 !== void 0 ? react.createElement(react.Fragment, null, react.createElement("span", {className: css(styles$s.switchToggle)}), react.createElement("span", {className: css(styles$s.switchLabel, styles$s.modifiers.on), id: isAriaLabelledBy ? `${this.id}-on` : null, "aria-hidden": "true"}, label2), react.createElement("span", {className: css(styles$s.switchLabel, styles$s.modifiers.off), id: isAriaLabelledBy ? `${this.id}-off` : null, "aria-hidden": "true"}, labelOff !== void 0 ? labelOff : label2)) : react.createElement("span", {className: css(styles$s.switchToggle)}, react.createElement("div", {className: css(styles$s.switchToggleIcon), "aria-hidden": "true"}, react.createElement(CheckIcon, {noVerticalAlign: true}))));
  }
};
Switch.displayName = "Switch";
Switch.defaultProps = {
  isChecked: true,
  isDisabled: false,
  isReversed: false,
  "aria-label": "",
  onChange: () => void 0
};
var Tab = (_props) => null;
Tab.displayName = "Tab";
var tabs = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    modifiers: {
      fill: "pf-m-fill",
      scrollable: "pf-m-scrollable",
      secondary: "pf-m-secondary",
      noBorderBottom: "pf-m-no-border-bottom",
      box: "pf-m-box",
      vertical: "pf-m-vertical",
      current: "pf-m-current",
      colorSchemeLight_300: "pf-m-color-scheme--light-300",
      expandable: "pf-m-expandable",
      nonExpandable: "pf-m-non-expandable",
      expandableOnSm: "pf-m-expandable-on-sm",
      nonExpandableOnSm: "pf-m-non-expandable-on-sm",
      expandableOnMd: "pf-m-expandable-on-md",
      nonExpandableOnMd: "pf-m-non-expandable-on-md",
      expandableOnLg: "pf-m-expandable-on-lg",
      nonExpandableOnLg: "pf-m-non-expandable-on-lg",
      expandableOnXl: "pf-m-expandable-on-xl",
      nonExpandableOnXl: "pf-m-non-expandable-on-xl",
      expandableOn_2xl: "pf-m-expandable-on-2xl",
      nonExpandableOn_2xl: "pf-m-non-expandable-on-2xl",
      expanded: "pf-m-expanded",
      pageInsets: "pf-m-page-insets",
      insetNone: "pf-m-inset-none",
      insetSm: "pf-m-inset-sm",
      insetMd: "pf-m-inset-md",
      insetLg: "pf-m-inset-lg",
      insetXl: "pf-m-inset-xl",
      inset_2xl: "pf-m-inset-2xl",
      insetNoneOnSm: "pf-m-inset-none-on-sm",
      insetSmOnSm: "pf-m-inset-sm-on-sm",
      insetMdOnSm: "pf-m-inset-md-on-sm",
      insetLgOnSm: "pf-m-inset-lg-on-sm",
      insetXlOnSm: "pf-m-inset-xl-on-sm",
      inset_2xlOnSm: "pf-m-inset-2xl-on-sm",
      insetNoneOnMd: "pf-m-inset-none-on-md",
      insetSmOnMd: "pf-m-inset-sm-on-md",
      insetMdOnMd: "pf-m-inset-md-on-md",
      insetLgOnMd: "pf-m-inset-lg-on-md",
      insetXlOnMd: "pf-m-inset-xl-on-md",
      inset_2xlOnMd: "pf-m-inset-2xl-on-md",
      insetNoneOnLg: "pf-m-inset-none-on-lg",
      insetSmOnLg: "pf-m-inset-sm-on-lg",
      insetMdOnLg: "pf-m-inset-md-on-lg",
      insetLgOnLg: "pf-m-inset-lg-on-lg",
      insetXlOnLg: "pf-m-inset-xl-on-lg",
      inset_2xlOnLg: "pf-m-inset-2xl-on-lg",
      insetNoneOnXl: "pf-m-inset-none-on-xl",
      insetSmOnXl: "pf-m-inset-sm-on-xl",
      insetMdOnXl: "pf-m-inset-md-on-xl",
      insetLgOnXl: "pf-m-inset-lg-on-xl",
      insetXlOnXl: "pf-m-inset-xl-on-xl",
      inset_2xlOnXl: "pf-m-inset-2xl-on-xl",
      insetNoneOn_2xl: "pf-m-inset-none-on-2xl",
      insetSmOn_2xl: "pf-m-inset-sm-on-2xl",
      insetMdOn_2xl: "pf-m-inset-md-on-2xl",
      insetLgOn_2xl: "pf-m-inset-lg-on-2xl",
      insetXlOn_2xl: "pf-m-inset-xl-on-2xl",
      inset_2xlOn_2xl: "pf-m-inset-2xl-on-2xl"
    },
    tabs: "pf-c-tabs",
    tabsItem: "pf-c-tabs__item",
    tabsItemIcon: "pf-c-tabs__item-icon",
    tabsItemText: "pf-c-tabs__item-text",
    tabsLink: "pf-c-tabs__link",
    tabsList: "pf-c-tabs__list",
    tabsScrollButton: "pf-c-tabs__scroll-button",
    tabsToggle: "pf-c-tabs__toggle",
    tabsToggleButton: "pf-c-tabs__toggle-button",
    tabsToggleIcon: "pf-c-tabs__toggle-icon"
  };
});
var styles$t = /* @__PURE__ */ getDefaultExportFromCjs(tabs);
var TabButton = (_a) => {
  var {
    children: children2,
    tabContentRef,
    ouiaId,
    ouiaSafe
  } = _a, props = __rest(_a, ["children", "tabContentRef", "ouiaId", "ouiaSafe"]);
  const Component = props.href ? "a" : "button";
  return react.createElement(Component, Object.assign({}, getOUIAProps(TabButton.displayName, ouiaId, ouiaSafe), props), children2);
};
TabButton.displayName = "TabButton";
var tabContent = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    modifiers: {
      light_300: "pf-m-light-300",
      padding: "pf-m-padding"
    },
    tabContent: "pf-c-tab-content",
    tabContentBody: "pf-c-tab-content__body"
  };
});
var styles$u = /* @__PURE__ */ getDefaultExportFromCjs(tabContent);
var TabsContext = react.createContext({
  variant: "default"
});
var TabsContextProvider = TabsContext.Provider;
var TabsContextConsumer = TabsContext.Consumer;
var variantStyle$1 = {
  default: "",
  light300: styles$u.modifiers.light_300
};
var TabContentBase = (_a) => {
  var {id: id3, activeKey, "aria-label": ariaLabel, child, children: children2, className, eventKey, innerRef, ouiaId, ouiaSafe} = _a, props = __rest(_a, ["id", "activeKey", "aria-label", "child", "children", "className", "eventKey", "innerRef", "ouiaId", "ouiaSafe"]);
  if (children2 || child) {
    let labelledBy;
    if (ariaLabel) {
      labelledBy = null;
    } else {
      labelledBy = children2 ? `pf-tab-${eventKey}-${id3}` : `pf-tab-${child.props.eventKey}-${id3}`;
    }
    return react.createElement(TabsContextConsumer, null, ({variant}) => react.createElement("section", Object.assign({ref: innerRef, hidden: children2 ? null : child.props.eventKey !== activeKey, className: children2 ? css("pf-c-tab-content", className, variantStyle$1[variant]) : css("pf-c-tab-content", child.props.className, variantStyle$1[variant]), id: children2 ? id3 : `pf-tab-section-${child.props.eventKey}-${id3}`, "aria-label": ariaLabel, "aria-labelledby": labelledBy, role: "tabpanel", tabIndex: 0}, getOUIAProps("TabContent", ouiaId, ouiaSafe), props), children2 || child.props.children));
  }
  return null;
};
var TabContent = react.forwardRef((props, ref) => react.createElement(TabContentBase, Object.assign({}, props, {innerRef: ref})));
var TabsComponent;
(function(TabsComponent2) {
  TabsComponent2["div"] = "div";
  TabsComponent2["nav"] = "nav";
})(TabsComponent || (TabsComponent = {}));
var variantStyle$2 = {
  default: "",
  light300: styles$t.modifiers.colorSchemeLight_300
};
var Tabs = class extends react.Component {
  constructor(props) {
    super(props);
    this.tabList = react.createRef();
    this.handleScrollButtons = () => {
      const container = this.tabList.current;
      if (container && !this.props.isVertical) {
        const overflowOnLeft = !isElementInView(container, container.firstChild, false);
        const overflowOnRight = !isElementInView(container, container.lastChild, false);
        const showScrollButtons = overflowOnLeft || overflowOnRight;
        const disableLeftScrollButton = !overflowOnLeft;
        const disableRightScrollButton = !overflowOnRight;
        this.setState({
          showScrollButtons,
          disableLeftScrollButton,
          disableRightScrollButton
        });
      }
    };
    this.scrollLeft = () => {
      if (this.tabList.current) {
        const container = this.tabList.current;
        const childrenArr = Array.from(container.children);
        let firstElementInView;
        let lastElementOutOfView;
        let i3;
        for (i3 = 0; i3 < childrenArr.length && !firstElementInView; i3++) {
          if (isElementInView(container, childrenArr[i3], false)) {
            firstElementInView = childrenArr[i3];
            lastElementOutOfView = childrenArr[i3 - 1];
          }
        }
        if (lastElementOutOfView) {
          container.scrollLeft -= lastElementOutOfView.scrollWidth;
        }
      }
    };
    this.scrollRight = () => {
      if (this.tabList.current) {
        const container = this.tabList.current;
        const childrenArr = Array.from(container.children);
        let lastElementInView;
        let firstElementOutOfView;
        for (let i3 = childrenArr.length - 1; i3 >= 0 && !lastElementInView; i3--) {
          if (isElementInView(container, childrenArr[i3], false)) {
            lastElementInView = childrenArr[i3];
            firstElementOutOfView = childrenArr[i3 + 1];
          }
        }
        if (firstElementOutOfView) {
          container.scrollLeft += firstElementOutOfView.scrollWidth;
        }
      }
    };
    this.state = {
      showScrollButtons: false,
      disableLeftScrollButton: false,
      disableRightScrollButton: false,
      shownKeys: this.props.defaultActiveKey !== void 0 ? [this.props.defaultActiveKey] : [this.props.activeKey],
      uncontrolledActiveKey: this.props.defaultActiveKey,
      ouiaStateId: getDefaultOUIAId(Tabs.displayName)
    };
  }
  handleTabClick(event, eventKey, tabContentRef, mountOnEnter) {
    const {shownKeys} = this.state;
    const {onSelect, defaultActiveKey} = this.props;
    if (defaultActiveKey !== void 0) {
      this.setState({
        uncontrolledActiveKey: eventKey
      });
    } else {
      onSelect(event, eventKey);
    }
    if (tabContentRef) {
      react.Children.toArray(this.props.children).map((child) => child).filter((child) => child.props && child.props.tabContentRef && child.props.tabContentRef.current).forEach((child) => child.props.tabContentRef.current.hidden = true);
      if (tabContentRef.current) {
        tabContentRef.current.hidden = false;
      }
    }
    if (mountOnEnter) {
      this.setState({
        shownKeys: shownKeys.concat(eventKey)
      });
    }
  }
  componentDidMount() {
    if (!this.props.isVertical) {
      if (canUseDOM) {
        window.addEventListener("resize", this.handleScrollButtons, false);
      }
      this.handleScrollButtons();
    }
  }
  componentWillUnmount() {
    if (!this.props.isVertical) {
      if (canUseDOM) {
        window.removeEventListener("resize", this.handleScrollButtons, false);
      }
    }
  }
  componentDidUpdate(prevProps) {
    const {activeKey, mountOnEnter} = this.props;
    const {shownKeys} = this.state;
    if (prevProps.activeKey !== activeKey && mountOnEnter && shownKeys.indexOf(activeKey) < 0) {
      this.setState({
        shownKeys: shownKeys.concat(activeKey)
      });
    }
  }
  render() {
    const _a = this.props, {className, children: children2, activeKey, defaultActiveKey, id: id3, isFilled, isSecondary, isVertical, isBox, leftScrollAriaLabel, rightScrollAriaLabel, "aria-label": ariaLabel, component, ouiaId, ouiaSafe, mountOnEnter, unmountOnExit, usePageInsets, inset, variant} = _a, props = __rest(_a, ["className", "children", "activeKey", "defaultActiveKey", "id", "isFilled", "isSecondary", "isVertical", "isBox", "leftScrollAriaLabel", "rightScrollAriaLabel", "aria-label", "component", "ouiaId", "ouiaSafe", "mountOnEnter", "unmountOnExit", "usePageInsets", "inset", "variant"]);
    const {showScrollButtons, disableLeftScrollButton, disableRightScrollButton, shownKeys, uncontrolledActiveKey} = this.state;
    const filteredChildren = react.Children.toArray(children2).filter(Boolean).filter((child) => !child.props.isHidden);
    const uniqueId2 = id3 || getUniqueId();
    const Component = component === TabsComponent.nav ? "nav" : "div";
    const localActiveKey = defaultActiveKey !== void 0 ? uncontrolledActiveKey : activeKey;
    return react.createElement(TabsContextProvider, {value: {variant}}, react.createElement(Component, Object.assign({"aria-label": ariaLabel, className: css(styles$t.tabs, isFilled && styles$t.modifiers.fill, isSecondary && styles$t.modifiers.secondary, isVertical && styles$t.modifiers.vertical, isBox && styles$t.modifiers.box, showScrollButtons && !isVertical && styles$t.modifiers.scrollable, usePageInsets && styles$t.modifiers.pageInsets, formatBreakpointMods(inset, styles$t), variantStyle$2[variant], className)}, getOUIAProps(Tabs.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe), {id: id3 && id3}, props), react.createElement("button", {className: css(styles$t.tabsScrollButton, isSecondary && buttonStyles.modifiers.secondary), "aria-label": leftScrollAriaLabel, onClick: this.scrollLeft, disabled: disableLeftScrollButton, "aria-hidden": disableLeftScrollButton}, react.createElement(AngleLeftIcon, null)), react.createElement("ul", {className: css(styles$t.tabsList), ref: this.tabList, onScroll: this.handleScrollButtons}, filteredChildren.map((child, index3) => {
      const _a2 = child.props, {
        title: title3,
        eventKey,
        tabContentRef,
        id: childId,
        tabContentId,
        className: childClassName = "",
        ouiaId: childOuiaId,
        isHidden: isHidden3
      } = _a2, rest = __rest(_a2, ["title", "eventKey", "tabContentRef", "id", "tabContentId", "className", "ouiaId", "isHidden"]);
      let ariaControls = tabContentId ? `${tabContentId}` : `pf-tab-section-${eventKey}-${childId || uniqueId2}`;
      if ((mountOnEnter || unmountOnExit) && eventKey !== localActiveKey) {
        ariaControls = void 0;
      }
      return react.createElement("li", {key: index3, className: css(styles$t.tabsItem, eventKey === localActiveKey && styles$t.modifiers.current, childClassName)}, react.createElement(TabButton, Object.assign({className: css(styles$t.tabsLink), onClick: (event) => this.handleTabClick(event, eventKey, tabContentRef, mountOnEnter), id: `pf-tab-${eventKey}-${childId || uniqueId2}`, "aria-controls": ariaControls, tabContentRef, ouiaId: childOuiaId}, rest), title3));
    })), react.createElement("button", {className: css(styles$t.tabsScrollButton, isSecondary && buttonStyles.modifiers.secondary), "aria-label": rightScrollAriaLabel, onClick: this.scrollRight, disabled: disableRightScrollButton, "aria-hidden": disableRightScrollButton}, react.createElement(AngleRightIcon, null))), filteredChildren.filter((child) => child.props.children && !(unmountOnExit && child.props.eventKey !== localActiveKey) && !(mountOnEnter && shownKeys.indexOf(child.props.eventKey) === -1)).map((child, index3) => react.createElement(TabContent, {key: index3, activeKey: localActiveKey, child, id: child.props.id || uniqueId2, ouiaId: child.props.ouiaId})));
  }
};
Tabs.displayName = "Tabs";
Tabs.defaultProps = {
  activeKey: 0,
  onSelect: () => void 0,
  isFilled: false,
  isSecondary: false,
  isVertical: false,
  isBox: false,
  leftScrollAriaLabel: "Scroll left",
  rightScrollAriaLabel: "Scroll right",
  component: TabsComponent.div,
  mountOnEnter: false,
  unmountOnExit: false,
  ouiaSafe: true,
  variant: "default"
};
var TabTitleText = (_a) => {
  var {children: children2, className = ""} = _a, props = __rest(_a, ["children", "className"]);
  return react.createElement("span", Object.assign({className: css(styles$t.tabsItemText, className)}, props), children2);
};
TabTitleText.displayName = "TabTitleText";
var toggleGroup = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    modifiers: {
      compact: "pf-m-compact",
      selected: "pf-m-selected",
      disabled: "pf-m-disabled"
    },
    toggleGroup: "pf-c-toggle-group",
    toggleGroupButton: "pf-c-toggle-group__button",
    toggleGroupIcon: "pf-c-toggle-group__icon",
    toggleGroupItem: "pf-c-toggle-group__item",
    toggleGroupText: "pf-c-toggle-group__text"
  };
});
var styles$v = /* @__PURE__ */ getDefaultExportFromCjs(toggleGroup);
var ToggleGroup = (_a) => {
  var {className, children: children2, isCompact = false, "aria-label": ariaLabel} = _a, props = __rest(_a, ["className", "children", "isCompact", "aria-label"]);
  const toggleGroupItemList = [];
  react.Children.forEach(children2, (child) => {
    toggleGroupItemList.push(child);
  });
  return react.createElement("div", Object.assign({className: css(styles$v.toggleGroup, isCompact && styles$v.modifiers.compact, className), role: "group", "aria-label": ariaLabel}, props), toggleGroupItemList);
};
ToggleGroup.displayName = "ToggleGroup";
var ToggleGroupItemVariant;
(function(ToggleGroupItemVariant2) {
  ToggleGroupItemVariant2["icon"] = "icon";
  ToggleGroupItemVariant2["text"] = "text";
})(ToggleGroupItemVariant || (ToggleGroupItemVariant = {}));
var ToggleGroupItemElement = ({variant, children: children2}) => react.createElement("span", {className: css(variant === "icon" && styles$v.toggleGroupIcon, variant === "text" && styles$v.toggleGroupText)}, children2);
ToggleGroupItemElement.displayName = "ToggleGroupItemElement";
var ToggleGroupItem = (_a) => {
  var {text, icon, className, isDisabled = false, isSelected = false, "aria-label": ariaLabel = "", onChange = () => {
  }, buttonId = ""} = _a, props = __rest(_a, ["text", "icon", "className", "isDisabled", "isSelected", "aria-label", "onChange", "buttonId"]);
  const handleChange = (event) => {
    onChange(!isSelected, event);
  };
  if (!ariaLabel && icon && !text) {
    console.warn("An accessible aria-label is required when using the toggle group item icon variant.");
  }
  return react.createElement("div", Object.assign({className: css(styles$v.toggleGroupItem, className)}, props), react.createElement("button", Object.assign({type: "button", className: css(styles$v.toggleGroupButton, isSelected && styles$v.modifiers.selected), "aria-pressed": isSelected, onClick: handleChange}, ariaLabel && {"aria-label": ariaLabel}, isDisabled && {disabled: true}, buttonId && {id: buttonId}), icon ? react.createElement(ToggleGroupItemElement, {variant: ToggleGroupItemVariant.icon}, icon) : null, text ? react.createElement(ToggleGroupItemElement, {variant: ToggleGroupItemVariant.text}, text) : null));
};
ToggleGroupItem.displayName = "ToggleGroupItem";
var toolbar = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    button: "pf-c-button",
    chipGroup: "pf-c-chip-group",
    divider: "pf-c-divider",
    modifiers: {
      hidden: "pf-m-hidden",
      hiddenOnSm: "pf-m-hidden-on-sm",
      visibleOnSm: "pf-m-visible-on-sm",
      hiddenOnMd: "pf-m-hidden-on-md",
      visibleOnMd: "pf-m-visible-on-md",
      hiddenOnLg: "pf-m-hidden-on-lg",
      visibleOnLg: "pf-m-visible-on-lg",
      hiddenOnXl: "pf-m-hidden-on-xl",
      visibleOnXl: "pf-m-visible-on-xl",
      hiddenOn_2xl: "pf-m-hidden-on-2xl",
      visibleOn_2xl: "pf-m-visible-on-2xl",
      pageInsets: "pf-m-page-insets",
      stickyTop: "pf-m-sticky-top",
      vertical: "pf-m-vertical",
      buttonGroup: "pf-m-button-group",
      iconButtonGroup: "pf-m-icon-button-group",
      filterGroup: "pf-m-filter-group",
      toggleGroup: "pf-m-toggle-group",
      overflowMenu: "pf-m-overflow-menu",
      bulkSelect: "pf-m-bulk-select",
      expandAll: "pf-m-expand-all",
      expanded: "pf-m-expanded",
      searchFilter: "pf-m-search-filter",
      chipGroup: "pf-m-chip-group",
      label: "pf-m-label",
      pagination: "pf-m-pagination",
      chipContainer: "pf-m-chip-container",
      plain: "pf-m-plain",
      show: "pf-m-show",
      showOnSm: "pf-m-show-on-sm",
      showOnMd: "pf-m-show-on-md",
      showOnLg: "pf-m-show-on-lg",
      showOnXl: "pf-m-show-on-xl",
      showOn_2xl: "pf-m-show-on-2xl",
      alignRight: "pf-m-align-right",
      alignLeft: "pf-m-align-left",
      nowrap: "pf-m-nowrap",
      wrap: "pf-m-wrap",
      alignRightOnSm: "pf-m-align-right-on-sm",
      alignLeftOnSm: "pf-m-align-left-on-sm",
      nowrapOnSm: "pf-m-nowrap-on-sm",
      wrapOnSm: "pf-m-wrap-on-sm",
      alignRightOnMd: "pf-m-align-right-on-md",
      alignLeftOnMd: "pf-m-align-left-on-md",
      nowrapOnMd: "pf-m-nowrap-on-md",
      wrapOnMd: "pf-m-wrap-on-md",
      alignRightOnLg: "pf-m-align-right-on-lg",
      alignLeftOnLg: "pf-m-align-left-on-lg",
      nowrapOnLg: "pf-m-nowrap-on-lg",
      wrapOnLg: "pf-m-wrap-on-lg",
      alignRightOnXl: "pf-m-align-right-on-xl",
      alignLeftOnXl: "pf-m-align-left-on-xl",
      nowrapOnXl: "pf-m-nowrap-on-xl",
      wrapOnXl: "pf-m-wrap-on-xl",
      alignRightOn_2xl: "pf-m-align-right-on-2xl",
      alignLeftOn_2xl: "pf-m-align-left-on-2xl",
      nowrapOn_2xl: "pf-m-nowrap-on-2xl",
      wrapOn_2xl: "pf-m-wrap-on-2xl",
      spaceItemsNone: "pf-m-space-items-none",
      spaceItemsSm: "pf-m-space-items-sm",
      spaceItemsMd: "pf-m-space-items-md",
      spaceItemsLg: "pf-m-space-items-lg",
      spaceItemsNoneOnSm: "pf-m-space-items-none-on-sm",
      spaceItemsSmOnSm: "pf-m-space-items-sm-on-sm",
      spaceItemsMdOnSm: "pf-m-space-items-md-on-sm",
      spaceItemsLgOnSm: "pf-m-space-items-lg-on-sm",
      spaceItemsNoneOnMd: "pf-m-space-items-none-on-md",
      spaceItemsSmOnMd: "pf-m-space-items-sm-on-md",
      spaceItemsMdOnMd: "pf-m-space-items-md-on-md",
      spaceItemsLgOnMd: "pf-m-space-items-lg-on-md",
      spaceItemsNoneOnLg: "pf-m-space-items-none-on-lg",
      spaceItemsSmOnLg: "pf-m-space-items-sm-on-lg",
      spaceItemsMdOnLg: "pf-m-space-items-md-on-lg",
      spaceItemsLgOnLg: "pf-m-space-items-lg-on-lg",
      spaceItemsNoneOnXl: "pf-m-space-items-none-on-xl",
      spaceItemsSmOnXl: "pf-m-space-items-sm-on-xl",
      spaceItemsMdOnXl: "pf-m-space-items-md-on-xl",
      spaceItemsLgOnXl: "pf-m-space-items-lg-on-xl",
      spaceItemsNoneOn_2xl: "pf-m-space-items-none-on-2xl",
      spaceItemsSmOn_2xl: "pf-m-space-items-sm-on-2xl",
      spaceItemsMdOn_2xl: "pf-m-space-items-md-on-2xl",
      spaceItemsLgOn_2xl: "pf-m-space-items-lg-on-2xl",
      spacerNone: "pf-m-spacer-none",
      spacerSm: "pf-m-spacer-sm",
      spacerMd: "pf-m-spacer-md",
      spacerLg: "pf-m-spacer-lg",
      spacerNoneOnSm: "pf-m-spacer-none-on-sm",
      spacerSmOnSm: "pf-m-spacer-sm-on-sm",
      spacerMdOnSm: "pf-m-spacer-md-on-sm",
      spacerLgOnSm: "pf-m-spacer-lg-on-sm",
      spacerNoneOnMd: "pf-m-spacer-none-on-md",
      spacerSmOnMd: "pf-m-spacer-sm-on-md",
      spacerMdOnMd: "pf-m-spacer-md-on-md",
      spacerLgOnMd: "pf-m-spacer-lg-on-md",
      spacerNoneOnLg: "pf-m-spacer-none-on-lg",
      spacerSmOnLg: "pf-m-spacer-sm-on-lg",
      spacerMdOnLg: "pf-m-spacer-md-on-lg",
      spacerLgOnLg: "pf-m-spacer-lg-on-lg",
      spacerNoneOnXl: "pf-m-spacer-none-on-xl",
      spacerSmOnXl: "pf-m-spacer-sm-on-xl",
      spacerMdOnXl: "pf-m-spacer-md-on-xl",
      spacerLgOnXl: "pf-m-spacer-lg-on-xl",
      spacerNoneOn_2xl: "pf-m-spacer-none-on-2xl",
      spacerSmOn_2xl: "pf-m-spacer-sm-on-2xl",
      spacerMdOn_2xl: "pf-m-spacer-md-on-2xl",
      spacerLgOn_2xl: "pf-m-spacer-lg-on-2xl",
      insetNone: "pf-m-inset-none",
      insetSm: "pf-m-inset-sm",
      insetMd: "pf-m-inset-md",
      insetLg: "pf-m-inset-lg",
      insetXl: "pf-m-inset-xl",
      inset_2xl: "pf-m-inset-2xl",
      insetNoneOnSm: "pf-m-inset-none-on-sm",
      insetSmOnSm: "pf-m-inset-sm-on-sm",
      insetMdOnSm: "pf-m-inset-md-on-sm",
      insetLgOnSm: "pf-m-inset-lg-on-sm",
      insetXlOnSm: "pf-m-inset-xl-on-sm",
      inset_2xlOnSm: "pf-m-inset-2xl-on-sm",
      insetNoneOnMd: "pf-m-inset-none-on-md",
      insetSmOnMd: "pf-m-inset-sm-on-md",
      insetMdOnMd: "pf-m-inset-md-on-md",
      insetLgOnMd: "pf-m-inset-lg-on-md",
      insetXlOnMd: "pf-m-inset-xl-on-md",
      inset_2xlOnMd: "pf-m-inset-2xl-on-md",
      insetNoneOnLg: "pf-m-inset-none-on-lg",
      insetSmOnLg: "pf-m-inset-sm-on-lg",
      insetMdOnLg: "pf-m-inset-md-on-lg",
      insetLgOnLg: "pf-m-inset-lg-on-lg",
      insetXlOnLg: "pf-m-inset-xl-on-lg",
      inset_2xlOnLg: "pf-m-inset-2xl-on-lg",
      insetNoneOnXl: "pf-m-inset-none-on-xl",
      insetSmOnXl: "pf-m-inset-sm-on-xl",
      insetMdOnXl: "pf-m-inset-md-on-xl",
      insetLgOnXl: "pf-m-inset-lg-on-xl",
      insetXlOnXl: "pf-m-inset-xl-on-xl",
      inset_2xlOnXl: "pf-m-inset-2xl-on-xl",
      insetNoneOn_2xl: "pf-m-inset-none-on-2xl",
      insetSmOn_2xl: "pf-m-inset-sm-on-2xl",
      insetMdOn_2xl: "pf-m-inset-md-on-2xl",
      insetLgOn_2xl: "pf-m-inset-lg-on-2xl",
      insetXlOn_2xl: "pf-m-inset-xl-on-2xl",
      inset_2xlOn_2xl: "pf-m-inset-2xl-on-2xl"
    },
    pagination: "pf-c-pagination",
    toolbar: "pf-c-toolbar",
    toolbarContent: "pf-c-toolbar__content",
    toolbarContentSection: "pf-c-toolbar__content-section",
    toolbarExpandAllIcon: "pf-c-toolbar__expand-all-icon",
    toolbarExpandableContent: "pf-c-toolbar__expandable-content",
    toolbarGroup: "pf-c-toolbar__group",
    toolbarItem: "pf-c-toolbar__item",
    toolbarToggle: "pf-c-toolbar__toggle"
  };
});
var styles$w = /* @__PURE__ */ getDefaultExportFromCjs(toolbar);
var ToolbarContext = react.createContext({
  isExpanded: false,
  toggleIsExpanded: () => {
  },
  chipGroupContentRef: null,
  updateNumberFilters: () => {
  },
  numberOfFilters: 0,
  clearAllFilters: () => {
  }
});
var ToolbarContentContext = react.createContext({
  expandableContentRef: null,
  expandableContentId: "",
  chipContainerRef: null
});
var globalBreakpoints = {
  md: parseInt(global_breakpoint_md.value),
  lg: parseInt(global_breakpoint_lg.value),
  xl: parseInt(global_breakpoint_xl.value),
  "2xl": parseInt(global_breakpoint_2xl.value)
};
var ToolbarItemVariant;
(function(ToolbarItemVariant2) {
  ToolbarItemVariant2["separator"] = "separator";
  ToolbarItemVariant2["bulk-select"] = "bulk-select";
  ToolbarItemVariant2["overflow-menu"] = "overflow-menu";
  ToolbarItemVariant2["pagination"] = "pagination";
  ToolbarItemVariant2["search-filter"] = "search-filter";
  ToolbarItemVariant2["label"] = "label";
  ToolbarItemVariant2["chip-group"] = "chip-group";
  ToolbarItemVariant2["expand-all"] = "expand-all";
})(ToolbarItemVariant || (ToolbarItemVariant = {}));
var ToolbarItem = (_a) => {
  var {className, variant, visibility, visiblity, alignment, spacer, widths, id: id3, children: children2, isAllExpanded} = _a, props = __rest(_a, ["className", "variant", "visibility", "visiblity", "alignment", "spacer", "widths", "id", "children", "isAllExpanded"]);
  if (variant === ToolbarItemVariant.separator) {
    return react.createElement(Divider, Object.assign({className: css(styles$w.modifiers.vertical, className)}, props));
  }
  if (visiblity !== void 0) {
    console.warn("The ToolbarItem visiblity prop has been deprecated. Please use the correctly spelled visibility prop instead.");
  }
  const widthStyles = {};
  if (widths) {
    Object.entries(widths || {}).map(([breakpoint, value]) => widthStyles[`--pf-c-toolbar__item--Width${breakpoint !== "default" ? `-on-${breakpoint}` : ""}`] = value);
  }
  return react.createElement("div", Object.assign({className: css(styles$w.toolbarItem, variant && styles$w.modifiers[toCamel(variant)], isAllExpanded && styles$w.modifiers.expanded, formatBreakpointMods(visibility || visiblity, styles$w), formatBreakpointMods(alignment, styles$w), formatBreakpointMods(spacer, styles$w), className)}, variant === "label" && {"aria-hidden": true}, {id: id3}, props, widths && {style: Object.assign(Object.assign({}, widthStyles), props.style)}), children2);
};
ToolbarItem.displayName = "ToolbarItem";
var ToolbarGroupVariant;
(function(ToolbarGroupVariant2) {
  ToolbarGroupVariant2["filter-group"] = "filter-group";
  ToolbarGroupVariant2["icon-button-group"] = "icon-button-group";
  ToolbarGroupVariant2["button-group"] = "button-group";
})(ToolbarGroupVariant || (ToolbarGroupVariant = {}));
var ToolbarGroupWithRef = class extends react.Component {
  render() {
    const _a = this.props, {visibility, visiblity, alignment, spacer, spaceItems, className, variant, children: children2, innerRef} = _a, props = __rest(_a, ["visibility", "visiblity", "alignment", "spacer", "spaceItems", "className", "variant", "children", "innerRef"]);
    if (visiblity !== void 0) {
      console.warn("The ToolbarGroup visiblity prop has been deprecated. Please use the correctly spelled visibility prop instead.");
    }
    return react.createElement("div", Object.assign({className: css(styles$w.toolbarGroup, variant && styles$w.modifiers[toCamel(variant)], formatBreakpointMods(visibility || visiblity, styles$w), formatBreakpointMods(alignment, styles$w), formatBreakpointMods(spacer, styles$w), formatBreakpointMods(spaceItems, styles$w), className)}, props, {ref: innerRef}), children2);
  }
};
var ToolbarGroup = react.forwardRef((props, ref) => react.createElement(ToolbarGroupWithRef, Object.assign({}, props, {innerRef: ref})));
var ToolbarChipGroupContent = class extends react.Component {
  render() {
    const _a = this.props, {className, isExpanded, chipGroupContentRef, clearAllFilters, showClearFiltersButton, clearFiltersButtonText, collapseListedFiltersBreakpoint, numberOfFilters} = _a, props = __rest(_a, ["className", "isExpanded", "chipGroupContentRef", "clearAllFilters", "showClearFiltersButton", "clearFiltersButtonText", "collapseListedFiltersBreakpoint", "numberOfFilters"]);
    const clearChipGroups = () => {
      clearAllFilters();
    };
    let collapseListedFilters = false;
    if (collapseListedFiltersBreakpoint === "all") {
      collapseListedFilters = true;
    } else if (canUseDOM) {
      collapseListedFilters = (canUseDOM ? window.innerWidth : 1200) < globalBreakpoints[collapseListedFiltersBreakpoint];
    }
    return react.createElement("div", Object.assign({className: css(styles$w.toolbarContent, (numberOfFilters === 0 || isExpanded) && styles$w.modifiers.hidden, className)}, (numberOfFilters === 0 || isExpanded) && {hidden: true}, {ref: chipGroupContentRef}, props), react.createElement(ToolbarGroup, Object.assign({className: css(collapseListedFilters && styles$w.modifiers.hidden)}, collapseListedFilters && {hidden: true}, collapseListedFilters && {"aria-hidden": true})), collapseListedFilters && numberOfFilters > 0 && !isExpanded && react.createElement(ToolbarGroup, null, react.createElement(ToolbarItem, null, numberOfFilters, " filters applied")), showClearFiltersButton && !isExpanded && react.createElement(ToolbarItem, null, react.createElement(Button, {variant: "link", onClick: clearChipGroups, isInline: true}, clearFiltersButtonText)));
  }
};
ToolbarChipGroupContent.displayName = "ToolbarChipGroupContent";
ToolbarChipGroupContent.defaultProps = {
  clearFiltersButtonText: "Clear all filters",
  collapseListedFiltersBreakpoint: "lg"
};
var Toolbar = class extends react.Component {
  constructor() {
    super(...arguments);
    this.chipGroupContentRef = react.createRef();
    this.staticFilterInfo = {};
    this.state = {
      isManagedToggleExpanded: false,
      filterInfo: {},
      windowWidth: canUseDOM ? window.innerWidth : 1200,
      ouiaStateId: getDefaultOUIAId(Toolbar.displayName)
    };
    this.isToggleManaged = () => !(this.props.isExpanded || !!this.props.toggleIsExpanded);
    this.toggleIsExpanded = () => {
      this.setState((prevState) => ({
        isManagedToggleExpanded: !prevState.isManagedToggleExpanded
      }));
    };
    this.closeExpandableContent = (e3) => {
      if (e3.target.innerWidth !== this.state.windowWidth) {
        this.setState(() => ({
          isManagedToggleExpanded: false,
          windowWidth: e3.target.innerWidth
        }));
      }
    };
    this.updateNumberFilters = (categoryName, numberOfFilters) => {
      const filterInfoToUpdate = Object.assign({}, this.staticFilterInfo);
      if (!filterInfoToUpdate.hasOwnProperty(categoryName) || filterInfoToUpdate[categoryName] !== numberOfFilters) {
        filterInfoToUpdate[categoryName] = numberOfFilters;
        this.staticFilterInfo = filterInfoToUpdate;
        this.setState({filterInfo: filterInfoToUpdate});
      }
    };
    this.getNumberOfFilters = () => Object.values(this.state.filterInfo).reduce((acc, cur) => acc + cur, 0);
    this.renderToolbar = (randomId) => {
      const _a = this.props, {clearAllFilters, clearFiltersButtonText, collapseListedFiltersBreakpoint, isExpanded: isExpandedProp, toggleIsExpanded, className, children: children2, inset, usePageInsets, ouiaId} = _a, props = __rest(_a, ["clearAllFilters", "clearFiltersButtonText", "collapseListedFiltersBreakpoint", "isExpanded", "toggleIsExpanded", "className", "children", "inset", "usePageInsets", "ouiaId"]);
      const {isManagedToggleExpanded} = this.state;
      const isToggleManaged = this.isToggleManaged();
      const isExpanded = isToggleManaged ? isManagedToggleExpanded : isExpandedProp;
      const numberOfFilters = this.getNumberOfFilters();
      const showClearFiltersButton = numberOfFilters > 0;
      return react.createElement("div", Object.assign({className: css(styles$w.toolbar, usePageInsets && styles$w.modifiers.pageInsets, formatBreakpointMods(inset, styles$w), className), id: randomId}, getOUIAProps(Toolbar.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId), props), react.createElement(ToolbarContext.Provider, {value: {
        isExpanded,
        toggleIsExpanded: isToggleManaged ? this.toggleIsExpanded : toggleIsExpanded,
        chipGroupContentRef: this.chipGroupContentRef,
        updateNumberFilters: this.updateNumberFilters,
        numberOfFilters,
        clearAllFilters,
        clearFiltersButtonText,
        showClearFiltersButton,
        toolbarId: randomId
      }}, children2, react.createElement(ToolbarChipGroupContent, {isExpanded, chipGroupContentRef: this.chipGroupContentRef, clearAllFilters, showClearFiltersButton, clearFiltersButtonText, numberOfFilters, collapseListedFiltersBreakpoint})));
    };
  }
  componentDidMount() {
    if (this.isToggleManaged() && canUseDOM) {
      window.addEventListener("resize", this.closeExpandableContent);
    }
  }
  componentWillUnmount() {
    if (this.isToggleManaged() && canUseDOM) {
      window.removeEventListener("resize", this.closeExpandableContent);
    }
  }
  render() {
    return this.props.id ? this.renderToolbar(this.props.id) : react.createElement(GenerateId, null, (randomId) => this.renderToolbar(randomId));
  }
};
Toolbar.displayName = "Toolbar";
var ToolbarExpandableContent = class extends react.Component {
  render() {
    const _a = this.props, {
      className,
      expandableContentRef,
      chipContainerRef,
      isExpanded,
      clearAllFilters,
      clearFiltersButtonText,
      showClearFiltersButton
    } = _a, props = __rest(_a, ["className", "expandableContentRef", "chipContainerRef", "isExpanded", "clearAllFilters", "clearFiltersButtonText", "showClearFiltersButton"]);
    const {numberOfFilters} = this.context;
    const clearChipGroups = () => {
      clearAllFilters();
    };
    return react.createElement("div", Object.assign({className: css(styles$w.toolbarExpandableContent, className), ref: expandableContentRef}, props), react.createElement(ToolbarGroup, null), numberOfFilters > 0 && react.createElement(ToolbarGroup, {className: styles$w.modifiers.chipContainer}, react.createElement(ToolbarGroup, {ref: chipContainerRef}), showClearFiltersButton && react.createElement(ToolbarItem, null, react.createElement(Button, {variant: "link", onClick: clearChipGroups, isInline: true}, clearFiltersButtonText))));
  }
};
ToolbarExpandableContent.displayName = "ToolbarExpandableContent";
ToolbarExpandableContent.contextType = ToolbarContext;
ToolbarExpandableContent.defaultProps = {
  isExpanded: false,
  clearFiltersButtonText: "Clear all filters"
};
var ToolbarContent = class extends react.Component {
  constructor() {
    super(...arguments);
    this.expandableContentRef = react.createRef();
    this.chipContainerRef = react.createRef();
  }
  render() {
    const _a = this.props, {className, children: children2, isExpanded, toolbarId, visibility, visiblity, alignment, clearAllFilters, showClearFiltersButton, clearFiltersButtonText} = _a, props = __rest(_a, ["className", "children", "isExpanded", "toolbarId", "visibility", "visiblity", "alignment", "clearAllFilters", "showClearFiltersButton", "clearFiltersButtonText"]);
    if (visiblity !== void 0) {
      console.warn("The ToolbarContent visiblity prop has been deprecated. Please use the correctly spelled visibility prop instead.");
    }
    return react.createElement("div", Object.assign({className: css(styles$w.toolbarContent, formatBreakpointMods(visibility || visiblity, styles$w), formatBreakpointMods(alignment, styles$w), className)}, props), react.createElement(ToolbarContext.Consumer, null, ({clearAllFilters: clearAllFiltersContext, clearFiltersButtonText: clearFiltersButtonContext, showClearFiltersButton: showClearFiltersButtonContext, toolbarId: toolbarIdContext}) => {
      const expandableContentId = `${toolbarId || toolbarIdContext}-expandable-content-${ToolbarContent.currentId++}`;
      return react.createElement(ToolbarContentContext.Provider, {value: {
        expandableContentRef: this.expandableContentRef,
        expandableContentId,
        chipContainerRef: this.chipContainerRef
      }}, react.createElement("div", {className: css(styles$w.toolbarContentSection)}, children2), react.createElement(ToolbarExpandableContent, {id: expandableContentId, isExpanded, expandableContentRef: this.expandableContentRef, chipContainerRef: this.chipContainerRef, clearAllFilters: clearAllFilters || clearAllFiltersContext, showClearFiltersButton: showClearFiltersButton || showClearFiltersButtonContext, clearFiltersButtonText: clearFiltersButtonText || clearFiltersButtonContext}));
    }));
  }
};
ToolbarContent.displayName = "ToolbarContent";
ToolbarContent.currentId = 0;
ToolbarContent.defaultProps = {
  isExpanded: false,
  showClearFiltersButton: false
};
var numberInput = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    formControl: "pf-c-form-control",
    inputGroup: "pf-c-input-group",
    numberInput: "pf-c-number-input",
    numberInputIcon: "pf-c-number-input__icon",
    numberInputUnit: "pf-c-number-input__unit"
  };
});
var styles$x = /* @__PURE__ */ getDefaultExportFromCjs(numberInput);
var NumberInput = (_a) => {
  var {value = 0, className, widthChars, isDisabled = false, onMinus, onChange, onPlus, unit, unitPosition = "after", min: min2, max: max2, inputName, inputAriaLabel = "Input", minusBtnAriaLabel = "Minus", plusBtnAriaLabel = "Plus", inputProps, minusBtnProps, plusBtnProps} = _a, props = __rest(_a, ["value", "className", "widthChars", "isDisabled", "onMinus", "onChange", "onPlus", "unit", "unitPosition", "min", "max", "inputName", "inputAriaLabel", "minusBtnAriaLabel", "plusBtnAriaLabel", "inputProps", "minusBtnProps", "plusBtnProps"]);
  const numberInputUnit = react.createElement("div", {className: css(styles$x.numberInputUnit)}, unit);
  return react.createElement("div", Object.assign({className: css(styles$x.numberInput, className)}, widthChars && {
    style: Object.assign({"--pf-c-number-input--c-form-control--width-chars": widthChars}, props.style)
  }, props), unit && unitPosition === "before" && numberInputUnit, react.createElement("div", {className: css(styles$x.inputGroup)}, react.createElement(Button, Object.assign({variant: "control", "aria-label": minusBtnAriaLabel, isDisabled: isDisabled || value === min2, onClick: (evt) => onMinus(evt, inputName)}, minusBtnProps), react.createElement("span", {className: css(styles$x.numberInputIcon)}, react.createElement(MinusIcon, {"aria-hidden": "true"}))), react.createElement("input", Object.assign({className: css(styles$x.formControl), type: "number", value, name: inputName, "aria-label": inputAriaLabel}, isDisabled && {disabled: isDisabled}, onChange && {onChange}, !onChange && {readOnly: true}, inputProps)), react.createElement(Button, Object.assign({variant: "control", "aria-label": plusBtnAriaLabel, isDisabled: isDisabled || value === max2, onClick: (evt) => onPlus(evt, inputName)}, plusBtnProps), react.createElement("span", {className: css(styles$x.numberInputIcon)}, react.createElement(PlusIcon, {"aria-hidden": "true"})))), unit && unitPosition === "after" && numberInputUnit);
};
NumberInput.displayName = "NumberInput";
var wizard = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    button: "pf-c-button",
    card: "pf-c-card",
    modalBox: "pf-c-modal-box",
    modifiers: {
      finished: "pf-m-finished",
      expanded: "pf-m-expanded",
      current: "pf-m-current",
      expandable: "pf-m-expandable",
      disabled: "pf-m-disabled",
      noPadding: "pf-m-no-padding"
    },
    pageMainWizard: "pf-c-page__main-wizard",
    wizard: "pf-c-wizard",
    wizardClose: "pf-c-wizard__close",
    wizardDescription: "pf-c-wizard__description",
    wizardFooter: "pf-c-wizard__footer",
    wizardFooterCancel: "pf-c-wizard__footer-cancel",
    wizardHeader: "pf-c-wizard__header",
    wizardInnerWrap: "pf-c-wizard__inner-wrap",
    wizardMain: "pf-c-wizard__main",
    wizardMainBody: "pf-c-wizard__main-body",
    wizardNav: "pf-c-wizard__nav",
    wizardNavItem: "pf-c-wizard__nav-item",
    wizardNavLink: "pf-c-wizard__nav-link",
    wizardNavLinkText: "pf-c-wizard__nav-link-text",
    wizardNavLinkToggle: "pf-c-wizard__nav-link-toggle",
    wizardNavLinkToggleIcon: "pf-c-wizard__nav-link-toggle-icon",
    wizardNavList: "pf-c-wizard__nav-list",
    wizardOuterWrap: "pf-c-wizard__outer-wrap",
    wizardTitle: "pf-c-wizard__title",
    wizardToggle: "pf-c-wizard__toggle",
    wizardToggleIcon: "pf-c-wizard__toggle-icon",
    wizardToggleList: "pf-c-wizard__toggle-list",
    wizardToggleListItem: "pf-c-wizard__toggle-list-item",
    wizardToggleNum: "pf-c-wizard__toggle-num",
    wizardToggleSeparator: "pf-c-wizard__toggle-separator"
  };
});
var styles$y = /* @__PURE__ */ getDefaultExportFromCjs(wizard);
var WizardFooterInternal = ({onNext, onBack, onClose, isValid, firstStep, activeStep, nextButtonText, backButtonText, cancelButtonText}) => react.createElement("footer", {className: css(styles$y.wizardFooter)}, react.createElement(Button, {variant: ButtonVariant.primary, type: "submit", onClick: onNext, isDisabled: !isValid}, nextButtonText), !activeStep.hideBackButton && react.createElement(Button, {variant: ButtonVariant.secondary, onClick: onBack, isDisabled: firstStep}, backButtonText), !activeStep.hideCancelButton && react.createElement("div", {className: styles$y.wizardFooterCancel}, react.createElement(Button, {variant: ButtonVariant.link, onClick: onClose}, cancelButtonText)));
WizardFooterInternal.displayName = "WizardFooterInternal";
var WizardBody = ({children: children2, hasNoBodyPadding = false, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, mainComponent = "div"}) => {
  const MainComponent = mainComponent;
  return react.createElement(MainComponent, {"aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, className: css(styles$y.wizardMain)}, react.createElement("div", {className: css(styles$y.wizardMainBody, hasNoBodyPadding && styles$y.modifiers.noPadding)}, children2));
};
WizardBody.displayName = "WizardBody";
var WizardToggle = ({isNavOpen, onNavToggle, nav: nav2, steps, activeStep, children: children2, hasNoBodyPadding = false, "aria-label": ariaLabel = "Wizard Toggle", mainAriaLabelledBy = null, mainAriaLabel = null, isInPage = true}) => {
  let activeStepIndex;
  let activeStepName;
  let activeStepSubName;
  for (let i3 = 0; i3 < steps.length; i3++) {
    if (activeStep.id && steps[i3].id === activeStep.id || steps[i3].name === activeStep.name) {
      activeStepIndex = i3 + 1;
      activeStepName = steps[i3].name;
      break;
    } else if (steps[i3].steps) {
      for (const step of steps[i3].steps) {
        if (activeStep.id && step.id === activeStep.id || step.name === activeStep.name) {
          activeStepIndex = i3 + 1;
          activeStepName = steps[i3].name;
          activeStepSubName = step.name;
          break;
        }
      }
    }
  }
  return react.createElement(react.Fragment, null, react.createElement("button", {onClick: () => onNavToggle(!isNavOpen), className: css(styles$y.wizardToggle, isNavOpen && "pf-m-expanded"), "aria-label": ariaLabel, "aria-expanded": isNavOpen}, react.createElement("ol", {className: css(styles$y.wizardToggleList)}, react.createElement("li", {className: css(styles$y.wizardToggleListItem)}, react.createElement("span", {className: css(styles$y.wizardToggleNum)}, activeStepIndex), " ", activeStepName, activeStepSubName && react.createElement(AngleRightIcon, {className: css(styles$y.wizardToggleSeparator), "aria-hidden": "true"})), activeStepSubName && react.createElement("li", {className: css(styles$y.wizardToggleListItem)}, activeStepSubName)), react.createElement("span", {className: css(styles$y.wizardToggleIcon)}, react.createElement(CaretDownIcon, {"aria-hidden": "true"}))), react.createElement("div", {className: css(styles$y.wizardOuterWrap)}, react.createElement("div", {className: css(styles$y.wizardInnerWrap)}, nav2(isNavOpen), react.createElement(WizardBody, {mainComponent: isInPage ? "div" : "main", "aria-label": mainAriaLabel, "aria-labelledby": mainAriaLabelledBy, hasNoBodyPadding}, activeStep.component)), children2));
};
WizardToggle.displayName = "WizardToggle";
var WizardNav = ({children: children2, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, isOpen = false, returnList = false}) => {
  const innerList = react.createElement("ol", {className: css(styles$y.wizardNavList)}, children2);
  if (returnList) {
    return innerList;
  }
  return react.createElement("nav", {className: css(styles$y.wizardNav, isOpen && styles$y.modifiers.expanded), "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy}, react.createElement("ol", {className: css(styles$y.wizardNavList)}, children2));
};
WizardNav.displayName = "WizardNav";
var WizardNavItem = (_a) => {
  var {children: children2 = null, content: content2 = "", isCurrent = false, isDisabled = false, step, onNavItemClick = () => void 0, navItemComponent = "button", href = null, isExpandable = false} = _a, rest = __rest(_a, ["children", "content", "isCurrent", "isDisabled", "step", "onNavItemClick", "navItemComponent", "href", "isExpandable"]);
  const NavItemComponent = navItemComponent;
  const [isExpanded, setIsExpanded] = react.useState(false);
  react.useEffect(() => {
    setIsExpanded(isCurrent);
  }, [isCurrent]);
  if (navItemComponent === "a" && !href && false) {
    console.error("WizardNavItem: When using an anchor, please provide an href");
  }
  const btnProps = {
    disabled: isDisabled
  };
  const linkProps = {
    tabIndex: isDisabled ? -1 : void 0,
    href
  };
  return react.createElement("li", {className: css(styles$y.wizardNavItem, isExpandable && styles$y.modifiers.expandable, isExpandable && isExpanded && styles$y.modifiers.expanded)}, react.createElement(NavItemComponent, Object.assign({}, rest, navItemComponent === "a" ? Object.assign({}, linkProps) : Object.assign({}, btnProps), {onClick: () => isExpandable ? setIsExpanded(!isExpanded || isCurrent) : onNavItemClick(step), className: css(styles$y.wizardNavLink, isCurrent && styles$y.modifiers.current, isDisabled && styles$y.modifiers.disabled), "aria-disabled": isDisabled ? true : null, "aria-current": isCurrent && !children2 ? "page" : false}, isExpandable && {"aria-expanded": isExpanded}), isExpandable ? react.createElement(react.Fragment, null, react.createElement("span", {className: css(styles$y.wizardNavLinkText)}, content2), react.createElement("span", {className: css(styles$y.wizardNavLinkToggle)}, react.createElement("span", {className: css(styles$y.wizardNavLinkToggleIcon)}, react.createElement(AngleRightIcon, null)))) : content2), children2);
};
WizardNavItem.displayName = "WizardNavItem";
var WizardContext = react.createContext({
  goToStepById: () => null,
  goToStepByName: () => null,
  onNext: () => null,
  onBack: () => null,
  onClose: () => null,
  activeStep: {name: null}
});
var WizardContextProvider = WizardContext.Provider;
var WizardContextConsumer = WizardContext.Consumer;
var WizardHeader = ({onClose = () => void 0, title: title3, description, hideClose, closeButtonAriaLabel, titleId, descriptionId}) => react.createElement("div", {className: css(styles$y.wizardHeader)}, !hideClose && react.createElement(Button, {variant: "plain", className: css(styles$y.wizardClose), "aria-label": closeButtonAriaLabel, onClick: onClose}, react.createElement(TimesIcon, {"aria-hidden": "true"})), react.createElement(Title, {headingLevel: "h2", size: "3xl", className: css(styles$y.wizardTitle), "aria-label": title3, id: titleId}, title3 || react.createElement(react.Fragment, null, "")), description && react.createElement("p", {className: css(styles$y.wizardDescription), id: descriptionId}, description));
WizardHeader.displayName = "WizardHeader";
var Wizard = class extends react.Component {
  constructor(props) {
    super(props);
    this.handleKeyClicks = (event) => {
      if (event.keyCode === KEY_CODES.ESCAPE_KEY) {
        if (this.state.isNavOpen) {
          this.setState({isNavOpen: !this.state.isNavOpen});
        } else if (this.props.isOpen) {
          this.props.onClose();
        }
      }
    };
    this.onNext = () => {
      const {onNext, onClose, onSave} = this.props;
      const {currentStep} = this.state;
      const flattenedSteps = this.getFlattenedSteps();
      const maxSteps = flattenedSteps.length;
      if (currentStep >= maxSteps) {
        if (onSave) {
          return onSave();
        }
        return onClose();
      } else {
        const newStep = currentStep + 1;
        this.setState({
          currentStep: newStep
        });
        const {id: prevId, name: prevName} = flattenedSteps[currentStep - 1];
        const {id: id3, name} = flattenedSteps[newStep - 1];
        return onNext && onNext({id: id3, name}, {prevId, prevName});
      }
    };
    this.onBack = () => {
      const {onBack} = this.props;
      const {currentStep} = this.state;
      const flattenedSteps = this.getFlattenedSteps();
      if (flattenedSteps.length < currentStep) {
        const adjustedStep = flattenedSteps.length;
        this.setState({
          currentStep: adjustedStep
        });
      } else {
        const newStep = currentStep - 1 <= 0 ? 0 : currentStep - 1;
        this.setState({
          currentStep: newStep
        });
        const {id: prevId, name: prevName} = flattenedSteps[newStep];
        const {id: id3, name} = flattenedSteps[newStep - 1];
        return onBack && onBack({id: id3, name}, {prevId, prevName});
      }
    };
    this.goToStep = (step) => {
      const {onGoToStep} = this.props;
      const {currentStep} = this.state;
      const flattenedSteps = this.getFlattenedSteps();
      const maxSteps = flattenedSteps.length;
      if (step < 1) {
        step = 1;
      } else if (step > maxSteps) {
        step = maxSteps;
      }
      this.setState({currentStep: step, isNavOpen: false});
      const {id: prevId, name: prevName} = flattenedSteps[currentStep - 1];
      const {id: id3, name} = flattenedSteps[step - 1];
      return onGoToStep && onGoToStep({id: id3, name}, {prevId, prevName});
    };
    this.goToStepById = (stepId) => {
      const flattenedSteps = this.getFlattenedSteps();
      let step;
      for (let i3 = 0; i3 < flattenedSteps.length; i3++) {
        if (flattenedSteps[i3].id === stepId) {
          step = i3 + 1;
          break;
        }
      }
      if (step) {
        this.setState({currentStep: step});
      }
    };
    this.goToStepByName = (stepName) => {
      const flattenedSteps = this.getFlattenedSteps();
      let step;
      for (let i3 = 0; i3 < flattenedSteps.length; i3++) {
        if (flattenedSteps[i3].name === stepName) {
          step = i3 + 1;
          break;
        }
      }
      if (step) {
        this.setState({currentStep: step});
      }
    };
    this.getFlattenedSteps = () => {
      const {steps} = this.props;
      const flattenedSteps = [];
      for (const step of steps) {
        if (step.steps) {
          for (const childStep of step.steps) {
            flattenedSteps.push(childStep);
          }
        } else {
          flattenedSteps.push(step);
        }
      }
      return flattenedSteps;
    };
    this.getFlattenedStepsIndex = (flattenedSteps, stepName) => {
      for (let i3 = 0; i3 < flattenedSteps.length; i3++) {
        if (flattenedSteps[i3].name === stepName) {
          return i3 + 1;
        }
      }
      return 0;
    };
    this.initSteps = (steps) => {
      for (let i3 = 0; i3 < steps.length; i3++) {
        if (steps[i3].steps) {
          for (let j = 0; j < steps[i3].steps.length; j++) {
            steps[i3].steps[j] = Object.assign({canJumpTo: true}, steps[i3].steps[j]);
          }
        }
        steps[i3] = Object.assign({canJumpTo: true}, steps[i3]);
      }
      return steps;
    };
    this.getElement = (appendTo) => {
      if (typeof appendTo === "function") {
        return appendTo();
      }
      return appendTo || document.body;
    };
    const newId3 = Wizard.currentId++;
    this.titleId = props.titleId || `pf-wizard-title-${newId3}`;
    this.descriptionId = props.descriptionId || `pf-wizard-description-${newId3}`;
    this.state = {
      currentStep: this.props.startAtStep && Number.isInteger(this.props.startAtStep) ? this.props.startAtStep : 1,
      isNavOpen: false
    };
  }
  componentDidMount() {
    const target = typeof document !== "undefined" ? document.body : null;
    if (target) {
      target.addEventListener("keydown", this.handleKeyClicks, false);
    }
  }
  componentWillUnmount() {
    const target = typeof document !== "undefined" && document.body || null;
    if (target) {
      target.removeEventListener("keydown", this.handleKeyClicks, false);
    }
  }
  render() {
    const _a = this.props, {
      width: width2,
      height,
      title: title3,
      description,
      onClose,
      onSave,
      onBack,
      onNext,
      onGoToStep,
      className,
      steps,
      startAtStep,
      nextButtonText = "Next",
      backButtonText = "Back",
      cancelButtonText = "Cancel",
      hideClose,
      closeButtonAriaLabel = "Close",
      navAriaLabel,
      navAriaLabelledBy,
      mainAriaLabel,
      mainAriaLabelledBy,
      hasNoBodyPadding,
      footer,
      appendTo,
      isOpen,
      titleId,
      descriptionId,
      isNavExpandable
    } = _a, rest = __rest(_a, ["width", "height", "title", "description", "onClose", "onSave", "onBack", "onNext", "onGoToStep", "className", "steps", "startAtStep", "nextButtonText", "backButtonText", "cancelButtonText", "hideClose", "closeButtonAriaLabel", "navAriaLabel", "navAriaLabelledBy", "mainAriaLabel", "mainAriaLabelledBy", "hasNoBodyPadding", "footer", "appendTo", "isOpen", "titleId", "descriptionId", "isNavExpandable"]);
    const {currentStep} = this.state;
    const flattenedSteps = this.getFlattenedSteps();
    const adjustedStep = flattenedSteps.length < currentStep ? flattenedSteps.length : currentStep;
    const activeStep = flattenedSteps[adjustedStep - 1];
    const computedSteps = this.initSteps(steps);
    const firstStep = activeStep === flattenedSteps[0];
    const isValid = activeStep && activeStep.enableNext !== void 0 ? activeStep.enableNext : true;
    const nav2 = (isWizardNavOpen) => {
      const wizNavAProps = {
        isOpen: isWizardNavOpen,
        "aria-label": navAriaLabel,
        "aria-labelledby": (title3 || navAriaLabelledBy) && (navAriaLabelledBy || this.titleId)
      };
      return react.createElement(WizardNav, Object.assign({}, wizNavAProps), computedSteps.map((step, index3) => {
        if (step.isFinishedStep) {
          return;
        }
        let enabled;
        let navItemStep;
        if (step.steps) {
          let hasActiveChild = false;
          let canJumpToParent = false;
          for (const subStep of step.steps) {
            if (activeStep.name === subStep.name) {
              hasActiveChild = true;
            }
            if (subStep.canJumpTo) {
              canJumpToParent = true;
            }
          }
          navItemStep = this.getFlattenedStepsIndex(flattenedSteps, step.steps[0].name);
          return react.createElement(WizardNavItem, {key: index3, content: step.name, isExpandable: isNavExpandable, isCurrent: hasActiveChild, isDisabled: !canJumpToParent, step: navItemStep, onNavItemClick: this.goToStep}, react.createElement(WizardNav, Object.assign({}, wizNavAProps, {returnList: true}), step.steps.map((childStep, indexChild) => {
            if (childStep.isFinishedStep) {
              return;
            }
            navItemStep = this.getFlattenedStepsIndex(flattenedSteps, childStep.name);
            enabled = childStep.canJumpTo;
            return react.createElement(WizardNavItem, {key: `child_${indexChild}`, content: childStep.name, isCurrent: activeStep.name === childStep.name, isDisabled: !enabled, step: navItemStep, onNavItemClick: this.goToStep});
          })));
        }
        navItemStep = this.getFlattenedStepsIndex(flattenedSteps, step.name);
        enabled = step.canJumpTo;
        return react.createElement(WizardNavItem, Object.assign({}, step.stepNavItemProps, {key: index3, content: step.name, isCurrent: activeStep.name === step.name, isDisabled: !enabled, step: navItemStep, onNavItemClick: this.goToStep}));
      }));
    };
    const context2 = {
      goToStepById: this.goToStepById,
      goToStepByName: this.goToStepByName,
      onNext: this.onNext,
      onBack: this.onBack,
      onClose,
      activeStep
    };
    const divStyles = Object.assign(Object.assign({}, height ? {height} : {}), width2 ? {width: width2} : {});
    const wizard2 = react.createElement(WizardContextProvider, {value: context2}, react.createElement("div", Object.assign({}, rest, {className: css(styles$y.wizard, activeStep && activeStep.isFinishedStep && "pf-m-finished", className), style: Object.keys(divStyles).length ? divStyles : void 0}), title3 && react.createElement(WizardHeader, {titleId: this.titleId, descriptionId: this.descriptionId, onClose, title: title3, description, closeButtonAriaLabel, hideClose}), react.createElement(WizardToggle, {mainAriaLabel, isInPage: isOpen === void 0, mainAriaLabelledBy: (title3 || mainAriaLabelledBy) && (mainAriaLabelledBy || this.titleId), isNavOpen: this.state.isNavOpen, onNavToggle: (isNavOpen) => this.setState({isNavOpen}), nav: nav2, steps, activeStep, hasNoBodyPadding}, footer || react.createElement(WizardFooterInternal, {onNext: this.onNext, onBack: this.onBack, onClose, isValid, firstStep, activeStep, nextButtonText: activeStep && activeStep.nextButtonText || nextButtonText, backButtonText, cancelButtonText}))));
    if (isOpen !== void 0) {
      return react.createElement(Modal, {width: width2 !== null ? width2 : void 0, isOpen, variant: ModalVariant.large, "aria-labelledby": this.titleId, "aria-describedby": this.descriptionId, showClose: false, hasNoBodyWrapper: true}, wizard2);
    }
    return wizard2;
  }
};
Wizard.displayName = "Wizard";
Wizard.currentId = 0;
Wizard.defaultProps = {
  title: null,
  description: "",
  className: "",
  startAtStep: 1,
  nextButtonText: "Next",
  backButtonText: "Back",
  cancelButtonText: "Cancel",
  hideClose: false,
  closeButtonAriaLabel: "Close",
  navAriaLabel: null,
  navAriaLabelledBy: null,
  mainAriaLabel: null,
  mainAriaLabelledBy: null,
  hasNoBodyPadding: false,
  onBack: null,
  onNext: null,
  onGoToStep: null,
  width: null,
  height: null,
  footer: null,
  onClose: () => void 0,
  appendTo: null,
  isOpen: void 0,
  isNavExpandable: false
};
var WizardFooter = ({children: children2}) => react.createElement("footer", {className: css(styles$y.wizardFooter)}, children2);
WizardFooter.displayName = "WizardFooter";
var flex = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    flex: "pf-l-flex",
    modifiers: {
      flex: "pf-m-flex",
      inlineFlex: "pf-m-inline-flex",
      column: "pf-m-column",
      columnReverse: "pf-m-column-reverse",
      row: "pf-m-row",
      rowReverse: "pf-m-row-reverse",
      wrap: "pf-m-wrap",
      wrapReverse: "pf-m-wrap-reverse",
      nowrap: "pf-m-nowrap",
      justifyContentFlexStart: "pf-m-justify-content-flex-start",
      justifyContentFlexEnd: "pf-m-justify-content-flex-end",
      justifyContentCenter: "pf-m-justify-content-center",
      justifyContentSpaceBetween: "pf-m-justify-content-space-between",
      justifyContentSpaceAround: "pf-m-justify-content-space-around",
      justifyContentSpaceEvenly: "pf-m-justify-content-space-evenly",
      alignItemsFlexStart: "pf-m-align-items-flex-start",
      alignItemsFlexEnd: "pf-m-align-items-flex-end",
      alignItemsCenter: "pf-m-align-items-center",
      alignItemsStretch: "pf-m-align-items-stretch",
      alignItemsBaseline: "pf-m-align-items-baseline",
      alignContentFlexStart: "pf-m-align-content-flex-start",
      alignContentFlexEnd: "pf-m-align-content-flex-end",
      alignContentCenter: "pf-m-align-content-center",
      alignContentStretch: "pf-m-align-content-stretch",
      alignContentSpaceBetween: "pf-m-align-content-space-between",
      alignContentSpaceAround: "pf-m-align-content-space-around",
      alignRight: "pf-m-align-right",
      alignLeft: "pf-m-align-left",
      grow: "pf-m-grow",
      shrink: "pf-m-shrink",
      fullWidth: "pf-m-full-width",
      flex_1: "pf-m-flex-1",
      flex_2: "pf-m-flex-2",
      flex_3: "pf-m-flex-3",
      flex_4: "pf-m-flex-4",
      flexDefault: "pf-m-flex-default",
      flexNone: "pf-m-flex-none",
      alignSelfFlexStart: "pf-m-align-self-flex-start",
      alignSelfFlexEnd: "pf-m-align-self-flex-end",
      alignSelfCenter: "pf-m-align-self-center",
      alignSelfBaseline: "pf-m-align-self-baseline",
      alignSelfStretch: "pf-m-align-self-stretch",
      flexOnSm: "pf-m-flex-on-sm",
      inlineFlexOnSm: "pf-m-inline-flex-on-sm",
      columnOnSm: "pf-m-column-on-sm",
      columnReverseOnSm: "pf-m-column-reverse-on-sm",
      rowOnSm: "pf-m-row-on-sm",
      rowReverseOnSm: "pf-m-row-reverse-on-sm",
      wrapOnSm: "pf-m-wrap-on-sm",
      wrapReverseOnSm: "pf-m-wrap-reverse-on-sm",
      nowrapOnSm: "pf-m-nowrap-on-sm",
      justifyContentFlexStartOnSm: "pf-m-justify-content-flex-start-on-sm",
      justifyContentFlexEndOnSm: "pf-m-justify-content-flex-end-on-sm",
      justifyContentCenterOnSm: "pf-m-justify-content-center-on-sm",
      justifyContentSpaceBetweenOnSm: "pf-m-justify-content-space-between-on-sm",
      justifyContentSpaceAroundOnSm: "pf-m-justify-content-space-around-on-sm",
      justifyContentSpaceEvenlyOnSm: "pf-m-justify-content-space-evenly-on-sm",
      alignItemsFlexStartOnSm: "pf-m-align-items-flex-start-on-sm",
      alignItemsFlexEndOnSm: "pf-m-align-items-flex-end-on-sm",
      alignItemsCenterOnSm: "pf-m-align-items-center-on-sm",
      alignItemsStretchOnSm: "pf-m-align-items-stretch-on-sm",
      alignItemsBaselineOnSm: "pf-m-align-items-baseline-on-sm",
      alignContentFlexStartOnSm: "pf-m-align-content-flex-start-on-sm",
      alignContentFlexEndOnSm: "pf-m-align-content-flex-end-on-sm",
      alignContentCenterOnSm: "pf-m-align-content-center-on-sm",
      alignContentStretchOnSm: "pf-m-align-content-stretch-on-sm",
      alignContentSpaceBetweenOnSm: "pf-m-align-content-space-between-on-sm",
      alignContentSpaceAroundOnSm: "pf-m-align-content-space-around-on-sm",
      alignRightOnSm: "pf-m-align-right-on-sm",
      alignLeftOnSm: "pf-m-align-left-on-sm",
      growOnSm: "pf-m-grow-on-sm",
      shrinkOnSm: "pf-m-shrink-on-sm",
      fullWidthOnSm: "pf-m-full-width-on-sm",
      flex_1OnSm: "pf-m-flex-1-on-sm",
      flex_2OnSm: "pf-m-flex-2-on-sm",
      flex_3OnSm: "pf-m-flex-3-on-sm",
      flex_4OnSm: "pf-m-flex-4-on-sm",
      flexDefaultOnSm: "pf-m-flex-default-on-sm",
      flexNoneOnSm: "pf-m-flex-none-on-sm",
      alignSelfFlexStartOnSm: "pf-m-align-self-flex-start-on-sm",
      alignSelfFlexEndOnSm: "pf-m-align-self-flex-end-on-sm",
      alignSelfCenterOnSm: "pf-m-align-self-center-on-sm",
      alignSelfBaselineOnSm: "pf-m-align-self-baseline-on-sm",
      alignSelfStretchOnSm: "pf-m-align-self-stretch-on-sm",
      flexOnMd: "pf-m-flex-on-md",
      inlineFlexOnMd: "pf-m-inline-flex-on-md",
      columnOnMd: "pf-m-column-on-md",
      columnReverseOnMd: "pf-m-column-reverse-on-md",
      rowOnMd: "pf-m-row-on-md",
      rowReverseOnMd: "pf-m-row-reverse-on-md",
      wrapOnMd: "pf-m-wrap-on-md",
      wrapReverseOnMd: "pf-m-wrap-reverse-on-md",
      nowrapOnMd: "pf-m-nowrap-on-md",
      justifyContentFlexStartOnMd: "pf-m-justify-content-flex-start-on-md",
      justifyContentFlexEndOnMd: "pf-m-justify-content-flex-end-on-md",
      justifyContentCenterOnMd: "pf-m-justify-content-center-on-md",
      justifyContentSpaceBetweenOnMd: "pf-m-justify-content-space-between-on-md",
      justifyContentSpaceAroundOnMd: "pf-m-justify-content-space-around-on-md",
      justifyContentSpaceEvenlyOnMd: "pf-m-justify-content-space-evenly-on-md",
      alignItemsFlexStartOnMd: "pf-m-align-items-flex-start-on-md",
      alignItemsFlexEndOnMd: "pf-m-align-items-flex-end-on-md",
      alignItemsCenterOnMd: "pf-m-align-items-center-on-md",
      alignItemsStretchOnMd: "pf-m-align-items-stretch-on-md",
      alignItemsBaselineOnMd: "pf-m-align-items-baseline-on-md",
      alignContentFlexStartOnMd: "pf-m-align-content-flex-start-on-md",
      alignContentFlexEndOnMd: "pf-m-align-content-flex-end-on-md",
      alignContentCenterOnMd: "pf-m-align-content-center-on-md",
      alignContentStretchOnMd: "pf-m-align-content-stretch-on-md",
      alignContentSpaceBetweenOnMd: "pf-m-align-content-space-between-on-md",
      alignContentSpaceAroundOnMd: "pf-m-align-content-space-around-on-md",
      alignRightOnMd: "pf-m-align-right-on-md",
      alignLeftOnMd: "pf-m-align-left-on-md",
      growOnMd: "pf-m-grow-on-md",
      shrinkOnMd: "pf-m-shrink-on-md",
      fullWidthOnMd: "pf-m-full-width-on-md",
      flex_1OnMd: "pf-m-flex-1-on-md",
      flex_2OnMd: "pf-m-flex-2-on-md",
      flex_3OnMd: "pf-m-flex-3-on-md",
      flex_4OnMd: "pf-m-flex-4-on-md",
      flexDefaultOnMd: "pf-m-flex-default-on-md",
      flexNoneOnMd: "pf-m-flex-none-on-md",
      alignSelfFlexStartOnMd: "pf-m-align-self-flex-start-on-md",
      alignSelfFlexEndOnMd: "pf-m-align-self-flex-end-on-md",
      alignSelfCenterOnMd: "pf-m-align-self-center-on-md",
      alignSelfBaselineOnMd: "pf-m-align-self-baseline-on-md",
      alignSelfStretchOnMd: "pf-m-align-self-stretch-on-md",
      flexOnLg: "pf-m-flex-on-lg",
      inlineFlexOnLg: "pf-m-inline-flex-on-lg",
      columnOnLg: "pf-m-column-on-lg",
      columnReverseOnLg: "pf-m-column-reverse-on-lg",
      rowOnLg: "pf-m-row-on-lg",
      rowReverseOnLg: "pf-m-row-reverse-on-lg",
      wrapOnLg: "pf-m-wrap-on-lg",
      wrapReverseOnLg: "pf-m-wrap-reverse-on-lg",
      nowrapOnLg: "pf-m-nowrap-on-lg",
      justifyContentFlexStartOnLg: "pf-m-justify-content-flex-start-on-lg",
      justifyContentFlexEndOnLg: "pf-m-justify-content-flex-end-on-lg",
      justifyContentCenterOnLg: "pf-m-justify-content-center-on-lg",
      justifyContentSpaceBetweenOnLg: "pf-m-justify-content-space-between-on-lg",
      justifyContentSpaceAroundOnLg: "pf-m-justify-content-space-around-on-lg",
      justifyContentSpaceEvenlyOnLg: "pf-m-justify-content-space-evenly-on-lg",
      alignItemsFlexStartOnLg: "pf-m-align-items-flex-start-on-lg",
      alignItemsFlexEndOnLg: "pf-m-align-items-flex-end-on-lg",
      alignItemsCenterOnLg: "pf-m-align-items-center-on-lg",
      alignItemsStretchOnLg: "pf-m-align-items-stretch-on-lg",
      alignItemsBaselineOnLg: "pf-m-align-items-baseline-on-lg",
      alignContentFlexStartOnLg: "pf-m-align-content-flex-start-on-lg",
      alignContentFlexEndOnLg: "pf-m-align-content-flex-end-on-lg",
      alignContentCenterOnLg: "pf-m-align-content-center-on-lg",
      alignContentStretchOnLg: "pf-m-align-content-stretch-on-lg",
      alignContentSpaceBetweenOnLg: "pf-m-align-content-space-between-on-lg",
      alignContentSpaceAroundOnLg: "pf-m-align-content-space-around-on-lg",
      alignRightOnLg: "pf-m-align-right-on-lg",
      alignLeftOnLg: "pf-m-align-left-on-lg",
      growOnLg: "pf-m-grow-on-lg",
      shrinkOnLg: "pf-m-shrink-on-lg",
      fullWidthOnLg: "pf-m-full-width-on-lg",
      flex_1OnLg: "pf-m-flex-1-on-lg",
      flex_2OnLg: "pf-m-flex-2-on-lg",
      flex_3OnLg: "pf-m-flex-3-on-lg",
      flex_4OnLg: "pf-m-flex-4-on-lg",
      flexDefaultOnLg: "pf-m-flex-default-on-lg",
      flexNoneOnLg: "pf-m-flex-none-on-lg",
      alignSelfFlexStartOnLg: "pf-m-align-self-flex-start-on-lg",
      alignSelfFlexEndOnLg: "pf-m-align-self-flex-end-on-lg",
      alignSelfCenterOnLg: "pf-m-align-self-center-on-lg",
      alignSelfBaselineOnLg: "pf-m-align-self-baseline-on-lg",
      alignSelfStretchOnLg: "pf-m-align-self-stretch-on-lg",
      flexOnXl: "pf-m-flex-on-xl",
      inlineFlexOnXl: "pf-m-inline-flex-on-xl",
      columnOnXl: "pf-m-column-on-xl",
      columnReverseOnXl: "pf-m-column-reverse-on-xl",
      rowOnXl: "pf-m-row-on-xl",
      rowReverseOnXl: "pf-m-row-reverse-on-xl",
      wrapOnXl: "pf-m-wrap-on-xl",
      wrapReverseOnXl: "pf-m-wrap-reverse-on-xl",
      nowrapOnXl: "pf-m-nowrap-on-xl",
      justifyContentFlexStartOnXl: "pf-m-justify-content-flex-start-on-xl",
      justifyContentFlexEndOnXl: "pf-m-justify-content-flex-end-on-xl",
      justifyContentCenterOnXl: "pf-m-justify-content-center-on-xl",
      justifyContentSpaceBetweenOnXl: "pf-m-justify-content-space-between-on-xl",
      justifyContentSpaceAroundOnXl: "pf-m-justify-content-space-around-on-xl",
      justifyContentSpaceEvenlyOnXl: "pf-m-justify-content-space-evenly-on-xl",
      alignItemsFlexStartOnXl: "pf-m-align-items-flex-start-on-xl",
      alignItemsFlexEndOnXl: "pf-m-align-items-flex-end-on-xl",
      alignItemsCenterOnXl: "pf-m-align-items-center-on-xl",
      alignItemsStretchOnXl: "pf-m-align-items-stretch-on-xl",
      alignItemsBaselineOnXl: "pf-m-align-items-baseline-on-xl",
      alignContentFlexStartOnXl: "pf-m-align-content-flex-start-on-xl",
      alignContentFlexEndOnXl: "pf-m-align-content-flex-end-on-xl",
      alignContentCenterOnXl: "pf-m-align-content-center-on-xl",
      alignContentStretchOnXl: "pf-m-align-content-stretch-on-xl",
      alignContentSpaceBetweenOnXl: "pf-m-align-content-space-between-on-xl",
      alignContentSpaceAroundOnXl: "pf-m-align-content-space-around-on-xl",
      alignRightOnXl: "pf-m-align-right-on-xl",
      alignLeftOnXl: "pf-m-align-left-on-xl",
      growOnXl: "pf-m-grow-on-xl",
      shrinkOnXl: "pf-m-shrink-on-xl",
      fullWidthOnXl: "pf-m-full-width-on-xl",
      flex_1OnXl: "pf-m-flex-1-on-xl",
      flex_2OnXl: "pf-m-flex-2-on-xl",
      flex_3OnXl: "pf-m-flex-3-on-xl",
      flex_4OnXl: "pf-m-flex-4-on-xl",
      flexDefaultOnXl: "pf-m-flex-default-on-xl",
      flexNoneOnXl: "pf-m-flex-none-on-xl",
      alignSelfFlexStartOnXl: "pf-m-align-self-flex-start-on-xl",
      alignSelfFlexEndOnXl: "pf-m-align-self-flex-end-on-xl",
      alignSelfCenterOnXl: "pf-m-align-self-center-on-xl",
      alignSelfBaselineOnXl: "pf-m-align-self-baseline-on-xl",
      alignSelfStretchOnXl: "pf-m-align-self-stretch-on-xl",
      flexOn_2xl: "pf-m-flex-on-2xl",
      inlineFlexOn_2xl: "pf-m-inline-flex-on-2xl",
      columnOn_2xl: "pf-m-column-on-2xl",
      columnReverseOn_2xl: "pf-m-column-reverse-on-2xl",
      rowOn_2xl: "pf-m-row-on-2xl",
      rowReverseOn_2xl: "pf-m-row-reverse-on-2xl",
      wrapOn_2xl: "pf-m-wrap-on-2xl",
      wrapReverseOn_2xl: "pf-m-wrap-reverse-on-2xl",
      nowrapOn_2xl: "pf-m-nowrap-on-2xl",
      justifyContentFlexStartOn_2xl: "pf-m-justify-content-flex-start-on-2xl",
      justifyContentFlexEndOn_2xl: "pf-m-justify-content-flex-end-on-2xl",
      justifyContentCenterOn_2xl: "pf-m-justify-content-center-on-2xl",
      justifyContentSpaceBetweenOn_2xl: "pf-m-justify-content-space-between-on-2xl",
      justifyContentSpaceAroundOn_2xl: "pf-m-justify-content-space-around-on-2xl",
      justifyContentSpaceEvenlyOn_2xl: "pf-m-justify-content-space-evenly-on-2xl",
      alignItemsFlexStartOn_2xl: "pf-m-align-items-flex-start-on-2xl",
      alignItemsFlexEndOn_2xl: "pf-m-align-items-flex-end-on-2xl",
      alignItemsCenterOn_2xl: "pf-m-align-items-center-on-2xl",
      alignItemsStretchOn_2xl: "pf-m-align-items-stretch-on-2xl",
      alignItemsBaselineOn_2xl: "pf-m-align-items-baseline-on-2xl",
      alignContentFlexStartOn_2xl: "pf-m-align-content-flex-start-on-2xl",
      alignContentFlexEndOn_2xl: "pf-m-align-content-flex-end-on-2xl",
      alignContentCenterOn_2xl: "pf-m-align-content-center-on-2xl",
      alignContentStretchOn_2xl: "pf-m-align-content-stretch-on-2xl",
      alignContentSpaceBetweenOn_2xl: "pf-m-align-content-space-between-on-2xl",
      alignContentSpaceAroundOn_2xl: "pf-m-align-content-space-around-on-2xl",
      alignRightOn_2xl: "pf-m-align-right-on-2xl",
      alignLeftOn_2xl: "pf-m-align-left-on-2xl",
      growOn_2xl: "pf-m-grow-on-2xl",
      shrinkOn_2xl: "pf-m-shrink-on-2xl",
      fullWidthOn_2xl: "pf-m-full-width-on-2xl",
      flex_1On_2xl: "pf-m-flex-1-on-2xl",
      flex_2On_2xl: "pf-m-flex-2-on-2xl",
      flex_3On_2xl: "pf-m-flex-3-on-2xl",
      flex_4On_2xl: "pf-m-flex-4-on-2xl",
      flexDefaultOn_2xl: "pf-m-flex-default-on-2xl",
      flexNoneOn_2xl: "pf-m-flex-none-on-2xl",
      alignSelfFlexStartOn_2xl: "pf-m-align-self-flex-start-on-2xl",
      alignSelfFlexEndOn_2xl: "pf-m-align-self-flex-end-on-2xl",
      alignSelfCenterOn_2xl: "pf-m-align-self-center-on-2xl",
      alignSelfBaselineOn_2xl: "pf-m-align-self-baseline-on-2xl",
      alignSelfStretchOn_2xl: "pf-m-align-self-stretch-on-2xl",
      spaceItemsNone: "pf-m-space-items-none",
      spaceItemsXs: "pf-m-space-items-xs",
      spaceItemsSm: "pf-m-space-items-sm",
      spaceItemsMd: "pf-m-space-items-md",
      spaceItemsLg: "pf-m-space-items-lg",
      spaceItemsXl: "pf-m-space-items-xl",
      spaceItems_2xl: "pf-m-space-items-2xl",
      spaceItems_3xl: "pf-m-space-items-3xl",
      spaceItems_4xl: "pf-m-space-items-4xl",
      spaceItemsNoneOnSm: "pf-m-space-items-none-on-sm",
      spaceItemsXsOnSm: "pf-m-space-items-xs-on-sm",
      spaceItemsSmOnSm: "pf-m-space-items-sm-on-sm",
      spaceItemsMdOnSm: "pf-m-space-items-md-on-sm",
      spaceItemsLgOnSm: "pf-m-space-items-lg-on-sm",
      spaceItemsXlOnSm: "pf-m-space-items-xl-on-sm",
      spaceItems_2xlOnSm: "pf-m-space-items-2xl-on-sm",
      spaceItems_3xlOnSm: "pf-m-space-items-3xl-on-sm",
      spaceItems_4xlOnSm: "pf-m-space-items-4xl-on-sm",
      spaceItemsNoneOnMd: "pf-m-space-items-none-on-md",
      spaceItemsXsOnMd: "pf-m-space-items-xs-on-md",
      spaceItemsSmOnMd: "pf-m-space-items-sm-on-md",
      spaceItemsMdOnMd: "pf-m-space-items-md-on-md",
      spaceItemsLgOnMd: "pf-m-space-items-lg-on-md",
      spaceItemsXlOnMd: "pf-m-space-items-xl-on-md",
      spaceItems_2xlOnMd: "pf-m-space-items-2xl-on-md",
      spaceItems_3xlOnMd: "pf-m-space-items-3xl-on-md",
      spaceItems_4xlOnMd: "pf-m-space-items-4xl-on-md",
      spaceItemsNoneOnLg: "pf-m-space-items-none-on-lg",
      spaceItemsXsOnLg: "pf-m-space-items-xs-on-lg",
      spaceItemsSmOnLg: "pf-m-space-items-sm-on-lg",
      spaceItemsMdOnLg: "pf-m-space-items-md-on-lg",
      spaceItemsLgOnLg: "pf-m-space-items-lg-on-lg",
      spaceItemsXlOnLg: "pf-m-space-items-xl-on-lg",
      spaceItems_2xlOnLg: "pf-m-space-items-2xl-on-lg",
      spaceItems_3xlOnLg: "pf-m-space-items-3xl-on-lg",
      spaceItems_4xlOnLg: "pf-m-space-items-4xl-on-lg",
      spaceItemsNoneOnXl: "pf-m-space-items-none-on-xl",
      spaceItemsXsOnXl: "pf-m-space-items-xs-on-xl",
      spaceItemsSmOnXl: "pf-m-space-items-sm-on-xl",
      spaceItemsMdOnXl: "pf-m-space-items-md-on-xl",
      spaceItemsLgOnXl: "pf-m-space-items-lg-on-xl",
      spaceItemsXlOnXl: "pf-m-space-items-xl-on-xl",
      spaceItems_2xlOnXl: "pf-m-space-items-2xl-on-xl",
      spaceItems_3xlOnXl: "pf-m-space-items-3xl-on-xl",
      spaceItems_4xlOnXl: "pf-m-space-items-4xl-on-xl",
      spaceItemsNoneOn_2xl: "pf-m-space-items-none-on-2xl",
      spaceItemsXsOn_2xl: "pf-m-space-items-xs-on-2xl",
      spaceItemsSmOn_2xl: "pf-m-space-items-sm-on-2xl",
      spaceItemsMdOn_2xl: "pf-m-space-items-md-on-2xl",
      spaceItemsLgOn_2xl: "pf-m-space-items-lg-on-2xl",
      spaceItemsXlOn_2xl: "pf-m-space-items-xl-on-2xl",
      spaceItems_2xlOn_2xl: "pf-m-space-items-2xl-on-2xl",
      spaceItems_3xlOn_2xl: "pf-m-space-items-3xl-on-2xl",
      spaceItems_4xlOn_2xl: "pf-m-space-items-4xl-on-2xl",
      spacerNone: "pf-m-spacer-none",
      spacerXs: "pf-m-spacer-xs",
      spacerSm: "pf-m-spacer-sm",
      spacerMd: "pf-m-spacer-md",
      spacerLg: "pf-m-spacer-lg",
      spacerXl: "pf-m-spacer-xl",
      spacer_2xl: "pf-m-spacer-2xl",
      spacer_3xl: "pf-m-spacer-3xl",
      spacer_4xl: "pf-m-spacer-4xl",
      spacerNoneOnSm: "pf-m-spacer-none-on-sm",
      spacerXsOnSm: "pf-m-spacer-xs-on-sm",
      spacerSmOnSm: "pf-m-spacer-sm-on-sm",
      spacerMdOnSm: "pf-m-spacer-md-on-sm",
      spacerLgOnSm: "pf-m-spacer-lg-on-sm",
      spacerXlOnSm: "pf-m-spacer-xl-on-sm",
      spacer_2xlOnSm: "pf-m-spacer-2xl-on-sm",
      spacer_3xlOnSm: "pf-m-spacer-3xl-on-sm",
      spacer_4xlOnSm: "pf-m-spacer-4xl-on-sm",
      spacerNoneOnMd: "pf-m-spacer-none-on-md",
      spacerXsOnMd: "pf-m-spacer-xs-on-md",
      spacerSmOnMd: "pf-m-spacer-sm-on-md",
      spacerMdOnMd: "pf-m-spacer-md-on-md",
      spacerLgOnMd: "pf-m-spacer-lg-on-md",
      spacerXlOnMd: "pf-m-spacer-xl-on-md",
      spacer_2xlOnMd: "pf-m-spacer-2xl-on-md",
      spacer_3xlOnMd: "pf-m-spacer-3xl-on-md",
      spacer_4xlOnMd: "pf-m-spacer-4xl-on-md",
      spacerNoneOnLg: "pf-m-spacer-none-on-lg",
      spacerXsOnLg: "pf-m-spacer-xs-on-lg",
      spacerSmOnLg: "pf-m-spacer-sm-on-lg",
      spacerMdOnLg: "pf-m-spacer-md-on-lg",
      spacerLgOnLg: "pf-m-spacer-lg-on-lg",
      spacerXlOnLg: "pf-m-spacer-xl-on-lg",
      spacer_2xlOnLg: "pf-m-spacer-2xl-on-lg",
      spacer_3xlOnLg: "pf-m-spacer-3xl-on-lg",
      spacer_4xlOnLg: "pf-m-spacer-4xl-on-lg",
      spacerNoneOnXl: "pf-m-spacer-none-on-xl",
      spacerXsOnXl: "pf-m-spacer-xs-on-xl",
      spacerSmOnXl: "pf-m-spacer-sm-on-xl",
      spacerMdOnXl: "pf-m-spacer-md-on-xl",
      spacerLgOnXl: "pf-m-spacer-lg-on-xl",
      spacerXlOnXl: "pf-m-spacer-xl-on-xl",
      spacer_2xlOnXl: "pf-m-spacer-2xl-on-xl",
      spacer_3xlOnXl: "pf-m-spacer-3xl-on-xl",
      spacer_4xlOnXl: "pf-m-spacer-4xl-on-xl",
      spacerNoneOn_2xl: "pf-m-spacer-none-on-2xl",
      spacerXsOn_2xl: "pf-m-spacer-xs-on-2xl",
      spacerSmOn_2xl: "pf-m-spacer-sm-on-2xl",
      spacerMdOn_2xl: "pf-m-spacer-md-on-2xl",
      spacerLgOn_2xl: "pf-m-spacer-lg-on-2xl",
      spacerXlOn_2xl: "pf-m-spacer-xl-on-2xl",
      spacer_2xlOn_2xl: "pf-m-spacer-2xl-on-2xl",
      spacer_3xlOn_2xl: "pf-m-spacer-3xl-on-2xl",
      spacer_4xlOn_2xl: "pf-m-spacer-4xl-on-2xl"
    }
  };
});
var styles$z = /* @__PURE__ */ getDefaultExportFromCjs(flex);
var l_flex_item_Order = {
  name: "--pf-l-flex--item--Order",
  value: "0",
  var: "var(--pf-l-flex--item--Order)"
};
var Flex = (_a) => {
  var {children: children2 = null, className = "", spacer, spaceItems, grow, shrink, flex: flex2, direction, alignItems, alignContent, alignSelf, align, justifyContent, display, fullWidth, flexWrap, order: order3, style} = _a, props = __rest(_a, ["children", "className", "spacer", "spaceItems", "grow", "shrink", "flex", "direction", "alignItems", "alignContent", "alignSelf", "align", "justifyContent", "display", "fullWidth", "flexWrap", "order", "style"]);
  return react.createElement("div", Object.assign({className: css(styles$z.flex, formatBreakpointMods(spacer, styles$z), formatBreakpointMods(spaceItems, styles$z), formatBreakpointMods(grow, styles$z), formatBreakpointMods(shrink, styles$z), formatBreakpointMods(flex2, styles$z), formatBreakpointMods(direction, styles$z), formatBreakpointMods(alignItems, styles$z), formatBreakpointMods(alignContent, styles$z), formatBreakpointMods(alignSelf, styles$z), formatBreakpointMods(align, styles$z), formatBreakpointMods(justifyContent, styles$z), formatBreakpointMods(display, styles$z), formatBreakpointMods(fullWidth, styles$z), formatBreakpointMods(flexWrap, styles$z), className), style: style || order3 ? Object.assign(Object.assign({}, style), setBreakpointCssVars(order3, l_flex_item_Order.name)) : void 0}, props), children2);
};
Flex.displayName = "Flex";
var FlexItem = (_a) => {
  var {children: children2 = null, className = "", spacer, grow, shrink, flex: flex2, alignSelf, align, fullWidth, order: order3, style} = _a, props = __rest(_a, ["children", "className", "spacer", "grow", "shrink", "flex", "alignSelf", "align", "fullWidth", "order", "style"]);
  return react.createElement("div", Object.assign({}, props, {className: css(formatBreakpointMods(spacer, styles$z), formatBreakpointMods(grow, styles$z), formatBreakpointMods(shrink, styles$z), formatBreakpointMods(flex2, styles$z), formatBreakpointMods(alignSelf, styles$z), formatBreakpointMods(align, styles$z), formatBreakpointMods(fullWidth, styles$z), className), style: style || order3 ? Object.assign(Object.assign({}, style), setBreakpointCssVars(order3, l_flex_item_Order.name)) : void 0}), children2);
};
FlexItem.displayName = "FlexItem";
var gallery = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    gallery: "pf-l-gallery",
    modifiers: {
      gutter: "pf-m-gutter"
    }
  };
});
var styles$A = /* @__PURE__ */ getDefaultExportFromCjs(gallery);
var Gallery = (_a) => {
  var {children: children2 = null, className = "", hasGutter = false, minWidths, maxWidths} = _a, props = __rest(_a, ["children", "className", "hasGutter", "minWidths", "maxWidths"]);
  const minWidthStyles = {};
  if (minWidths) {
    Object.entries(minWidths || {}).map(([breakpoint, value]) => minWidthStyles[`--pf-l-gallery--GridTemplateColumns--min${breakpoint !== "default" ? `-on-${breakpoint}` : ""}`] = value);
  }
  const maxWidthStyles = {};
  if (maxWidths) {
    Object.entries(maxWidths || {}).map(([breakpoint, value]) => maxWidthStyles[`--pf-l-gallery--GridTemplateColumns--max${breakpoint !== "default" ? `-on-${breakpoint}` : ""}`] = value);
  }
  const widthStyles = Object.assign(Object.assign({}, minWidthStyles), maxWidthStyles);
  return react.createElement("div", Object.assign({className: css(styles$A.gallery, hasGutter && styles$A.modifiers.gutter, className)}, props, (minWidths || maxWidths) && {style: Object.assign(Object.assign({}, widthStyles), props.style)}), children2);
};
Gallery.displayName = "Gallery";
var GalleryItem = (_a) => {
  var {children: children2 = null} = _a, props = __rest(_a, ["children"]);
  return react.createElement("div", Object.assign({}, props), children2);
};
GalleryItem.displayName = "GalleryItem";
var grid = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    grid: "pf-l-grid",
    gridItem: "pf-l-grid__item",
    modifiers: {
      all_1Col: "pf-m-all-1-col",
      all_2Col: "pf-m-all-2-col",
      all_3Col: "pf-m-all-3-col",
      all_4Col: "pf-m-all-4-col",
      all_5Col: "pf-m-all-5-col",
      all_6Col: "pf-m-all-6-col",
      all_7Col: "pf-m-all-7-col",
      all_8Col: "pf-m-all-8-col",
      all_9Col: "pf-m-all-9-col",
      all_10Col: "pf-m-all-10-col",
      all_11Col: "pf-m-all-11-col",
      all_12Col: "pf-m-all-12-col",
      all_1ColOnSm: "pf-m-all-1-col-on-sm",
      all_2ColOnSm: "pf-m-all-2-col-on-sm",
      all_3ColOnSm: "pf-m-all-3-col-on-sm",
      all_4ColOnSm: "pf-m-all-4-col-on-sm",
      all_5ColOnSm: "pf-m-all-5-col-on-sm",
      all_6ColOnSm: "pf-m-all-6-col-on-sm",
      all_7ColOnSm: "pf-m-all-7-col-on-sm",
      all_8ColOnSm: "pf-m-all-8-col-on-sm",
      all_9ColOnSm: "pf-m-all-9-col-on-sm",
      all_10ColOnSm: "pf-m-all-10-col-on-sm",
      all_11ColOnSm: "pf-m-all-11-col-on-sm",
      all_12ColOnSm: "pf-m-all-12-col-on-sm",
      all_1ColOnMd: "pf-m-all-1-col-on-md",
      all_2ColOnMd: "pf-m-all-2-col-on-md",
      all_3ColOnMd: "pf-m-all-3-col-on-md",
      all_4ColOnMd: "pf-m-all-4-col-on-md",
      all_5ColOnMd: "pf-m-all-5-col-on-md",
      all_6ColOnMd: "pf-m-all-6-col-on-md",
      all_7ColOnMd: "pf-m-all-7-col-on-md",
      all_8ColOnMd: "pf-m-all-8-col-on-md",
      all_9ColOnMd: "pf-m-all-9-col-on-md",
      all_10ColOnMd: "pf-m-all-10-col-on-md",
      all_11ColOnMd: "pf-m-all-11-col-on-md",
      all_12ColOnMd: "pf-m-all-12-col-on-md",
      all_1ColOnLg: "pf-m-all-1-col-on-lg",
      all_2ColOnLg: "pf-m-all-2-col-on-lg",
      all_3ColOnLg: "pf-m-all-3-col-on-lg",
      all_4ColOnLg: "pf-m-all-4-col-on-lg",
      all_5ColOnLg: "pf-m-all-5-col-on-lg",
      all_6ColOnLg: "pf-m-all-6-col-on-lg",
      all_7ColOnLg: "pf-m-all-7-col-on-lg",
      all_8ColOnLg: "pf-m-all-8-col-on-lg",
      all_9ColOnLg: "pf-m-all-9-col-on-lg",
      all_10ColOnLg: "pf-m-all-10-col-on-lg",
      all_11ColOnLg: "pf-m-all-11-col-on-lg",
      all_12ColOnLg: "pf-m-all-12-col-on-lg",
      all_1ColOnXl: "pf-m-all-1-col-on-xl",
      all_2ColOnXl: "pf-m-all-2-col-on-xl",
      all_3ColOnXl: "pf-m-all-3-col-on-xl",
      all_4ColOnXl: "pf-m-all-4-col-on-xl",
      all_5ColOnXl: "pf-m-all-5-col-on-xl",
      all_6ColOnXl: "pf-m-all-6-col-on-xl",
      all_7ColOnXl: "pf-m-all-7-col-on-xl",
      all_8ColOnXl: "pf-m-all-8-col-on-xl",
      all_9ColOnXl: "pf-m-all-9-col-on-xl",
      all_10ColOnXl: "pf-m-all-10-col-on-xl",
      all_11ColOnXl: "pf-m-all-11-col-on-xl",
      all_12ColOnXl: "pf-m-all-12-col-on-xl",
      all_1ColOn_2xl: "pf-m-all-1-col-on-2xl",
      all_2ColOn_2xl: "pf-m-all-2-col-on-2xl",
      all_3ColOn_2xl: "pf-m-all-3-col-on-2xl",
      all_4ColOn_2xl: "pf-m-all-4-col-on-2xl",
      all_5ColOn_2xl: "pf-m-all-5-col-on-2xl",
      all_6ColOn_2xl: "pf-m-all-6-col-on-2xl",
      all_7ColOn_2xl: "pf-m-all-7-col-on-2xl",
      all_8ColOn_2xl: "pf-m-all-8-col-on-2xl",
      all_9ColOn_2xl: "pf-m-all-9-col-on-2xl",
      all_10ColOn_2xl: "pf-m-all-10-col-on-2xl",
      all_11ColOn_2xl: "pf-m-all-11-col-on-2xl",
      all_12ColOn_2xl: "pf-m-all-12-col-on-2xl",
      "1Col": "pf-m-1-col",
      "2Col": "pf-m-2-col",
      "3Col": "pf-m-3-col",
      "4Col": "pf-m-4-col",
      "5Col": "pf-m-5-col",
      "6Col": "pf-m-6-col",
      "7Col": "pf-m-7-col",
      "8Col": "pf-m-8-col",
      "9Col": "pf-m-9-col",
      "10Col": "pf-m-10-col",
      "11Col": "pf-m-11-col",
      "12Col": "pf-m-12-col",
      offset_1Col: "pf-m-offset-1-col",
      offset_2Col: "pf-m-offset-2-col",
      offset_3Col: "pf-m-offset-3-col",
      offset_4Col: "pf-m-offset-4-col",
      offset_5Col: "pf-m-offset-5-col",
      offset_6Col: "pf-m-offset-6-col",
      offset_7Col: "pf-m-offset-7-col",
      offset_8Col: "pf-m-offset-8-col",
      offset_9Col: "pf-m-offset-9-col",
      offset_10Col: "pf-m-offset-10-col",
      offset_11Col: "pf-m-offset-11-col",
      offset_12Col: "pf-m-offset-12-col",
      "1Row": "pf-m-1-row",
      "2Row": "pf-m-2-row",
      "3Row": "pf-m-3-row",
      "4Row": "pf-m-4-row",
      "5Row": "pf-m-5-row",
      "6Row": "pf-m-6-row",
      "7Row": "pf-m-7-row",
      "8Row": "pf-m-8-row",
      "9Row": "pf-m-9-row",
      "10Row": "pf-m-10-row",
      "11Row": "pf-m-11-row",
      "12Row": "pf-m-12-row",
      "1ColOnSm": "pf-m-1-col-on-sm",
      "2ColOnSm": "pf-m-2-col-on-sm",
      "3ColOnSm": "pf-m-3-col-on-sm",
      "4ColOnSm": "pf-m-4-col-on-sm",
      "5ColOnSm": "pf-m-5-col-on-sm",
      "6ColOnSm": "pf-m-6-col-on-sm",
      "7ColOnSm": "pf-m-7-col-on-sm",
      "8ColOnSm": "pf-m-8-col-on-sm",
      "9ColOnSm": "pf-m-9-col-on-sm",
      "10ColOnSm": "pf-m-10-col-on-sm",
      "11ColOnSm": "pf-m-11-col-on-sm",
      "12ColOnSm": "pf-m-12-col-on-sm",
      offset_1ColOnSm: "pf-m-offset-1-col-on-sm",
      offset_2ColOnSm: "pf-m-offset-2-col-on-sm",
      offset_3ColOnSm: "pf-m-offset-3-col-on-sm",
      offset_4ColOnSm: "pf-m-offset-4-col-on-sm",
      offset_5ColOnSm: "pf-m-offset-5-col-on-sm",
      offset_6ColOnSm: "pf-m-offset-6-col-on-sm",
      offset_7ColOnSm: "pf-m-offset-7-col-on-sm",
      offset_8ColOnSm: "pf-m-offset-8-col-on-sm",
      offset_9ColOnSm: "pf-m-offset-9-col-on-sm",
      offset_10ColOnSm: "pf-m-offset-10-col-on-sm",
      offset_11ColOnSm: "pf-m-offset-11-col-on-sm",
      offset_12ColOnSm: "pf-m-offset-12-col-on-sm",
      "1RowOnSm": "pf-m-1-row-on-sm",
      "2RowOnSm": "pf-m-2-row-on-sm",
      "3RowOnSm": "pf-m-3-row-on-sm",
      "4RowOnSm": "pf-m-4-row-on-sm",
      "5RowOnSm": "pf-m-5-row-on-sm",
      "6RowOnSm": "pf-m-6-row-on-sm",
      "7RowOnSm": "pf-m-7-row-on-sm",
      "8RowOnSm": "pf-m-8-row-on-sm",
      "9RowOnSm": "pf-m-9-row-on-sm",
      "10RowOnSm": "pf-m-10-row-on-sm",
      "11RowOnSm": "pf-m-11-row-on-sm",
      "12RowOnSm": "pf-m-12-row-on-sm",
      "1ColOnMd": "pf-m-1-col-on-md",
      "2ColOnMd": "pf-m-2-col-on-md",
      "3ColOnMd": "pf-m-3-col-on-md",
      "4ColOnMd": "pf-m-4-col-on-md",
      "5ColOnMd": "pf-m-5-col-on-md",
      "6ColOnMd": "pf-m-6-col-on-md",
      "7ColOnMd": "pf-m-7-col-on-md",
      "8ColOnMd": "pf-m-8-col-on-md",
      "9ColOnMd": "pf-m-9-col-on-md",
      "10ColOnMd": "pf-m-10-col-on-md",
      "11ColOnMd": "pf-m-11-col-on-md",
      "12ColOnMd": "pf-m-12-col-on-md",
      offset_1ColOnMd: "pf-m-offset-1-col-on-md",
      offset_2ColOnMd: "pf-m-offset-2-col-on-md",
      offset_3ColOnMd: "pf-m-offset-3-col-on-md",
      offset_4ColOnMd: "pf-m-offset-4-col-on-md",
      offset_5ColOnMd: "pf-m-offset-5-col-on-md",
      offset_6ColOnMd: "pf-m-offset-6-col-on-md",
      offset_7ColOnMd: "pf-m-offset-7-col-on-md",
      offset_8ColOnMd: "pf-m-offset-8-col-on-md",
      offset_9ColOnMd: "pf-m-offset-9-col-on-md",
      offset_10ColOnMd: "pf-m-offset-10-col-on-md",
      offset_11ColOnMd: "pf-m-offset-11-col-on-md",
      offset_12ColOnMd: "pf-m-offset-12-col-on-md",
      "1RowOnMd": "pf-m-1-row-on-md",
      "2RowOnMd": "pf-m-2-row-on-md",
      "3RowOnMd": "pf-m-3-row-on-md",
      "4RowOnMd": "pf-m-4-row-on-md",
      "5RowOnMd": "pf-m-5-row-on-md",
      "6RowOnMd": "pf-m-6-row-on-md",
      "7RowOnMd": "pf-m-7-row-on-md",
      "8RowOnMd": "pf-m-8-row-on-md",
      "9RowOnMd": "pf-m-9-row-on-md",
      "10RowOnMd": "pf-m-10-row-on-md",
      "11RowOnMd": "pf-m-11-row-on-md",
      "12RowOnMd": "pf-m-12-row-on-md",
      "1ColOnLg": "pf-m-1-col-on-lg",
      "2ColOnLg": "pf-m-2-col-on-lg",
      "3ColOnLg": "pf-m-3-col-on-lg",
      "4ColOnLg": "pf-m-4-col-on-lg",
      "5ColOnLg": "pf-m-5-col-on-lg",
      "6ColOnLg": "pf-m-6-col-on-lg",
      "7ColOnLg": "pf-m-7-col-on-lg",
      "8ColOnLg": "pf-m-8-col-on-lg",
      "9ColOnLg": "pf-m-9-col-on-lg",
      "10ColOnLg": "pf-m-10-col-on-lg",
      "11ColOnLg": "pf-m-11-col-on-lg",
      "12ColOnLg": "pf-m-12-col-on-lg",
      offset_1ColOnLg: "pf-m-offset-1-col-on-lg",
      offset_2ColOnLg: "pf-m-offset-2-col-on-lg",
      offset_3ColOnLg: "pf-m-offset-3-col-on-lg",
      offset_4ColOnLg: "pf-m-offset-4-col-on-lg",
      offset_5ColOnLg: "pf-m-offset-5-col-on-lg",
      offset_6ColOnLg: "pf-m-offset-6-col-on-lg",
      offset_7ColOnLg: "pf-m-offset-7-col-on-lg",
      offset_8ColOnLg: "pf-m-offset-8-col-on-lg",
      offset_9ColOnLg: "pf-m-offset-9-col-on-lg",
      offset_10ColOnLg: "pf-m-offset-10-col-on-lg",
      offset_11ColOnLg: "pf-m-offset-11-col-on-lg",
      offset_12ColOnLg: "pf-m-offset-12-col-on-lg",
      "1RowOnLg": "pf-m-1-row-on-lg",
      "2RowOnLg": "pf-m-2-row-on-lg",
      "3RowOnLg": "pf-m-3-row-on-lg",
      "4RowOnLg": "pf-m-4-row-on-lg",
      "5RowOnLg": "pf-m-5-row-on-lg",
      "6RowOnLg": "pf-m-6-row-on-lg",
      "7RowOnLg": "pf-m-7-row-on-lg",
      "8RowOnLg": "pf-m-8-row-on-lg",
      "9RowOnLg": "pf-m-9-row-on-lg",
      "10RowOnLg": "pf-m-10-row-on-lg",
      "11RowOnLg": "pf-m-11-row-on-lg",
      "12RowOnLg": "pf-m-12-row-on-lg",
      "1ColOnXl": "pf-m-1-col-on-xl",
      "2ColOnXl": "pf-m-2-col-on-xl",
      "3ColOnXl": "pf-m-3-col-on-xl",
      "4ColOnXl": "pf-m-4-col-on-xl",
      "5ColOnXl": "pf-m-5-col-on-xl",
      "6ColOnXl": "pf-m-6-col-on-xl",
      "7ColOnXl": "pf-m-7-col-on-xl",
      "8ColOnXl": "pf-m-8-col-on-xl",
      "9ColOnXl": "pf-m-9-col-on-xl",
      "10ColOnXl": "pf-m-10-col-on-xl",
      "11ColOnXl": "pf-m-11-col-on-xl",
      "12ColOnXl": "pf-m-12-col-on-xl",
      offset_1ColOnXl: "pf-m-offset-1-col-on-xl",
      offset_2ColOnXl: "pf-m-offset-2-col-on-xl",
      offset_3ColOnXl: "pf-m-offset-3-col-on-xl",
      offset_4ColOnXl: "pf-m-offset-4-col-on-xl",
      offset_5ColOnXl: "pf-m-offset-5-col-on-xl",
      offset_6ColOnXl: "pf-m-offset-6-col-on-xl",
      offset_7ColOnXl: "pf-m-offset-7-col-on-xl",
      offset_8ColOnXl: "pf-m-offset-8-col-on-xl",
      offset_9ColOnXl: "pf-m-offset-9-col-on-xl",
      offset_10ColOnXl: "pf-m-offset-10-col-on-xl",
      offset_11ColOnXl: "pf-m-offset-11-col-on-xl",
      offset_12ColOnXl: "pf-m-offset-12-col-on-xl",
      "1RowOnXl": "pf-m-1-row-on-xl",
      "2RowOnXl": "pf-m-2-row-on-xl",
      "3RowOnXl": "pf-m-3-row-on-xl",
      "4RowOnXl": "pf-m-4-row-on-xl",
      "5RowOnXl": "pf-m-5-row-on-xl",
      "6RowOnXl": "pf-m-6-row-on-xl",
      "7RowOnXl": "pf-m-7-row-on-xl",
      "8RowOnXl": "pf-m-8-row-on-xl",
      "9RowOnXl": "pf-m-9-row-on-xl",
      "10RowOnXl": "pf-m-10-row-on-xl",
      "11RowOnXl": "pf-m-11-row-on-xl",
      "12RowOnXl": "pf-m-12-row-on-xl",
      "1ColOn_2xl": "pf-m-1-col-on-2xl",
      "2ColOn_2xl": "pf-m-2-col-on-2xl",
      "3ColOn_2xl": "pf-m-3-col-on-2xl",
      "4ColOn_2xl": "pf-m-4-col-on-2xl",
      "5ColOn_2xl": "pf-m-5-col-on-2xl",
      "6ColOn_2xl": "pf-m-6-col-on-2xl",
      "7ColOn_2xl": "pf-m-7-col-on-2xl",
      "8ColOn_2xl": "pf-m-8-col-on-2xl",
      "9ColOn_2xl": "pf-m-9-col-on-2xl",
      "10ColOn_2xl": "pf-m-10-col-on-2xl",
      "11ColOn_2xl": "pf-m-11-col-on-2xl",
      "12ColOn_2xl": "pf-m-12-col-on-2xl",
      offset_1ColOn_2xl: "pf-m-offset-1-col-on-2xl",
      offset_2ColOn_2xl: "pf-m-offset-2-col-on-2xl",
      offset_3ColOn_2xl: "pf-m-offset-3-col-on-2xl",
      offset_4ColOn_2xl: "pf-m-offset-4-col-on-2xl",
      offset_5ColOn_2xl: "pf-m-offset-5-col-on-2xl",
      offset_6ColOn_2xl: "pf-m-offset-6-col-on-2xl",
      offset_7ColOn_2xl: "pf-m-offset-7-col-on-2xl",
      offset_8ColOn_2xl: "pf-m-offset-8-col-on-2xl",
      offset_9ColOn_2xl: "pf-m-offset-9-col-on-2xl",
      offset_10ColOn_2xl: "pf-m-offset-10-col-on-2xl",
      offset_11ColOn_2xl: "pf-m-offset-11-col-on-2xl",
      offset_12ColOn_2xl: "pf-m-offset-12-col-on-2xl",
      "1RowOn_2xl": "pf-m-1-row-on-2xl",
      "2RowOn_2xl": "pf-m-2-row-on-2xl",
      "3RowOn_2xl": "pf-m-3-row-on-2xl",
      "4RowOn_2xl": "pf-m-4-row-on-2xl",
      "5RowOn_2xl": "pf-m-5-row-on-2xl",
      "6RowOn_2xl": "pf-m-6-row-on-2xl",
      "7RowOn_2xl": "pf-m-7-row-on-2xl",
      "8RowOn_2xl": "pf-m-8-row-on-2xl",
      "9RowOn_2xl": "pf-m-9-row-on-2xl",
      "10RowOn_2xl": "pf-m-10-row-on-2xl",
      "11RowOn_2xl": "pf-m-11-row-on-2xl",
      "12RowOn_2xl": "pf-m-12-row-on-2xl",
      gutter: "pf-m-gutter"
    }
  };
});
var styles$B = /* @__PURE__ */ getDefaultExportFromCjs(grid);
var BaseSizes;
(function(BaseSizes2) {
  BaseSizes2["xs"] = "xs";
  BaseSizes2["sm"] = "sm";
  BaseSizes2["md"] = "md";
  BaseSizes2["lg"] = "lg";
  BaseSizes2["xl"] = "xl";
  BaseSizes2["2xl"] = "2xl";
  BaseSizes2["3xl"] = "3xl";
  BaseSizes2["4xl"] = "4xl";
})(BaseSizes || (BaseSizes = {}));
var DeviceSizes;
(function(DeviceSizes2) {
  DeviceSizes2["sm"] = "Sm";
  DeviceSizes2["md"] = "Md";
  DeviceSizes2["lg"] = "Lg";
  DeviceSizes2["xl"] = "Xl";
  DeviceSizes2["xl2"] = "_2xl";
})(DeviceSizes || (DeviceSizes = {}));
var l_grid_item_Order = {
  name: "--pf-l-grid--item--Order",
  value: "0",
  var: "var(--pf-l-grid--item--Order)"
};
var Grid = (_a) => {
  var {children: children2 = null, className = "", hasGutter, span = null, order: order3, style} = _a, props = __rest(_a, ["children", "className", "hasGutter", "span", "order", "style"]);
  const classes = [styles$B.grid, span && styles$B.modifiers[`all_${span}Col`]];
  Object.entries(DeviceSizes).forEach(([propKey, gridSpanModifier]) => {
    const key = propKey;
    const propValue = props[key];
    if (propValue) {
      classes.push(styles$B.modifiers[`all_${propValue}ColOn${gridSpanModifier}`]);
    }
    delete props[key];
  });
  return react.createElement("div", Object.assign({className: css(...classes, hasGutter && styles$B.modifiers.gutter, className), style: style || order3 ? Object.assign(Object.assign({}, style), setBreakpointCssVars(order3, l_grid_item_Order.name)) : void 0}, props), children2);
};
Grid.displayName = "Grid";
var GridItem = (_a) => {
  var {children: children2 = null, className = "", span = null, rowSpan = null, offset: offset2 = null, order: order3, style} = _a, props = __rest(_a, ["children", "className", "span", "rowSpan", "offset", "order", "style"]);
  const classes = [
    styles$B.gridItem,
    span && styles$B.modifiers[`${span}Col`],
    rowSpan && styles$B.modifiers[`${rowSpan}Row`],
    offset2 && styles$B.modifiers[`offset_${offset2}Col`]
  ];
  Object.entries(DeviceSizes).forEach(([propKey, classModifier]) => {
    const key = propKey;
    const rowSpanKey = `${key}RowSpan`;
    const offsetKey = `${key}Offset`;
    const spanValue = props[key];
    const rowSpanValue = props[rowSpanKey];
    const offsetValue = props[offsetKey];
    if (spanValue) {
      classes.push(styles$B.modifiers[`${spanValue}ColOn${classModifier}`]);
    }
    if (rowSpanValue) {
      classes.push(styles$B.modifiers[`${rowSpanValue}RowOn${classModifier}`]);
    }
    if (offsetValue) {
      classes.push(styles$B.modifiers[`offset_${offsetValue}ColOn${classModifier}`]);
    }
    delete props[key];
    delete props[rowSpanKey];
    delete props[offsetKey];
  });
  return react.createElement("div", Object.assign({className: css(...classes, className), style: style || order3 ? Object.assign(Object.assign({}, style), setBreakpointCssVars(order3, l_grid_item_Order.name)) : void 0}, props), children2);
};
GridItem.displayName = "GridItem";
var level = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    level: "pf-l-level",
    modifiers: {
      gutter: "pf-m-gutter"
    }
  };
});
var styles$C = /* @__PURE__ */ getDefaultExportFromCjs(level);
var Level = (_a) => {
  var {hasGutter, className = "", children: children2 = null} = _a, props = __rest(_a, ["hasGutter", "className", "children"]);
  return react.createElement("div", Object.assign({}, props, {className: css(styles$C.level, hasGutter && styles$C.modifiers.gutter, className)}), children2);
};
Level.displayName = "Level";
var LevelItem = (_a) => {
  var {children: children2 = null} = _a, props = __rest(_a, ["children"]);
  return react.createElement("div", Object.assign({}, props), children2);
};
LevelItem.displayName = "LevelItem";
var split = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    modifiers: {
      wrap: "pf-m-wrap",
      fill: "pf-m-fill",
      gutter: "pf-m-gutter"
    },
    split: "pf-l-split",
    splitItem: "pf-l-split__item"
  };
});
var styles$D = /* @__PURE__ */ getDefaultExportFromCjs(split);
var Split = (_a) => {
  var {hasGutter = false, isWrappable = false, className = "", children: children2 = null, component = "div"} = _a, props = __rest(_a, ["hasGutter", "isWrappable", "className", "children", "component"]);
  const Component = component;
  return react.createElement(Component, Object.assign({}, props, {className: css(styles$D.split, hasGutter && styles$D.modifiers.gutter, isWrappable && styles$D.modifiers.wrap, className)}), children2);
};
Split.displayName = "Split";
var SplitItem = (_a) => {
  var {isFilled = false, className = "", children: children2 = null} = _a, props = __rest(_a, ["isFilled", "className", "children"]);
  return react.createElement("div", Object.assign({}, props, {className: css(styles$D.splitItem, isFilled && styles$D.modifiers.fill, className)}), children2);
};
SplitItem.displayName = "SplitItem";
var stack = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    modifiers: {
      fill: "pf-m-fill",
      gutter: "pf-m-gutter"
    },
    stack: "pf-l-stack",
    stackItem: "pf-l-stack__item"
  };
});
var styles$E = /* @__PURE__ */ getDefaultExportFromCjs(stack);
var Stack = (_a) => {
  var {hasGutter = false, className = "", children: children2 = null, component = "div"} = _a, props = __rest(_a, ["hasGutter", "className", "children", "component"]);
  const Component = component;
  return react.createElement(Component, Object.assign({}, props, {className: css(styles$E.stack, hasGutter && styles$E.modifiers.gutter, className)}), children2);
};
Stack.displayName = "Stack";
var StackItem = (_a) => {
  var {isFilled = false, className = "", children: children2 = null} = _a, props = __rest(_a, ["isFilled", "className", "children"]);
  return react.createElement("div", Object.assign({}, props, {className: css(styles$E.stackItem, isFilled && styles$E.modifiers.fill, className)}), children2);
};
StackItem.displayName = "StackItem";

// build/_snowpack/pkg/common/setPrototypeOf-adc775f4.js
function _setPrototypeOf(o, p3) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf3(o2, p4) {
    o2.__proto__ = p4;
    return o2;
  };
  return _setPrototypeOf(o, p3);
}

// build/_snowpack/pkg/common/inheritsLoose-978d85dc.js
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

// build/_snowpack/pkg/common/react-router-c9e8158c.js
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source2 = arguments[i3];
      for (var key in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key)) {
          target[key] = source2[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function isAbsolute(pathname) {
  return pathname.charAt(0) === "/";
}
function spliceOne(list3, index3) {
  for (var i3 = index3, k3 = i3 + 1, n4 = list3.length; k3 < n4; i3 += 1, k3 += 1) {
    list3[i3] = list3[k3];
  }
  list3.pop();
}
function resolvePathname(to, from) {
  if (from === void 0)
    from = "";
  var toParts = to && to.split("/") || [];
  var fromParts = from && from.split("/") || [];
  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;
  if (to && isAbsolute(to)) {
    fromParts = toParts;
  } else if (toParts.length) {
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }
  if (!fromParts.length)
    return "/";
  var hasTrailingSlash;
  if (fromParts.length) {
    var last2 = fromParts[fromParts.length - 1];
    hasTrailingSlash = last2 === "." || last2 === ".." || last2 === "";
  } else {
    hasTrailingSlash = false;
  }
  var up = 0;
  for (var i3 = fromParts.length; i3 >= 0; i3--) {
    var part = fromParts[i3];
    if (part === ".") {
      spliceOne(fromParts, i3);
    } else if (part === "..") {
      spliceOne(fromParts, i3);
      up++;
    } else if (up) {
      spliceOne(fromParts, i3);
      up--;
    }
  }
  if (!mustEndAbs)
    for (; up--; up)
      fromParts.unshift("..");
  if (mustEndAbs && fromParts[0] !== "" && (!fromParts[0] || !isAbsolute(fromParts[0])))
    fromParts.unshift("");
  var result = fromParts.join("/");
  if (hasTrailingSlash && result.substr(-1) !== "/")
    result += "/";
  return result;
}
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  {
    throw new Error(prefix);
  }
}
function addLeadingSlash(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
}
function stripLeadingSlash(path) {
  return path.charAt(0) === "/" ? path.substr(1) : path;
}
function hasBasename(path, prefix2) {
  return path.toLowerCase().indexOf(prefix2.toLowerCase()) === 0 && "/?#".indexOf(path.charAt(prefix2.length)) !== -1;
}
function stripBasename(path, prefix2) {
  return hasBasename(path, prefix2) ? path.substr(prefix2.length) : path;
}
function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === "/" ? path.slice(0, -1) : path;
}
function parsePath(path) {
  var pathname = path || "/";
  var search = "";
  var hash2 = "";
  var hashIndex = pathname.indexOf("#");
  if (hashIndex !== -1) {
    hash2 = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }
  var searchIndex = pathname.indexOf("?");
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }
  return {
    pathname,
    search: search === "?" ? "" : search,
    hash: hash2 === "#" ? "" : hash2
  };
}
function createPath(location2) {
  var pathname = location2.pathname, search = location2.search, hash2 = location2.hash;
  var path = pathname || "/";
  if (search && search !== "?")
    path += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#")
    path += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return path;
}
function createLocation(path, state, key, currentLocation) {
  var location2;
  if (typeof path === "string") {
    location2 = parsePath(path);
    location2.state = state;
  } else {
    location2 = _extends2({}, path);
    if (location2.pathname === void 0)
      location2.pathname = "";
    if (location2.search) {
      if (location2.search.charAt(0) !== "?")
        location2.search = "?" + location2.search;
    } else {
      location2.search = "";
    }
    if (location2.hash) {
      if (location2.hash.charAt(0) !== "#")
        location2.hash = "#" + location2.hash;
    } else {
      location2.hash = "";
    }
    if (state !== void 0 && location2.state === void 0)
      location2.state = state;
  }
  try {
    location2.pathname = decodeURI(location2.pathname);
  } catch (e3) {
    if (e3 instanceof URIError) {
      throw new URIError('Pathname "' + location2.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.');
    } else {
      throw e3;
    }
  }
  if (key)
    location2.key = key;
  if (currentLocation) {
    if (!location2.pathname) {
      location2.pathname = currentLocation.pathname;
    } else if (location2.pathname.charAt(0) !== "/") {
      location2.pathname = resolvePathname(location2.pathname, currentLocation.pathname);
    }
  } else {
    if (!location2.pathname) {
      location2.pathname = "/";
    }
  }
  return location2;
}
function createTransitionManager() {
  var prompt = null;
  function setPrompt(nextPrompt) {
    prompt = nextPrompt;
    return function() {
      if (prompt === nextPrompt)
        prompt = null;
    };
  }
  function confirmTransitionTo(location2, action, getUserConfirmation, callback) {
    if (prompt != null) {
      var result = typeof prompt === "function" ? prompt(location2, action) : prompt;
      if (typeof result === "string") {
        if (typeof getUserConfirmation === "function") {
          getUserConfirmation(result, callback);
        } else {
          callback(true);
        }
      } else {
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  }
  var listeners = [];
  function appendListener(fn) {
    var isActive = true;
    function listener() {
      if (isActive)
        fn.apply(void 0, arguments);
    }
    listeners.push(listener);
    return function() {
      isActive = false;
      listeners = listeners.filter(function(item) {
        return item !== listener;
      });
    };
  }
  function notifyListeners() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    listeners.forEach(function(listener) {
      return listener.apply(void 0, args);
    });
  }
  return {
    setPrompt,
    confirmTransitionTo,
    appendListener,
    notifyListeners
  };
}
var canUseDOM2 = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function getConfirmation(message, callback) {
  callback(window.confirm(message));
}
function supportsHistory() {
  var ua2 = window.navigator.userAgent;
  if ((ua2.indexOf("Android 2.") !== -1 || ua2.indexOf("Android 4.0") !== -1) && ua2.indexOf("Mobile Safari") !== -1 && ua2.indexOf("Chrome") === -1 && ua2.indexOf("Windows Phone") === -1)
    return false;
  return window.history && "pushState" in window.history;
}
function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf("Trident") === -1;
}
function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf("Firefox") === -1;
}
function isExtraneousPopstateEvent(event) {
  return event.state === void 0 && navigator.userAgent.indexOf("CriOS") === -1;
}
var PopStateEvent = "popstate";
var HashChangeEvent = "hashchange";
function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e3) {
    return {};
  }
}
function createBrowserHistory(props) {
  if (props === void 0) {
    props = {};
  }
  !canUseDOM2 ? invariant(false) : void 0;
  var globalHistory = window.history;
  var canUseHistory = supportsHistory();
  var needsHashChangeListener = !supportsPopStateOnHashChange();
  var _props = props, _props$forceRefresh = _props.forceRefresh, forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : "";
  function getDOMLocation(historyState) {
    var _ref = historyState || {}, key = _ref.key, state = _ref.state;
    var _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash2 = _window$location.hash;
    var path = pathname + search + hash2;
    if (basename)
      path = stripBasename(path, basename);
    return createLocation(path, state, key);
  }
  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends2(history, nextState);
    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  function handlePopState(event) {
    if (isExtraneousPopstateEvent(event))
      return;
    handlePop(getDOMLocation(event.state));
  }
  function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  }
  var forceNextPop = false;
  function handlePop(location2) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = "POP";
      transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
        if (ok2) {
          setState({
            action,
            location: location2
          });
        } else {
          revertPop(location2);
        }
      });
    }
  }
  function revertPop(fromLocation) {
    var toLocation = history.location;
    var toIndex = allKeys.indexOf(toLocation.key);
    if (toIndex === -1)
      toIndex = 0;
    var fromIndex = allKeys.indexOf(fromLocation.key);
    if (fromIndex === -1)
      fromIndex = 0;
    var delta = toIndex - fromIndex;
    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }
  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];
  function createHref(location2) {
    return basename + createPath(location2);
  }
  function push(path, state) {
    var action = "PUSH";
    var location2 = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var href = createHref(location2);
      var key = location2.key, state2 = location2.state;
      if (canUseHistory) {
        globalHistory.pushState({
          key,
          state: state2
        }, null, href);
        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex + 1);
          nextKeys.push(location2.key);
          allKeys = nextKeys;
          setState({
            action,
            location: location2
          });
        }
      } else {
        window.location.href = href;
      }
    });
  }
  function replace(path, state) {
    var action = "REPLACE";
    var location2 = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var href = createHref(location2);
      var key = location2.key, state2 = location2.state;
      if (canUseHistory) {
        globalHistory.replaceState({
          key,
          state: state2
        }, null, href);
        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          if (prevIndex !== -1)
            allKeys[prevIndex] = location2.key;
          setState({
            action,
            location: location2
          });
        }
      } else {
        window.location.replace(href);
      }
    });
  }
  function go(n4) {
    globalHistory.go(n4);
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  var listenerCount = 0;
  function checkDOMListeners(delta) {
    listenerCount += delta;
    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener)
        window.addEventListener(HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener)
        window.removeEventListener(HashChangeEvent, handleHashChange);
    }
  }
  var isBlocked = false;
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    var unblock = transitionManager.setPrompt(prompt);
    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }
    return function() {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }
      return unblock();
    };
  }
  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function() {
      checkDOMListeners(-1);
      unlisten();
    };
  }
  var history = {
    length: globalHistory.length,
    action: "POP",
    location: initialLocation,
    createHref,
    push,
    replace,
    go,
    goBack,
    goForward,
    block,
    listen
  };
  return history;
}
var HashChangeEvent$1 = "hashchange";
var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === "!" ? path : "!/" + stripLeadingSlash(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === "!" ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash
  },
  slash: {
    encodePath: addLeadingSlash,
    decodePath: addLeadingSlash
  }
};
function stripHash(url) {
  var hashIndex = url.indexOf("#");
  return hashIndex === -1 ? url : url.slice(0, hashIndex);
}
function getHashPath() {
  var href = window.location.href;
  var hashIndex = href.indexOf("#");
  return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
}
function pushHashPath(path) {
  window.location.hash = path;
}
function replaceHashPath(path) {
  window.location.replace(stripHash(window.location.href) + "#" + path);
}
function createHashHistory(props) {
  if (props === void 0) {
    props = {};
  }
  !canUseDOM2 ? invariant(false) : void 0;
  var globalHistory = window.history;
  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();
  var _props = props, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$hashType = _props.hashType, hashType = _props$hashType === void 0 ? "slash" : _props$hashType;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : "";
  var _HashPathCoders$hashT = HashPathCoders[hashType], encodePath2 = _HashPathCoders$hashT.encodePath, decodePath2 = _HashPathCoders$hashT.decodePath;
  function getDOMLocation() {
    var path2 = decodePath2(getHashPath());
    if (basename)
      path2 = stripBasename(path2, basename);
    return createLocation(path2);
  }
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends2(history, nextState);
    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  var forceNextPop = false;
  var ignorePath = null;
  function locationsAreEqual$$1(a2, b3) {
    return a2.pathname === b3.pathname && a2.search === b3.search && a2.hash === b3.hash;
  }
  function handleHashChange() {
    var path2 = getHashPath();
    var encodedPath2 = encodePath2(path2);
    if (path2 !== encodedPath2) {
      replaceHashPath(encodedPath2);
    } else {
      var location2 = getDOMLocation();
      var prevLocation = history.location;
      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location2))
        return;
      if (ignorePath === createPath(location2))
        return;
      ignorePath = null;
      handlePop(location2);
    }
  }
  function handlePop(location2) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = "POP";
      transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
        if (ok2) {
          setState({
            action,
            location: location2
          });
        } else {
          revertPop(location2);
        }
      });
    }
  }
  function revertPop(fromLocation) {
    var toLocation = history.location;
    var toIndex = allPaths.lastIndexOf(createPath(toLocation));
    if (toIndex === -1)
      toIndex = 0;
    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
    if (fromIndex === -1)
      fromIndex = 0;
    var delta = toIndex - fromIndex;
    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }
  var path = getHashPath();
  var encodedPath = encodePath2(path);
  if (path !== encodedPath)
    replaceHashPath(encodedPath);
  var initialLocation = getDOMLocation();
  var allPaths = [createPath(initialLocation)];
  function createHref(location2) {
    var baseTag = document.querySelector("base");
    var href = "";
    if (baseTag && baseTag.getAttribute("href")) {
      href = stripHash(window.location.href);
    }
    return href + "#" + encodePath2(basename + createPath(location2));
  }
  function push(path2, state) {
    var action = "PUSH";
    var location2 = createLocation(path2, void 0, void 0, history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var path3 = createPath(location2);
      var encodedPath2 = encodePath2(basename + path3);
      var hashChanged = getHashPath() !== encodedPath2;
      if (hashChanged) {
        ignorePath = path3;
        pushHashPath(encodedPath2);
        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
        var nextPaths = allPaths.slice(0, prevIndex + 1);
        nextPaths.push(path3);
        allPaths = nextPaths;
        setState({
          action,
          location: location2
        });
      } else {
        setState();
      }
    });
  }
  function replace(path2, state) {
    var action = "REPLACE";
    var location2 = createLocation(path2, void 0, void 0, history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var path3 = createPath(location2);
      var encodedPath2 = encodePath2(basename + path3);
      var hashChanged = getHashPath() !== encodedPath2;
      if (hashChanged) {
        ignorePath = path3;
        replaceHashPath(encodedPath2);
      }
      var prevIndex = allPaths.indexOf(createPath(history.location));
      if (prevIndex !== -1)
        allPaths[prevIndex] = path3;
      setState({
        action,
        location: location2
      });
    });
  }
  function go(n4) {
    globalHistory.go(n4);
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  var listenerCount = 0;
  function checkDOMListeners(delta) {
    listenerCount += delta;
    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(HashChangeEvent$1, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(HashChangeEvent$1, handleHashChange);
    }
  }
  var isBlocked = false;
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    var unblock = transitionManager.setPrompt(prompt);
    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }
    return function() {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }
      return unblock();
    };
  }
  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function() {
      checkDOMListeners(-1);
      unlisten();
    };
  }
  var history = {
    length: globalHistory.length,
    action: "POP",
    location: initialLocation,
    createHref,
    push,
    replace,
    go,
    goBack,
    goForward,
    block,
    listen
  };
  return history;
}
function clamp(n4, lowerBound, upperBound) {
  return Math.min(Math.max(n4, lowerBound), upperBound);
}
function createMemoryHistory(props) {
  if (props === void 0) {
    props = {};
  }
  var _props = props, getUserConfirmation = _props.getUserConfirmation, _props$initialEntries = _props.initialEntries, initialEntries = _props$initialEntries === void 0 ? ["/"] : _props$initialEntries, _props$initialIndex = _props.initialIndex, initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends2(history, nextState);
    history.length = history.entries.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }
  var index3 = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function(entry) {
    return typeof entry === "string" ? createLocation(entry, void 0, createKey()) : createLocation(entry, void 0, entry.key || createKey());
  });
  var createHref = createPath;
  function push(path, state) {
    var action = "PUSH";
    var location2 = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;
      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location2);
      } else {
        nextEntries.push(location2);
      }
      setState({
        action,
        location: location2,
        index: nextIndex,
        entries: nextEntries
      });
    });
  }
  function replace(path, state) {
    var action = "REPLACE";
    var location2 = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      history.entries[history.index] = location2;
      setState({
        action,
        location: location2
      });
    });
  }
  function go(n4) {
    var nextIndex = clamp(history.index + n4, 0, history.entries.length - 1);
    var action = "POP";
    var location2 = history.entries[nextIndex];
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (ok2) {
        setState({
          action,
          location: location2,
          index: nextIndex
        });
      } else {
        setState();
      }
    });
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  function canGo(n4) {
    var nextIndex = history.index + n4;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  }
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    return transitionManager.setPrompt(prompt);
  }
  function listen(listener) {
    return transitionManager.appendListener(listener);
  }
  var history = {
    length: entries.length,
    action: "POP",
    location: entries[index3],
    index: index3,
    entries,
    createHref,
    push,
    replace,
    go,
    goBack,
    goForward,
    canGo,
    block,
    listen
  };
  return history;
}
var MAX_SIGNED_31_BIT_INT = 1073741823;
var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
function getUniqueId2() {
  var key = "__global_unique_id__";
  return commonjsGlobal2[key] = (commonjsGlobal2[key] || 0) + 1;
}
function objectIs(x3, y4) {
  if (x3 === y4) {
    return x3 !== 0 || 1 / x3 === 1 / y4;
  } else {
    return x3 !== x3 && y4 !== y4;
  }
}
function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on2(handler) {
      handlers.push(handler);
    },
    off: function off2(handler) {
      handlers = handlers.filter(function(h3) {
        return h3 !== handler;
      });
    },
    get: function get5() {
      return value;
    },
    set: function set3(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function(handler) {
        return handler(value, changedBits);
      });
    }
  };
}
function onlyChild(children2) {
  return Array.isArray(children2) ? children2[0] : children2;
}
function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;
  var contextProp = "__create-react-context-" + getUniqueId2() + "__";
  var Provider3 = /* @__PURE__ */ function(_Component) {
    _inheritsLoose(Provider4, _Component);
    function Provider4() {
      var _this;
      _this = _Component.apply(this, arguments) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }
    var _proto = Provider4.prototype;
    _proto.getChildContext = function getChildContext() {
      var _ref;
      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };
    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;
        if (objectIs(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === "function" ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
          changedBits |= 0;
          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };
    _proto.render = function render4() {
      return this.props.children;
    };
    return Provider4;
  }(react.Component);
  Provider3.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = propTypes.object.isRequired, _Provider$childContex);
  var Consumer = /* @__PURE__ */ function(_Component2) {
    _inheritsLoose(Consumer2, _Component2);
    function Consumer2() {
      var _this2;
      _this2 = _Component2.apply(this, arguments) || this;
      _this2.state = {
        value: _this2.getValue()
      };
      _this2.onUpdate = function(newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;
        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };
      return _this2;
    }
    var _proto2 = Consumer2.prototype;
    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }
      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };
    _proto2.getValue = function getValue2() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };
    _proto2.render = function render4() {
      return onlyChild(this.props.children)(this.state.value);
    };
    return Consumer2;
  }(react.Component);
  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = propTypes.object, _Consumer$contextType);
  return {
    Provider: Provider3,
    Consumer
  };
}
var index = react.createContext || createReactContext;
var isarray = Array.isArray || function(arr) {
  return Object.prototype.toString.call(arr) == "[object Array]";
};
var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;
var PATH_REGEXP = new RegExp([
  "(\\\\.)",
  "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"
].join("|"), "g");
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index3 = 0;
  var path = "";
  var defaultDelimiter = options && options.delimiter || "/";
  var res;
  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m3 = res[0];
    var escaped = res[1];
    var offset2 = res.index;
    path += str.slice(index3, offset2);
    index3 = offset2 + m3.length;
    if (escaped) {
      path += escaped[1];
      continue;
    }
    var next = str[index3];
    var prefix2 = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];
    if (path) {
      tokens.push(path);
      path = "";
    }
    var partial = prefix2 != null && next != null && next !== prefix2;
    var repeat = modifier === "+" || modifier === "*";
    var optional = modifier === "?" || modifier === "*";
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;
    tokens.push({
      name: name || key++,
      prefix: prefix2 || "",
      delimiter,
      optional,
      repeat,
      partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? ".*" : "[^" + escapeString(delimiter) + "]+?"
    });
  }
  if (index3 < str.length) {
    path += str.substr(index3);
  }
  if (path) {
    tokens.push(path);
  }
  return tokens;
}
function compile(str, options) {
  return tokensToFunction(parse(str, options), options);
}
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function(c4) {
    return "%" + c4.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function(c4) {
    return "%" + c4.charCodeAt(0).toString(16).toUpperCase();
  });
}
function tokensToFunction(tokens, options) {
  var matches2 = new Array(tokens.length);
  for (var i3 = 0; i3 < tokens.length; i3++) {
    if (typeof tokens[i3] === "object") {
      matches2[i3] = new RegExp("^(?:" + tokens[i3].pattern + ")$", flags(options));
    }
  }
  return function(obj, opts) {
    var path = "";
    var data = obj || {};
    var options2 = opts || {};
    var encode2 = options2.pretty ? encodeURIComponentPretty : encodeURIComponent;
    for (var i4 = 0; i4 < tokens.length; i4++) {
      var token2 = tokens[i4];
      if (typeof token2 === "string") {
        path += token2;
        continue;
      }
      var value = data[token2.name];
      var segment;
      if (value == null) {
        if (token2.optional) {
          if (token2.partial) {
            path += token2.prefix;
          }
          continue;
        } else {
          throw new TypeError('Expected "' + token2.name + '" to be defined');
        }
      }
      if (isarray(value)) {
        if (!token2.repeat) {
          throw new TypeError('Expected "' + token2.name + '" to not repeat, but received `' + JSON.stringify(value) + "`");
        }
        if (value.length === 0) {
          if (token2.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token2.name + '" to not be empty');
          }
        }
        for (var j = 0; j < value.length; j++) {
          segment = encode2(value[j]);
          if (!matches2[i4].test(segment)) {
            throw new TypeError('Expected all "' + token2.name + '" to match "' + token2.pattern + '", but received `' + JSON.stringify(segment) + "`");
          }
          path += (j === 0 ? token2.prefix : token2.delimiter) + segment;
        }
        continue;
      }
      segment = token2.asterisk ? encodeAsterisk(value) : encode2(value);
      if (!matches2[i4].test(segment)) {
        throw new TypeError('Expected "' + token2.name + '" to match "' + token2.pattern + '", but received "' + segment + '"');
      }
      path += token2.prefix + segment;
    }
    return path;
  };
}
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
}
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, "\\$1");
}
function attachKeys(re2, keys2) {
  re2.keys = keys2;
  return re2;
}
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
function regexpToRegexp(path, keys2) {
  var groups2 = path.source.match(/\((?!\?)/g);
  if (groups2) {
    for (var i3 = 0; i3 < groups2.length; i3++) {
      keys2.push({
        name: i3,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }
  return attachKeys(path, keys2);
}
function arrayToRegexp(path, keys2, options) {
  var parts = [];
  for (var i3 = 0; i3 < path.length; i3++) {
    parts.push(pathToRegexp(path[i3], keys2, options).source);
  }
  var regexp = new RegExp("(?:" + parts.join("|") + ")", flags(options));
  return attachKeys(regexp, keys2);
}
function stringToRegexp(path, keys2, options) {
  return tokensToRegExp(parse(path, options), keys2, options);
}
function tokensToRegExp(tokens, keys2, options) {
  if (!isarray(keys2)) {
    options = keys2 || options;
    keys2 = [];
  }
  options = options || {};
  var strict = options.strict;
  var end2 = options.end !== false;
  var route = "";
  for (var i3 = 0; i3 < tokens.length; i3++) {
    var token2 = tokens[i3];
    if (typeof token2 === "string") {
      route += escapeString(token2);
    } else {
      var prefix2 = escapeString(token2.prefix);
      var capture = "(?:" + token2.pattern + ")";
      keys2.push(token2);
      if (token2.repeat) {
        capture += "(?:" + prefix2 + capture + ")*";
      }
      if (token2.optional) {
        if (!token2.partial) {
          capture = "(?:" + prefix2 + "(" + capture + "))?";
        } else {
          capture = prefix2 + "(" + capture + ")?";
        }
      } else {
        capture = prefix2 + "(" + capture + ")";
      }
      route += capture;
    }
  }
  var delimiter = escapeString(options.delimiter || "/");
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + "(?:" + delimiter + "(?=$))?";
  }
  if (end2) {
    route += "$";
  } else {
    route += strict && endsWithDelimiter ? "" : "(?=" + delimiter + "|$)";
  }
  return attachKeys(new RegExp("^" + route, flags(options)), keys2);
}
function pathToRegexp(path, keys2, options) {
  if (!isarray(keys2)) {
    options = keys2 || options;
    keys2 = [];
  }
  options = options || {};
  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys2);
  }
  if (isarray(path)) {
    return arrayToRegexp(path, keys2, options);
  }
  return stringToRegexp(path, keys2, options);
}
pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = typeof Symbol === "function" && Symbol.for;
var c = b ? Symbol.for("react.element") : 60103;
var d = b ? Symbol.for("react.portal") : 60106;
var e = b ? Symbol.for("react.fragment") : 60107;
var f = b ? Symbol.for("react.strict_mode") : 60108;
var g = b ? Symbol.for("react.profiler") : 60114;
var h = b ? Symbol.for("react.provider") : 60109;
var k = b ? Symbol.for("react.context") : 60110;
var l = b ? Symbol.for("react.async_mode") : 60111;
var m = b ? Symbol.for("react.concurrent_mode") : 60111;
var n = b ? Symbol.for("react.forward_ref") : 60112;
var p = b ? Symbol.for("react.suspense") : 60113;
var q = b ? Symbol.for("react.suspense_list") : 60120;
var r = b ? Symbol.for("react.memo") : 60115;
var t = b ? Symbol.for("react.lazy") : 60116;
var v = b ? Symbol.for("react.block") : 60121;
var w = b ? Symbol.for("react.fundamental") : 60117;
var x = b ? Symbol.for("react.responder") : 60118;
var y2 = b ? Symbol.for("react.scope") : 60119;
function z(a2) {
  if (typeof a2 === "object" && a2 !== null) {
    var u = a2.$$typeof;
    switch (u) {
      case c:
        switch (a2 = a2.type, a2) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k:
              case n:
              case t:
              case r:
              case h:
                return a2;
              default:
                return u;
            }
        }
      case d:
        return u;
    }
  }
}
function A(a2) {
  return z(a2) === m;
}
var AsyncMode = l;
var ConcurrentMode = m;
var ContextConsumer = k;
var ContextProvider = h;
var Element2 = c;
var ForwardRef = n;
var Fragment2 = e;
var Lazy = t;
var Memo = r;
var Portal = d;
var Profiler = g;
var StrictMode2 = f;
var Suspense = p;
var isAsyncMode = function(a2) {
  return A(a2) || z(a2) === l;
};
var isConcurrentMode = A;
var isContextConsumer = function(a2) {
  return z(a2) === k;
};
var isContextProvider = function(a2) {
  return z(a2) === h;
};
var isElement2 = function(a2) {
  return typeof a2 === "object" && a2 !== null && a2.$$typeof === c;
};
var isForwardRef = function(a2) {
  return z(a2) === n;
};
var isFragment = function(a2) {
  return z(a2) === e;
};
var isLazy = function(a2) {
  return z(a2) === t;
};
var isMemo = function(a2) {
  return z(a2) === r;
};
var isPortal = function(a2) {
  return z(a2) === d;
};
var isProfiler = function(a2) {
  return z(a2) === g;
};
var isStrictMode = function(a2) {
  return z(a2) === f;
};
var isSuspense = function(a2) {
  return z(a2) === p;
};
var isValidElementType = function(a2) {
  return typeof a2 === "string" || typeof a2 === "function" || a2 === e || a2 === m || a2 === g || a2 === f || a2 === p || a2 === q || typeof a2 === "object" && a2 !== null && (a2.$$typeof === t || a2.$$typeof === r || a2.$$typeof === h || a2.$$typeof === k || a2.$$typeof === n || a2.$$typeof === w || a2.$$typeof === x || a2.$$typeof === y2 || a2.$$typeof === v);
};
var typeOf = z;
var reactIs_production_min = {
  AsyncMode,
  ConcurrentMode,
  ContextConsumer,
  ContextProvider,
  Element: Element2,
  ForwardRef,
  Fragment: Fragment2,
  Lazy,
  Memo,
  Portal,
  Profiler,
  StrictMode: StrictMode2,
  Suspense,
  isAsyncMode,
  isConcurrentMode,
  isContextConsumer,
  isContextProvider,
  isElement: isElement2,
  isForwardRef,
  isFragment,
  isLazy,
  isMemo,
  isPortal,
  isProfiler,
  isStrictMode,
  isSuspense,
  isValidElementType,
  typeOf
};
var reactIs = createCommonjsModule(function(module2) {
  {
    module2.exports = reactIs_production_min;
  }
});
function _objectWithoutPropertiesLoose(source2, excluded) {
  if (source2 == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source2);
  var key, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++) {
    key = sourceKeys[i3];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source2[key];
  }
  return target;
}
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = typeof Symbol === "function" && Symbol.for;
var c$1 = b$1 ? Symbol.for("react.element") : 60103;
var d$1 = b$1 ? Symbol.for("react.portal") : 60106;
var e$1 = b$1 ? Symbol.for("react.fragment") : 60107;
var f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108;
var g$1 = b$1 ? Symbol.for("react.profiler") : 60114;
var h$1 = b$1 ? Symbol.for("react.provider") : 60109;
var k$1 = b$1 ? Symbol.for("react.context") : 60110;
var l$1 = b$1 ? Symbol.for("react.async_mode") : 60111;
var m$1 = b$1 ? Symbol.for("react.concurrent_mode") : 60111;
var n$1 = b$1 ? Symbol.for("react.forward_ref") : 60112;
var p$1 = b$1 ? Symbol.for("react.suspense") : 60113;
var q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120;
var r$1 = b$1 ? Symbol.for("react.memo") : 60115;
var t$1 = b$1 ? Symbol.for("react.lazy") : 60116;
var v$1 = b$1 ? Symbol.for("react.block") : 60121;
var w$1 = b$1 ? Symbol.for("react.fundamental") : 60117;
var x$1 = b$1 ? Symbol.for("react.responder") : 60118;
var y$1 = b$1 ? Symbol.for("react.scope") : 60119;
function z$1(a2) {
  if (typeof a2 === "object" && a2 !== null) {
    var u = a2.$$typeof;
    switch (u) {
      case c$1:
        switch (a2 = a2.type, a2) {
          case l$1:
          case m$1:
          case e$1:
          case g$1:
          case f$1:
          case p$1:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$1:
              case n$1:
              case t$1:
              case r$1:
              case h$1:
                return a2;
              default:
                return u;
            }
        }
      case d$1:
        return u;
    }
  }
}
function A$1(a2) {
  return z$1(a2) === m$1;
}
var AsyncMode$1 = l$1;
var ConcurrentMode$1 = m$1;
var ContextConsumer$1 = k$1;
var ContextProvider$1 = h$1;
var Element$1 = c$1;
var ForwardRef$1 = n$1;
var Fragment$1 = e$1;
var Lazy$1 = t$1;
var Memo$1 = r$1;
var Portal$1 = d$1;
var Profiler$1 = g$1;
var StrictMode$1 = f$1;
var Suspense$1 = p$1;
var isAsyncMode$1 = function(a2) {
  return A$1(a2) || z$1(a2) === l$1;
};
var isConcurrentMode$1 = A$1;
var isContextConsumer$1 = function(a2) {
  return z$1(a2) === k$1;
};
var isContextProvider$1 = function(a2) {
  return z$1(a2) === h$1;
};
var isElement$1 = function(a2) {
  return typeof a2 === "object" && a2 !== null && a2.$$typeof === c$1;
};
var isForwardRef$1 = function(a2) {
  return z$1(a2) === n$1;
};
var isFragment$1 = function(a2) {
  return z$1(a2) === e$1;
};
var isLazy$1 = function(a2) {
  return z$1(a2) === t$1;
};
var isMemo$1 = function(a2) {
  return z$1(a2) === r$1;
};
var isPortal$1 = function(a2) {
  return z$1(a2) === d$1;
};
var isProfiler$1 = function(a2) {
  return z$1(a2) === g$1;
};
var isStrictMode$1 = function(a2) {
  return z$1(a2) === f$1;
};
var isSuspense$1 = function(a2) {
  return z$1(a2) === p$1;
};
var isValidElementType$1 = function(a2) {
  return typeof a2 === "string" || typeof a2 === "function" || a2 === e$1 || a2 === m$1 || a2 === g$1 || a2 === f$1 || a2 === p$1 || a2 === q$1 || typeof a2 === "object" && a2 !== null && (a2.$$typeof === t$1 || a2.$$typeof === r$1 || a2.$$typeof === h$1 || a2.$$typeof === k$1 || a2.$$typeof === n$1 || a2.$$typeof === w$1 || a2.$$typeof === x$1 || a2.$$typeof === y$1 || a2.$$typeof === v$1);
};
var typeOf$1 = z$1;
var reactIs_production_min$1 = {
  AsyncMode: AsyncMode$1,
  ConcurrentMode: ConcurrentMode$1,
  ContextConsumer: ContextConsumer$1,
  ContextProvider: ContextProvider$1,
  Element: Element$1,
  ForwardRef: ForwardRef$1,
  Fragment: Fragment$1,
  Lazy: Lazy$1,
  Memo: Memo$1,
  Portal: Portal$1,
  Profiler: Profiler$1,
  StrictMode: StrictMode$1,
  Suspense: Suspense$1,
  isAsyncMode: isAsyncMode$1,
  isConcurrentMode: isConcurrentMode$1,
  isContextConsumer: isContextConsumer$1,
  isContextProvider: isContextProvider$1,
  isElement: isElement$1,
  isForwardRef: isForwardRef$1,
  isFragment: isFragment$1,
  isLazy: isLazy$1,
  isMemo: isMemo$1,
  isPortal: isPortal$1,
  isProfiler: isProfiler$1,
  isStrictMode: isStrictMode$1,
  isSuspense: isSuspense$1,
  isValidElementType: isValidElementType$1,
  typeOf: typeOf$1
};
var reactIs$1 = createCommonjsModule(function(module2) {
  {
    module2.exports = reactIs_production_min$1;
  }
});
var FORWARD_REF_STATICS = {
  $$typeof: true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  $$typeof: true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs$1.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs$1.Memo] = MEMO_STATICS;
var createNamedContext = function createNamedContext2(name) {
  var context2 = index();
  context2.displayName = name;
  return context2;
};
var historyContext = /* @__PURE__ */ createNamedContext("Router-History");
var createNamedContext$1 = function createNamedContext3(name) {
  var context2 = index();
  context2.displayName = name;
  return context2;
};
var context = /* @__PURE__ */ createNamedContext$1("Router");
var Router = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Router2, _React$Component);
  Router2.computeRootMatch = function computeRootMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };
  function Router2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    _this.state = {
      location: props.history.location
    };
    _this._isMounted = false;
    _this._pendingLocation = null;
    if (!props.staticContext) {
      _this.unlisten = props.history.listen(function(location2) {
        if (_this._isMounted) {
          _this.setState({
            location: location2
          });
        } else {
          _this._pendingLocation = location2;
        }
      });
    }
    return _this;
  }
  var _proto = Router2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this._isMounted = true;
    if (this._pendingLocation) {
      this.setState({
        location: this._pendingLocation
      });
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten)
      this.unlisten();
  };
  _proto.render = function render4() {
    return react.createElement(context.Provider, {
      value: {
        history: this.props.history,
        location: this.state.location,
        match: Router2.computeRootMatch(this.state.location.pathname),
        staticContext: this.props.staticContext
      }
    }, react.createElement(historyContext.Provider, {
      children: this.props.children || null,
      value: this.props.history
    }));
  };
  return Router2;
}(react.Component);
var MemoryRouter = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(MemoryRouter2, _React$Component);
  function MemoryRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createMemoryHistory(_this.props);
    return _this;
  }
  var _proto = MemoryRouter2.prototype;
  _proto.render = function render4() {
    return react.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return MemoryRouter2;
}(react.Component);
var Lifecycle = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Lifecycle2, _React$Component);
  function Lifecycle2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Lifecycle2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount)
      this.props.onMount.call(this, this);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate)
      this.props.onUpdate.call(this, this, prevProps);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount)
      this.props.onUnmount.call(this, this);
  };
  _proto.render = function render4() {
    return null;
  };
  return Lifecycle2;
}(react.Component);
var cache2 = {};
var cacheLimit = 1e4;
var cacheCount = 0;
function compilePath(path) {
  if (cache2[path])
    return cache2[path];
  var generator = pathToRegexp_1.compile(path);
  if (cacheCount < cacheLimit) {
    cache2[path] = generator;
    cacheCount++;
  }
  return generator;
}
function generatePath(path, params) {
  if (path === void 0) {
    path = "/";
  }
  if (params === void 0) {
    params = {};
  }
  return path === "/" ? path : compilePath(path)(params, {
    pretty: true
  });
}
var cache$1 = {};
var cacheLimit$1 = 1e4;
var cacheCount$1 = 0;
function compilePath$1(path, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
  if (pathCache[path])
    return pathCache[path];
  var keys2 = [];
  var regexp = pathToRegexp_1(path, keys2, options);
  var result = {
    regexp,
    keys: keys2
  };
  if (cacheCount$1 < cacheLimit$1) {
    pathCache[path] = result;
    cacheCount$1++;
  }
  return result;
}
function matchPath(pathname, options) {
  if (options === void 0) {
    options = {};
  }
  if (typeof options === "string" || Array.isArray(options)) {
    options = {
      path: options
    };
  }
  var _options = options, path = _options.path, _options$exact = _options.exact, exact = _options$exact === void 0 ? false : _options$exact, _options$strict = _options.strict, strict = _options$strict === void 0 ? false : _options$strict, _options$sensitive = _options.sensitive, sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
  var paths = [].concat(path);
  return paths.reduce(function(matched, path2) {
    if (!path2 && path2 !== "")
      return null;
    if (matched)
      return matched;
    var _compilePath = compilePath$1(path2, {
      end: exact,
      strict,
      sensitive
    }), regexp = _compilePath.regexp, keys2 = _compilePath.keys;
    var match = regexp.exec(pathname);
    if (!match)
      return null;
    var url = match[0], values2 = match.slice(1);
    var isExact = pathname === url;
    if (exact && !isExact)
      return null;
    return {
      path: path2,
      url: path2 === "/" && url === "" ? "/" : url,
      isExact,
      params: keys2.reduce(function(memo2, key, index3) {
        memo2[key.name] = values2[index3];
        return memo2;
      }, {})
    };
  }, null);
}
var Route = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Route2, _React$Component);
  function Route2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Route2.prototype;
  _proto.render = function render4() {
    var _this = this;
    return react.createElement(context.Consumer, null, function(context$1) {
      !context$1 ? invariant(false) : void 0;
      var location2 = _this.props.location || context$1.location;
      var match = _this.props.computedMatch ? _this.props.computedMatch : _this.props.path ? matchPath(location2.pathname, _this.props) : context$1.match;
      var props = _extends2({}, context$1, {
        location: location2,
        match
      });
      var _this$props = _this.props, children2 = _this$props.children, component = _this$props.component, render5 = _this$props.render;
      if (Array.isArray(children2) && children2.length === 0) {
        children2 = null;
      }
      return react.createElement(context.Provider, {
        value: props
      }, props.match ? children2 ? typeof children2 === "function" ? children2(props) : children2 : component ? react.createElement(component, props) : render5 ? render5(props) : null : typeof children2 === "function" ? children2(props) : null);
    });
  };
  return Route2;
}(react.Component);
function addLeadingSlash$1(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
}
function addBasename(basename, location2) {
  if (!basename)
    return location2;
  return _extends2({}, location2, {
    pathname: addLeadingSlash$1(basename) + location2.pathname
  });
}
function stripBasename$1(basename, location2) {
  if (!basename)
    return location2;
  var base = addLeadingSlash$1(basename);
  if (location2.pathname.indexOf(base) !== 0)
    return location2;
  return _extends2({}, location2, {
    pathname: location2.pathname.substr(base.length)
  });
}
function createURL(location2) {
  return typeof location2 === "string" ? location2 : createPath(location2);
}
function staticHandler(methodName) {
  return function() {
    invariant(false);
  };
}
function noop() {
}
var StaticRouter = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(StaticRouter2, _React$Component);
  function StaticRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.handlePush = function(location2) {
      return _this.navigateTo(location2, "PUSH");
    };
    _this.handleReplace = function(location2) {
      return _this.navigateTo(location2, "REPLACE");
    };
    _this.handleListen = function() {
      return noop;
    };
    _this.handleBlock = function() {
      return noop;
    };
    return _this;
  }
  var _proto = StaticRouter2.prototype;
  _proto.navigateTo = function navigateTo(location2, action) {
    var _this$props = this.props, _this$props$basename = _this$props.basename, basename = _this$props$basename === void 0 ? "" : _this$props$basename, _this$props$context = _this$props.context, context2 = _this$props$context === void 0 ? {} : _this$props$context;
    context2.action = action;
    context2.location = addBasename(basename, createLocation(location2));
    context2.url = createURL(context2.location);
  };
  _proto.render = function render4() {
    var _this$props2 = this.props, _this$props2$basename = _this$props2.basename, basename = _this$props2$basename === void 0 ? "" : _this$props2$basename, _this$props2$context = _this$props2.context, context2 = _this$props2$context === void 0 ? {} : _this$props2$context, _this$props2$location = _this$props2.location, location2 = _this$props2$location === void 0 ? "/" : _this$props2$location, rest = _objectWithoutPropertiesLoose(_this$props2, ["basename", "context", "location"]);
    var history = {
      createHref: function createHref(path) {
        return addLeadingSlash$1(basename + createURL(path));
      },
      action: "POP",
      location: stripBasename$1(basename, createLocation(location2)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler(),
      goBack: staticHandler(),
      goForward: staticHandler(),
      listen: this.handleListen,
      block: this.handleBlock
    };
    return react.createElement(Router, _extends2({}, rest, {
      history,
      staticContext: context2
    }));
  };
  return StaticRouter2;
}(react.Component);
var Switch2 = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Switch3, _React$Component);
  function Switch3() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Switch3.prototype;
  _proto.render = function render4() {
    var _this = this;
    return react.createElement(context.Consumer, null, function(context2) {
      !context2 ? invariant(false) : void 0;
      var location2 = _this.props.location || context2.location;
      var element, match;
      react.Children.forEach(_this.props.children, function(child) {
        if (match == null && react.isValidElement(child)) {
          element = child;
          var path = child.props.path || child.props.from;
          match = path ? matchPath(location2.pathname, _extends2({}, child.props, {
            path
          })) : context2.match;
        }
      });
      return match ? react.cloneElement(element, {
        location: location2,
        computedMatch: match
      }) : null;
    });
  };
  return Switch3;
}(react.Component);
var useContext2 = react.useContext;
function useHistory() {
  return useContext2(historyContext);
}
function useLocation() {
  return useContext2(context).location;
}
function useParams() {
  var match = useContext2(context).match;
  return match ? match.params : {};
}
function useRouteMatch(path) {
  var location2 = useLocation();
  var match = useContext2(context).match;
  return path ? matchPath(location2.pathname, path) : match;
}

// build/_snowpack/pkg/react-router-dom.js
var BrowserRouter = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(BrowserRouter2, _React$Component);
  function BrowserRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createBrowserHistory(_this.props);
    return _this;
  }
  var _proto = BrowserRouter2.prototype;
  _proto.render = function render4() {
    return react.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return BrowserRouter2;
}(react.Component);
var HashRouter = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(HashRouter2, _React$Component);
  function HashRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createHashHistory(_this.props);
    return _this;
  }
  var _proto = HashRouter2.prototype;
  _proto.render = function render4() {
    return react.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return HashRouter2;
}(react.Component);
var resolveToLocation = function resolveToLocation2(to, currentLocation) {
  return typeof to === "function" ? to(currentLocation) : to;
};
var normalizeToLocation = function normalizeToLocation2(to, currentLocation) {
  return typeof to === "string" ? createLocation(to, null, null, currentLocation) : to;
};
var forwardRefShim = function forwardRefShim2(C) {
  return C;
};
var forwardRef = react.forwardRef;
if (typeof forwardRef === "undefined") {
  forwardRef = forwardRefShim;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
var LinkAnchor = forwardRef(function(_ref, forwardedRef) {
  var innerRef = _ref.innerRef, navigate = _ref.navigate, _onClick = _ref.onClick, rest = _objectWithoutPropertiesLoose(_ref, ["innerRef", "navigate", "onClick"]);
  var target = rest.target;
  var props = _extends2({}, rest, {
    onClick: function onClick(event) {
      try {
        if (_onClick)
          _onClick(event);
      } catch (ex) {
        event.preventDefault();
        throw ex;
      }
      if (!event.defaultPrevented && event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
        event.preventDefault();
        navigate();
      }
    }
  });
  if (forwardRefShim !== forwardRef) {
    props.ref = forwardedRef || innerRef;
  } else {
    props.ref = innerRef;
  }
  return react.createElement("a", props);
});
var Link = forwardRef(function(_ref2, forwardedRef) {
  var _ref2$component = _ref2.component, component = _ref2$component === void 0 ? LinkAnchor : _ref2$component, replace = _ref2.replace, to = _ref2.to, innerRef = _ref2.innerRef, rest = _objectWithoutPropertiesLoose(_ref2, ["component", "replace", "to", "innerRef"]);
  return react.createElement(context.Consumer, null, function(context2) {
    !context2 ? invariant(false) : void 0;
    var history = context2.history;
    var location2 = normalizeToLocation(resolveToLocation(to, context2.location), context2.location);
    var href = location2 ? history.createHref(location2) : "";
    var props = _extends2({}, rest, {
      href,
      navigate: function navigate() {
        var location3 = resolveToLocation(to, context2.location);
        var method = replace ? history.replace : history.push;
        method(location3);
      }
    });
    if (forwardRefShim !== forwardRef) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }
    return react.createElement(component, props);
  });
});
var forwardRefShim$1 = function forwardRefShim3(C) {
  return C;
};
var forwardRef$1 = react.forwardRef;
if (typeof forwardRef$1 === "undefined") {
  forwardRef$1 = forwardRefShim$1;
}
function joinClassnames() {
  for (var _len = arguments.length, classnames2 = new Array(_len), _key = 0; _key < _len; _key++) {
    classnames2[_key] = arguments[_key];
  }
  return classnames2.filter(function(i3) {
    return i3;
  }).join(" ");
}
var NavLink = forwardRef$1(function(_ref, forwardedRef) {
  var _ref$ariaCurrent = _ref["aria-current"], ariaCurrent = _ref$ariaCurrent === void 0 ? "page" : _ref$ariaCurrent, _ref$activeClassName = _ref.activeClassName, activeClassName = _ref$activeClassName === void 0 ? "active" : _ref$activeClassName, activeStyle = _ref.activeStyle, classNameProp = _ref.className, exact = _ref.exact, isActiveProp = _ref.isActive, locationProp = _ref.location, sensitive = _ref.sensitive, strict = _ref.strict, styleProp = _ref.style, to = _ref.to, innerRef = _ref.innerRef, rest = _objectWithoutPropertiesLoose(_ref, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "sensitive", "strict", "style", "to", "innerRef"]);
  return react.createElement(context.Consumer, null, function(context2) {
    !context2 ? invariant(false) : void 0;
    var currentLocation = locationProp || context2.location;
    var toLocation = normalizeToLocation(resolveToLocation(to, currentLocation), currentLocation);
    var path = toLocation.pathname;
    var escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    var match = escapedPath ? matchPath(currentLocation.pathname, {
      path: escapedPath,
      exact,
      sensitive,
      strict
    }) : null;
    var isActive = !!(isActiveProp ? isActiveProp(match, currentLocation) : match);
    var className = isActive ? joinClassnames(classNameProp, activeClassName) : classNameProp;
    var style = isActive ? _extends2({}, styleProp, {}, activeStyle) : styleProp;
    var props = _extends2({
      "aria-current": isActive && ariaCurrent || null,
      className,
      style,
      to: toLocation
    }, rest);
    if (forwardRefShim$1 !== forwardRef$1) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }
    return react.createElement(Link, props);
  });
});

// build/_snowpack/pkg/react-error-boundary.js
var changedArray = function changedArray2(a2, b3) {
  if (a2 === void 0) {
    a2 = [];
  }
  if (b3 === void 0) {
    b3 = [];
  }
  return a2.length !== b3.length || a2.some(function(item, index3) {
    return !Object.is(item, b3[index3]);
  });
};
var initialState = {
  error: null
};
var ErrorBoundary = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(ErrorBoundary2, _React$Component);
  function ErrorBoundary2() {
    var _this;
    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;
    _this.state = initialState;
    _this.updatedWithError = false;
    _this.resetErrorBoundary = function() {
      var _this$props;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);
      _this.reset();
    };
    return _this;
  }
  ErrorBoundary2.getDerivedStateFromError = function getDerivedStateFromError(error2) {
    return {
      error: error2
    };
  };
  var _proto = ErrorBoundary2.prototype;
  _proto.reset = function reset() {
    this.updatedWithError = false;
    this.setState(initialState);
  };
  _proto.componentDidCatch = function componentDidCatch(error2, info2) {
    var _this$props$onError, _this$props2;
    (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error2, info2);
  };
  _proto.componentDidMount = function componentDidMount() {
    var error2 = this.state.error;
    if (error2 !== null) {
      this.updatedWithError = true;
    }
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var error2 = this.state.error;
    var resetKeys = this.props.resetKeys;
    if (error2 !== null && !this.updatedWithError) {
      this.updatedWithError = true;
      return;
    }
    if (error2 !== null && changedArray(prevProps.resetKeys, resetKeys)) {
      var _this$props$onResetKe, _this$props3;
      (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);
      this.reset();
    }
  };
  _proto.render = function render4() {
    var error2 = this.state.error;
    var _this$props4 = this.props, fallbackRender = _this$props4.fallbackRender, FallbackComponent = _this$props4.FallbackComponent, fallback = _this$props4.fallback;
    if (error2 !== null) {
      var _props = {
        error: error2,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (/* @__PURE__ */ react.isValidElement(fallback)) {
        return fallback;
      } else if (typeof fallbackRender === "function") {
        return fallbackRender(_props);
      } else if (FallbackComponent) {
        return /* @__PURE__ */ react.createElement(FallbackComponent, _props);
      } else {
        throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
      }
    }
    return this.props.children;
  };
  return ErrorBoundary2;
}(react.Component);
function useErrorHandler(givenError) {
  var _React$useState = react.useState(null), error2 = _React$useState[0], setError = _React$useState[1];
  if (givenError != null)
    throw givenError;
  if (error2 != null)
    throw error2;
  return setError;
}

// build/_snowpack/pkg/common/help-icon-648fde5d.js
var HelpIconConfig = {
  name: "HelpIcon",
  height: 1024,
  width: 1024,
  svgPath: "M521.3,576 C627.5,576 713.7,502 713.7,413.7 C713.7,325.4 627.6,253.6 521.3,253.6 C366,253.6 334.5,337.7 329.2,407.2 C329.2,414.3 335.2,416 343.5,416 L445,416 C450.5,416 458,415.5 460.8,406.5 C460.8,362.6 582.9,357.1 582.9,413.6 C582.9,441.9 556.2,470.9 521.3,473 C486.4,475.1 447.3,479.8 447.3,521.7 L447.3,553.8 C447.3,570.8 456.1,576 472,576 C487.9,576 521.3,576 521.3,576 M575.3,751.3 L575.3,655.3 C575.313862,651.055109 573.620137,646.982962 570.6,644 C567.638831,640.947672 563.552355,639.247987 559.3,639.29884 L463.3,639.29884 C459.055109,639.286138 454.982962,640.979863 452,644 C448.947672,646.961169 447.247987,651.047645 447.29884,655.3 L447.29884,751.3 C447.286138,755.544891 448.979863,759.617038 452,762.6 C454.961169,765.652328 459.047645,767.352013 463.3,767.30116 L559.3,767.30116 C563.544891,767.313862 567.617038,765.620137 570.6,762.6 C573.659349,759.643612 575.360354,755.553963 575.3,751.3 M512,896 C300.2,896 128,723.9 128,512 C128,300.3 300.2,128 512,128 C723.8,128 896,300.2 896,512 C896,723.8 723.7,896 512,896 M512.1,0 C229.7,0 0,229.8 0,512 C0,794.2 229.8,1024 512.1,1024 C794.4,1024 1024,794.3 1024,512 C1024,229.7 794.4,0 512.1,0",
  yOffset: 0,
  xOffset: 0
};
var HelpIcon = createIcon(HelpIconConfig);

// build/_snowpack/pkg/@patternfly/react-icons.js
var ExternalLinkAltIconConfig = {
  name: "ExternalLinkAltIcon",
  height: 512,
  width: 512,
  svgPath: "M432,320H400a16,16,0,0,0-16,16V448H64V128H208a16,16,0,0,0,16-16V80a16,16,0,0,0-16-16H48A48,48,0,0,0,0,112V464a48,48,0,0,0,48,48H400a48,48,0,0,0,48-48V336A16,16,0,0,0,432,320ZM488,0h-128c-21.37,0-32.05,25.91-17,41l35.73,35.73L135,320.37a24,24,0,0,0,0,34L157.67,377a24,24,0,0,0,34,0L435.28,133.32,471,169c15,15,41,4.5,41-17V24A24,24,0,0,0,488,0Z",
  yOffset: 0,
  xOffset: 0
};
var ExternalLinkAltIcon = createIcon(ExternalLinkAltIconConfig);
var EyeSlashIconConfig = {
  name: "EyeSlashIcon",
  height: 512,
  width: 640,
  svgPath: "M320 400c-75.85 0-137.25-58.71-142.9-133.11L72.2 185.82c-13.79 17.3-26.48 35.59-36.72 55.59a32.35 32.35 0 0 0 0 29.19C89.71 376.41 197.07 448 320 448c26.91 0 52.87-4 77.89-10.46L346 397.39a144.13 144.13 0 0 1-26 2.61zm313.82 58.1l-110.55-85.44a331.25 331.25 0 0 0 81.25-102.07 32.35 32.35 0 0 0 0-29.19C550.29 135.59 442.93 64 320 64a308.15 308.15 0 0 0-147.32 37.7L45.46 3.37A16 16 0 0 0 23 6.18L3.37 31.45A16 16 0 0 0 6.18 53.9l588.36 454.73a16 16 0 0 0 22.46-2.81l19.64-25.27a16 16 0 0 0-2.82-22.45zm-183.72-142l-39.3-30.38A94.75 94.75 0 0 0 416 256a94.76 94.76 0 0 0-121.31-92.21A47.65 47.65 0 0 1 304 192a46.64 46.64 0 0 1-1.54 10l-73.61-56.89A142.31 142.31 0 0 1 320 112a143.92 143.92 0 0 1 144 144c0 21.63-5.29 41.79-13.9 60.11z",
  yOffset: 0,
  xOffset: 0
};
var EyeSlashIcon = createIcon(EyeSlashIconConfig);
var EyeIconConfig = {
  name: "EyeIcon",
  height: 512,
  width: 576,
  svgPath: "M572.52 241.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400a144 144 0 1 1 144-144 143.93 143.93 0 0 1-144 144zm0-240a95.31 95.31 0 0 0-25.31 3.79 47.85 47.85 0 0 1-66.9 66.9A95.78 95.78 0 1 0 288 160z",
  yOffset: 0,
  xOffset: 0
};
var EyeIcon = createIcon(EyeIconConfig);
var CaretUpIconConfig = {
  name: "CaretUpIcon",
  height: 512,
  width: 320,
  svgPath: "M288.662 352H31.338c-17.818 0-26.741-21.543-14.142-34.142l128.662-128.662c7.81-7.81 20.474-7.81 28.284 0l128.662 128.662c12.6 12.599 3.676 34.142-14.142 34.142z",
  yOffset: 0,
  xOffset: 0
};
var CaretUpIcon = createIcon(CaretUpIconConfig);
var CubeIconConfig = {
  name: "CubeIcon",
  height: 512,
  width: 512,
  svgPath: "M239.1 6.3l-208 78c-18.7 7-31.1 25-31.1 45v225.1c0 18.2 10.3 34.8 26.5 42.9l208 104c13.5 6.8 29.4 6.8 42.9 0l208-104c16.3-8.1 26.5-24.8 26.5-42.9V129.3c0-20-12.4-37.9-31.1-44.9l-208-78C262 2.2 250 2.2 239.1 6.3zM256 68.4l192 72v1.1l-192 78-192-78v-1.1l192-72zm32 356V275.5l160-65v133.9l-160 80z",
  yOffset: 0,
  xOffset: 0
};
var CubeIcon = createIcon(CubeIconConfig);
var CubesIconConfig = {
  name: "CubesIcon",
  height: 512,
  width: 512,
  svgPath: "M488.6 250.2L392 214V105.5c0-15-9.3-28.4-23.4-33.7l-100-37.5c-8.1-3.1-17.1-3.1-25.3 0l-100 37.5c-14.1 5.3-23.4 18.7-23.4 33.7V214l-96.6 36.2C9.3 255.5 0 268.9 0 283.9V394c0 13.6 7.7 26.1 19.9 32.2l100 50c10.1 5.1 22.1 5.1 32.2 0l103.9-52 103.9 52c10.1 5.1 22.1 5.1 32.2 0l100-50c12.2-6.1 19.9-18.6 19.9-32.2V283.9c0-15-9.3-28.4-23.4-33.7zM358 214.8l-85 31.9v-68.2l85-37v73.3zM154 104.1l102-38.2 102 38.2v.6l-102 41.4-102-41.4v-.6zm84 291.1l-85 42.5v-79.1l85-38.8v75.4zm0-112l-102 41.4-102-41.4v-.6l102-38.2 102 38.2v.6zm240 112l-85 42.5v-79.1l85-38.8v75.4zm0-112l-102 41.4-102-41.4v-.6l102-38.2 102 38.2v.6z",
  yOffset: 0,
  xOffset: 0
};
var CubesIcon = createIcon(CubesIconConfig);
var DatabaseIconConfig = {
  name: "DatabaseIcon",
  height: 512,
  width: 448,
  svgPath: "M448 73.143v45.714C448 159.143 347.667 192 224 192S0 159.143 0 118.857V73.143C0 32.857 100.333 0 224 0s224 32.857 224 73.143zM448 176v102.857C448 319.143 347.667 352 224 352S0 319.143 0 278.857V176c48.125 33.143 136.208 48.572 224 48.572S399.874 209.143 448 176zm0 160v102.857C448 479.143 347.667 512 224 512S0 479.143 0 438.857V336c48.125 33.143 136.208 48.572 224 48.572S399.874 369.143 448 336z",
  yOffset: 0,
  xOffset: 0
};
var DatabaseIcon = createIcon(DatabaseIconConfig);
var FacebookSquareIconConfig = {
  name: "FacebookSquareIcon",
  height: 512,
  width: 448,
  svgPath: "M400 32H48A48 48 0 0 0 0 80v352a48 48 0 0 0 48 48h137.25V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.27c-30.81 0-40.42 19.12-40.42 38.73V256h68.78l-11 71.69h-57.78V480H400a48 48 0 0 0 48-48V80a48 48 0 0 0-48-48z",
  yOffset: 0,
  xOffset: 0
};
var FacebookSquareIcon = createIcon(FacebookSquareIconConfig);
var FilterIconConfig = {
  name: "FilterIcon",
  height: 512,
  width: 512,
  svgPath: "M487.976 0H24.028C2.71 0-8.047 25.866 7.058 40.971L192 225.941V432c0 7.831 3.821 15.17 10.237 19.662l80 55.98C298.02 518.69 320 507.493 320 487.98V225.941l184.947-184.97C520.021 25.896 509.338 0 487.976 0z",
  yOffset: 0,
  xOffset: 0
};
var FilterIcon = createIcon(FilterIconConfig);
var GithubIconConfig = {
  name: "GithubIcon",
  height: 512,
  width: 496,
  svgPath: "M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z",
  yOffset: 0,
  xOffset: 0
};
var GithubIcon = createIcon(GithubIconConfig);
var GitlabIconConfig = {
  name: "GitlabIcon",
  height: 512,
  width: 512,
  svgPath: "M105.2 24.9c-3.1-8.9-15.7-8.9-18.9 0L29.8 199.7h132c-.1 0-56.6-174.8-56.6-174.8zM.9 287.7c-2.6 8 .3 16.9 7.1 22l247.9 184-226.2-294zm160.8-88l94.3 294 94.3-294zm349.4 88l-28.8-88-226.3 294 247.9-184c6.9-5.1 9.7-14 7.2-22zM425.7 24.9c-3.1-8.9-15.7-8.9-18.9 0l-56.6 174.8h132z",
  yOffset: 0,
  xOffset: 0
};
var GitlabIcon = createIcon(GitlabIconConfig);
var GoogleIconConfig = {
  name: "GoogleIcon",
  height: 512,
  width: 488,
  svgPath: "M488 261.8C488 403.3 391.1 504 248 504 110.8 504 0 393.2 0 256S110.8 8 248 8c66.8 0 123 24.5 166.3 64.9l-67.5 64.9C258.5 52.6 94.3 116.6 94.3 256c0 86.5 69.1 156.6 153.7 156.6 98.2 0 135-70.4 140.8-106.9H248v-85.3h236.1c2.3 12.7 3.9 24.9 3.9 41.4z",
  yOffset: 0,
  xOffset: 0
};
var GoogleIcon = createIcon(GoogleIconConfig);
var LinkedinIconConfig = {
  name: "LinkedinIcon",
  height: 512,
  width: 448,
  svgPath: "M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z",
  yOffset: 0,
  xOffset: 0
};
var LinkedinIcon = createIcon(LinkedinIconConfig);
var MinusCircleIconConfig = {
  name: "MinusCircleIcon",
  height: 512,
  width: 512,
  svgPath: "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zM124 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H124z",
  yOffset: 0,
  xOffset: 0
};
var MinusCircleIcon = createIcon(MinusCircleIconConfig);
var OpenshiftIconConfig = {
  name: "OpenshiftIcon",
  height: 100,
  width: 100,
  svgPath: "M145.7,45.3l-16.1,5.8c0.2,2.6,0.6,5.1,1.3,7.6l15.3-5.6C145.7,50.6,145.5,47.9,145.7,45.3M216.7,27.5c-1.1-2.3-2.4-4.5-3.9-6.6l-16.1,5.8c1.9,1.9,3.4,4.1,4.7,6.4L216.7,27.5zM181.4,23c3.3,1.6,6.2,3.7,8.7,6.2l16.1-5.8c-4.4-6.2-10.5-11.5-17.9-14.9c-22.9-10.7-50.3-0.7-61,22.2c-3.5,7.4-4.8,15.3-4.1,23l16.1-5.8c0.3-3.5,1.1-7,2.7-10.3C148.7,22.5,166.4,16,181.4,23M131.9,58.4l-15.3,5.6c1.4,5.6,3.8,10.8,7.2,15.5l16-5.8C135.8,69.4,133,64.1,131.9,58.4M198.5,52.3c-0.3,3.5-1.1,7-2.7,10.3C188.8,77.5,171,84,156.1,77c-3.3-1.6-6.3-3.7-8.7-6.2l-16,5.8c4.4,6.2,10.5,11.5,17.9,14.9c22.9,10.7,50.3,0.7,61-22.2c3.5-7.4,4.7-15.3,4.1-22.9L198.5,52.3zM202.4,32.7l-15.3,5.6c2.8,5.1,4.2,10.9,3.7,16.8l16-5.8C206.5,43.5,204.9,37.9,202.4,32.7",
  yOffset: 0,
  xOffset: 116
};
var OpenshiftIcon = createIcon(OpenshiftIconConfig);
var PlusCircleIconConfig = {
  name: "PlusCircleIcon",
  height: 512,
  width: 512,
  svgPath: "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92h-92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z",
  yOffset: 0,
  xOffset: 0
};
var PlusCircleIcon = createIcon(PlusCircleIconConfig);
var QuestionCircleIconConfig = {
  name: "QuestionCircleIcon",
  height: 512,
  width: 512,
  svgPath: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zM262.655 90c-54.497 0-89.255 22.957-116.549 63.758-3.536 5.286-2.353 12.415 2.715 16.258l34.699 26.31c5.205 3.947 12.621 3.008 16.665-2.122 17.864-22.658 30.113-35.797 57.303-35.797 20.429 0 45.698 13.148 45.698 32.958 0 14.976-12.363 22.667-32.534 33.976C247.128 238.528 216 254.941 216 296v4c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12v-1.333c0-28.462 83.186-29.647 83.186-106.667 0-58.002-60.165-102-116.531-102zM256 338c-25.365 0-46 20.635-46 46 0 25.364 20.635 46 46 46s46-20.636 46-46c0-25.365-20.635-46-46-46z",
  yOffset: 0,
  xOffset: 0
};
var QuestionCircleIcon = createIcon(QuestionCircleIconConfig);
var StackOverflowIconConfig = {
  name: "StackOverflowIcon",
  height: 512,
  width: 384,
  svgPath: "M290.7 311L95 269.7 86.8 309l195.7 41zm51-87L188.2 95.7l-25.5 30.8 153.5 128.3zm-31.2 39.7L129.2 179l-16.7 36.5L293.7 300zM262 32l-32 24 119.3 160.3 32-24zm20.5 328h-200v39.7h200zm39.7 80H42.7V320h-40v160h359.5V320h-40z",
  yOffset: 0,
  xOffset: 0
};
var StackOverflowIcon = createIcon(StackOverflowIconConfig);
var TableIconConfig = {
  name: "TableIcon",
  height: 512,
  width: 512,
  svgPath: "M464 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zM224 416H64v-96h160v96zm0-160H64v-96h160v96zm224 160H288v-96h160v96zm0-160H288v-96h160v96z",
  yOffset: 0,
  xOffset: 0
};
var TableIcon = createIcon(TableIconConfig);
var TwitterIconConfig = {
  name: "TwitterIcon",
  height: 512,
  width: 512,
  svgPath: "M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z",
  yOffset: 0,
  xOffset: 0
};
var TwitterIcon = createIcon(TwitterIconConfig);
var WarningTriangleIconConfig = {
  name: "WarningTriangleIcon",
  height: 1024,
  width: 1088,
  svgPath: "M1057.10141,663.5 L845.101405,215.4 C787.101405,71.8 665.401405,0 542.901405,0 C420.201405,0 296.701405,71.9 235.001405,215.6 L31.7014051,648.5 C10.4014051,700 -0.0985948775,752.3 0.000697596367,800.8 C0.301405123,924.8 70.2014051,1024 209.101405,1024 L868.401405,1024 C1005.80141,1024 1087.70141,918.6 1088.00215,795.5 C1088.10141,752.4 1078.20141,707.2 1057.10141,663.5 Z M959.401405,800.3 C958.701405,822.9 952.901405,843.5 942.601405,859.7 C926.801405,884.6 902.601405,896.7 868.301405,896.7 L209.101405,896.7 C191.201405,896.7 176.601405,893.8 165.401405,888.2 C157.301405,884 150.801405,878.4 145.401405,870.3 C135.101405,855 129.101405,832 128.401405,805.6 C127.601405,772.8 134.901405,736.5 149.401405,700.5 L353.001405,266.7 C363.201405,242.9 376.101405,221.5 391.101405,203.2 C404.801405,186.6 420.301405,172.4 437.401405,161.1 C469.201405,139.9 505.701405,128.8 542.901405,128.8 C579.701405,128.8 615.401405,139.8 646.001405,160.5 C662.401405,171.6 677.101405,185.4 690.101405,201.6 C704.501405,219.6 716.401405,240.6 725.901405,264 L940.901405,718.9 L941.101405,719.3 L941.301405,719.7 C953.901405,746 960.201405,773.9 959.401405,800.3 Z M586.601405,832 L501.301405,832 C489.501405,831.8 480.201405,821.5 480.001405,808.7 L480.001405,727.3 C480.201405,714.5 489.601405,704.3 501.301405,704 L586.601405,704 C598.401405,704.2 607.701405,714.5 607.901405,727.3 L607.901405,808.7 L608.001405,808.7 C607.701405,821.5 598.301405,831.8 586.601405,832 M639.901405,290.7 L613.201405,610.4 C611.801405,626.9 598.001405,640 581.301405,640 L506.601405,640 C490.001405,640 476.101405,627.2 474.701405,610.7 L448.101405,291 C446.501405,272.3 461.301405,256.3 480.001405,256.3 L608.001405,256 C626.701405,256 641.401405,272 639.901405,290.7",
  yOffset: 0,
  xOffset: 0
};
var WarningTriangleIcon = createIcon(WarningTriangleIconConfig);

// build/_snowpack/pkg/common/unsupportedIterableToArray-5dd32933.js
var arrayLikeToArray = createCommonjsModule(function(module2) {
  function _arrayLikeToArray2(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i3 = 0, arr2 = new Array(len2); i3 < len2; i3++) {
      arr2[i3] = arr[i3];
    }
    return arr2;
  }
  module2.exports = _arrayLikeToArray2;
  module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
});
var unsupportedIterableToArray = createCommonjsModule(function(module2) {
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return arrayLikeToArray(o, minLen);
    var n4 = Object.prototype.toString.call(o).slice(8, -1);
    if (n4 === "Object" && o.constructor)
      n4 = o.constructor.name;
    if (n4 === "Map" || n4 === "Set")
      return Array.from(o);
    if (n4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4))
      return arrayLikeToArray(o, minLen);
  }
  module2.exports = _unsupportedIterableToArray2;
  module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
});

// build/_snowpack/pkg/common/typeof-acae9cd0.js
var _typeof_1 = createCommonjsModule(function(module2) {
  function _typeof4(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      module2.exports = _typeof4 = function _typeof5(obj2) {
        return typeof obj2;
      };
      module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
    } else {
      module2.exports = _typeof4 = function _typeof5(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
      module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
    }
    return _typeof4(obj);
  }
  module2.exports = _typeof4;
  module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
});
var _typeof = /* @__PURE__ */ getDefaultExportFromCjs(_typeof_1);

// build/_snowpack/pkg/react-i18next.js
var objectWithoutPropertiesLoose = createCommonjsModule(function(module2) {
  function _objectWithoutPropertiesLoose3(source2, excluded) {
    if (source2 == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source2);
    var key, i3;
    for (i3 = 0; i3 < sourceKeys.length; i3++) {
      key = sourceKeys[i3];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source2[key];
    }
    return target;
  }
  module2.exports = _objectWithoutPropertiesLoose3;
  module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
});
var objectWithoutProperties = createCommonjsModule(function(module2) {
  function _objectWithoutProperties4(source2, excluded) {
    if (source2 == null)
      return {};
    var target = objectWithoutPropertiesLoose(source2, excluded);
    var key, i3;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source2);
      for (i3 = 0; i3 < sourceSymbolKeys.length; i3++) {
        key = sourceSymbolKeys[i3];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source2, key))
          continue;
        target[key] = source2[key];
      }
    }
    return target;
  }
  module2.exports = _objectWithoutProperties4;
  module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
});
var _objectWithoutProperties2 = /* @__PURE__ */ getDefaultExportFromCjs(objectWithoutProperties);
var defineProperty = createCommonjsModule(function(module2) {
  function _defineProperty7(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  module2.exports = _defineProperty7;
  module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
});
var _defineProperty3 = /* @__PURE__ */ getDefaultExportFromCjs(defineProperty);
var voidElements = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};
var t2 = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
function n2(n4) {
  var r4 = {type: "tag", name: "", voidElement: false, attrs: {}, children: []}, i3 = n4.match(/<\/?([^\s]+?)[/\s>]/);
  if (i3 && (r4.name = i3[1], (voidElements[i3[1]] || n4.charAt(n4.length - 2) === "/") && (r4.voidElement = true), r4.name.startsWith("!--"))) {
    var s2 = n4.indexOf("-->");
    return {type: "comment", comment: s2 !== -1 ? n4.slice(4, s2) : ""};
  }
  for (var a2 = new RegExp(t2), c4 = null; (c4 = a2.exec(n4)) !== null; )
    if (c4[0].trim())
      if (c4[1]) {
        var o = c4[1].trim(), l3 = [o, ""];
        o.indexOf("=") > -1 && (l3 = o.split("=")), r4.attrs[l3[0]] = l3[1], a2.lastIndex--;
      } else
        c4[2] && (r4.attrs[c4[2]] = c4[3].trim().substring(1, c4[3].length - 1));
  return r4;
}
var r2 = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g;
var i2 = /^\s*$/;
var s = Object.create(null);
function a(e3, t4) {
  switch (t4.type) {
    case "text":
      return e3 + t4.content;
    case "tag":
      return e3 += "<" + t4.name + (t4.attrs ? function(e4) {
        var t5 = [];
        for (var n4 in e4)
          t5.push(n4 + '="' + e4[n4] + '"');
        return t5.length ? " " + t5.join(" ") : "";
      }(t4.attrs) : "") + (t4.voidElement ? "/>" : ">"), t4.voidElement ? e3 : e3 + t4.children.reduce(a, "") + "</" + t4.name + ">";
    case "comment":
      return e3 + "<!--" + t4.comment + "-->";
  }
}
var c2 = {parse: function(e3, t4) {
  t4 || (t4 = {}), t4.components || (t4.components = s);
  var a2, c4 = [], o = [], l3 = -1, m3 = false;
  if (e3.indexOf("<") !== 0) {
    var u = e3.indexOf("<");
    c4.push({type: "text", content: u === -1 ? e3 : e3.substring(0, u)});
  }
  return e3.replace(r2, function(r4, s2) {
    if (m3) {
      if (r4 !== "</" + a2.name + ">")
        return;
      m3 = false;
    }
    var u2, f3 = r4.charAt(1) !== "/", h3 = r4.startsWith("<!--"), p3 = s2 + r4.length, d3 = e3.charAt(p3);
    if (h3) {
      var v3 = n2(r4);
      return l3 < 0 ? (c4.push(v3), c4) : ((u2 = o[l3]).children.push(v3), c4);
    }
    if (f3 && (l3++, (a2 = n2(r4)).type === "tag" && t4.components[a2.name] && (a2.type = "component", m3 = true), a2.voidElement || m3 || !d3 || d3 === "<" || a2.children.push({type: "text", content: e3.slice(p3, e3.indexOf("<", p3))}), l3 === 0 && c4.push(a2), (u2 = o[l3 - 1]) && u2.children.push(a2), o[l3] = a2), (!f3 || a2.voidElement) && (l3 > -1 && (a2.voidElement || a2.name === r4.slice(2, -1)) && (l3--, a2 = l3 === -1 ? c4 : o[l3]), !m3 && d3 !== "<" && d3)) {
      u2 = l3 === -1 ? c4 : o[l3].children;
      var x3 = e3.indexOf("<", p3), g3 = e3.slice(p3, x3 === -1 ? void 0 : x3);
      i2.test(g3) && (g3 = " "), (x3 > -1 && l3 + u2.length >= 0 || g3 !== " ") && u2.push({type: "text", content: g3});
    }
  }), c4;
}, stringify: function(e3) {
  return e3.reduce(function(e4, t4) {
    return e4 + a("", t4);
  }, "");
}};
var classCallCheck = createCommonjsModule(function(module2) {
  function _classCallCheck5(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  module2.exports = _classCallCheck5;
  module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
});
var _classCallCheck2 = /* @__PURE__ */ getDefaultExportFromCjs(classCallCheck);
var createClass = createCommonjsModule(function(module2) {
  function _defineProperties3(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass5(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties3(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties3(Constructor, staticProps);
    return Constructor;
  }
  module2.exports = _createClass5;
  module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
});
var _createClass2 = /* @__PURE__ */ getDefaultExportFromCjs(createClass);
function ownKeys2(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys2(Object(source2), true).forEach(function(key) {
        _defineProperty3(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys2(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
var defaultOptions = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true
};
var i18nInstance;
var I18nContext = react.createContext();
function setDefaults() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  defaultOptions = _objectSpread(_objectSpread({}, defaultOptions), options);
}
function getDefaults() {
  return defaultOptions;
}
var ReportNamespaces = function() {
  function ReportNamespaces2() {
    _classCallCheck2(this, ReportNamespaces2);
    this.usedNamespaces = {};
  }
  _createClass2(ReportNamespaces2, [{
    key: "addUsedNamespaces",
    value: function addUsedNamespaces(namespaces2) {
      var _this = this;
      namespaces2.forEach(function(ns) {
        if (!_this.usedNamespaces[ns])
          _this.usedNamespaces[ns] = true;
      });
    }
  }, {
    key: "getUsedNamespaces",
    value: function getUsedNamespaces() {
      return Object.keys(this.usedNamespaces);
    }
  }]);
  return ReportNamespaces2;
}();
function setI18n(instance) {
  i18nInstance = instance;
}
function getI18n() {
  return i18nInstance;
}
var initReactI18next = {
  type: "3rdParty",
  init: function init(instance) {
    setDefaults(instance.options.react);
    setI18n(instance);
  }
};
function warn() {
  if (console && console.warn) {
    var _console;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[0] === "string")
      args[0] = "react-i18next:: ".concat(args[0]);
    (_console = console).warn.apply(_console, args);
  }
}
var alreadyWarned = {};
function warnOnce() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  if (typeof args[0] === "string" && alreadyWarned[args[0]])
    return;
  if (typeof args[0] === "string")
    alreadyWarned[args[0]] = new Date();
  warn.apply(void 0, args);
}
function loadNamespaces(i18n, ns, cb2) {
  i18n.loadNamespaces(ns, function() {
    if (i18n.isInitialized) {
      cb2();
    } else {
      var initialized = function initialized2() {
        setTimeout(function() {
          i18n.off("initialized", initialized2);
        }, 0);
        cb2();
      };
      i18n.on("initialized", initialized);
    }
  });
}
function hasLoadedNamespace(ns, i18n) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!i18n.languages || !i18n.languages.length) {
    warnOnce("i18n.languages were undefined or empty", i18n.languages);
    return true;
  }
  var lng = i18n.languages[0];
  var fallbackLng = i18n.options ? i18n.options.fallbackLng : false;
  var lastLng = i18n.languages[i18n.languages.length - 1];
  if (lng.toLowerCase() === "cimode")
    return true;
  var loadNotPending = function loadNotPending2(l3, n4) {
    var loadState = i18n.services.backendConnector.state["".concat(l3, "|").concat(n4)];
    return loadState === -1 || loadState === 2;
  };
  if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns))
    return false;
  if (i18n.hasResourceBundle(lng, ns))
    return true;
  if (!i18n.services.backendConnector.backend)
    return true;
  if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
    return true;
  return false;
}
var _excluded = ["format"];
var _excluded2 = ["children", "count", "parent", "i18nKey", "tOptions", "values", "defaults", "components", "ns", "i18n", "t"];
function ownKeys$1(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$1(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys$1(Object(source2), true).forEach(function(key) {
        _defineProperty3(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys$1(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
function hasChildren(node, checkLength) {
  if (!node)
    return false;
  var base = node.props ? node.props.children : node.children;
  if (checkLength)
    return base.length > 0;
  return !!base;
}
function getChildren(node) {
  if (!node)
    return [];
  return node && node.children ? node.children : node.props && node.props.children;
}
function hasValidReactChildren(children2) {
  if (Object.prototype.toString.call(children2) !== "[object Array]")
    return false;
  return children2.every(function(child) {
    return react.isValidElement(child);
  });
}
function getAsArray(data) {
  return Array.isArray(data) ? data : [data];
}
function mergeProps(source2, target) {
  var newTarget = _objectSpread$1({}, target);
  newTarget.props = Object.assign(source2.props, target.props);
  return newTarget;
}
function nodesToString(children2, i18nOptions) {
  if (!children2)
    return "";
  var stringNode = "";
  var childrenArray = getAsArray(children2);
  var keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];
  childrenArray.forEach(function(child, childIndex) {
    if (typeof child === "string") {
      stringNode += "".concat(child);
    } else if (react.isValidElement(child)) {
      var childPropsCount = Object.keys(child.props).length;
      var shouldKeepChild = keepArray.indexOf(child.type) > -1;
      var childChildren = child.props.children;
      if (!childChildren && shouldKeepChild && childPropsCount === 0) {
        stringNode += "<".concat(child.type, "/>");
      } else if (!childChildren && (!shouldKeepChild || childPropsCount !== 0)) {
        stringNode += "<".concat(childIndex, "></").concat(childIndex, ">");
      } else if (child.props.i18nIsDynamicList) {
        stringNode += "<".concat(childIndex, "></").concat(childIndex, ">");
      } else if (shouldKeepChild && childPropsCount === 1 && typeof childChildren === "string") {
        stringNode += "<".concat(child.type, ">").concat(childChildren, "</").concat(child.type, ">");
      } else {
        var content2 = nodesToString(childChildren, i18nOptions);
        stringNode += "<".concat(childIndex, ">").concat(content2, "</").concat(childIndex, ">");
      }
    } else if (child === null) {
      warn("Trans: the passed in value is invalid - seems you passed in a null child.");
    } else if (_typeof(child) === "object") {
      var format = child.format, clone2 = _objectWithoutProperties2(child, _excluded);
      var keys2 = Object.keys(clone2);
      if (keys2.length === 1) {
        var value = format ? "".concat(keys2[0], ", ").concat(format) : keys2[0];
        stringNode += "{{".concat(value, "}}");
      } else {
        warn("react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.", child);
      }
    } else {
      warn("Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.", child);
    }
  });
  return stringNode;
}
function renderNodes(children2, targetString, i18n, i18nOptions, combinedTOpts) {
  if (targetString === "")
    return [];
  var keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];
  var emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.join("|")).test(targetString);
  if (!children2 && !emptyChildrenButNeedsHandling)
    return [targetString];
  var data = {};
  function getData(childs) {
    var childrenArray = getAsArray(childs);
    childrenArray.forEach(function(child) {
      if (typeof child === "string")
        return;
      if (hasChildren(child))
        getData(getChildren(child));
      else if (_typeof(child) === "object" && !react.isValidElement(child))
        Object.assign(data, child);
    });
  }
  getData(children2);
  var ast = c2.parse("<0>".concat(targetString, "</0>"));
  var opts = _objectSpread$1(_objectSpread$1({}, data), combinedTOpts);
  function renderInner(child, node, rootReactNode) {
    var childs = getChildren(child);
    var mappedChildren = mapAST(childs, node.children, rootReactNode);
    return hasValidReactChildren(childs) && mappedChildren.length === 0 ? childs : mappedChildren;
  }
  function pushTranslatedJSX(child, inner, mem, i3, isVoid) {
    if (child.dummy)
      child.children = inner;
    mem.push(react.cloneElement(child, _objectSpread$1(_objectSpread$1({}, child.props), {}, {
      key: i3
    }), isVoid ? void 0 : inner));
  }
  function mapAST(reactNode, astNode, rootReactNode) {
    var reactNodes = getAsArray(reactNode);
    var astNodes = getAsArray(astNode);
    return astNodes.reduce(function(mem, node, i3) {
      var translationContent = node.children && node.children[0] && node.children[0].content && i18n.services.interpolator.interpolate(node.children[0].content, opts, i18n.language);
      if (node.type === "tag") {
        var tmp = reactNodes[parseInt(node.name, 10)];
        if (!tmp && rootReactNode.length === 1 && rootReactNode[0][node.name])
          tmp = rootReactNode[0][node.name];
        if (!tmp)
          tmp = {};
        var child = Object.keys(node.attrs).length !== 0 ? mergeProps({
          props: node.attrs
        }, tmp) : tmp;
        var isElement3 = react.isValidElement(child);
        var isValidTranslationWithChildren = isElement3 && hasChildren(node, true) && !node.voidElement;
        var isEmptyTransWithHTML = emptyChildrenButNeedsHandling && _typeof(child) === "object" && child.dummy && !isElement3;
        var isKnownComponent = _typeof(children2) === "object" && children2 !== null && Object.hasOwnProperty.call(children2, node.name);
        if (typeof child === "string") {
          var value = i18n.services.interpolator.interpolate(child, opts, i18n.language);
          mem.push(value);
        } else if (hasChildren(child) || isValidTranslationWithChildren) {
          var inner = renderInner(child, node, rootReactNode);
          pushTranslatedJSX(child, inner, mem, i3);
        } else if (isEmptyTransWithHTML) {
          var _inner = mapAST(reactNodes, node.children, rootReactNode);
          mem.push(react.cloneElement(child, _objectSpread$1(_objectSpread$1({}, child.props), {}, {
            key: i3
          }), _inner));
        } else if (Number.isNaN(parseFloat(node.name))) {
          if (isKnownComponent) {
            var _inner2 = renderInner(child, node, rootReactNode);
            pushTranslatedJSX(child, _inner2, mem, i3, node.voidElement);
          } else if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node.name) > -1) {
            if (node.voidElement) {
              mem.push(react.createElement(node.name, {
                key: "".concat(node.name, "-").concat(i3)
              }));
            } else {
              var _inner3 = mapAST(reactNodes, node.children, rootReactNode);
              mem.push(react.createElement(node.name, {
                key: "".concat(node.name, "-").concat(i3)
              }, _inner3));
            }
          } else if (node.voidElement) {
            mem.push("<".concat(node.name, " />"));
          } else {
            var _inner4 = mapAST(reactNodes, node.children, rootReactNode);
            mem.push("<".concat(node.name, ">").concat(_inner4, "</").concat(node.name, ">"));
          }
        } else if (_typeof(child) === "object" && !isElement3) {
          var content2 = node.children[0] ? translationContent : null;
          if (content2)
            mem.push(content2);
        } else if (node.children.length === 1 && translationContent) {
          mem.push(react.cloneElement(child, _objectSpread$1(_objectSpread$1({}, child.props), {}, {
            key: i3
          }), translationContent));
        } else {
          mem.push(react.cloneElement(child, _objectSpread$1(_objectSpread$1({}, child.props), {}, {
            key: i3
          })));
        }
      } else if (node.type === "text") {
        var wrapTextNodes = i18nOptions.transWrapTextNodes;
        var _content = i18n.services.interpolator.interpolate(node.content, opts, i18n.language);
        if (wrapTextNodes) {
          mem.push(react.createElement(wrapTextNodes, {
            key: "".concat(node.name, "-").concat(i3)
          }, _content));
        } else {
          mem.push(_content);
        }
      }
      return mem;
    }, []);
  }
  var result = mapAST([{
    dummy: true,
    children: children2
  }], ast, getAsArray(children2 || []));
  return getChildren(result[0]);
}
function Trans(_ref) {
  var children2 = _ref.children, count = _ref.count, parent = _ref.parent, i18nKey = _ref.i18nKey, _ref$tOptions = _ref.tOptions, tOptions = _ref$tOptions === void 0 ? {} : _ref$tOptions, values2 = _ref.values, defaults3 = _ref.defaults, components3 = _ref.components, ns = _ref.ns, i18nFromProps = _ref.i18n, tFromProps = _ref.t, additionalProps = _objectWithoutProperties2(_ref, _excluded2);
  var _ref2 = react.useContext(I18nContext) || {}, i18nFromContext = _ref2.i18n, defaultNSFromContext = _ref2.defaultNS;
  var i18n = i18nFromProps || i18nFromContext || getI18n();
  if (!i18n) {
    warnOnce("You will need to pass in an i18next instance by using i18nextReactModule");
    return children2;
  }
  var t4 = tFromProps || i18n.t.bind(i18n) || function(k3) {
    return k3;
  };
  var reactI18nextOptions = _objectSpread$1(_objectSpread$1({}, getDefaults()), i18n.options && i18n.options.react);
  var namespaces2 = ns || t4.ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
  namespaces2 = typeof namespaces2 === "string" ? [namespaces2] : namespaces2 || ["translation"];
  var defaultValue = defaults3 || nodesToString(children2, reactI18nextOptions) || reactI18nextOptions.transEmptyNodeValue || i18nKey;
  var hashTransKey = reactI18nextOptions.hashTransKey;
  var key = i18nKey || (hashTransKey ? hashTransKey(defaultValue) : defaultValue);
  var interpolationOverride = values2 ? tOptions.interpolation : {
    interpolation: _objectSpread$1(_objectSpread$1({}, tOptions.interpolation), {}, {
      prefix: "#$?",
      suffix: "?$#"
    })
  };
  var combinedTOpts = _objectSpread$1(_objectSpread$1(_objectSpread$1(_objectSpread$1({}, tOptions), {}, {
    count
  }, values2), interpolationOverride), {}, {
    defaultValue,
    ns: namespaces2
  });
  var translation = key ? t4(key, combinedTOpts) : defaultValue;
  var content2 = renderNodes(components3 || children2, translation, i18n, reactI18nextOptions, combinedTOpts);
  var useAsParent = parent !== void 0 ? parent : reactI18nextOptions.defaultTransParent;
  return useAsParent ? react.createElement(useAsParent, additionalProps, content2) : content2;
}
var arrayWithHoles = createCommonjsModule(function(module2) {
  function _arrayWithHoles2(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  module2.exports = _arrayWithHoles2;
  module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
});
var iterableToArrayLimit = createCommonjsModule(function(module2) {
  function _iterableToArrayLimit2(arr, i3) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null)
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i3 && _arr.length === i3)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  module2.exports = _iterableToArrayLimit2;
  module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
});
var nonIterableRest = createCommonjsModule(function(module2) {
  function _nonIterableRest2() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  module2.exports = _nonIterableRest2;
  module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
});
var slicedToArray = createCommonjsModule(function(module2) {
  function _slicedToArray3(arr, i3) {
    return arrayWithHoles(arr) || iterableToArrayLimit(arr, i3) || unsupportedIterableToArray(arr, i3) || nonIterableRest();
  }
  module2.exports = _slicedToArray3;
  module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
});
var _slicedToArray = /* @__PURE__ */ getDefaultExportFromCjs(slicedToArray);
function ownKeys$2(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$2(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys$2(Object(source2), true).forEach(function(key) {
        _defineProperty3(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys$2(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
function useTranslation(ns) {
  var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var i18nFromProps = props.i18n;
  var _ref = react.useContext(I18nContext) || {}, i18nFromContext = _ref.i18n, defaultNSFromContext = _ref.defaultNS;
  var i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces)
    i18n.reportNamespaces = new ReportNamespaces();
  if (!i18n) {
    warnOnce("You will need to pass in an i18next instance by using initReactI18next");
    var notReadyT = function notReadyT2(k3) {
      return Array.isArray(k3) ? k3[k3.length - 1] : k3;
    };
    var retNotReady = [notReadyT, {}, false];
    retNotReady.t = notReadyT;
    retNotReady.i18n = {};
    retNotReady.ready = false;
    return retNotReady;
  }
  if (i18n.options.react && i18n.options.react.wait !== void 0)
    warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  var i18nOptions = _objectSpread$2(_objectSpread$2(_objectSpread$2({}, getDefaults()), i18n.options.react), props);
  var useSuspense = i18nOptions.useSuspense;
  var namespaces2 = ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
  namespaces2 = typeof namespaces2 === "string" ? [namespaces2] : namespaces2 || ["translation"];
  if (i18n.reportNamespaces.addUsedNamespaces)
    i18n.reportNamespaces.addUsedNamespaces(namespaces2);
  var ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces2.every(function(n4) {
    return hasLoadedNamespace(n4, i18n, i18nOptions);
  });
  function getT() {
    return i18n.getFixedT(null, i18nOptions.nsMode === "fallback" ? namespaces2 : namespaces2[0]);
  }
  var _useState = react.useState(getT), _useState2 = _slicedToArray(_useState, 2), t4 = _useState2[0], setT = _useState2[1];
  var isMounted = react.useRef(true);
  react.useEffect(function() {
    var bindI18n = i18nOptions.bindI18n, bindI18nStore = i18nOptions.bindI18nStore;
    isMounted.current = true;
    if (!ready && !useSuspense) {
      loadNamespaces(i18n, namespaces2, function() {
        if (isMounted.current)
          setT(getT);
      });
    }
    function boundReset() {
      if (isMounted.current)
        setT(getT);
    }
    if (bindI18n && i18n)
      i18n.on(bindI18n, boundReset);
    if (bindI18nStore && i18n)
      i18n.store.on(bindI18nStore, boundReset);
    return function() {
      isMounted.current = false;
      if (bindI18n && i18n)
        bindI18n.split(" ").forEach(function(e3) {
          return i18n.off(e3, boundReset);
        });
      if (bindI18nStore && i18n)
        bindI18nStore.split(" ").forEach(function(e3) {
          return i18n.store.off(e3, boundReset);
        });
    };
  }, [i18n, namespaces2.join()]);
  var isInitial = react.useRef(true);
  react.useEffect(function() {
    if (isMounted.current && !isInitial.current) {
      setT(getT);
    }
    isInitial.current = false;
  }, [i18n]);
  var ret = [t4, i18n, ready];
  ret.t = t4;
  ret.i18n = i18n;
  ret.ready = ready;
  if (ready)
    return ret;
  if (!ready && !useSuspense)
    return ret;
  throw new Promise(function(resolve) {
    loadNamespaces(i18n, namespaces2, function() {
      resolve();
    });
  });
}

// build/utils/useRequiredContext.js
function useRequiredContext(context2) {
  const resolved = useContext(context2);
  if (resolved !== void 0 && resolved !== null) {
    return resolved;
  }
  throw new Error(`No provider found for ${context2.displayName ? `the '${context2.displayName}'` : "an unknown"} context, make sure it is included in your component hierarchy.`);
}

// build/components/help-enabler/HelpHeader.js
var HelpContext = createContext(void 0);
var useHelp = () => useRequiredContext(HelpContext);
var Help = ({children: children2}) => {
  const [enabled, setHelp] = useState(true);
  function toggleHelp() {
    setHelp((help) => !help);
  }
  return /* @__PURE__ */ react.createElement(HelpContext.Provider, {
    value: {enabled, toggleHelp}
  }, children2);
};
var HelpHeader = () => {
  const [open2, setOpen] = useState(false);
  const help = useHelp();
  const {t: t4} = useTranslation();
  const dropdownItems = [
    /* @__PURE__ */ react.createElement(DropdownItem, {
      key: "link",
      id: "link"
    }, /* @__PURE__ */ react.createElement(Split, null, /* @__PURE__ */ react.createElement(SplitItem, {
      isFilled: true
    }, t4("documentation")), /* @__PURE__ */ react.createElement(SplitItem, null, /* @__PURE__ */ react.createElement(ExternalLinkAltIcon, null)))),
    /* @__PURE__ */ react.createElement(Divider, {
      key: "divide"
    }),
    /* @__PURE__ */ react.createElement(DropdownItem, {
      key: "enable",
      id: "enable"
    }, /* @__PURE__ */ react.createElement(Split, null, /* @__PURE__ */ react.createElement(SplitItem, {
      isFilled: true
    }, t4("enableHelpMode")), /* @__PURE__ */ react.createElement(SplitItem, null, /* @__PURE__ */ react.createElement(Switch, {
      id: "enableHelp",
      "aria-label": "Help is enabled",
      isChecked: help.enabled,
      label: "",
      className: "keycloak_help-header-switch",
      onChange: () => help.toggleHelp()
    }))), /* @__PURE__ */ react.createElement(TextContent, {
      className: "keycloak_help-header-description"
    }, t4("common-help:helpToggleInfo")))
  ];
  return /* @__PURE__ */ react.createElement(Dropdown, {
    position: "right",
    isPlain: true,
    isOpen: open2,
    toggle: /* @__PURE__ */ react.createElement(DropdownToggle, {
      toggleIndicator: null,
      onToggle: () => setOpen(!open2),
      "aria-label": "Help",
      id: "help"
    }, /* @__PURE__ */ react.createElement(HelpIcon, null)),
    dropdownItems
  });
};

// build/_snowpack/pkg/common/index-66fa324b.js
var bind = function bind2(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i3 = 0; i3 < args.length; i3++) {
      args[i3] = arguments[i3];
    }
    return fn.apply(thisArg, args);
  };
};
var toString = Object.prototype.toString;
function isArray2(val) {
  return toString.call(val) === "[object Array]";
}
function isUndefined(val) {
  return typeof val === "undefined";
}
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
function isArrayBuffer(val) {
  return toString.call(val) === "[object ArrayBuffer]";
}
function isFormData(val) {
  return typeof FormData !== "undefined" && val instanceof FormData;
}
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}
function isString(val) {
  return typeof val === "string";
}
function isNumber(val) {
  return typeof val === "number";
}
function isObject(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject(val) {
  if (toString.call(val) !== "[object Object]") {
    return false;
  }
  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
function isDate2(val) {
  return toString.call(val) === "[object Date]";
}
function isFile(val) {
  return toString.call(val) === "[object File]";
}
function isBlob(val) {
  return toString.call(val) === "[object Blob]";
}
function isFunction(val) {
  return toString.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
function isURLSearchParams(val) {
  return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
}
function trim(str) {
  return str.replace(/^\s*/, "").replace(/\s*$/, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach(obj, fn) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray2(obj)) {
    for (var i3 = 0, l3 = obj.length; i3 < l3; i3++) {
      fn.call(null, obj[i3], i3, obj);
    }
  } else {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
function merge() {
  var result = {};
  function assignValue2(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray2(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }
  for (var i3 = 0, l3 = arguments.length; i3 < l3; i3++) {
    forEach(arguments[i3], assignValue2);
  }
  return result;
}
function extend(a2, b3, thisArg) {
  forEach(b3, function assignValue2(val, key) {
    if (thisArg && typeof val === "function") {
      a2[key] = bind(val, thisArg);
    } else {
      a2[key] = val;
    }
  });
  return a2;
}
function stripBOM(content2) {
  if (content2.charCodeAt(0) === 65279) {
    content2 = content2.slice(1);
  }
  return content2;
}
var utils = {
  isArray: isArray2,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isObject,
  isPlainObject,
  isUndefined,
  isDate: isDate2,
  isFile,
  isBlob,
  isFunction,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge,
  extend,
  trim,
  stripBOM
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL = function buildURL2(url, params, paramsSerializer) {
  if (!params) {
    return url;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils.isArray(val)) {
        key = key + "[]";
      } else {
        val = [val];
      }
      utils.forEach(val, function parseValue(v3) {
        if (utils.isDate(v3)) {
          v3 = v3.toISOString();
        } else if (utils.isObject(v3)) {
          v3 = JSON.stringify(v3);
        }
        parts.push(encode(key) + "=" + encode(v3));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
};
function InterceptorManager() {
  this.handlers = [];
}
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled,
    rejected
  });
  return this.handlers.length - 1;
};
InterceptorManager.prototype.eject = function eject(id3) {
  if (this.handlers[id3]) {
    this.handlers[id3] = null;
  }
};
InterceptorManager.prototype.forEach = function forEach2(fn) {
  utils.forEach(this.handlers, function forEachHandler(h3) {
    if (h3 !== null) {
      fn(h3);
    }
  });
};
var InterceptorManager_1 = InterceptorManager;
var transformData = function transformData2(data, headers, fns) {
  utils.forEach(fns, function transform3(fn) {
    data = fn(data, headers);
  });
  return data;
};
var isCancel = function isCancel2(value) {
  return !!(value && value.__CANCEL__);
};
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
var globalContext;
if (typeof window !== "undefined") {
  globalContext = window;
} else if (typeof self !== "undefined") {
  globalContext = self;
} else {
  globalContext = {};
}
if (typeof globalContext.setTimeout === "function") {
  cachedSetTimeout = setTimeout;
}
if (typeof globalContext.clearTimeout === "function") {
  cachedClearTimeout = clearTimeout;
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e3) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e4) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e3) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e4) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout2 = runTimeout(cleanUpNextTick);
  draining = true;
  var len2 = queue.length;
  while (len2) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len2) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len2 = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout2);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      args[i3 - 1] = arguments[i3];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array2) {
  this.fun = fun;
  this.array = array2;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title2 = "browser";
var platform = "browser";
var browser = true;
var argv = [];
var version2 = "";
var versions = {};
var release = {};
var config = {};
function noop2() {
}
var on = noop2;
var addListener = noop2;
var once = noop2;
var off = noop2;
var removeListener = noop2;
var removeAllListeners = noop2;
var emit = noop2;
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
var performance2 = globalContext.performance || {};
var performanceNow = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
  return new Date().getTime();
};
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance2) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var process = {
  nextTick,
  title: title2,
  browser,
  env: {NODE_ENV: "production"},
  argv,
  version: version2,
  versions,
  on,
  addListener,
  once,
  off,
  removeListener,
  removeAllListeners,
  emit,
  binding,
  cwd,
  chdir,
  umask,
  hrtime,
  platform,
  release,
  config,
  uptime
};
var normalizeHeaderName = function normalizeHeaderName2(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};
var enhanceError = function enhanceError2(error2, config2, code2, request2, response) {
  error2.config = config2;
  if (code2) {
    error2.code = code2;
  }
  error2.request = request2;
  error2.response = response;
  error2.isAxiosError = true;
  error2.toJSON = function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code
    };
  };
  return error2;
};
var createError = function createError2(message, config2, code2, request2, response) {
  var error2 = new Error(message);
  return enhanceError(error2, config2, code2, request2, response);
};
var settle = function settle2(resolve, reject, response) {
  var validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
  }
};
var cookies = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
  return {
    write: function write3(name, value, expires2, path, domain, secure) {
      var cookie = [];
      cookie.push(name + "=" + encodeURIComponent(value));
      if (utils.isNumber(expires2)) {
        cookie.push("expires=" + new Date(expires2).toGMTString());
      }
      if (utils.isString(path)) {
        cookie.push("path=" + path);
      }
      if (utils.isString(domain)) {
        cookie.push("domain=" + domain);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      document.cookie = cookie.join("; ");
    },
    read: function read3(name) {
      var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove3(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  };
}() : function nonStandardBrowserEnv() {
  return {
    write: function write3() {
    },
    read: function read3() {
      return null;
    },
    remove: function remove3() {
    }
  };
}();
var isAbsoluteURL = function isAbsoluteURL2(url) {
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};
var combineURLs = function combineURLs2(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var buildFullPath = function buildFullPath2(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};
var ignoreDuplicateOf = [
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
];
var parseHeaders = function parseHeaders2(headers) {
  var parsed = {};
  var key;
  var val;
  var i3;
  if (!headers) {
    return parsed;
  }
  utils.forEach(headers.split("\n"), function parser(line) {
    i3 = line.indexOf(":");
    key = utils.trim(line.substr(0, i3)).toLowerCase();
    val = utils.trim(line.substr(i3 + 1));
    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === "set-cookie") {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    }
  });
  return parsed;
};
var isURLSameOrigin = utils.isStandardBrowserEnv() ? function standardBrowserEnv2() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement("a");
  var originURL;
  function resolveURL(url) {
    var href = url;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin2(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv2() {
  return function isURLSameOrigin2() {
    return true;
  };
}();
var xhr = function xhrAdapter(config2) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config2.data;
    var requestHeaders = config2.headers;
    if (utils.isFormData(requestData)) {
      delete requestHeaders["Content-Type"];
    }
    var request2 = new XMLHttpRequest();
    if (config2.auth) {
      var username = config2.auth.username || "";
      var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
      requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
    }
    var fullPath = buildFullPath(config2.baseURL, config2.url);
    request2.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
    request2.timeout = config2.timeout;
    request2.onreadystatechange = function handleLoad() {
      if (!request2 || request2.readyState !== 4) {
        return;
      }
      if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
        return;
      }
      var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders(request2.getAllResponseHeaders()) : null;
      var responseData = !config2.responseType || config2.responseType === "text" ? request2.responseText : request2.response;
      var response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config: config2,
        request: request2
      };
      settle(resolve, reject, response);
      request2 = null;
    };
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(createError("Request aborted", config2, "ECONNABORTED", request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(createError("Network Error", config2, null, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = "timeout of " + config2.timeout + "ms exceeded";
      if (config2.timeoutErrorMessage) {
        timeoutErrorMessage = config2.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config2, "ECONNABORTED", request2));
      request2 = null;
    };
    if (utils.isStandardBrowserEnv()) {
      var xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName ? cookies.read(config2.xsrfCookieName) : void 0;
      if (xsrfValue) {
        requestHeaders[config2.xsrfHeaderName] = xsrfValue;
      }
    }
    if ("setRequestHeader" in request2) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
          delete requestHeaders[key];
        } else {
          request2.setRequestHeader(key, val);
        }
      });
    }
    if (!utils.isUndefined(config2.withCredentials)) {
      request2.withCredentials = !!config2.withCredentials;
    }
    if (config2.responseType) {
      try {
        request2.responseType = config2.responseType;
      } catch (e3) {
        if (config2.responseType !== "json") {
          throw e3;
        }
      }
    }
    if (typeof config2.onDownloadProgress === "function") {
      request2.addEventListener("progress", config2.onDownloadProgress);
    }
    if (typeof config2.onUploadProgress === "function" && request2.upload) {
      request2.upload.addEventListener("progress", config2.onUploadProgress);
    }
    if (config2.cancelToken) {
      config2.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request2) {
          return;
        }
        request2.abort();
        reject(cancel);
        request2 = null;
      });
    }
    if (!requestData) {
      requestData = null;
    }
    request2.send(requestData);
  });
};
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = xhr;
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = xhr;
  }
  return adapter;
}
var defaults = {
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, "Accept");
    normalizeHeaderName(headers, "Content-Type");
    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, "application/json;charset=utf-8");
      return JSON.stringify(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    if (typeof data === "string") {
      try {
        data = JSON.parse(data);
      } catch (e3) {
      }
    }
    return data;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults.headers = {
  common: {
    Accept: "application/json, text/plain, */*"
  }
};
utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults;
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
}
var dispatchRequest = function dispatchRequest2(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = config2.headers || {};
  config2.data = transformData(config2.data, config2.headers, config2.transformRequest);
  config2.headers = utils.merge(config2.headers.common || {}, config2.headers[config2.method] || {}, config2.headers);
  utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
    delete config2.headers[method];
  });
  var adapter = config2.adapter || defaults_1.adapter;
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData(response.data, response.headers, config2.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config2.transformResponse);
      }
    }
    return Promise.reject(reason);
  });
};
var mergeConfig = function mergeConfig2(config1, config2) {
  config2 = config2 || {};
  var config3 = {};
  var valueFromConfig2Keys = ["url", "method", "data"];
  var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
  var defaultToConfig2Keys = [
    "baseURL",
    "transformRequest",
    "transformResponse",
    "paramsSerializer",
    "timeout",
    "timeoutMessage",
    "withCredentials",
    "adapter",
    "responseType",
    "xsrfCookieName",
    "xsrfHeaderName",
    "onUploadProgress",
    "onDownloadProgress",
    "decompress",
    "maxContentLength",
    "maxBodyLength",
    "maxRedirects",
    "transport",
    "httpAgent",
    "httpsAgent",
    "cancelToken",
    "socketPath",
    "responseEncoding"
  ];
  var directMergeKeys = ["validateStatus"];
  function getMergedValue(target, source2) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source2)) {
      return utils.merge(target, source2);
    } else if (utils.isPlainObject(source2)) {
      return utils.merge({}, source2);
    } else if (utils.isArray(source2)) {
      return source2.slice();
    }
    return source2;
  }
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  }
  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(void 0, config2[prop]);
    }
  });
  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(void 0, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  });
  utils.forEach(directMergeKeys, function merge3(prop) {
    if (prop in config2) {
      config3[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
  var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
    return axiosKeys.indexOf(key) === -1;
  });
  utils.forEach(otherKeys, mergeDeepProperties);
  return config3;
};
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager_1(),
    response: new InterceptorManager_1()
  };
}
Axios.prototype.request = function request(config2) {
  if (typeof config2 === "string") {
    config2 = arguments[1] || {};
    config2.url = arguments[0];
  } else {
    config2 = config2 || {};
  }
  config2 = mergeConfig(this.defaults, config2);
  if (config2.method) {
    config2.method = config2.method.toLowerCase();
  } else if (this.defaults.method) {
    config2.method = this.defaults.method.toLowerCase();
  } else {
    config2.method = "get";
  }
  var chain = [dispatchRequest, void 0];
  var promise = Promise.resolve(config2);
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });
  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }
  return promise;
};
Axios.prototype.getUri = function getUri(config2) {
  config2 = mergeConfig(this.defaults, config2);
  return buildURL(config2.url, config2.params, config2.paramsSerializer).replace(/^\?/, "");
};
utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios.prototype[method] = function(url, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  Axios.prototype[method] = function(url, data, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url,
      data
    }));
  };
});
var Axios_1 = Axios;
function Cancel(message) {
  this.message = message;
}
Cancel.prototype.toString = function toString2() {
  return "Cancel" + (this.message ? ": " + this.message : "");
};
Cancel.prototype.__CANCEL__ = true;
var Cancel_1 = Cancel;
function CancelToken(executor) {
  if (typeof executor !== "function") {
    throw new TypeError("executor must be a function.");
  }
  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token2 = this;
  executor(function cancel(message) {
    if (token2.reason) {
      return;
    }
    token2.reason = new Cancel_1(message);
    resolvePromise(token2.reason);
  });
}
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
CancelToken.source = function source() {
  var cancel;
  var token2 = new CancelToken(function executor(c4) {
    cancel = c4;
  });
  return {
    token: token2,
    cancel
  };
};
var CancelToken_1 = CancelToken;
var spread = function spread2(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};
var isAxiosError = function isAxiosError2(payload) {
  return typeof payload === "object" && payload.isAxiosError === true;
};
function createInstance(defaultConfig) {
  var context2 = new Axios_1(defaultConfig);
  var instance = bind(Axios_1.prototype.request, context2);
  utils.extend(instance, Axios_1.prototype, context2);
  utils.extend(instance, context2);
  return instance;
}
var axios = createInstance(defaults_1);
axios.Axios = Axios_1;
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};
axios.Cancel = Cancel_1;
axios.CancelToken = CancelToken_1;
axios.isCancel = isCancel;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
var axios_1 = axios;
var _default = axios;
axios_1.default = _default;
var axios$1 = axios_1;

// build/context/auth/AdminClient.js
var AdminClient = createContext(void 0);
var useAdminClient = () => useRequiredContext(AdminClient);
function useFetch(adminClientCall, callback, deps) {
  const adminClient = useAdminClient();
  const onError = useErrorHandler();
  const source2 = axios$1.CancelToken.source();
  adminClient.setConfig({requestConfig: {cancelToken: source2.token}});
  useEffect(() => {
    adminClientCall().then((result) => {
      if (!source2.token.reason) {
        callback(result);
      }
    }).catch((error2) => {
      if (!axios$1.isCancel(error2)) {
        onError(error2);
      }
    });
    return () => {
      source2.cancel();
    };
  }, deps);
}

// build/_snowpack/pkg/common/lodash-63f0b2ce.js
var lodash = createCommonjsModule(function(module2, exports2) {
  (function() {
    var undefined$1;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE3 = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT2 = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE2 = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG2 = 1, CLONE_FLAT_FLAG2 = 2, CLONE_SYMBOLS_FLAG2 = 4;
    var COMPARE_PARTIAL_FLAG3 = 1, COMPARE_UNORDERED_FLAG3 = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT2 = 800, HOT_SPAN2 = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY2 = 1 / 0, MAX_SAFE_INTEGER2 = 9007199254740991, MAX_INTEGER2 = 17976931348623157e292, NAN2 = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag3 = "[object Arguments]", arrayTag3 = "[object Array]", asyncTag2 = "[object AsyncFunction]", boolTag3 = "[object Boolean]", dateTag3 = "[object Date]", domExcTag = "[object DOMException]", errorTag3 = "[object Error]", funcTag3 = "[object Function]", genTag3 = "[object GeneratorFunction]", mapTag3 = "[object Map]", numberTag3 = "[object Number]", nullTag2 = "[object Null]", objectTag3 = "[object Object]", promiseTag2 = "[object Promise]", proxyTag2 = "[object Proxy]", regexpTag3 = "[object RegExp]", setTag3 = "[object Set]", stringTag3 = "[object String]", symbolTag3 = "[object Symbol]", undefinedTag2 = "[object Undefined]", weakMapTag3 = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag3 = "[object ArrayBuffer]", dataViewTag3 = "[object DataView]", float32Tag3 = "[object Float32Array]", float64Tag3 = "[object Float64Array]", int8Tag3 = "[object Int8Array]", int16Tag3 = "[object Int16Array]", int32Tag3 = "[object Int32Array]", uint8Tag3 = "[object Uint8Array]", uint8ClampedTag3 = "[object Uint8ClampedArray]", uint16Tag3 = "[object Uint16Array]", uint32Tag3 = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp2 = /^\w*$/, rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar2.source);
    var reTrimStart2 = /^\s+/;
    var reWhitespace2 = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar2 = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags2 = /\w*$/;
    var reIsBadHex2 = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary2 = /^0b[01]+$/i;
    var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
    var reIsOctal2 = /^0o[0-7]+$/i;
    var reIsUint2 = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange2 = "\\ud800-\\udfff", rsComboMarksRange2 = "\\u0300-\\u036f", reComboHalfMarksRange2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange2 = "\\u20d0-\\u20ff", rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange2 = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "[']", rsAstral2 = "[" + rsAstralRange2 + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo2 = "[" + rsComboRange2 + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz2 = "\\ud83c[\\udffb-\\udfff]", rsModifier2 = "(?:" + rsCombo2 + "|" + rsFitz2 + ")", rsNonAstral2 = "[^" + rsAstralRange2 + "]", rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ2 = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod2 = rsModifier2 + "?", rsOptVar2 = "[" + rsVarRange2 + "]?", rsOptJoin2 = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2, rsEmoji = "(?:" + [rsDingbat, rsRegional2, rsSurrPair2].join("|") + ")" + rsSeq2, rsSymbol2 = "(?:" + [rsNonAstral2 + rsCombo2 + "?", rsCombo2, rsRegional2, rsSurrPair2, rsAstral2].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo2, "g");
    var reUnicode2 = RegExp(rsFitz2 + "(?=" + rsFitz2 + ")|" + rsSymbol2 + rsSeq2, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode2 = RegExp("[" + rsZWJ2 + rsAstralRange2 + rsComboRange2 + rsVarRange2 + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags2 = {};
    typedArrayTags2[float32Tag3] = typedArrayTags2[float64Tag3] = typedArrayTags2[int8Tag3] = typedArrayTags2[int16Tag3] = typedArrayTags2[int32Tag3] = typedArrayTags2[uint8Tag3] = typedArrayTags2[uint8ClampedTag3] = typedArrayTags2[uint16Tag3] = typedArrayTags2[uint32Tag3] = true;
    typedArrayTags2[argsTag3] = typedArrayTags2[arrayTag3] = typedArrayTags2[arrayBufferTag3] = typedArrayTags2[boolTag3] = typedArrayTags2[dataViewTag3] = typedArrayTags2[dateTag3] = typedArrayTags2[errorTag3] = typedArrayTags2[funcTag3] = typedArrayTags2[mapTag3] = typedArrayTags2[numberTag3] = typedArrayTags2[objectTag3] = typedArrayTags2[regexpTag3] = typedArrayTags2[setTag3] = typedArrayTags2[stringTag3] = typedArrayTags2[weakMapTag3] = false;
    var cloneableTags2 = {};
    cloneableTags2[argsTag3] = cloneableTags2[arrayTag3] = cloneableTags2[arrayBufferTag3] = cloneableTags2[dataViewTag3] = cloneableTags2[boolTag3] = cloneableTags2[dateTag3] = cloneableTags2[float32Tag3] = cloneableTags2[float64Tag3] = cloneableTags2[int8Tag3] = cloneableTags2[int16Tag3] = cloneableTags2[int32Tag3] = cloneableTags2[mapTag3] = cloneableTags2[numberTag3] = cloneableTags2[objectTag3] = cloneableTags2[regexpTag3] = cloneableTags2[setTag3] = cloneableTags2[stringTag3] = cloneableTags2[symbolTag3] = cloneableTags2[uint8Tag3] = cloneableTags2[uint8ClampedTag3] = cloneableTags2[uint16Tag3] = cloneableTags2[uint32Tag3] = true;
    cloneableTags2[errorTag3] = cloneableTags2[funcTag3] = cloneableTags2[weakMapTag3] = false;
    var deburredLetters = {
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "C",
      : "c",
      : "D",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "N",
      : "n",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "Y",
      : "y",
      : "y",
      : "Ae",
      : "ae",
      : "Th",
      : "th",
      : "ss",
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "C",
      : "C",
      : "C",
      : "C",
      : "c",
      : "c",
      : "c",
      : "c",
      : "D",
      : "D",
      : "d",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "e",
      : "G",
      : "G",
      : "G",
      : "G",
      : "g",
      : "g",
      : "g",
      : "g",
      : "H",
      : "H",
      : "h",
      : "h",
      : "I",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "i",
      : "J",
      : "j",
      : "K",
      : "k",
      : "k",
      : "L",
      : "L",
      : "L",
      : "L",
      : "L",
      : "l",
      : "l",
      : "l",
      : "l",
      : "l",
      : "N",
      : "N",
      : "N",
      : "N",
      : "n",
      : "n",
      : "n",
      : "n",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "R",
      : "R",
      : "R",
      : "r",
      : "r",
      : "r",
      : "S",
      : "S",
      : "S",
      : "S",
      : "s",
      : "s",
      : "s",
      : "s",
      : "T",
      : "T",
      : "T",
      : "t",
      : "t",
      : "t",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "W",
      : "w",
      : "Y",
      : "y",
      : "Y",
      : "Z",
      : "Z",
      : "Z",
      : "z",
      : "z",
      : "z",
      : "IJ",
      : "ij",
      : "Oe",
      : "oe",
      : "'n",
      : "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt2 = parseInt;
    var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
    var root3 = freeGlobal2 || freeSelf2 || Function("return this")();
    var freeExports = exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal2.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e3) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap2 = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet2 = nodeUtil && nodeUtil.isSet, nodeIsTypedArray2 = nodeUtil && nodeUtil.isTypedArray;
    function apply2(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array2, setter, iteratee, accumulator) {
      var index3 = -1, length = array2 == null ? 0 : array2.length;
      while (++index3 < length) {
        var value = array2[index3];
        setter(accumulator, value, iteratee(value), array2);
      }
      return accumulator;
    }
    function arrayEach2(array2, iteratee) {
      var index3 = -1, length = array2 == null ? 0 : array2.length;
      while (++index3 < length) {
        if (iteratee(array2[index3], index3, array2) === false) {
          break;
        }
      }
      return array2;
    }
    function arrayEachRight(array2, iteratee) {
      var length = array2 == null ? 0 : array2.length;
      while (length--) {
        if (iteratee(array2[length], length, array2) === false) {
          break;
        }
      }
      return array2;
    }
    function arrayEvery(array2, predicate) {
      var index3 = -1, length = array2 == null ? 0 : array2.length;
      while (++index3 < length) {
        if (!predicate(array2[index3], index3, array2)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter2(array2, predicate) {
      var index3 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index3 < length) {
        var value = array2[index3];
        if (predicate(value, index3, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes2(array2, value) {
      var length = array2 == null ? 0 : array2.length;
      return !!length && baseIndexOf2(array2, value, 0) > -1;
    }
    function arrayIncludesWith2(array2, value, comparator) {
      var index3 = -1, length = array2 == null ? 0 : array2.length;
      while (++index3 < length) {
        if (comparator(value, array2[index3])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap2(array2, iteratee) {
      var index3 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
      while (++index3 < length) {
        result[index3] = iteratee(array2[index3], index3, array2);
      }
      return result;
    }
    function arrayPush2(array2, values2) {
      var index3 = -1, length = values2.length, offset2 = array2.length;
      while (++index3 < length) {
        array2[offset2 + index3] = values2[index3];
      }
      return array2;
    }
    function arrayReduce2(array2, iteratee, accumulator, initAccum) {
      var index3 = -1, length = array2 == null ? 0 : array2.length;
      if (initAccum && length) {
        accumulator = array2[++index3];
      }
      while (++index3 < length) {
        accumulator = iteratee(accumulator, array2[index3], index3, array2);
      }
      return accumulator;
    }
    function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
      var length = array2 == null ? 0 : array2.length;
      if (initAccum && length) {
        accumulator = array2[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array2[length], length, array2);
      }
      return accumulator;
    }
    function arraySome2(array2, predicate) {
      var index3 = -1, length = array2 == null ? 0 : array2.length;
      while (++index3 < length) {
        if (predicate(array2[index3], index3, array2)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize2 = baseProperty2("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex2(array2, predicate, fromIndex, fromRight) {
      var length = array2.length, index3 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index3-- : ++index3 < length) {
        if (predicate(array2[index3], index3, array2)) {
          return index3;
        }
      }
      return -1;
    }
    function baseIndexOf2(array2, value, fromIndex) {
      return value === value ? strictIndexOf2(array2, value, fromIndex) : baseFindIndex2(array2, baseIsNaN2, fromIndex);
    }
    function baseIndexOfWith(array2, value, fromIndex, comparator) {
      var index3 = fromIndex - 1, length = array2.length;
      while (++index3 < length) {
        if (comparator(array2[index3], value)) {
          return index3;
        }
      }
      return -1;
    }
    function baseIsNaN2(value) {
      return value !== value;
    }
    function baseMean(array2, iteratee) {
      var length = array2 == null ? 0 : array2.length;
      return length ? baseSum(array2, iteratee) / length : NAN2;
    }
    function baseProperty2(key) {
      return function(object) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function baseReduce2(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index3, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index3, collection2);
      });
      return accumulator;
    }
    function baseSortBy2(array2, comparer) {
      var length = array2.length;
      array2.sort(comparer);
      while (length--) {
        array2[length] = array2[length].value;
      }
      return array2;
    }
    function baseSum(array2, iteratee) {
      var result, index3 = -1, length = array2.length;
      while (++index3 < length) {
        var current = iteratee(array2[index3]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes2(n4, iteratee) {
      var index3 = -1, result = Array(n4);
      while (++index3 < n4) {
        result[index3] = iteratee(index3);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap2(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim2(string) {
      return string ? string.slice(0, trimmedEndIndex2(string) + 1).replace(reTrimStart2, "") : string;
    }
    function baseUnary2(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues2(object, props) {
      return arrayMap2(props, function(key) {
        return object[key];
      });
    }
    function cacheHas2(cache3, key) {
      return cache3.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index3 = -1, length = strSymbols.length;
      while (++index3 < length && baseIndexOf2(chrSymbols, strSymbols[index3], 0) > -1) {
      }
      return index3;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index3 = strSymbols.length;
      while (index3-- && baseIndexOf2(chrSymbols, strSymbols[index3], 0) > -1) {
      }
      return index3;
    }
    function countHolders(array2, placeholder) {
      var length = array2.length, result = 0;
      while (length--) {
        if (array2[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue2(object, key) {
      return object == null ? undefined$1 : object[key];
    }
    function hasUnicode2(string) {
      return reHasUnicode2.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray2(map3) {
      var index3 = -1, result = Array(map3.size);
      map3.forEach(function(value, key) {
        result[++index3] = [key, value];
      });
      return result;
    }
    function overArg2(func, transform3) {
      return function(arg) {
        return func(transform3(arg));
      };
    }
    function replaceHolders(array2, placeholder) {
      var index3 = -1, length = array2.length, resIndex = 0, result = [];
      while (++index3 < length) {
        var value = array2[index3];
        if (value === placeholder || value === PLACEHOLDER) {
          array2[index3] = PLACEHOLDER;
          result[resIndex++] = index3;
        }
      }
      return result;
    }
    function setToArray2(set3) {
      var index3 = -1, result = Array(set3.size);
      set3.forEach(function(value) {
        result[++index3] = value;
      });
      return result;
    }
    function setToPairs(set3) {
      var index3 = -1, result = Array(set3.size);
      set3.forEach(function(value) {
        result[++index3] = [value, value];
      });
      return result;
    }
    function strictIndexOf2(array2, value, fromIndex) {
      var index3 = fromIndex - 1, length = array2.length;
      while (++index3 < length) {
        if (array2[index3] === value) {
          return index3;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array2, value, fromIndex) {
      var index3 = fromIndex + 1;
      while (index3--) {
        if (array2[index3] === value) {
          return index3;
        }
      }
      return index3;
    }
    function stringSize2(string) {
      return hasUnicode2(string) ? unicodeSize2(string) : asciiSize2(string);
    }
    function stringToArray(string) {
      return hasUnicode2(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex2(string) {
      var index3 = string.length;
      while (index3-- && reWhitespace2.test(string.charAt(index3))) {
      }
      return index3;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize2(string) {
      var result = reUnicode2.lastIndex = 0;
      while (reUnicode2.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode2) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context2) {
      context2 = context2 == null ? root3 : _23.defaults(root3.Object(), context2, _23.pick(root3, contextProps));
      var Array2 = context2.Array, Date2 = context2.Date, Error2 = context2.Error, Function2 = context2.Function, Math2 = context2.Math, Object2 = context2.Object, RegExp2 = context2.RegExp, String2 = context2.String, TypeError2 = context2.TypeError;
      var arrayProto2 = Array2.prototype, funcProto2 = Function2.prototype, objectProto3 = Object2.prototype;
      var coreJsData2 = context2["__core-js_shared__"];
      var funcToString2 = funcProto2.toString;
      var hasOwnProperty5 = objectProto3.hasOwnProperty;
      var idCounter2 = 0;
      var maskSrcKey2 = function() {
        var uid2 = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      var nativeObjectToString2 = objectProto3.toString;
      var objectCtorString2 = funcToString2.call(Object2);
      var oldDash = root3._;
      var reIsNative2 = RegExp2("^" + funcToString2.call(hasOwnProperty5).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context2.Buffer : undefined$1, Symbol3 = context2.Symbol, Uint8Array3 = context2.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype2 = overArg2(Object2.getPrototypeOf, Object2), objectCreate2 = Object2.create, propertyIsEnumerable2 = objectProto3.propertyIsEnumerable, splice2 = arrayProto2.splice, spreadableSymbol2 = Symbol3 ? Symbol3.isConcatSpreadable : undefined$1, symIterator = Symbol3 ? Symbol3.iterator : undefined$1, symToStringTag2 = Symbol3 ? Symbol3.toStringTag : undefined$1;
      var defineProperty3 = function() {
        try {
          var func = getNative2(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e3) {
        }
      }();
      var ctxClearTimeout = context2.clearTimeout !== root3.clearTimeout && context2.clearTimeout, ctxNow = Date2 && Date2.now !== root3.Date.now && Date2.now, ctxSetTimeout = context2.setTimeout !== root3.setTimeout && context2.setTimeout;
      var nativeCeil2 = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols3 = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context2.isFinite, nativeJoin = arrayProto2.join, nativeKeys2 = overArg2(Object2.keys, Object2), nativeMax3 = Math2.max, nativeMin = Math2.min, nativeNow2 = Date2.now, nativeParseInt = context2.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto2.reverse;
      var DataView3 = getNative2(context2, "DataView"), Map3 = getNative2(context2, "Map"), Promise3 = getNative2(context2, "Promise"), Set3 = getNative2(context2, "Set"), WeakMap3 = getNative2(context2, "WeakMap"), nativeCreate2 = getNative2(Object2, "create");
      var metaMap = WeakMap3 && new WeakMap3();
      var realNames = {};
      var dataViewCtorString2 = toSource2(DataView3), mapCtorString2 = toSource2(Map3), promiseCtorString2 = toSource2(Promise3), setCtorString2 = toSource2(Set3), weakMapCtorString2 = toSource2(WeakMap3);
      var symbolProto3 = Symbol3 ? Symbol3.prototype : undefined$1, symbolValueOf3 = symbolProto3 ? symbolProto3.valueOf : undefined$1, symbolToString2 = symbolProto3 ? symbolProto3.toString : undefined$1;
      function lodash3(value) {
        if (isObjectLike2(value) && !isArray4(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty5.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate2 = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject4(proto)) {
            return {};
          }
          if (objectCreate2) {
            return objectCreate2(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash3.templateSettings = {
        escape: reEscape,
        evaluate: reEvaluate,
        interpolate: reInterpolate,
        variable: "",
        imports: {
          _: lodash3
        }
      };
      lodash3.prototype = baseLodash.prototype;
      lodash3.prototype.constructor = lodash3;
      LodashWrapper.prototype = baseCreate2(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray2(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray2(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray2(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray4(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start3 = view.start, end2 = view.end, length = end2 - start3, index3 = isRight ? end2 : start3 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array2, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index3 += dir;
            var iterIndex = -1, value = array2[index3];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate2(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash2(entries) {
        var index3 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index3 < length) {
          var entry = entries[index3];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear2() {
        this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
        this.size = 0;
      }
      function hashDelete2(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet2(key) {
        var data = this.__data__;
        if (nativeCreate2) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED2 ? undefined$1 : result2;
        }
        return hasOwnProperty5.call(data, key) ? data[key] : undefined$1;
      }
      function hashHas2(key) {
        var data = this.__data__;
        return nativeCreate2 ? data[key] !== undefined$1 : hasOwnProperty5.call(data, key);
      }
      function hashSet2(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate2 && value === undefined$1 ? HASH_UNDEFINED2 : value;
        return this;
      }
      Hash2.prototype.clear = hashClear2;
      Hash2.prototype["delete"] = hashDelete2;
      Hash2.prototype.get = hashGet2;
      Hash2.prototype.has = hashHas2;
      Hash2.prototype.set = hashSet2;
      function ListCache2(entries) {
        var index3 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index3 < length) {
          var entry = entries[index3];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear2() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete2(key) {
        var data = this.__data__, index3 = assocIndexOf2(data, key);
        if (index3 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index3 == lastIndex) {
          data.pop();
        } else {
          splice2.call(data, index3, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet2(key) {
        var data = this.__data__, index3 = assocIndexOf2(data, key);
        return index3 < 0 ? undefined$1 : data[index3][1];
      }
      function listCacheHas2(key) {
        return assocIndexOf2(this.__data__, key) > -1;
      }
      function listCacheSet2(key, value) {
        var data = this.__data__, index3 = assocIndexOf2(data, key);
        if (index3 < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index3][1] = value;
        }
        return this;
      }
      ListCache2.prototype.clear = listCacheClear2;
      ListCache2.prototype["delete"] = listCacheDelete2;
      ListCache2.prototype.get = listCacheGet2;
      ListCache2.prototype.has = listCacheHas2;
      ListCache2.prototype.set = listCacheSet2;
      function MapCache2(entries) {
        var index3 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index3 < length) {
          var entry = entries[index3];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear2() {
        this.size = 0;
        this.__data__ = {
          hash: new Hash2(),
          map: new (Map3 || ListCache2)(),
          string: new Hash2()
        };
      }
      function mapCacheDelete2(key) {
        var result2 = getMapData2(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet2(key) {
        return getMapData2(this, key).get(key);
      }
      function mapCacheHas2(key) {
        return getMapData2(this, key).has(key);
      }
      function mapCacheSet2(key, value) {
        var data = getMapData2(this, key), size3 = data.size;
        data.set(key, value);
        this.size += data.size == size3 ? 0 : 1;
        return this;
      }
      MapCache2.prototype.clear = mapCacheClear2;
      MapCache2.prototype["delete"] = mapCacheDelete2;
      MapCache2.prototype.get = mapCacheGet2;
      MapCache2.prototype.has = mapCacheHas2;
      MapCache2.prototype.set = mapCacheSet2;
      function SetCache2(values3) {
        var index3 = -1, length = values3 == null ? 0 : values3.length;
        this.__data__ = new MapCache2();
        while (++index3 < length) {
          this.add(values3[index3]);
        }
      }
      function setCacheAdd2(value) {
        this.__data__.set(value, HASH_UNDEFINED2);
        return this;
      }
      function setCacheHas2(value) {
        return this.__data__.has(value);
      }
      SetCache2.prototype.add = SetCache2.prototype.push = setCacheAdd2;
      SetCache2.prototype.has = setCacheHas2;
      function Stack3(entries) {
        var data = this.__data__ = new ListCache2(entries);
        this.size = data.size;
      }
      function stackClear2() {
        this.__data__ = new ListCache2();
        this.size = 0;
      }
      function stackDelete2(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet2(key) {
        return this.__data__.get(key);
      }
      function stackHas2(key) {
        return this.__data__.has(key);
      }
      function stackSet2(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache2) {
          var pairs = data.__data__;
          if (!Map3 || pairs.length < LARGE_ARRAY_SIZE3 - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache2(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack3.prototype.clear = stackClear2;
      Stack3.prototype["delete"] = stackDelete2;
      Stack3.prototype.get = stackGet2;
      Stack3.prototype.has = stackHas2;
      Stack3.prototype.set = stackSet2;
      function arrayLikeKeys2(value, inherited) {
        var isArr = isArray4(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes2(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty5.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex2(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array2) {
        var length = array2.length;
        return length ? array2[baseRandom(0, length - 1)] : undefined$1;
      }
      function arraySampleSize(array2, n4) {
        return shuffleSelf(copyArray2(array2), baseClamp(n4, 0, array2.length));
      }
      function arrayShuffle(array2) {
        return shuffleSelf(copyArray2(array2));
      }
      function assignMergeValue2(object, key, value) {
        if (value !== undefined$1 && !eq2(object[key], value) || value === undefined$1 && !(key in object)) {
          baseAssignValue2(object, key, value);
        }
      }
      function assignValue2(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty5.call(object, key) && eq2(objValue, value)) || value === undefined$1 && !(key in object)) {
          baseAssignValue2(object, key, value);
        }
      }
      function assocIndexOf2(array2, key) {
        var length = array2.length;
        while (length--) {
          if (eq2(array2[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach2(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign2(object, source2) {
        return object && copyObject2(source2, keys2(source2), object);
      }
      function baseAssignIn2(object, source2) {
        return object && copyObject2(source2, keysIn2(source2), object);
      }
      function baseAssignValue2(object, key, value) {
        if (key == "__proto__" && defineProperty3) {
          defineProperty3(object, key, {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index3 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index3 < length) {
          result2[index3] = skip ? undefined$1 : get5(object, paths[index3]);
        }
        return result2;
      }
      function baseClamp(number, lower2, upper) {
        if (number === number) {
          if (upper !== undefined$1) {
            number = number <= upper ? number : upper;
          }
          if (lower2 !== undefined$1) {
            number = number >= lower2 ? number : lower2;
          }
        }
        return number;
      }
      function baseClone2(value, bitmask, customizer, key, object, stack2) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG2, isFlat = bitmask & CLONE_FLAT_FLAG2, isFull = bitmask & CLONE_SYMBOLS_FLAG2;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack2) : customizer(value);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject4(value)) {
          return value;
        }
        var isArr = isArray4(value);
        if (isArr) {
          result2 = initCloneArray2(value);
          if (!isDeep) {
            return copyArray2(value, result2);
          }
        } else {
          var tag = getTag2(value), isFunc = tag == funcTag3 || tag == genTag3;
          if (isBuffer2(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag3 || tag == argsTag3 || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject2(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn2(value, baseAssignIn2(result2, value)) : copySymbols2(value, baseAssign2(result2, value));
            }
          } else {
            if (!cloneableTags2[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag2(value, tag, isDeep);
          }
        }
        stack2 || (stack2 = new Stack3());
        var stacked = stack2.get(value);
        if (stacked) {
          return stacked;
        }
        stack2.set(value, result2);
        if (isSet2(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone2(subValue, bitmask, customizer, subValue, value, stack2));
          });
        } else if (isMap2(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone2(subValue, bitmask, customizer, key2, value, stack2));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn2 : getAllKeys2 : isFlat ? keysIn2 : keys2;
        var props = isArr ? undefined$1 : keysFunc(value);
        arrayEach2(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue2(result2, key2, baseClone2(subValue, bitmask, customizer, key2, value, stack2));
        });
        return result2;
      }
      function baseConforms(source2) {
        var props = keys2(source2);
        return function(object) {
          return baseConformsTo(object, source2, props);
        };
      }
      function baseConformsTo(object, source2, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source2[key], value = object[key];
          if (value === undefined$1 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array2, values3, iteratee2, comparator) {
        var index3 = -1, includes2 = arrayIncludes2, isCommon = true, length = array2.length, result2 = [], valuesLength = values3.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values3 = arrayMap2(values3, baseUnary2(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith2;
          isCommon = false;
        } else if (values3.length >= LARGE_ARRAY_SIZE3) {
          includes2 = cacheHas2;
          isCommon = false;
          values3 = new SetCache2(values3);
        }
        outer:
          while (++index3 < length) {
            var value = array2[index3], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values3[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values3, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach2 = createBaseEach2(baseForOwn2);
      var baseEachRight = createBaseEach2(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach2(collection, function(value, index3, collection2) {
          result2 = !!predicate(value, index3, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum2(array2, iteratee2, comparator) {
        var index3 = -1, length = array2.length;
        while (++index3 < length) {
          var value = array2[index3], current = iteratee2(value);
          if (current != null && (computed === undefined$1 ? current === current && !isSymbol2(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array2, value, start3, end2) {
        var length = array2.length;
        start3 = toInteger2(start3);
        if (start3 < 0) {
          start3 = -start3 > length ? 0 : length + start3;
        }
        end2 = end2 === undefined$1 || end2 > length ? length : toInteger2(end2);
        if (end2 < 0) {
          end2 += length;
        }
        end2 = start3 > end2 ? 0 : toLength(end2);
        while (start3 < end2) {
          array2[start3++] = value;
        }
        return array2;
      }
      function baseFilter2(collection, predicate) {
        var result2 = [];
        baseEach2(collection, function(value, index3, collection2) {
          if (predicate(value, index3, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten2(array2, depth, predicate, isStrict, result2) {
        var index3 = -1, length = array2.length;
        predicate || (predicate = isFlattenable2);
        result2 || (result2 = []);
        while (++index3 < length) {
          var value = array2[index3];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten2(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush2(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor2 = createBaseFor2();
      var baseForRight = createBaseFor2(true);
      function baseForOwn2(object, iteratee2) {
        return object && baseFor2(object, iteratee2, keys2);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys2);
      }
      function baseFunctions(object, props) {
        return arrayFilter2(props, function(key) {
          return isFunction5(object[key]);
        });
      }
      function baseGet3(object, path) {
        path = castPath2(path, object);
        var index3 = 0, length = path.length;
        while (object != null && index3 < length) {
          object = object[toKey2(path[index3++])];
        }
        return index3 && index3 == length ? object : undefined$1;
      }
      function baseGetAllKeys2(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray4(object) ? result2 : arrayPush2(result2, symbolsFunc(object));
      }
      function baseGetTag2(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag2 : nullTag2;
        }
        return symToStringTag2 && symToStringTag2 in Object2(value) ? getRawTag2(value) : objectToString2(value);
      }
      function baseGt2(value, other) {
        return value > other;
      }
      function baseHas2(object, key) {
        return object != null && hasOwnProperty5.call(object, key);
      }
      function baseHasIn2(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start3, end2) {
        return number >= nativeMin(start3, end2) && number < nativeMax3(start3, end2);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith2 : arrayIncludes2, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array2 = arrays[othIndex];
          if (othIndex && iteratee2) {
            array2 = arrayMap2(array2, baseUnary2(iteratee2));
          }
          maxLength = nativeMin(array2.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array2.length >= 120) ? new SetCache2(othIndex && array2) : undefined$1;
        }
        array2 = arrays[0];
        var index3 = -1, seen = caches[0];
        outer:
          while (++index3 < length && result2.length < maxLength) {
            var value = array2[index3], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas2(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache3 = caches[othIndex];
                if (!(cache3 ? cacheHas2(cache3, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn2(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath2(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey2(last2(path))];
        return func == null ? undefined$1 : apply2(func, object, args);
      }
      function baseIsArguments2(value) {
        return isObjectLike2(value) && baseGetTag2(value) == argsTag3;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike2(value) && baseGetTag2(value) == arrayBufferTag3;
      }
      function baseIsDate(value) {
        return isObjectLike2(value) && baseGetTag2(value) == dateTag3;
      }
      function baseIsEqual2(value, other, bitmask, customizer, stack2) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep2(value, other, bitmask, customizer, baseIsEqual2, stack2);
      }
      function baseIsEqualDeep2(object, other, bitmask, customizer, equalFunc, stack2) {
        var objIsArr = isArray4(object), othIsArr = isArray4(other), objTag = objIsArr ? arrayTag3 : getTag2(object), othTag = othIsArr ? arrayTag3 : getTag2(other);
        objTag = objTag == argsTag3 ? objectTag3 : objTag;
        othTag = othTag == argsTag3 ? objectTag3 : othTag;
        var objIsObj = objTag == objectTag3, othIsObj = othTag == objectTag3, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer2(object)) {
          if (!isBuffer2(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack2 || (stack2 = new Stack3());
          return objIsArr || isTypedArray2(object) ? equalArrays2(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag2(object, other, objTag, bitmask, customizer, equalFunc, stack2);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG3)) {
          var objIsWrapped = objIsObj && hasOwnProperty5.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty5.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack2 || (stack2 = new Stack3());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack2 || (stack2 = new Stack3());
        return equalObjects2(object, other, bitmask, customizer, equalFunc, stack2);
      }
      function baseIsMap2(value) {
        return isObjectLike2(value) && getTag2(value) == mapTag3;
      }
      function baseIsMatch2(object, source2, matchData, customizer) {
        var index3 = matchData.length, length = index3, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index3--) {
          var data = matchData[index3];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index3 < length) {
          data = matchData[index3];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined$1 && !(key in object)) {
              return false;
            }
          } else {
            var stack2 = new Stack3();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source2, stack2);
            }
            if (!(result2 === undefined$1 ? baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG3 | COMPARE_UNORDERED_FLAG3, customizer, stack2) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative2(value) {
        if (!isObject4(value) || isMasked2(value)) {
          return false;
        }
        var pattern = isFunction5(value) ? reIsNative2 : reIsHostCtor2;
        return pattern.test(toSource2(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike2(value) && baseGetTag2(value) == regexpTag3;
      }
      function baseIsSet2(value) {
        return isObjectLike2(value) && getTag2(value) == setTag3;
      }
      function baseIsTypedArray2(value) {
        return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[baseGetTag2(value)];
      }
      function baseIteratee2(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity3;
        }
        if (typeof value == "object") {
          return isArray4(value) ? baseMatchesProperty2(value[0], value[1]) : baseMatches2(value);
        }
        return property2(value);
      }
      function baseKeys2(object) {
        if (!isPrototype2(object)) {
          return nativeKeys2(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty5.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn2(object) {
        if (!isObject4(object)) {
          return nativeKeysIn2(object);
        }
        var isProto = isPrototype2(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty5.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt2(value, other) {
        return value < other;
      }
      function baseMap2(collection, iteratee2) {
        var index3 = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
        baseEach2(collection, function(value, key, collection2) {
          result2[++index3] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches2(source2) {
        var matchData = getMatchData2(source2);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable2(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source2 || baseIsMatch2(object, source2, matchData);
        };
      }
      function baseMatchesProperty2(path, srcValue) {
        if (isKey3(path) && isStrictComparable2(srcValue)) {
          return matchesStrictComparable2(toKey2(path), srcValue);
        }
        return function(object) {
          var objValue = get5(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn2(object, path) : baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG3 | COMPARE_UNORDERED_FLAG3);
        };
      }
      function baseMerge2(object, source2, srcIndex, customizer, stack2) {
        if (object === source2) {
          return;
        }
        baseFor2(source2, function(srcValue, key) {
          stack2 || (stack2 = new Stack3());
          if (isObject4(srcValue)) {
            baseMergeDeep2(object, source2, key, srcIndex, baseMerge2, customizer, stack2);
          } else {
            var newValue = customizer ? customizer(safeGet2(object, key), srcValue, key + "", object, source2, stack2) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue2(object, key, newValue);
          }
        }, keysIn2);
      }
      function baseMergeDeep2(object, source2, key, srcIndex, mergeFunc, customizer, stack2) {
        var objValue = safeGet2(object, key), srcValue = safeGet2(source2, key), stacked = stack2.get(srcValue);
        if (stacked) {
          assignMergeValue2(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source2, stack2) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray4(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray4(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject2(objValue)) {
              newValue = copyArray2(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray2(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject4(srcValue) || isArguments2(srcValue)) {
            newValue = objValue;
            if (isArguments2(objValue)) {
              newValue = toPlainObject2(objValue);
            } else if (!isObject4(objValue) || isFunction5(objValue)) {
              newValue = initCloneObject2(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack2.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
          stack2["delete"](srcValue);
        }
        assignMergeValue2(object, key, newValue);
      }
      function baseNth(array2, n4) {
        var length = array2.length;
        if (!length) {
          return;
        }
        n4 += n4 < 0 ? length : 0;
        return isIndex2(n4, length) ? array2[n4] : undefined$1;
      }
      function baseOrderBy2(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap2(iteratees, function(iteratee2) {
            if (isArray4(iteratee2)) {
              return function(value) {
                return baseGet3(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity3];
        }
        var index3 = -1;
        iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
        var result2 = baseMap2(collection, function(value, key, collection2) {
          var criteria = arrayMap2(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return {criteria, index: ++index3, value};
        });
        return baseSortBy2(result2, function(object, other) {
          return compareMultiple2(object, other, orders);
        });
      }
      function basePick2(object, paths) {
        return basePickBy2(object, paths, function(value, path) {
          return hasIn2(object, path);
        });
      }
      function basePickBy2(object, paths, predicate) {
        var index3 = -1, length = paths.length, result2 = {};
        while (++index3 < length) {
          var path = paths[index3], value = baseGet3(object, path);
          if (predicate(value, path)) {
            baseSet2(result2, castPath2(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep2(path) {
        return function(object) {
          return baseGet3(object, path);
        };
      }
      function basePullAll(array2, values3, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf2, index3 = -1, length = values3.length, seen = array2;
        if (array2 === values3) {
          values3 = copyArray2(values3);
        }
        if (iteratee2) {
          seen = arrayMap2(array2, baseUnary2(iteratee2));
        }
        while (++index3 < length) {
          var fromIndex = 0, value = values3[index3], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array2) {
              splice2.call(seen, fromIndex, 1);
            }
            splice2.call(array2, fromIndex, 1);
          }
        }
        return array2;
      }
      function basePullAt(array2, indexes) {
        var length = array2 ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index3 = indexes[length];
          if (length == lastIndex || index3 !== previous) {
            var previous = index3;
            if (isIndex2(index3)) {
              splice2.call(array2, index3, 1);
            } else {
              baseUnset(array2, index3);
            }
          }
        }
        return array2;
      }
      function baseRandom(lower2, upper) {
        return lower2 + nativeFloor(nativeRandom() * (upper - lower2 + 1));
      }
      function baseRange2(start3, end2, step, fromRight) {
        var index3 = -1, length = nativeMax3(nativeCeil2((end2 - start3) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index3] = start3;
          start3 += step;
        }
        return result2;
      }
      function baseRepeat(string, n4) {
        var result2 = "";
        if (!string || n4 < 1 || n4 > MAX_SAFE_INTEGER2) {
          return result2;
        }
        do {
          if (n4 % 2) {
            result2 += string;
          }
          n4 = nativeFloor(n4 / 2);
          if (n4) {
            string += string;
          }
        } while (n4);
        return result2;
      }
      function baseRest2(func, start3) {
        return setToString2(overRest2(func, start3, identity3), func + "");
      }
      function baseSample(collection) {
        return arraySample(values2(collection));
      }
      function baseSampleSize(collection, n4) {
        var array2 = values2(collection);
        return shuffleSelf(array2, baseClamp(n4, 0, array2.length));
      }
      function baseSet2(object, path, value, customizer) {
        if (!isObject4(object)) {
          return object;
        }
        path = castPath2(path, object);
        var index3 = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index3 < length) {
          var key = toKey2(path[index3]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index3 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject4(objValue) ? objValue : isIndex2(path[index3 + 1]) ? [] : {};
            }
          }
          assignValue2(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity3 : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString2 = !defineProperty3 ? identity3 : function(func, string) {
        return defineProperty3(func, "toString", {
          configurable: true,
          enumerable: false,
          value: constant3(string),
          writable: true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values2(collection));
      }
      function baseSlice(array2, start3, end2) {
        var index3 = -1, length = array2.length;
        if (start3 < 0) {
          start3 = -start3 > length ? 0 : length + start3;
        }
        end2 = end2 > length ? length : end2;
        if (end2 < 0) {
          end2 += length;
        }
        length = start3 > end2 ? 0 : end2 - start3 >>> 0;
        start3 >>>= 0;
        var result2 = Array2(length);
        while (++index3 < length) {
          result2[index3] = array2[index3 + start3];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach2(collection, function(value, index3, collection2) {
          result2 = predicate(value, index3, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array2, value, retHighest) {
        var low = 0, high = array2 == null ? low : array2.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array2[mid];
            if (computed !== null && !isSymbol2(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array2, value, identity3, retHighest);
      }
      function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
        var low = 0, high = array2 == null ? 0 : array2.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array2[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol2(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array2, iteratee2) {
        var index3 = -1, length = array2.length, resIndex = 0, result2 = [];
        while (++index3 < length) {
          var value = array2[index3], computed = iteratee2 ? iteratee2(value) : value;
          if (!index3 || !eq2(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN2;
        }
        return +value;
      }
      function baseToString2(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray4(value)) {
          return arrayMap2(value, baseToString2) + "";
        }
        if (isSymbol2(value)) {
          return symbolToString2 ? symbolToString2.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
      }
      function baseUniq2(array2, iteratee2, comparator) {
        var index3 = -1, includes2 = arrayIncludes2, length = array2.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith2;
        } else if (length >= LARGE_ARRAY_SIZE3) {
          var set4 = iteratee2 ? null : createSet2(array2);
          if (set4) {
            return setToArray2(set4);
          }
          isCommon = false;
          includes2 = cacheHas2;
          seen = new SetCache2();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index3 < length) {
            var value = array2[index3], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath2(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey2(last2(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet2(object, path, updater(baseGet3(object, path)), customizer);
      }
      function baseWhile(array2, predicate, isDrop, fromRight) {
        var length = array2.length, index3 = fromRight ? length : -1;
        while ((fromRight ? index3-- : ++index3 < length) && predicate(array2[index3], index3, array2)) {
        }
        return isDrop ? baseSlice(array2, fromRight ? 0 : index3, fromRight ? index3 + 1 : length) : baseSlice(array2, fromRight ? index3 + 1 : 0, fromRight ? length : index3);
      }
      function baseWrapperValue(value, actions2) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce2(actions2, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush2([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq2(arrays[0]) : [];
        }
        var index3 = -1, result2 = Array2(length);
        while (++index3 < length) {
          var array2 = arrays[index3], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index3) {
              result2[index3] = baseDifference(result2[index3] || array2, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq2(baseFlatten2(result2, 1), iteratee2, comparator);
      }
      function baseZipObject2(props, values3, assignFunc) {
        var index3 = -1, length = props.length, valsLength = values3.length, result2 = {};
        while (++index3 < length) {
          var value = index3 < valsLength ? values3[index3] : undefined$1;
          assignFunc(result2, props[index3], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject2(value) ? value : [];
      }
      function castFunction2(value) {
        return typeof value == "function" ? value : identity3;
      }
      function castPath2(value, object) {
        if (isArray4(value)) {
          return value;
        }
        return isKey3(value, object) ? [value] : stringToPath3(toString4(value));
      }
      var castRest = baseRest2;
      function castSlice(array2, start3, end2) {
        var length = array2.length;
        end2 = end2 === undefined$1 ? length : end2;
        return !start3 && end2 >= length ? array2 : baseSlice(array2, start3, end2);
      }
      var clearTimeout2 = ctxClearTimeout || function(id3) {
        return root3.clearTimeout(id3);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer2(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array3(result2).set(new Uint8Array3(arrayBuffer));
        return result2;
      }
      function cloneDataView2(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp2(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags2.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol2(symbol) {
        return symbolValueOf3 ? Object2(symbolValueOf3.call(symbol)) : {};
      }
      function cloneTypedArray2(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending2(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple2(object, other, orders) {
        var index3 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index3 < length) {
          var result2 = compareAscending2(objCriteria[index3], othCriteria[index3]);
          if (result2) {
            if (index3 >= ordersLength) {
              return result2;
            }
            var order3 = orders[index3];
            return result2 * (order3 == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax3(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax3(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset2 = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset2 + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray2(source2, array2) {
        var index3 = -1, length = source2.length;
        array2 || (array2 = Array2(length));
        while (++index3 < length) {
          array2[index3] = source2[index3];
        }
        return array2;
      }
      function copyObject2(source2, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index3 = -1, length = props.length;
        while (++index3 < length) {
          var key = props[index3];
          var newValue = customizer ? customizer(object[key], source2[key], key, object, source2) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source2[key];
          }
          if (isNew) {
            baseAssignValue2(object, key, newValue);
          } else {
            assignValue2(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols2(source2, object) {
        return copyObject2(source2, getSymbols2(source2), object);
      }
      function copySymbolsIn2(source2, object) {
        return copyObject2(source2, getSymbolsIn2(source2), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray4(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner2(assigner) {
        return baseRest2(function(object, sources) {
          var index3 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
          if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$1 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index3 < length) {
            var source2 = sources[index3];
            if (source2) {
              assigner(object, source2, index3, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach2(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike2(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index3 = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index3-- : ++index3 < length) {
            if (iteratee2(iterable[index3], index3, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor2(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index3 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index3];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root3 && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString4(string);
          var strSymbols = hasUnicode2(string) ? stringToArray(string) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce2(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate2(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject4(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index3 = length, placeholder = getHolder(wrapper);
          while (index3--) {
            args[index3] = arguments[index3];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined$1, args, holders, undefined$1, undefined$1, arity - length);
          }
          var fn = this && this !== root3 && this instanceof wrapper ? Ctor : func;
          return apply2(fn, this, args);
        }
        return wrapper;
      }
      function createFind2(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike2(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys2(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index3 = findIndexFunc(collection, predicate, fromIndex);
          return index3 > -1 ? iterable[iteratee2 ? collection[index3] : index3] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest2(function(funcs) {
          var length = funcs.length, index3 = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index3--) {
            var func = funcs[index3];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index3 = wrapper ? index3 : length;
          while (++index3 < length) {
            func = funcs[index3];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray4(value)) {
              return wrapper.plant(value).value();
            }
            var index4 = 0, result2 = length ? funcs[index4].apply(this, args) : value;
            while (++index4 < length) {
              result2 = funcs[index4].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index3 = length;
          while (index3--) {
            args[index3] = arguments[index3];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root3 && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result2 = value;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString2(value);
              other = baseToString2(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest2(function(iteratees) {
          iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
          return baseRest2(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply2(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? " " : baseToString2(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil2(length / stringSize2(chars)));
        return hasUnicode2(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root3 && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply2(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange2(fromRight) {
        return function(start3, end2, step) {
          if (step && typeof step != "number" && isIterateeCall2(start3, end2, step)) {
            end2 = step = undefined$1;
          }
          start3 = toFinite2(start3);
          if (end2 === undefined$1) {
            end2 = start3;
            start3 = 0;
          } else {
            end2 = toFinite2(end2);
          }
          step = step === undefined$1 ? start3 < end2 ? 1 : -1 : toFinite2(step);
          return baseRange2(start3, end2, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber2(value);
            other = toNumber2(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber2(number);
          precision = precision == null ? 0 : nativeMin(toInteger2(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString4(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString4(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet2 = !(Set3 && 1 / setToArray2(new Set3([, -0]))[1] == INFINITY2) ? noop6 : function(values3) {
        return new Set3(values3);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag2(object);
          if (tag == mapTag3) {
            return mapToArray2(object);
          }
          if (tag == setTag3) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax3(toInteger2(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger2(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data = isBindKey ? undefined$1 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax3(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$1 || eq2(objValue, objectProto3[key]) && !hasOwnProperty5.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source2, stack2) {
        if (isObject4(objValue) && isObject4(srcValue)) {
          stack2.set(srcValue, objValue);
          baseMerge2(objValue, srcValue, undefined$1, customDefaultsMerge, stack2);
          stack2["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject4(value) ? undefined$1 : value;
      }
      function equalArrays2(array2, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, arrLength = array2.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack2.get(array2);
        var othStacked = stack2.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array2;
        }
        var index3 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG3 ? new SetCache2() : undefined$1;
        stack2.set(array2, other);
        stack2.set(other, array2);
        while (++index3 < arrLength) {
          var arrValue = array2[index3], othValue = other[index3];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index3, other, array2, stack2) : customizer(arrValue, othValue, index3, array2, other, stack2);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome2(other, function(othValue2, othIndex) {
              if (!cacheHas2(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
            result2 = false;
            break;
          }
        }
        stack2["delete"](array2);
        stack2["delete"](other);
        return result2;
      }
      function equalByTag2(object, other, tag, bitmask, customizer, equalFunc, stack2) {
        switch (tag) {
          case dataViewTag3:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag3:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object), new Uint8Array3(other))) {
              return false;
            }
            return true;
          case boolTag3:
          case dateTag3:
          case numberTag3:
            return eq2(+object, +other);
          case errorTag3:
            return object.name == other.name && object.message == other.message;
          case regexpTag3:
          case stringTag3:
            return object == other + "";
          case mapTag3:
            var convert = mapToArray2;
          case setTag3:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG3;
            convert || (convert = setToArray2);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack2.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG3;
            stack2.set(object, other);
            var result2 = equalArrays2(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
            stack2["delete"](object);
            return result2;
          case symbolTag3:
            if (symbolValueOf3) {
              return symbolValueOf3.call(object) == symbolValueOf3.call(other);
            }
        }
        return false;
      }
      function equalObjects2(object, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys2(object), objLength = objProps.length, othProps = getAllKeys2(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index3 = objLength;
        while (index3--) {
          var key = objProps[index3];
          if (!(isPartial ? key in other : hasOwnProperty5.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack2.get(object);
        var othStacked = stack2.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack2.set(object, other);
        stack2.set(other, object);
        var skipCtor = isPartial;
        while (++index3 < objLength) {
          key = objProps[index3];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack2["delete"](object);
        stack2["delete"](other);
        return result2;
      }
      function flatRest2(func) {
        return setToString2(overRest2(func, undefined$1, flatten4), func + "");
      }
      function getAllKeys2(object) {
        return baseGetAllKeys2(object, keys2, getSymbols2);
      }
      function getAllKeysIn2(object) {
        return baseGetAllKeys2(object, keysIn2, getSymbolsIn2);
      }
      var getData = !metaMap ? noop6 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array2 = realNames[result2], length = hasOwnProperty5.call(realNames, result2) ? array2.length : 0;
        while (length--) {
          var data = array2[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty5.call(lodash3, "placeholder") ? lodash3 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash3.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee2 : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData2(map4, key) {
        var data = map4.__data__;
        return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData2(object) {
        var result2 = keys2(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable2(value)];
        }
        return result2;
      }
      function getNative2(object, key) {
        var value = getValue2(object, key);
        return baseIsNative2(value) ? value : undefined$1;
      }
      function getRawTag2(value) {
        var isOwn = hasOwnProperty5.call(value, symToStringTag2), tag = value[symToStringTag2];
        try {
          value[symToStringTag2] = undefined$1;
          var unmasked = true;
        } catch (e3) {
        }
        var result2 = nativeObjectToString2.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag2] = tag;
          } else {
            delete value[symToStringTag2];
          }
        }
        return result2;
      }
      var getSymbols2 = !nativeGetSymbols3 ? stubArray2 : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter2(nativeGetSymbols3(object), function(symbol) {
          return propertyIsEnumerable2.call(object, symbol);
        });
      };
      var getSymbolsIn2 = !nativeGetSymbols3 ? stubArray2 : function(object) {
        var result2 = [];
        while (object) {
          arrayPush2(result2, getSymbols2(object));
          object = getPrototype2(object);
        }
        return result2;
      };
      var getTag2 = baseGetTag2;
      if (DataView3 && getTag2(new DataView3(new ArrayBuffer(1))) != dataViewTag3 || Map3 && getTag2(new Map3()) != mapTag3 || Promise3 && getTag2(Promise3.resolve()) != promiseTag2 || Set3 && getTag2(new Set3()) != setTag3 || WeakMap3 && getTag2(new WeakMap3()) != weakMapTag3) {
        getTag2 = function(value) {
          var result2 = baseGetTag2(value), Ctor = result2 == objectTag3 ? value.constructor : undefined$1, ctorString = Ctor ? toSource2(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString2:
                return dataViewTag3;
              case mapCtorString2:
                return mapTag3;
              case promiseCtorString2:
                return promiseTag2;
              case setCtorString2:
                return setTag3;
              case weakMapCtorString2:
                return weakMapTag3;
            }
          }
          return result2;
        };
      }
      function getView(start3, end2, transforms) {
        var index3 = -1, length = transforms.length;
        while (++index3 < length) {
          var data = transforms[index3], size3 = data.size;
          switch (data.type) {
            case "drop":
              start3 += size3;
              break;
            case "dropRight":
              end2 -= size3;
              break;
            case "take":
              end2 = nativeMin(end2, start3 + size3);
              break;
            case "takeRight":
              start3 = nativeMax3(start3, end2 - size3);
              break;
          }
        }
        return {start: start3, end: end2};
      }
      function getWrapDetails(source2) {
        var match = source2.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath2(object, path, hasFunc) {
        path = castPath2(path, object);
        var index3 = -1, length = path.length, result2 = false;
        while (++index3 < length) {
          var key = toKey2(path[index3]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index3 != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength2(length) && isIndex2(key, length) && (isArray4(object) || isArguments2(object));
      }
      function initCloneArray2(array2) {
        var length = array2.length, result2 = new array2.constructor(length);
        if (length && typeof array2[0] == "string" && hasOwnProperty5.call(array2, "index")) {
          result2.index = array2.index;
          result2.input = array2.input;
        }
        return result2;
      }
      function initCloneObject2(object) {
        return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate2(getPrototype2(object)) : {};
      }
      function initCloneByTag2(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag3:
            return cloneArrayBuffer2(object);
          case boolTag3:
          case dateTag3:
            return new Ctor(+object);
          case dataViewTag3:
            return cloneDataView2(object, isDeep);
          case float32Tag3:
          case float64Tag3:
          case int8Tag3:
          case int16Tag3:
          case int32Tag3:
          case uint8Tag3:
          case uint8ClampedTag3:
          case uint16Tag3:
          case uint32Tag3:
            return cloneTypedArray2(object, isDeep);
          case mapTag3:
            return new Ctor();
          case numberTag3:
          case stringTag3:
            return new Ctor(object);
          case regexpTag3:
            return cloneRegExp2(object);
          case setTag3:
            return new Ctor();
          case symbolTag3:
            return cloneSymbol2(object);
        }
      }
      function insertWrapDetails(source2, details) {
        var length = details.length;
        if (!length) {
          return source2;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source2.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable2(value) {
        return isArray4(value) || isArguments2(value) || !!(spreadableSymbol2 && value && value[spreadableSymbol2]);
      }
      function isIndex2(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER2 : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall2(value, index3, object) {
        if (!isObject4(object)) {
          return false;
        }
        var type = typeof index3;
        if (type == "number" ? isArrayLike2(object) && isIndex2(index3, object.length) : type == "string" && index3 in object) {
          return eq2(object[index3], value);
        }
        return false;
      }
      function isKey3(value, object) {
        if (isArray4(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
          return true;
        }
        return reIsPlainProp2.test(value) || !reIsDeepProp2.test(value) || object != null && value in Object2(object);
      }
      function isKeyable2(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash3[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked2(func) {
        return !!maskSrcKey2 && maskSrcKey2 in func;
      }
      var isMaskable = coreJsData2 ? isFunction5 : stubFalse2;
      function isPrototype2(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto3;
        return value === proto;
      }
      function isStrictComparable2(value) {
        return value === value && !isObject4(value);
      }
      function matchesStrictComparable2(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
        };
      }
      function memoizeCapped2(func) {
        var result2 = memoize2(func, function(key) {
          if (cache3.size === MAX_MEMOIZE_SIZE2) {
            cache3.clear();
          }
          return key;
        });
        var cache3 = result2.cache;
        return result2;
      }
      function mergeData(data, source2) {
        var bitmask = data[1], srcBitmask = source2[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source2[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source2[7].length <= source2[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source2[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source2[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source2[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source2[4];
        }
        value = source2[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source2[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source2[6];
        }
        value = source2[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source2[8] : nativeMin(data[8], source2[8]);
        }
        if (data[9] == null) {
          data[9] = source2[9];
        }
        data[0] = source2[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn2(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString2(value) {
        return nativeObjectToString2.call(value);
      }
      function overRest2(func, start3, transform4) {
        start3 = nativeMax3(start3 === undefined$1 ? func.length - 1 : start3, 0);
        return function() {
          var args = arguments, index3 = -1, length = nativeMax3(args.length - start3, 0), array2 = Array2(length);
          while (++index3 < length) {
            array2[index3] = args[start3 + index3];
          }
          index3 = -1;
          var otherArgs = Array2(start3 + 1);
          while (++index3 < start3) {
            otherArgs[index3] = args[index3];
          }
          otherArgs[start3] = transform4(array2);
          return apply2(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet3(object, baseSlice(path, 0, -1));
      }
      function reorder(array2, indexes) {
        var arrLength = array2.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray2(array2);
        while (length--) {
          var index3 = indexes[length];
          array2[length] = isIndex2(index3, arrLength) ? oldArray[index3] : undefined$1;
        }
        return array2;
      }
      function safeGet2(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut2(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root3.setTimeout(func, wait);
      };
      var setToString2 = shortOut2(baseSetToString2);
      function setWrapToString(wrapper, reference2, bitmask) {
        var source2 = reference2 + "";
        return setToString2(wrapper, insertWrapDetails(source2, updateWrapDetails(getWrapDetails(source2), bitmask)));
      }
      function shortOut2(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow2(), remaining = HOT_SPAN2 - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT2) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array2, size3) {
        var index3 = -1, length = array2.length, lastIndex = length - 1;
        size3 = size3 === undefined$1 ? length : size3;
        while (++index3 < size3) {
          var rand = baseRandom(index3, lastIndex), value = array2[rand];
          array2[rand] = array2[index3];
          array2[index3] = value;
        }
        array2.length = size3;
        return array2;
      }
      var stringToPath3 = memoizeCapped2(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName2, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar2, "$1") : number || match);
        });
        return result2;
      });
      function toKey2(value) {
        if (typeof value == "string" || isSymbol2(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
      }
      function toSource2(func) {
        if (func != null) {
          try {
            return funcToString2.call(func);
          } catch (e3) {
          }
          try {
            return func + "";
          } catch (e3) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach2(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes2(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray2(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array2, size3, guard) {
        if (guard ? isIterateeCall2(array2, size3, guard) : size3 === undefined$1) {
          size3 = 1;
        } else {
          size3 = nativeMax3(toInteger2(size3), 0);
        }
        var length = array2 == null ? 0 : array2.length;
        if (!length || size3 < 1) {
          return [];
        }
        var index3 = 0, resIndex = 0, result2 = Array2(nativeCeil2(length / size3));
        while (index3 < length) {
          result2[resIndex++] = baseSlice(array2, index3, index3 += size3);
        }
        return result2;
      }
      function compact2(array2) {
        var index3 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
        while (++index3 < length) {
          var value = array2[index3];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array2 = arguments[0], index3 = length;
        while (index3--) {
          args[index3 - 1] = arguments[index3];
        }
        return arrayPush2(isArray4(array2) ? copyArray2(array2) : [array2], baseFlatten2(args, 1));
      }
      var difference = baseRest2(function(array2, values3) {
        return isArrayLikeObject2(array2) ? baseDifference(array2, baseFlatten2(values3, 1, isArrayLikeObject2, true)) : [];
      });
      var differenceBy = baseRest2(function(array2, values3) {
        var iteratee2 = last2(values3);
        if (isArrayLikeObject2(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject2(array2) ? baseDifference(array2, baseFlatten2(values3, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest2(function(array2, values3) {
        var comparator = last2(values3);
        if (isArrayLikeObject2(comparator)) {
          comparator = undefined$1;
        }
        return isArrayLikeObject2(array2) ? baseDifference(array2, baseFlatten2(values3, 1, isArrayLikeObject2, true), undefined$1, comparator) : [];
      });
      function drop(array2, n4, guard) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return [];
        }
        n4 = guard || n4 === undefined$1 ? 1 : toInteger2(n4);
        return baseSlice(array2, n4 < 0 ? 0 : n4, length);
      }
      function dropRight(array2, n4, guard) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return [];
        }
        n4 = guard || n4 === undefined$1 ? 1 : toInteger2(n4);
        n4 = length - n4;
        return baseSlice(array2, 0, n4 < 0 ? 0 : n4);
      }
      function dropRightWhile(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
      }
      function fill(array2, value, start3, end2) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return [];
        }
        if (start3 && typeof start3 != "number" && isIterateeCall2(array2, value, start3)) {
          start3 = 0;
          end2 = length;
        }
        return baseFill(array2, value, start3, end2);
      }
      function findIndex2(array2, predicate, fromIndex) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return -1;
        }
        var index3 = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index3 < 0) {
          index3 = nativeMax3(length + index3, 0);
        }
        return baseFindIndex2(array2, getIteratee(predicate, 3), index3);
      }
      function findLastIndex(array2, predicate, fromIndex) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return -1;
        }
        var index3 = length - 1;
        if (fromIndex !== undefined$1) {
          index3 = toInteger2(fromIndex);
          index3 = fromIndex < 0 ? nativeMax3(length + index3, 0) : nativeMin(index3, length - 1);
        }
        return baseFindIndex2(array2, getIteratee(predicate, 3), index3, true);
      }
      function flatten4(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseFlatten2(array2, 1) : [];
      }
      function flattenDeep(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseFlatten2(array2, INFINITY2) : [];
      }
      function flattenDepth(array2, depth) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger2(depth);
        return baseFlatten2(array2, depth);
      }
      function fromPairs(pairs) {
        var index3 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index3 < length) {
          var pair = pairs[index3];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array2) {
        return array2 && array2.length ? array2[0] : undefined$1;
      }
      function indexOf(array2, value, fromIndex) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return -1;
        }
        var index3 = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index3 < 0) {
          index3 = nativeMax3(length + index3, 0);
        }
        return baseIndexOf2(array2, value, index3);
      }
      function initial(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseSlice(array2, 0, -1) : [];
      }
      var intersection = baseRest2(function(arrays) {
        var mapped = arrayMap2(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest2(function(arrays) {
        var iteratee2 = last2(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
        if (iteratee2 === last2(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest2(function(arrays) {
        var comparator = last2(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join(array2, separator) {
        return array2 == null ? "" : nativeJoin.call(array2, separator);
      }
      function last2(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? array2[length - 1] : undefined$1;
      }
      function lastIndexOf(array2, value, fromIndex) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return -1;
        }
        var index3 = length;
        if (fromIndex !== undefined$1) {
          index3 = toInteger2(fromIndex);
          index3 = index3 < 0 ? nativeMax3(length + index3, 0) : nativeMin(index3, length - 1);
        }
        return value === value ? strictLastIndexOf(array2, value, index3) : baseFindIndex2(array2, baseIsNaN2, index3, true);
      }
      function nth(array2, n4) {
        return array2 && array2.length ? baseNth(array2, toInteger2(n4)) : undefined$1;
      }
      var pull = baseRest2(pullAll);
      function pullAll(array2, values3) {
        return array2 && array2.length && values3 && values3.length ? basePullAll(array2, values3) : array2;
      }
      function pullAllBy(array2, values3, iteratee2) {
        return array2 && array2.length && values3 && values3.length ? basePullAll(array2, values3, getIteratee(iteratee2, 2)) : array2;
      }
      function pullAllWith(array2, values3, comparator) {
        return array2 && array2.length && values3 && values3.length ? basePullAll(array2, values3, undefined$1, comparator) : array2;
      }
      var pullAt = flatRest2(function(array2, indexes) {
        var length = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
        basePullAt(array2, arrayMap2(indexes, function(index3) {
          return isIndex2(index3, length) ? +index3 : index3;
        }).sort(compareAscending2));
        return result2;
      });
      function remove3(array2, predicate) {
        var result2 = [];
        if (!(array2 && array2.length)) {
          return result2;
        }
        var index3 = -1, indexes = [], length = array2.length;
        predicate = getIteratee(predicate, 3);
        while (++index3 < length) {
          var value = array2[index3];
          if (predicate(value, index3, array2)) {
            result2.push(value);
            indexes.push(index3);
          }
        }
        basePullAt(array2, indexes);
        return result2;
      }
      function reverse(array2) {
        return array2 == null ? array2 : nativeReverse.call(array2);
      }
      function slice(array2, start3, end2) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return [];
        }
        if (end2 && typeof end2 != "number" && isIterateeCall2(array2, start3, end2)) {
          start3 = 0;
          end2 = length;
        } else {
          start3 = start3 == null ? 0 : toInteger2(start3);
          end2 = end2 === undefined$1 ? length : toInteger2(end2);
        }
        return baseSlice(array2, start3, end2);
      }
      function sortedIndex(array2, value) {
        return baseSortedIndex(array2, value);
      }
      function sortedIndexBy(array2, value, iteratee2) {
        return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array2, value) {
        var length = array2 == null ? 0 : array2.length;
        if (length) {
          var index3 = baseSortedIndex(array2, value);
          if (index3 < length && eq2(array2[index3], value)) {
            return index3;
          }
        }
        return -1;
      }
      function sortedLastIndex(array2, value) {
        return baseSortedIndex(array2, value, true);
      }
      function sortedLastIndexBy(array2, value, iteratee2) {
        return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array2, value) {
        var length = array2 == null ? 0 : array2.length;
        if (length) {
          var index3 = baseSortedIndex(array2, value, true) - 1;
          if (eq2(array2[index3], value)) {
            return index3;
          }
        }
        return -1;
      }
      function sortedUniq(array2) {
        return array2 && array2.length ? baseSortedUniq(array2) : [];
      }
      function sortedUniqBy(array2, iteratee2) {
        return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseSlice(array2, 1, length) : [];
      }
      function take(array2, n4, guard) {
        if (!(array2 && array2.length)) {
          return [];
        }
        n4 = guard || n4 === undefined$1 ? 1 : toInteger2(n4);
        return baseSlice(array2, 0, n4 < 0 ? 0 : n4);
      }
      function takeRight(array2, n4, guard) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return [];
        }
        n4 = guard || n4 === undefined$1 ? 1 : toInteger2(n4);
        n4 = length - n4;
        return baseSlice(array2, n4 < 0 ? 0 : n4, length);
      }
      function takeRightWhile(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
      }
      var union2 = baseRest2(function(arrays) {
        return baseUniq2(baseFlatten2(arrays, 1, isArrayLikeObject2, true));
      });
      var unionBy = baseRest2(function(arrays) {
        var iteratee2 = last2(arrays);
        if (isArrayLikeObject2(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq2(baseFlatten2(arrays, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest2(function(arrays) {
        var comparator = last2(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseUniq2(baseFlatten2(arrays, 1, isArrayLikeObject2, true), undefined$1, comparator);
      });
      function uniq(array2) {
        return array2 && array2.length ? baseUniq2(array2) : [];
      }
      function uniqBy(array2, iteratee2) {
        return array2 && array2.length ? baseUniq2(array2, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array2, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return array2 && array2.length ? baseUniq2(array2, undefined$1, comparator) : [];
      }
      function unzip(array2) {
        if (!(array2 && array2.length)) {
          return [];
        }
        var length = 0;
        array2 = arrayFilter2(array2, function(group) {
          if (isArrayLikeObject2(group)) {
            length = nativeMax3(group.length, length);
            return true;
          }
        });
        return baseTimes2(length, function(index3) {
          return arrayMap2(array2, baseProperty2(index3));
        });
      }
      function unzipWith(array2, iteratee2) {
        if (!(array2 && array2.length)) {
          return [];
        }
        var result2 = unzip(array2);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap2(result2, function(group) {
          return apply2(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest2(function(array2, values3) {
        return isArrayLikeObject2(array2) ? baseDifference(array2, values3) : [];
      });
      var xor = baseRest2(function(arrays) {
        return baseXor(arrayFilter2(arrays, isArrayLikeObject2));
      });
      var xorBy = baseRest2(function(arrays) {
        var iteratee2 = last2(arrays);
        if (isArrayLikeObject2(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter2(arrays, isArrayLikeObject2), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest2(function(arrays) {
        var comparator = last2(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseXor(arrayFilter2(arrays, isArrayLikeObject2), undefined$1, comparator);
      });
      var zip = baseRest2(unzip);
      function zipObject2(props, values3) {
        return baseZipObject2(props || [], values3 || [], assignValue2);
      }
      function zipObjectDeep(props, values3) {
        return baseZipObject2(props || [], values3 || [], baseSet2);
      }
      var zipWith = baseRest2(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash3(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest2(function(paths) {
        var length = paths.length, start3 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex2(start3)) {
          return this.thru(interceptor);
        }
        value = value.slice(start3, +start3 + (length ? 1 : 0));
        value.__actions__.push({
          func: thru,
          args: [interceptor],
          thisArg: undefined$1
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array2) {
          if (length && !array2.length) {
            array2.push(undefined$1);
          }
          return array2;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return {done, value};
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone3 = wrapperClone(parent2);
          clone3.__index__ = 0;
          clone3.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone3;
          } else {
            result2 = clone3;
          }
          var previous = clone3;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            func: thru,
            args: [reverse],
            thisArg: undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty5.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue2(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray4(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall2(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter3(collection, predicate) {
        var func = isArray4(collection) ? arrayFilter2 : baseFilter2;
        return func(collection, getIteratee(predicate, 3));
      }
      var find3 = createFind2(findIndex2);
      var findLast = createFind2(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten2(map3(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten2(map3(collection, iteratee2), INFINITY2);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger2(depth);
        return baseFlatten2(map3(collection, iteratee2), depth);
      }
      function forEach4(collection, iteratee2) {
        var func = isArray4(collection) ? arrayEach2 : baseEach2;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray4(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty5.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue2(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike2(collection) ? collection : values2(collection);
        fromIndex = fromIndex && !guard ? toInteger2(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax3(length + fromIndex, 0);
        }
        return isString4(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf2(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest2(function(collection, path, args) {
        var index3 = -1, isFunc = typeof path == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
        baseEach2(collection, function(value) {
          result2[++index3] = isFunc ? apply2(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue2(result2, key, value);
      });
      function map3(collection, iteratee2) {
        var func = isArray4(collection) ? arrayMap2 : baseMap2;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray4(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray4(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy2(collection, iteratees, orders);
      }
      var partition2 = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce3(collection, iteratee2, accumulator) {
        var func = isArray4(collection) ? arrayReduce2 : baseReduce2, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach2);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray4(collection) ? arrayReduceRight : baseReduce2, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray4(collection) ? arrayFilter2 : baseFilter2;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray4(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n4, guard) {
        if (guard ? isIterateeCall2(collection, n4, guard) : n4 === undefined$1) {
          n4 = 1;
        } else {
          n4 = toInteger2(n4);
        }
        var func = isArray4(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n4);
      }
      function shuffle(collection) {
        var func = isArray4(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size2(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike2(collection)) {
          return isString4(collection) ? stringSize2(collection) : collection.length;
        }
        var tag = getTag2(collection);
        if (tag == mapTag3 || tag == setTag3) {
          return collection.size;
        }
        return baseKeys2(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray4(collection) ? arraySome2 : baseSome;
        if (guard && isIterateeCall2(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy2 = baseRest2(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall2(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall2(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy2(collection, baseFlatten2(iteratees, 1), []);
      });
      var now3 = ctxNow || function() {
        return root3.Date.now();
      };
      function after(n4, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        n4 = toInteger2(n4);
        return function() {
          if (--n4 < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n4, guard) {
        n4 = guard ? undefined$1 : n4;
        n4 = func && n4 == null ? func.length : n4;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n4);
      }
      function before(n4, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        n4 = toInteger2(n4);
        return function() {
          if (--n4 > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n4 <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      var bind3 = baseRest2(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind3));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey2 = baseRest2(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey2));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce2(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        wait = toNumber2(wait) || 0;
        if (isObject4(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax3(toNumber2(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time2) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time2;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time2) {
          lastInvokeTime = time2;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time2) : result2;
        }
        function remainingWait(time2) {
          var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time2) {
          var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time2 = now3();
          if (shouldInvoke(time2)) {
            return trailingEdge(time2);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time2));
        }
        function trailingEdge(time2) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time2);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now3());
        }
        function debounced() {
          var time2 = now3(), isInvoking = shouldInvoke(time2);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time2;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer2 = baseRest2(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay3 = baseRest2(function(func, wait, args) {
        return baseDelay(func, toNumber2(wait) || 0, args);
      });
      function flip2(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize2(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache3 = memoized.cache;
          if (cache3.has(key)) {
            return cache3.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache3.set(key, result2) || cache3;
          return result2;
        };
        memoized.cache = new (memoize2.Cache || MapCache2)();
        return memoized;
      }
      memoize2.Cache = MapCache2;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once2(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray4(transforms[0]) ? arrayMap2(transforms[0], baseUnary2(getIteratee())) : arrayMap2(baseFlatten2(transforms, 1), baseUnary2(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest2(function(args) {
          var index3 = -1, length = nativeMin(args.length, funcsLength);
          while (++index3 < length) {
            args[index3] = transforms[index3].call(this, args[index3]);
          }
          return apply2(func, this, args);
        });
      });
      var partial = baseRest2(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest2(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest2(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start3) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        start3 = start3 === undefined$1 ? start3 : toInteger2(start3);
        return baseRest2(func, start3);
      }
      function spread3(func, start3) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        start3 = start3 == null ? 0 : nativeMax3(toInteger2(start3), 0);
        return baseRest2(function(args) {
          var array2 = args[start3], otherArgs = castSlice(args, 0, start3);
          if (array2) {
            arrayPush2(otherArgs, array2);
          }
          return apply2(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        if (isObject4(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce2(func, wait, {
          leading,
          maxWait: wait,
          trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction2(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray4(value) ? value : [value];
      }
      function clone2(value) {
        return baseClone2(value, CLONE_SYMBOLS_FLAG2);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone2(value, CLONE_SYMBOLS_FLAG2, customizer);
      }
      function cloneDeep2(value) {
        return baseClone2(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone2(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2, customizer);
      }
      function conformsTo(object, source2) {
        return source2 == null || baseConformsTo(object, source2, keys2(source2));
      }
      function eq2(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt2);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments2 = baseIsArguments2(function() {
        return arguments;
      }()) ? baseIsArguments2 : function(value) {
        return isObjectLike2(value) && hasOwnProperty5.call(value, "callee") && !propertyIsEnumerable2.call(value, "callee");
      };
      var isArray4 = Array2.isArray;
      var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary2(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike2(value) {
        return value != null && isLength2(value.length) && !isFunction5(value);
      }
      function isArrayLikeObject2(value) {
        return isObjectLike2(value) && isArrayLike2(value);
      }
      function isBoolean2(value) {
        return value === true || value === false || isObjectLike2(value) && baseGetTag2(value) == boolTag3;
      }
      var isBuffer2 = nativeIsBuffer || stubFalse2;
      var isDate3 = nodeIsDate ? baseUnary2(nodeIsDate) : baseIsDate;
      function isElement3(value) {
        return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject4(value);
      }
      function isEmpty2(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike2(value) && (isArray4(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray2(value) || isArguments2(value))) {
          return !value.length;
        }
        var tag = getTag2(value);
        if (tag == mapTag3 || tag == setTag3) {
          return !value.size;
        }
        if (isPrototype2(value)) {
          return !baseKeys2(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty5.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual3(value, other) {
        return baseIsEqual2(value, other);
      }
      function isEqualWith2(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual2(value, other, undefined$1, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike2(value)) {
          return false;
        }
        var tag = baseGetTag2(value);
        return tag == errorTag3 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject4(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction5(value) {
        if (!isObject4(value)) {
          return false;
        }
        var tag = baseGetTag2(value);
        return tag == funcTag3 || tag == genTag3 || tag == asyncTag2 || tag == proxyTag2;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger2(value);
      }
      function isLength2(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
      }
      function isObject4(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike2(value) {
        return value != null && typeof value == "object";
      }
      var isMap2 = nodeIsMap2 ? baseUnary2(nodeIsMap2) : baseIsMap2;
      function isMatch(object, source2) {
        return object === source2 || baseIsMatch2(object, source2, getMatchData2(source2));
      }
      function isMatchWith(object, source2, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch2(object, source2, getMatchData2(source2), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative2(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike2(value) && baseGetTag2(value) == numberTag3;
      }
      function isPlainObject4(value) {
        if (!isObjectLike2(value) || baseGetTag2(value) != objectTag3) {
          return false;
        }
        var proto = getPrototype2(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty5.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString2;
      }
      var isRegExp = nodeIsRegExp ? baseUnary2(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER2 && value <= MAX_SAFE_INTEGER2;
      }
      var isSet2 = nodeIsSet2 ? baseUnary2(nodeIsSet2) : baseIsSet2;
      function isString4(value) {
        return typeof value == "string" || !isArray4(value) && isObjectLike2(value) && baseGetTag2(value) == stringTag3;
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike2(value) && baseGetTag2(value) == symbolTag3;
      }
      var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
      function isUndefined4(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike2(value) && getTag2(value) == weakMapTag3;
      }
      function isWeakSet(value) {
        return isObjectLike2(value) && baseGetTag2(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt2);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike2(value)) {
          return isString4(value) ? stringToArray(value) : copyArray2(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag2(value), func = tag == mapTag3 ? mapToArray2 : tag == setTag3 ? setToArray2 : values2;
        return func(value);
      }
      function toFinite2(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber2(value);
        if (value === INFINITY2 || value === -INFINITY2) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER2;
        }
        return value === value ? value : 0;
      }
      function toInteger2(value) {
        var result2 = toFinite2(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger2(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber2(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN2;
        }
        if (isObject4(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject4(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim2(value);
        var isBinary = reIsBinary2.test(value);
        return isBinary || reIsOctal2.test(value) ? freeParseInt2(value.slice(2), isBinary ? 2 : 8) : reIsBadHex2.test(value) ? NAN2 : +value;
      }
      function toPlainObject2(value) {
        return copyObject2(value, keysIn2(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger2(value), -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2) : value === 0 ? value : 0;
      }
      function toString4(value) {
        return value == null ? "" : baseToString2(value);
      }
      var assign = createAssigner2(function(object, source2) {
        if (isPrototype2(source2) || isArrayLike2(source2)) {
          copyObject2(source2, keys2(source2), object);
          return;
        }
        for (var key in source2) {
          if (hasOwnProperty5.call(source2, key)) {
            assignValue2(object, key, source2[key]);
          }
        }
      });
      var assignIn = createAssigner2(function(object, source2) {
        copyObject2(source2, keysIn2(source2), object);
      });
      var assignInWith = createAssigner2(function(object, source2, srcIndex, customizer) {
        copyObject2(source2, keysIn2(source2), object, customizer);
      });
      var assignWith = createAssigner2(function(object, source2, srcIndex, customizer) {
        copyObject2(source2, keys2(source2), object, customizer);
      });
      var at = flatRest2(baseAt);
      function create3(prototype, properties) {
        var result2 = baseCreate2(prototype);
        return properties == null ? result2 : baseAssign2(result2, properties);
      }
      var defaults3 = baseRest2(function(object, sources) {
        object = Object2(object);
        var index3 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index3 < length) {
          var source2 = sources[index3];
          var props = keysIn2(source2);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined$1 || eq2(value, objectProto3[key]) && !hasOwnProperty5.call(object, key)) {
              object[key] = source2[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest2(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply2(mergeWith2, undefined$1, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn2);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn2(object, iteratee2) {
        return object == null ? object : baseFor2(object, getIteratee(iteratee2, 3), keysIn2);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn2);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn2(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys2(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn2(object));
      }
      function get5(object, path, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet3(object, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has4(object, path) {
        return object != null && hasPath2(object, path, baseHas2);
      }
      function hasIn2(object, path) {
        return object != null && hasPath2(object, path, baseHasIn2);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString2.call(value);
        }
        result2[value] = key;
      }, constant3(identity3));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString2.call(value);
        }
        if (hasOwnProperty5.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest2(baseInvoke);
      function keys2(object) {
        return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
      }
      function keysIn2(object) {
        return isArrayLike2(object) ? arrayLikeKeys2(object, true) : baseKeysIn2(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn2(object, function(value, key, object2) {
          baseAssignValue2(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues2(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn2(object, function(value, key, object2) {
          baseAssignValue2(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge3 = createAssigner2(function(object, source2, srcIndex) {
        baseMerge2(object, source2, srcIndex);
      });
      var mergeWith2 = createAssigner2(function(object, source2, srcIndex, customizer) {
        baseMerge2(object, source2, srcIndex, customizer);
      });
      var omit = flatRest2(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap2(paths, function(path) {
          path = castPath2(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject2(object, getAllKeysIn2(object), result2);
        if (isDeep) {
          result2 = baseClone2(result2, CLONE_DEEP_FLAG2 | CLONE_FLAT_FLAG2 | CLONE_SYMBOLS_FLAG2, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick2 = flatRest2(function(object, paths) {
        return object == null ? {} : basePick2(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap2(getAllKeysIn2(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy2(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath2(path, object);
        var index3 = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined$1;
        }
        while (++index3 < length) {
          var value = object == null ? undefined$1 : object[toKey2(path[index3])];
          if (value === undefined$1) {
            index3 = length;
            value = defaultValue;
          }
          object = isFunction5(value) ? value.call(object) : value;
        }
        return object;
      }
      function set3(object, path, value) {
        return object == null ? object : baseSet2(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet2(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys2);
      var toPairsIn = createToPairs(keysIn2);
      function transform3(object, iteratee2, accumulator) {
        var isArr = isArray4(object), isArrLike = isArr || isBuffer2(object) || isTypedArray2(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject4(object)) {
            accumulator = isFunction5(Ctor) ? baseCreate2(getPrototype2(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach2 : baseForOwn2)(object, function(value, index3, object2) {
          return iteratee2(accumulator, value, index3, object2);
        });
        return accumulator;
      }
      function unset2(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction2(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction2(updater), customizer);
      }
      function values2(object) {
        return object == null ? [] : baseValues2(object, keys2(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues2(object, keysIn2(object));
      }
      function clamp4(number, lower2, upper) {
        if (upper === undefined$1) {
          upper = lower2;
          lower2 = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber2(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower2 !== undefined$1) {
          lower2 = toNumber2(lower2);
          lower2 = lower2 === lower2 ? lower2 : 0;
        }
        return baseClamp(toNumber2(number), lower2, upper);
      }
      function inRange(number, start3, end2) {
        start3 = toFinite2(start3);
        if (end2 === undefined$1) {
          end2 = start3;
          start3 = 0;
        } else {
          end2 = toFinite2(end2);
        }
        number = toNumber2(number);
        return baseInRange(number, start3, end2);
      }
      function random(lower2, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall2(lower2, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower2 == "boolean") {
            floating = lower2;
            lower2 = undefined$1;
          }
        }
        if (lower2 === undefined$1 && upper === undefined$1) {
          lower2 = 0;
          upper = 1;
        } else {
          lower2 = toFinite2(lower2);
          if (upper === undefined$1) {
            upper = lower2;
            lower2 = 0;
          } else {
            upper = toFinite2(upper);
          }
        }
        if (lower2 > upper) {
          var temp = lower2;
          lower2 = upper;
          upper = temp;
        }
        if (floating || lower2 % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower2 + rand * (upper - lower2 + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower2, upper);
      }
      var camelCase2 = createCompounder(function(result2, word, index3) {
        word = word.toLowerCase();
        return result2 + (index3 ? capitalize4(word) : word);
      });
      function capitalize4(string) {
        return upperFirst(toString4(string).toLowerCase());
      }
      function deburr(string) {
        string = toString4(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position2) {
        string = toString4(string);
        target = baseToString2(target);
        var length = string.length;
        position2 = position2 === undefined$1 ? length : baseClamp(toInteger2(position2), 0, length);
        var end2 = position2;
        position2 -= target.length;
        return position2 >= 0 && string.slice(position2, end2) == target;
      }
      function escape3(string) {
        string = toString4(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString4(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar2, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index3) {
        return result2 + (index3 ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index3) {
        return result2 + (index3 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString4(string);
        length = toInteger2(length);
        var strLength = length ? stringSize2(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil2(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString4(string);
        length = toInteger2(length);
        var strLength = length ? stringSize2(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString4(string);
        length = toInteger2(length);
        var strLength = length ? stringSize2(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString4(string).replace(reTrimStart2, ""), radix || 0);
      }
      function repeat(string, n4, guard) {
        if (guard ? isIterateeCall2(string, n4, guard) : n4 === undefined$1) {
          n4 = 1;
        } else {
          n4 = toInteger2(n4);
        }
        return baseRepeat(toString4(string), n4);
      }
      function replace() {
        var args = arguments, string = toString4(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index3) {
        return result2 + (index3 ? "_" : "") + word.toLowerCase();
      });
      function split2(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall2(string, separator, limit)) {
          separator = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString4(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString2(separator);
          if (!separator && hasUnicode2(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index3) {
        return result2 + (index3 ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position2) {
        string = toString4(string);
        position2 = position2 == null ? 0 : baseClamp(toInteger2(position2), 0, string.length);
        target = baseToString2(target);
        return string.slice(position2, position2 + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash3.templateSettings;
        if (guard && isIterateeCall2(string, options, guard)) {
          options = undefined$1;
        }
        string = toString4(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues2(imports, importsKeys);
        var isEscaping, isEvaluating, index3 = 0, interpolate2 = options.interpolate || reNoMatch, source2 = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate2.source + "|" + (interpolate2 === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty5.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source2 += string.slice(index3, offset2).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source2 += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source2 += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source2 += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index3 = offset2 + match.length;
          return match;
        });
        source2 += "';\n";
        var variable = hasOwnProperty5.call(options, "variable") && options.variable;
        if (!variable) {
          source2 = "with (obj) {\n" + source2 + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source2 = (isEvaluating ? source2.replace(reEmptyStringLeading, "") : source2).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source2 = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source2 + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source2).apply(undefined$1, importsValues);
        });
        result2.source = source2;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString4(value).toLowerCase();
      }
      function toUpper(value) {
        return toString4(value).toUpperCase();
      }
      function trim2(string, chars, guard) {
        string = toString4(string);
        if (string && (guard || chars === undefined$1)) {
          return baseTrim2(string);
        }
        if (!string || !(chars = baseToString2(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start3 = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start3, end2).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString4(string);
        if (string && (guard || chars === undefined$1)) {
          return string.slice(0, trimmedEndIndex2(string) + 1);
        }
        if (!string || !(chars = baseToString2(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end2 = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end2).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString4(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrimStart2, "");
        }
        if (!string || !(chars = baseToString2(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start3 = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start3).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject4(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger2(options.length) : length;
          omission = "omission" in options ? baseToString2(options.omission) : omission;
        }
        string = toString4(string);
        var strLength = string.length;
        if (hasUnicode2(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end2 = length - stringSize2(omission);
        if (end2 < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end2).join("") : string.slice(0, end2);
        if (separator === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end2 += result2.length - end2;
        }
        if (isRegExp(separator)) {
          if (string.slice(end2).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString4(reFlags2.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end2 : newEnd);
          }
        } else if (string.indexOf(baseToString2(separator), end2) != end2) {
          var index3 = result2.lastIndexOf(separator);
          if (index3 > -1) {
            result2 = result2.slice(0, index3);
          }
        }
        return result2 + omission;
      }
      function unescape2(string) {
        string = toString4(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index3) {
        return result2 + (index3 ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString4(string);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest2(function(func, args) {
        try {
          return apply2(func, undefined$1, args);
        } catch (e3) {
          return isError(e3) ? e3 : new Error2(e3);
        }
      });
      var bindAll = flatRest2(function(object, methodNames) {
        arrayEach2(methodNames, function(key) {
          key = toKey2(key);
          baseAssignValue2(object, key, bind3(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap2(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT2);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest2(function(args) {
          var index3 = -1;
          while (++index3 < length) {
            var pair = pairs[index3];
            if (apply2(pair[0], this, args)) {
              return apply2(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source2) {
        return baseConforms(baseClone2(source2, CLONE_DEEP_FLAG2));
      }
      function constant3(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity3(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee2(typeof func == "function" ? func : baseClone2(func, CLONE_DEEP_FLAG2));
      }
      function matches2(source2) {
        return baseMatches2(baseClone2(source2, CLONE_DEEP_FLAG2));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty2(path, baseClone2(srcValue, CLONE_DEEP_FLAG2));
      }
      var method = baseRest2(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest2(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source2, options) {
        var props = keys2(source2), methodNames = baseFunctions(source2, props);
        if (options == null && !(isObject4(source2) && (methodNames.length || !props.length))) {
          options = source2;
          source2 = object;
          object = this;
          methodNames = baseFunctions(source2, keys2(source2));
        }
        var chain2 = !(isObject4(options) && "chain" in options) || !!options.chain, isFunc = isFunction5(object);
        arrayEach2(methodNames, function(methodName) {
          var func = source2[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions2 = result2.__actions__ = copyArray2(this.__actions__);
                actions2.push({func, args: arguments, thisArg: object});
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush2([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root3._ === this) {
          root3._ = oldDash;
        }
        return this;
      }
      function noop6() {
      }
      function nthArg(n4) {
        n4 = toInteger2(n4);
        return baseRest2(function(args) {
          return baseNth(args, n4);
        });
      }
      var over = createOver(arrayMap2);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome2);
      function property2(path) {
        return isKey3(path) ? baseProperty2(toKey2(path)) : basePropertyDeep2(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet3(object, path);
        };
      }
      var range2 = createRange2();
      var rangeRight = createRange2(true);
      function stubArray2() {
        return [];
      }
      function stubFalse2() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n4, iteratee2) {
        n4 = toInteger2(n4);
        if (n4 < 1 || n4 > MAX_SAFE_INTEGER2) {
          return [];
        }
        var index3 = MAX_ARRAY_LENGTH, length = nativeMin(n4, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n4 -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes2(length, iteratee2);
        while (++index3 < n4) {
          iteratee2(index3);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray4(value)) {
          return arrayMap2(value, toKey2);
        }
        return isSymbol2(value) ? [value] : copyArray2(stringToPath3(toString4(value)));
      }
      function uniqueId2(prefix2) {
        var id3 = ++idCounter2;
        return toString4(prefix2) + id3;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max2(array2) {
        return array2 && array2.length ? baseExtremum2(array2, identity3, baseGt2) : undefined$1;
      }
      function maxBy(array2, iteratee2) {
        return array2 && array2.length ? baseExtremum2(array2, getIteratee(iteratee2, 2), baseGt2) : undefined$1;
      }
      function mean(array2) {
        return baseMean(array2, identity3);
      }
      function meanBy(array2, iteratee2) {
        return baseMean(array2, getIteratee(iteratee2, 2));
      }
      function min2(array2) {
        return array2 && array2.length ? baseExtremum2(array2, identity3, baseLt2) : undefined$1;
      }
      function minBy2(array2, iteratee2) {
        return array2 && array2.length ? baseExtremum2(array2, getIteratee(iteratee2, 2), baseLt2) : undefined$1;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array2) {
        return array2 && array2.length ? baseSum(array2, identity3) : 0;
      }
      function sumBy(array2, iteratee2) {
        return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
      }
      lodash3.after = after;
      lodash3.ary = ary;
      lodash3.assign = assign;
      lodash3.assignIn = assignIn;
      lodash3.assignInWith = assignInWith;
      lodash3.assignWith = assignWith;
      lodash3.at = at;
      lodash3.before = before;
      lodash3.bind = bind3;
      lodash3.bindAll = bindAll;
      lodash3.bindKey = bindKey2;
      lodash3.castArray = castArray;
      lodash3.chain = chain;
      lodash3.chunk = chunk;
      lodash3.compact = compact2;
      lodash3.concat = concat;
      lodash3.cond = cond;
      lodash3.conforms = conforms;
      lodash3.constant = constant3;
      lodash3.countBy = countBy;
      lodash3.create = create3;
      lodash3.curry = curry;
      lodash3.curryRight = curryRight;
      lodash3.debounce = debounce2;
      lodash3.defaults = defaults3;
      lodash3.defaultsDeep = defaultsDeep;
      lodash3.defer = defer2;
      lodash3.delay = delay3;
      lodash3.difference = difference;
      lodash3.differenceBy = differenceBy;
      lodash3.differenceWith = differenceWith;
      lodash3.drop = drop;
      lodash3.dropRight = dropRight;
      lodash3.dropRightWhile = dropRightWhile;
      lodash3.dropWhile = dropWhile;
      lodash3.fill = fill;
      lodash3.filter = filter3;
      lodash3.flatMap = flatMap;
      lodash3.flatMapDeep = flatMapDeep;
      lodash3.flatMapDepth = flatMapDepth;
      lodash3.flatten = flatten4;
      lodash3.flattenDeep = flattenDeep;
      lodash3.flattenDepth = flattenDepth;
      lodash3.flip = flip2;
      lodash3.flow = flow;
      lodash3.flowRight = flowRight;
      lodash3.fromPairs = fromPairs;
      lodash3.functions = functions;
      lodash3.functionsIn = functionsIn;
      lodash3.groupBy = groupBy;
      lodash3.initial = initial;
      lodash3.intersection = intersection;
      lodash3.intersectionBy = intersectionBy;
      lodash3.intersectionWith = intersectionWith;
      lodash3.invert = invert;
      lodash3.invertBy = invertBy;
      lodash3.invokeMap = invokeMap;
      lodash3.iteratee = iteratee;
      lodash3.keyBy = keyBy;
      lodash3.keys = keys2;
      lodash3.keysIn = keysIn2;
      lodash3.map = map3;
      lodash3.mapKeys = mapKeys;
      lodash3.mapValues = mapValues2;
      lodash3.matches = matches2;
      lodash3.matchesProperty = matchesProperty;
      lodash3.memoize = memoize2;
      lodash3.merge = merge3;
      lodash3.mergeWith = mergeWith2;
      lodash3.method = method;
      lodash3.methodOf = methodOf;
      lodash3.mixin = mixin;
      lodash3.negate = negate;
      lodash3.nthArg = nthArg;
      lodash3.omit = omit;
      lodash3.omitBy = omitBy;
      lodash3.once = once2;
      lodash3.orderBy = orderBy;
      lodash3.over = over;
      lodash3.overArgs = overArgs;
      lodash3.overEvery = overEvery;
      lodash3.overSome = overSome;
      lodash3.partial = partial;
      lodash3.partialRight = partialRight;
      lodash3.partition = partition2;
      lodash3.pick = pick2;
      lodash3.pickBy = pickBy;
      lodash3.property = property2;
      lodash3.propertyOf = propertyOf;
      lodash3.pull = pull;
      lodash3.pullAll = pullAll;
      lodash3.pullAllBy = pullAllBy;
      lodash3.pullAllWith = pullAllWith;
      lodash3.pullAt = pullAt;
      lodash3.range = range2;
      lodash3.rangeRight = rangeRight;
      lodash3.rearg = rearg;
      lodash3.reject = reject;
      lodash3.remove = remove3;
      lodash3.rest = rest;
      lodash3.reverse = reverse;
      lodash3.sampleSize = sampleSize;
      lodash3.set = set3;
      lodash3.setWith = setWith;
      lodash3.shuffle = shuffle;
      lodash3.slice = slice;
      lodash3.sortBy = sortBy2;
      lodash3.sortedUniq = sortedUniq;
      lodash3.sortedUniqBy = sortedUniqBy;
      lodash3.split = split2;
      lodash3.spread = spread3;
      lodash3.tail = tail;
      lodash3.take = take;
      lodash3.takeRight = takeRight;
      lodash3.takeRightWhile = takeRightWhile;
      lodash3.takeWhile = takeWhile;
      lodash3.tap = tap;
      lodash3.throttle = throttle;
      lodash3.thru = thru;
      lodash3.toArray = toArray;
      lodash3.toPairs = toPairs;
      lodash3.toPairsIn = toPairsIn;
      lodash3.toPath = toPath;
      lodash3.toPlainObject = toPlainObject2;
      lodash3.transform = transform3;
      lodash3.unary = unary;
      lodash3.union = union2;
      lodash3.unionBy = unionBy;
      lodash3.unionWith = unionWith;
      lodash3.uniq = uniq;
      lodash3.uniqBy = uniqBy;
      lodash3.uniqWith = uniqWith;
      lodash3.unset = unset2;
      lodash3.unzip = unzip;
      lodash3.unzipWith = unzipWith;
      lodash3.update = update;
      lodash3.updateWith = updateWith;
      lodash3.values = values2;
      lodash3.valuesIn = valuesIn;
      lodash3.without = without;
      lodash3.words = words;
      lodash3.wrap = wrap;
      lodash3.xor = xor;
      lodash3.xorBy = xorBy;
      lodash3.xorWith = xorWith;
      lodash3.zip = zip;
      lodash3.zipObject = zipObject2;
      lodash3.zipObjectDeep = zipObjectDeep;
      lodash3.zipWith = zipWith;
      lodash3.entries = toPairs;
      lodash3.entriesIn = toPairsIn;
      lodash3.extend = assignIn;
      lodash3.extendWith = assignInWith;
      mixin(lodash3, lodash3);
      lodash3.add = add;
      lodash3.attempt = attempt;
      lodash3.camelCase = camelCase2;
      lodash3.capitalize = capitalize4;
      lodash3.ceil = ceil;
      lodash3.clamp = clamp4;
      lodash3.clone = clone2;
      lodash3.cloneDeep = cloneDeep2;
      lodash3.cloneDeepWith = cloneDeepWith;
      lodash3.cloneWith = cloneWith;
      lodash3.conformsTo = conformsTo;
      lodash3.deburr = deburr;
      lodash3.defaultTo = defaultTo;
      lodash3.divide = divide;
      lodash3.endsWith = endsWith;
      lodash3.eq = eq2;
      lodash3.escape = escape3;
      lodash3.escapeRegExp = escapeRegExp;
      lodash3.every = every;
      lodash3.find = find3;
      lodash3.findIndex = findIndex2;
      lodash3.findKey = findKey;
      lodash3.findLast = findLast;
      lodash3.findLastIndex = findLastIndex;
      lodash3.findLastKey = findLastKey;
      lodash3.floor = floor;
      lodash3.forEach = forEach4;
      lodash3.forEachRight = forEachRight;
      lodash3.forIn = forIn2;
      lodash3.forInRight = forInRight;
      lodash3.forOwn = forOwn;
      lodash3.forOwnRight = forOwnRight;
      lodash3.get = get5;
      lodash3.gt = gt;
      lodash3.gte = gte;
      lodash3.has = has4;
      lodash3.hasIn = hasIn2;
      lodash3.head = head;
      lodash3.identity = identity3;
      lodash3.includes = includes;
      lodash3.indexOf = indexOf;
      lodash3.inRange = inRange;
      lodash3.invoke = invoke;
      lodash3.isArguments = isArguments2;
      lodash3.isArray = isArray4;
      lodash3.isArrayBuffer = isArrayBuffer2;
      lodash3.isArrayLike = isArrayLike2;
      lodash3.isArrayLikeObject = isArrayLikeObject2;
      lodash3.isBoolean = isBoolean2;
      lodash3.isBuffer = isBuffer2;
      lodash3.isDate = isDate3;
      lodash3.isElement = isElement3;
      lodash3.isEmpty = isEmpty2;
      lodash3.isEqual = isEqual3;
      lodash3.isEqualWith = isEqualWith2;
      lodash3.isError = isError;
      lodash3.isFinite = isFinite2;
      lodash3.isFunction = isFunction5;
      lodash3.isInteger = isInteger;
      lodash3.isLength = isLength2;
      lodash3.isMap = isMap2;
      lodash3.isMatch = isMatch;
      lodash3.isMatchWith = isMatchWith;
      lodash3.isNaN = isNaN2;
      lodash3.isNative = isNative;
      lodash3.isNil = isNil;
      lodash3.isNull = isNull;
      lodash3.isNumber = isNumber2;
      lodash3.isObject = isObject4;
      lodash3.isObjectLike = isObjectLike2;
      lodash3.isPlainObject = isPlainObject4;
      lodash3.isRegExp = isRegExp;
      lodash3.isSafeInteger = isSafeInteger;
      lodash3.isSet = isSet2;
      lodash3.isString = isString4;
      lodash3.isSymbol = isSymbol2;
      lodash3.isTypedArray = isTypedArray2;
      lodash3.isUndefined = isUndefined4;
      lodash3.isWeakMap = isWeakMap;
      lodash3.isWeakSet = isWeakSet;
      lodash3.join = join;
      lodash3.kebabCase = kebabCase;
      lodash3.last = last2;
      lodash3.lastIndexOf = lastIndexOf;
      lodash3.lowerCase = lowerCase;
      lodash3.lowerFirst = lowerFirst;
      lodash3.lt = lt;
      lodash3.lte = lte;
      lodash3.max = max2;
      lodash3.maxBy = maxBy;
      lodash3.mean = mean;
      lodash3.meanBy = meanBy;
      lodash3.min = min2;
      lodash3.minBy = minBy2;
      lodash3.stubArray = stubArray2;
      lodash3.stubFalse = stubFalse2;
      lodash3.stubObject = stubObject;
      lodash3.stubString = stubString;
      lodash3.stubTrue = stubTrue;
      lodash3.multiply = multiply;
      lodash3.nth = nth;
      lodash3.noConflict = noConflict;
      lodash3.noop = noop6;
      lodash3.now = now3;
      lodash3.pad = pad;
      lodash3.padEnd = padEnd;
      lodash3.padStart = padStart;
      lodash3.parseInt = parseInt2;
      lodash3.random = random;
      lodash3.reduce = reduce3;
      lodash3.reduceRight = reduceRight;
      lodash3.repeat = repeat;
      lodash3.replace = replace;
      lodash3.result = result;
      lodash3.round = round;
      lodash3.runInContext = runInContext2;
      lodash3.sample = sample;
      lodash3.size = size2;
      lodash3.snakeCase = snakeCase;
      lodash3.some = some;
      lodash3.sortedIndex = sortedIndex;
      lodash3.sortedIndexBy = sortedIndexBy;
      lodash3.sortedIndexOf = sortedIndexOf;
      lodash3.sortedLastIndex = sortedLastIndex;
      lodash3.sortedLastIndexBy = sortedLastIndexBy;
      lodash3.sortedLastIndexOf = sortedLastIndexOf;
      lodash3.startCase = startCase;
      lodash3.startsWith = startsWith;
      lodash3.subtract = subtract;
      lodash3.sum = sum;
      lodash3.sumBy = sumBy;
      lodash3.template = template;
      lodash3.times = times;
      lodash3.toFinite = toFinite2;
      lodash3.toInteger = toInteger2;
      lodash3.toLength = toLength;
      lodash3.toLower = toLower;
      lodash3.toNumber = toNumber2;
      lodash3.toSafeInteger = toSafeInteger;
      lodash3.toString = toString4;
      lodash3.toUpper = toUpper;
      lodash3.trim = trim2;
      lodash3.trimEnd = trimEnd;
      lodash3.trimStart = trimStart;
      lodash3.truncate = truncate;
      lodash3.unescape = unescape2;
      lodash3.uniqueId = uniqueId2;
      lodash3.upperCase = upperCase;
      lodash3.upperFirst = upperFirst;
      lodash3.each = forEach4;
      lodash3.eachRight = forEachRight;
      lodash3.first = head;
      mixin(lodash3, function() {
        var source2 = {};
        baseForOwn2(lodash3, function(func, methodName) {
          if (!hasOwnProperty5.call(lodash3.prototype, methodName)) {
            source2[methodName] = func;
          }
        });
        return source2;
      }(), {chain: false});
      lodash3.VERSION = VERSION;
      arrayEach2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash3[methodName].placeholder = lodash3;
      });
      arrayEach2(["drop", "take"], function(methodName, index3) {
        LazyWrapper.prototype[methodName] = function(n4) {
          n4 = n4 === undefined$1 ? 1 : nativeMax3(toInteger2(n4), 0);
          var result2 = this.__filtered__ && !index3 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n4, result2.__takeCount__);
          } else {
            result2.__views__.push({
              size: nativeMin(n4, MAX_ARRAY_LENGTH),
              type: methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n4) {
          return this.reverse()[methodName](n4).reverse();
        };
      });
      arrayEach2(["filter", "map", "takeWhile"], function(methodName, index3) {
        var type = index3 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            iteratee: getIteratee(iteratee2, 3),
            type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach2(["head", "last"], function(methodName, index3) {
        var takeName = "take" + (index3 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach2(["initial", "tail"], function(methodName, index3) {
        var dropName = "drop" + (index3 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity3);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest2(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start3, end2) {
        start3 = toInteger2(start3);
        var result2 = this;
        if (result2.__filtered__ && (start3 > 0 || end2 < 0)) {
          return new LazyWrapper(result2);
        }
        if (start3 < 0) {
          result2 = result2.takeRight(-start3);
        } else if (start3) {
          result2 = result2.drop(start3);
        }
        if (end2 !== undefined$1) {
          end2 = toInteger2(end2);
          result2 = end2 < 0 ? result2.dropRight(-end2) : result2.take(end2 - start3);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn2(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash3[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash3.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy2 = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy2 || isArray4(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash3, arrayPush2([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy2 = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy2 && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({func: thru, args: [interceptor], thisArg: undefined$1});
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach2(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto2[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash3.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray4(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray4(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn2(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash3[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty5.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({name: methodName, func: lodashFunc});
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        name: "wrapper",
        func: undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash3.prototype.at = wrapperAt;
      lodash3.prototype.chain = wrapperChain;
      lodash3.prototype.commit = wrapperCommit;
      lodash3.prototype.next = wrapperNext;
      lodash3.prototype.plant = wrapperPlant;
      lodash3.prototype.reverse = wrapperReverse;
      lodash3.prototype.toJSON = lodash3.prototype.valueOf = lodash3.prototype.value = wrapperValue;
      lodash3.prototype.first = lodash3.prototype.head;
      if (symIterator) {
        lodash3.prototype[symIterator] = wrapperToIterator;
      }
      return lodash3;
    };
    var _23 = runInContext();
    if (freeModule) {
      (freeModule.exports = _23)._ = _23;
      freeExports._ = _23;
    } else {
      root3._ = _23;
    }
  }).call(commonjsGlobal);
});

// build/components/realm-selector/recent-used.js
var RecentUsed = class {
  constructor() {
    this.MAX_NUM = 4;
    this.KEY = "recent-used-realms";
    this.recentUsedRealms = JSON.parse(localStorage.getItem(this.KEY) || "[]");
  }
  save() {
    this.recentUsedRealms = this.recentUsedRealms.slice(0, this.MAX_NUM);
    localStorage.setItem(this.KEY, JSON.stringify(this.recentUsedRealms));
  }
  clean(existingRealms) {
    this.recentUsedRealms = this.recentUsedRealms.filter((realm2) => existingRealms.includes(realm2));
    this.save();
  }
  get used() {
    return this.recentUsedRealms;
  }
  setRecentUsed(realm2) {
    if (!this.recentUsedRealms.includes(realm2)) {
      this.recentUsedRealms.unshift(realm2);
      this.save();
    }
  }
};

// build/components/data-loader/DataLoader.js
function DataLoader(props) {
  const [data, setData] = useState();
  useFetch(() => props.loader(), (result) => setData(result), props.deps || []);
  if (data) {
    if (props.children instanceof Function) {
      return props.children(data);
    }
    return props.children;
  }
  return /* @__PURE__ */ react.createElement("div", {
    className: "pf-u-text-align-center"
  }, /* @__PURE__ */ react.createElement(Spinner, null));
}

// build/_snowpack/pkg/file-saver.js
var FileSaver_min = createCommonjsModule(function(module2, exports2) {
  (function(a2, b3) {
    b3();
  })(commonjsGlobal, function() {
    function b3(a3, b4) {
      return typeof b4 == "undefined" ? b4 = {autoBom: false} : typeof b4 != "object" && (console.warn("Deprecated: Expected third argument to be a object"), b4 = {autoBom: !b4}), b4.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a3.type) ? new Blob(["\uFEFF", a3], {type: a3.type}) : a3;
    }
    function c4(a3, b4, c5) {
      var d4 = new XMLHttpRequest();
      d4.open("GET", a3), d4.responseType = "blob", d4.onload = function() {
        g3(d4.response, b4, c5);
      }, d4.onerror = function() {
        console.error("could not download file");
      }, d4.send();
    }
    function d3(a3) {
      var b4 = new XMLHttpRequest();
      b4.open("HEAD", a3, false);
      try {
        b4.send();
      } catch (a4) {
      }
      return 200 <= b4.status && 299 >= b4.status;
    }
    function e3(a3) {
      try {
        a3.dispatchEvent(new MouseEvent("click"));
      } catch (c5) {
        var b4 = document.createEvent("MouseEvents");
        b4.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a3.dispatchEvent(b4);
      }
    }
    var f3 = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof commonjsGlobal == "object" && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0, a2 = f3.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g3 = f3.saveAs || (typeof window != "object" || window !== f3 ? function() {
    } : "download" in HTMLAnchorElement.prototype && !a2 ? function(b4, g4, h3) {
      var i3 = f3.URL || f3.webkitURL, j = document.createElement("a");
      g4 = g4 || b4.name || "download", j.download = g4, j.rel = "noopener", typeof b4 == "string" ? (j.href = b4, j.origin === location.origin ? e3(j) : d3(j.href) ? c4(b4, g4, h3) : e3(j, j.target = "_blank")) : (j.href = i3.createObjectURL(b4), setTimeout(function() {
        i3.revokeObjectURL(j.href);
      }, 4e4), setTimeout(function() {
        e3(j);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(f4, g4, h3) {
      if (g4 = g4 || f4.name || "download", typeof f4 != "string")
        navigator.msSaveOrOpenBlob(b3(f4, h3), g4);
      else if (d3(f4))
        c4(f4, g4, h3);
      else {
        var i3 = document.createElement("a");
        i3.href = f4, i3.target = "_blank", setTimeout(function() {
          e3(i3);
        });
      }
    } : function(b4, d4, e4, g4) {
      if (g4 = g4 || open("", "_blank"), g4 && (g4.document.title = g4.document.body.innerText = "downloading..."), typeof b4 == "string")
        return c4(b4, d4, e4);
      var h3 = b4.type === "application/octet-stream", i3 = /constructor/i.test(f3.HTMLElement) || f3.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((j || h3 && i3 || a2) && typeof FileReader != "undefined") {
        var k3 = new FileReader();
        k3.onloadend = function() {
          var a3 = k3.result;
          a3 = j ? a3 : a3.replace(/^data:[^;]*;/, "data:attachment/file;"), g4 ? g4.location.href = a3 : location = a3, g4 = null;
        }, k3.readAsDataURL(b4);
      } else {
        var l3 = f3.URL || f3.webkitURL, m3 = l3.createObjectURL(b4);
        g4 ? g4.location = m3 : location.href = m3, g4 = null, setTimeout(function() {
          l3.revokeObjectURL(m3);
        }, 4e4);
      }
    });
    f3.saveAs = g3.saveAs = g3, module2.exports = g3;
  });
});
var file_saver_default = FileSaver_min;

// build/util.js
var sortProviders = (providers) => {
  return [...new Map(Object.entries(providers).sort(sortProvider)).keys()];
};
var sortProvider = (a2, b3) => {
  let s1, s2;
  if (a2[1].order !== b3[1].order) {
    s1 = b3[1].order;
    s2 = a2[1].order;
  } else {
    s1 = a2[0];
    s2 = b3[0];
  }
  if (s1 < s2) {
    return -1;
  } else if (s1 > s2) {
    return 1;
  } else {
    return 0;
  }
};
var exportClient = (client2) => {
  const clientCopy = lodash.cloneDeep(client2);
  delete clientCopy.id;
  if (clientCopy.protocolMappers) {
    for (let i3 = 0; i3 < clientCopy.protocolMappers.length; i3++) {
      delete clientCopy.protocolMappers[i3].id;
    }
  }
  file_saver_default.saveAs(new Blob([JSON.stringify(clientCopy, null, 2)], {
    type: "application/json"
  }), clientCopy.clientId + ".json");
};
var toUpperCase = (name) => name.charAt(0).toUpperCase() + name.slice(1);
var convertToFormValues = (obj, prefix2, setValue) => {
  return Object.keys(obj).map((key) => {
    const newKey = key.replace(/\./g, "-");
    setValue(prefix2 + "." + newKey, obj[key]);
  });
};
var flatten2 = (obj, path = "") => {
  if (!(obj instanceof Object))
    return {[path.replace(/\.$/g, "")]: obj};
  return Object.keys(obj).reduce((output2, key) => {
    return obj instanceof Array ? {
      ...output2,
      ...flatten2(obj[key], path + "[" + key + "].")
    } : {...output2, ...flatten2(obj[key], path + key + ".")};
  }, {});
};
var convertFormValuesToObject = (obj, firstInstanceOnly) => {
  const keyValues = Object.keys(obj).map((key) => {
    const newKey = firstInstanceOnly ? key.replace(/-/, ".") : key.replace(/-/g, ".");
    console.log(newKey);
    return {[newKey]: obj[key]};
  });
  return Object.assign({}, ...keyValues);
};
var emptyFormatter = () => (data) => {
  return data ? data : "";
};
var upperCaseFormatter = () => (data) => {
  const value = data?.toString();
  return value ? toUpperCase(value) : void 0;
};
var getBaseUrl = (adminClient) => {
  return (adminClient.keycloak ? adminClient.keycloak.authServerUrl : adminClient.baseUrl) + "/";
};
var emailRegexPattern = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var forHumans = (seconds) => {
  const {t: t4} = useTranslation();
  const levels = [
    [Math.floor(seconds / 31536e3), t4("common:times.years")],
    [Math.floor(seconds % 31536e3 / 86400), t4("common:times.days")],
    [
      Math.floor(seconds % 31536e3 % 86400 / 3600),
      t4("common:times.hours")
    ],
    [
      Math.floor(seconds % 31536e3 % 86400 % 3600 / 60),
      t4("common:times.minutes")
    ],
    [seconds % 31536e3 % 86400 % 3600 % 60, t4("common:times.seconds")]
  ];
  let returntext = "";
  for (let i3 = 0, max2 = levels.length; i3 < max2; i3++) {
    if (levels[i3][0] === 0)
      continue;
    returntext += " " + levels[i3][0] + " " + (levels[i3][0] === 1 ? levels[i3][1].substr(0, levels[i3][1].length - 1) : levels[i3][1]);
  }
  return returntext.trim();
};
var interpolateTimespan = (forHumans2) => {
  const {t: t4} = useTranslation();
  const timespan = forHumans2.split(" ");
  if (timespan[1] === "Years") {
    return t4(`realm-settings:convertedToYearsValue`, {
      convertedToYears: forHumans2
    });
  }
  if (timespan[1] === "Days") {
    return t4(`realm-settings:convertedToDaysValue`, {
      convertedToYears: forHumans2
    });
  }
  if (timespan[1] === "Hours") {
    return t4(`realm-settings:convertedToHoursValue`, {
      convertedToHours: forHumans2
    });
  }
  if (timespan[1] === "Minutes") {
    return t4(`realm-settings:convertedToMinutesValue`, {
      convertedToMinutes: forHumans2
    });
  }
  if (timespan[1] === "Seconds") {
    return t4(`realm-settings:convertedToSecondsValue`, {
      convertedToSeconds: forHumans2
    });
  }
};

// build/context/server-info/ServerInfoProvider.js
var ServerInfoContext = createContext(void 0);
var useServerInfo = () => useRequiredContext(ServerInfoContext);
var useLoginProviders = () => {
  return sortProviders(useServerInfo().providers["login-protocol"].providers);
};
var ServerInfoProvider = ({children: children2}) => {
  const adminClient = useAdminClient();
  const loader = async () => {
    return await adminClient.serverInfo.find();
  };
  return /* @__PURE__ */ react.createElement(DataLoader, {
    loader
  }, (serverInfo2) => /* @__PURE__ */ react.createElement(ServerInfoContext.Provider, {
    value: serverInfo2
  }, children2));
};

// build/components/help-enabler/HelpItem.js
var HelpItem = ({
  helpText,
  forLabel,
  forID,
  id: id3,
  noVerticalAlign = true,
  unWrap = false
}) => {
  const {t: t4} = useTranslation();
  const {enabled} = useHelp();
  return /* @__PURE__ */ react.createElement(react.Fragment, null, enabled && /* @__PURE__ */ react.createElement(Popover, {
    bodyContent: isValidElement(helpText) ? helpText : t4(helpText)
  }, /* @__PURE__ */ react.createElement(react.Fragment, null, !unWrap && /* @__PURE__ */ react.createElement("button", {
    id: id3,
    "aria-label": t4(`helpLabel`, {label: forLabel}),
    onClick: (e3) => e3.preventDefault(),
    "aria-describedby": forID,
    className: "pf-c-form__group-label-help"
  }, /* @__PURE__ */ react.createElement(HelpIcon, {
    noVerticalAlign
  })), unWrap && /* @__PURE__ */ react.createElement(HelpIcon, {
    noVerticalAlign
  }))));
};

// build/environment.js
var realm = new URLSearchParams(window.location.search).get("realm") ?? "master";
var defaultEnvironment = {
  loginRealm: realm,
  authServerUrl: "http://localhost:8180/auth",
  authUrl: "http://localhost:8180/auth",
  consoleBaseUrl: "/auth/admin/master/console/",
  resourceUrl: ".",
  masterRealm: "master",
  resourceVersion: "unknown",
  isRunningAsTheme: false
};
var environment = {
  ...defaultEnvironment,
  ...getInjectedEnvironment()
};
var environment_default = environment;
function getInjectedEnvironment() {
  const element = document.getElementById("environment");
  if (!element?.textContent) {
    return {};
  }
  try {
    return JSON.parse(element.textContent);
  } catch (error2) {
    console.error("Unable to parse environment variables.");
  }
  return {};
}

// build/dashboard/Dashboard.js
var EmptyDashboard = () => {
  const {t: t4} = useTranslation("dashboard");
  const {realm: realm2} = useRealm();
  return /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(EmptyState, {
    variant: "large"
  }, /* @__PURE__ */ react.createElement(Brand, {
    src: environment_default.resourceUrl + "/icon.svg",
    alt: "Keycloak icon",
    className: "keycloak__dashboard_icon"
  }), /* @__PURE__ */ react.createElement(Title, {
    headingLevel: "h4",
    size: "3xl"
  }, t4("welcome")), /* @__PURE__ */ react.createElement(Title, {
    headingLevel: "h4",
    size: "4xl"
  }, realm2), /* @__PURE__ */ react.createElement(EmptyStateBody, null, t4("introduction"))));
};
var Dashboard = () => {
  const {t: t4} = useTranslation("dashboard");
  const {realm: realm2} = useRealm();
  const serverInfo2 = useServerInfo();
  const enabledFeatures = lodash.xor(serverInfo2.profileInfo?.disabledFeatures, serverInfo2.profileInfo?.experimentalFeatures, serverInfo2.profileInfo?.previewFeatures);
  const isExperimentalFeature = (feature) => {
    return serverInfo2.profileInfo?.experimentalFeatures?.includes(feature);
  };
  const isPreviewFeature = (feature) => {
    return serverInfo2.profileInfo?.previewFeatures?.includes(feature);
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(TextContent, {
    className: "pf-u-mr-sm"
  }, /* @__PURE__ */ react.createElement(Text, {
    component: "h1"
  }, toUpperCase(realm2), " realm"))), /* @__PURE__ */ react.createElement(PageSection, null, /* @__PURE__ */ react.createElement(Grid, {
    hasGutter: true
  }, /* @__PURE__ */ react.createElement(GridItem, {
    lg: 2,
    sm: 12
  }, /* @__PURE__ */ react.createElement(Card, {
    className: "keycloak__dashboard_card"
  }, /* @__PURE__ */ react.createElement(CardTitle, null, t4("serverInfo")), /* @__PURE__ */ react.createElement(CardBody, null, /* @__PURE__ */ react.createElement(DescriptionList, null, /* @__PURE__ */ react.createElement(DescriptionListGroup, null, /* @__PURE__ */ react.createElement(DescriptionListTerm, null, t4("version")), /* @__PURE__ */ react.createElement(DescriptionListDescription, null, serverInfo2.systemInfo?.version), /* @__PURE__ */ react.createElement(DescriptionListTerm, null, t4("product")), /* @__PURE__ */ react.createElement(DescriptionListDescription, null, toUpperCase(serverInfo2.profileInfo?.name))))))), /* @__PURE__ */ react.createElement(GridItem, {
    lg: 10,
    sm: 12
  }, /* @__PURE__ */ react.createElement(Card, {
    className: "keycloak__dashboard_card"
  }, /* @__PURE__ */ react.createElement(CardTitle, null, t4("profile")), /* @__PURE__ */ react.createElement(CardBody, null, /* @__PURE__ */ react.createElement(DescriptionList, null, /* @__PURE__ */ react.createElement(DescriptionListGroup, null, /* @__PURE__ */ react.createElement(DescriptionListTerm, null, t4("enabledFeatures"), " ", /* @__PURE__ */ react.createElement(HelpItem, {
    forID: t4(`common:helpLabel`, {
      label: t4("enabledFeatures")
    }),
    forLabel: t4("enabledFeatures"),
    helpText: "dashboard:infoEnabledFeatures"
  })), /* @__PURE__ */ react.createElement(DescriptionListDescription, null, /* @__PURE__ */ react.createElement(List, {
    variant: ListVariant.inline
  }, enabledFeatures.map((feature) => /* @__PURE__ */ react.createElement(ListItem, {
    key: feature
  }, feature, " ", isExperimentalFeature(feature) ? /* @__PURE__ */ react.createElement(Label, {
    color: "orange"
  }, t4("experimental")) : /* @__PURE__ */ react.createElement(react.Fragment, null), isPreviewFeature(feature) ? /* @__PURE__ */ react.createElement(Label, {
    color: "blue"
  }, t4("preview")) : /* @__PURE__ */ react.createElement(react.Fragment, null)))))), /* @__PURE__ */ react.createElement(DescriptionListGroup, null, /* @__PURE__ */ react.createElement(DescriptionListTerm, null, t4("disabledFeatures"), " ", /* @__PURE__ */ react.createElement(HelpItem, {
    forID: t4(`common:helpLabel`, {
      label: t4("disabledFeatures")
    }),
    forLabel: t4("disabledFeatures"),
    helpText: "dashboard:infoDisabledFeatures"
  })), /* @__PURE__ */ react.createElement(DescriptionListDescription, null, /* @__PURE__ */ react.createElement(List, {
    variant: ListVariant.inline
  }, serverInfo2.profileInfo?.disabledFeatures?.map((feature) => /* @__PURE__ */ react.createElement(ListItem, {
    key: feature
  }, feature))))))))))));
};
var DashboardSection = () => {
  const {realm: realm2} = useRealm();
  const isMasterRealm = realm2 === "master";
  return /* @__PURE__ */ react.createElement(react.Fragment, null, !isMasterRealm && /* @__PURE__ */ react.createElement(EmptyDashboard, null), isMasterRealm && /* @__PURE__ */ react.createElement(Dashboard, null));
};

// build/dashboard/routes/Dashboard.js
var DashboardRoute = {
  path: "/:realm?",
  component: DashboardSection,
  breadcrumb: (t4) => t4("common:home"),
  access: "anyone"
};
var toDashboard = (params) => ({
  pathname: generatePath(DashboardRoute.path, params)
});

// build/context/realm-context/RealmContext.js
var RealmContext = react.createContext(void 0);
var RealmContextProvider = ({children: children2}) => {
  const routeMatch = useRouteMatch(DashboardRoute.path);
  const [realm2, setRealm] = useState(routeMatch?.params.realm ?? environment_default.loginRealm);
  const [realms2, setRealms] = useState([]);
  const adminClient = useAdminClient();
  const recentUsed = new RecentUsed();
  const updateRealmsList = (realms22) => {
    setRealms(lodash.sortBy(realms22, "realm"));
    recentUsed.clean(realms22.map((r4) => r4.realm));
  };
  useFetch(() => adminClient.realms.find(), (realms22) => updateRealmsList(realms22), []);
  useEffect(() => adminClient.setConfig({realmName: realm2}), [realm2]);
  const set3 = (realm22) => {
    if (realms2.length === 0 || realms2.findIndex((r4) => r4.realm == realm22) !== -1) {
      recentUsed.setRecentUsed(realm22);
      setRealm(realm22);
    }
  };
  return /* @__PURE__ */ react.createElement(RealmContext.Provider, {
    value: {
      realm: realm2,
      setRealm: set3,
      realms: realms2,
      refresh: async () => {
        const list3 = await adminClient.realms.find();
        updateRealmsList(list3);
      }
    }
  }, children2);
};
var useRealm = () => useRequiredContext(RealmContext);

// build/_snowpack/pkg/i18next.js
function _typeof2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof2 = function _typeof4(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof2 = function _typeof4(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof2(obj);
}
function _defineProperty4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread3(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? Object(arguments[i3]) : {};
    var ownKeys4 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys4 = ownKeys4.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys4.forEach(function(key) {
      _defineProperty4(target, key, source2[key]);
    });
  }
  return target;
}
function _classCallCheck3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn2(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self2);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _inherits2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
var consoleLogger = {
  type: "logger",
  log: function log(args) {
    this.output("log", args);
  },
  warn: function warn2(args) {
    this.output("warn", args);
  },
  error: function error(args) {
    this.output("error", args);
  },
  output: function output(type, args) {
    if (console && console[type])
      console[type].apply(console, args);
  }
};
var Logger = function() {
  function Logger2(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck3(this, Logger2);
    this.init(concreteLogger, options);
  }
  _createClass3(Logger2, [{
    key: "init",
    value: function init3(concreteLogger) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options.prefix || "i18next:";
      this.logger = concreteLogger || consoleLogger;
      this.options = options;
      this.debug = options.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log3() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.forward(args, "log", "", true);
    }
  }, {
    key: "warn",
    value: function warn3() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.forward(args, "warn", "", true);
    }
  }, {
    key: "error",
    value: function error2() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.forward(args, "error", "");
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix2, debugOnly) {
      if (debugOnly && !this.debug)
        return null;
      if (typeof args[0] === "string")
        args[0] = "".concat(prefix2).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create3(moduleName) {
      return new Logger2(this.logger, _objectSpread3({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }, this.options));
    }
  }]);
  return Logger2;
}();
var baseLogger = new Logger();
var EventEmitter = function() {
  function EventEmitter2() {
    _classCallCheck3(this, EventEmitter2);
    this.observers = {};
  }
  _createClass3(EventEmitter2, [{
    key: "on",
    value: function on2(events, listener) {
      var _this = this;
      events.split(" ").forEach(function(event) {
        _this.observers[event] = _this.observers[event] || [];
        _this.observers[event].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off2(event, listener) {
      if (!this.observers[event])
        return;
      if (!listener) {
        delete this.observers[event];
        return;
      }
      this.observers[event] = this.observers[event].filter(function(l3) {
        return l3 !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit2(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (this.observers[event]) {
        var cloned = [].concat(this.observers[event]);
        cloned.forEach(function(observer) {
          observer.apply(void 0, args);
        });
      }
      if (this.observers["*"]) {
        var _cloned = [].concat(this.observers["*"]);
        _cloned.forEach(function(observer) {
          observer.apply(observer, [event].concat(args));
        });
      }
    }
  }]);
  return EventEmitter2;
}();
function defer() {
  var res;
  var rej;
  var promise = new Promise(function(resolve, reject) {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString(object) {
  if (object == null)
    return "";
  return "" + object;
}
function copy(a2, s2, t4) {
  a2.forEach(function(m3) {
    if (s2[m3])
      t4[m3] = s2[m3];
  });
}
function getLastOfPath(object, path, Empty) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  function canNotTraverseDeeper() {
    return !object || typeof object === "string";
  }
  var stack2 = typeof path !== "string" ? [].concat(path) : path.split(".");
  while (stack2.length > 1) {
    if (canNotTraverseDeeper())
      return {};
    var key = cleanKey(stack2.shift());
    if (!object[key] && Empty)
      object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object,
    k: cleanKey(stack2.shift())
  };
}
function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object), obj = _getLastOfPath.obj, k3 = _getLastOfPath.k;
  obj[k3] = newValue;
}
function pushPath(object, path, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object), obj = _getLastOfPath2.obj, k3 = _getLastOfPath2.k;
  obj[k3] = obj[k3] || [];
  if (concat)
    obj[k3] = obj[k3].concat(newValue);
  if (!concat)
    obj[k3].push(newValue);
}
function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path), obj = _getLastOfPath3.obj, k3 = _getLastOfPath3.k;
  if (!obj)
    return void 0;
  return obj[k3];
}
function getPathWithDefaults(data, defaultData, key) {
  var value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
}
function deepExtend(target, source2, overwrite) {
  for (var prop in source2) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source2[prop] === "string" || source2[prop] instanceof String) {
          if (overwrite)
            target[prop] = source2[prop];
        } else {
          deepExtend(target[prop], source2[prop], overwrite);
        }
      } else {
        target[prop] = source2[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape2(data) {
  if (typeof data === "string") {
    return data.replace(/[&<>"'\/]/g, function(s2) {
      return _entityMap[s2];
    });
  }
  return data;
}
var isIE10 = typeof window !== "undefined" && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
function deepFind(obj, path) {
  var keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj)
    return void 0;
  if (obj[path])
    return obj[path];
  var paths = path.split(keySeparator);
  var current = obj;
  for (var i3 = 0; i3 < paths.length; ++i3) {
    if (typeof current[paths[i3]] === "string" && i3 + 1 < paths.length) {
      return void 0;
    }
    if (current[paths[i3]] === void 0) {
      var j = 2;
      var p3 = paths.slice(i3, i3 + j).join(keySeparator);
      var mix = current[p3];
      while (mix === void 0 && paths.length > i3 + j) {
        j++;
        p3 = paths.slice(i3, i3 + j).join(keySeparator);
        mix = current[p3];
      }
      if (mix === void 0)
        return void 0;
      if (typeof mix === "string")
        return mix;
      if (p3 && typeof mix[p3] === "string")
        return mix[p3];
      var joinedPath = paths.slice(i3 + j).join(keySeparator);
      if (joinedPath)
        return deepFind(mix, joinedPath, keySeparator);
      return void 0;
    }
    current = current[paths[i3]];
  }
  return current;
}
var ResourceStore = function(_EventEmitter) {
  _inherits2(ResourceStore2, _EventEmitter);
  function ResourceStore2(data) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    _classCallCheck3(this, ResourceStore2);
    _this = _possibleConstructorReturn2(this, _getPrototypeOf(ResourceStore2).call(this));
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.data = data || {};
    _this.options = options;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    if (_this.options.ignoreJSONStructure === void 0) {
      _this.options.ignoreJSONStructure = true;
    }
    return _this;
  }
  _createClass3(ResourceStore2, [{
    key: "addNamespaces",
    value: function addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns) {
      var index3 = this.options.ns.indexOf(ns);
      if (index3 > -1) {
        this.options.ns.splice(index3, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
      var path = [lng, ns];
      if (key && typeof key !== "string")
        path = path.concat(key);
      if (key && typeof key === "string")
        path = path.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
      }
      var result = getPath(this.data, path);
      if (result || !ignoreJSONStructure || typeof key !== "string")
        return result;
      return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns, key, value) {
      var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === void 0)
        keySeparator = ".";
      var path = [lng, ns];
      if (key)
        path = path.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
        value = ns;
        ns = path[1];
      }
      this.addNamespaces(ns);
      setPath(this.data, path, value);
      if (!options.silent)
        this.emit("added", lng, ns, key, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns, resources) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: false
      };
      for (var m3 in resources) {
        if (typeof resources[m3] === "string" || Object.prototype.toString.apply(resources[m3]) === "[object Array]")
          this.addResource(lng, ns, m3, resources[m3], {
            silent: true
          });
      }
      if (!options.silent)
        this.emit("added", lng, ns, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
      var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: false
      };
      var path = [lng, ns];
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
        deep = resources;
        resources = ns;
        ns = path[1];
      }
      this.addNamespaces(ns);
      var pack = getPath(this.data, path) || {};
      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = _objectSpread3({}, pack, resources);
      }
      setPath(this.data, path, pack);
      if (!options.silent)
        this.emit("added", lng, ns, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }
      this.removeNamespaces(ns);
      this.emit("removed", lng, ns);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns) {
      if (!ns)
        ns = this.options.defaultNS;
      if (this.options.compatibilityAPI === "v1")
        return _objectSpread3({}, {}, this.getResource(lng, ns));
      return this.getResource(lng, ns);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);
  return ResourceStore2;
}(EventEmitter);
var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module2) {
    this.processors[module2.name] = module2;
  },
  handle: function handle(processors, value, key, options, translator) {
    var _this = this;
    processors.forEach(function(processor) {
      if (_this.processors[processor])
        value = _this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
var checkedLoadedFor = {};
var Translator = function(_EventEmitter) {
  _inherits2(Translator2, _EventEmitter);
  function Translator2(services) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck3(this, Translator2);
    _this = _possibleConstructorReturn2(this, _getPrototypeOf(Translator2).call(this));
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this));
    _this.options = options;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    _this.logger = baseLogger.create("translator");
    return _this;
  }
  _createClass3(Translator2, [{
    key: "changeLanguage",
    value: function changeLanguage(lng) {
      if (lng)
        this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists(key) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      var resolved = this.resolve(key, options);
      return resolved && resolved.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options) {
      var nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === void 0)
        nsSeparator = ":";
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var namespaces2 = options.ns || this.options.defaultNS;
      if (nsSeparator && key.indexOf(nsSeparator) > -1) {
        var m3 = key.match(this.interpolator.nestingRegexp);
        if (m3 && m3.length > 0) {
          return {
            key,
            namespaces: namespaces2
          };
        }
        var parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
          namespaces2 = parts.shift();
        key = parts.join(keySeparator);
      }
      if (typeof namespaces2 === "string")
        namespaces2 = [namespaces2];
      return {
        key,
        namespaces: namespaces2
      };
    }
  }, {
    key: "translate",
    value: function translate(keys2, options, lastKey) {
      var _this2 = this;
      if (_typeof2(options) !== "object" && this.options.overloadTranslationOptionHandler) {
        options = this.options.overloadTranslationOptionHandler(arguments);
      }
      if (!options)
        options = {};
      if (keys2 === void 0 || keys2 === null)
        return "";
      if (!Array.isArray(keys2))
        keys2 = [String(keys2)];
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var _this$extractFromKey = this.extractFromKey(keys2[keys2.length - 1], options), key = _this$extractFromKey.key, namespaces2 = _this$extractFromKey.namespaces;
      var namespace2 = namespaces2[namespaces2.length - 1];
      var lng = options.lng || this.language;
      var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options.nsSeparator || this.options.nsSeparator;
          return namespace2 + nsSeparator + key;
        }
        return key;
      }
      var resolved = this.resolve(keys2, options);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
      var joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
        if (!options.returnObjects && !this.options.returnObjects) {
          if (!this.options.returnedObjectHandler) {
            this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          }
          return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread3({}, options, {
            ns: namespaces2
          })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
        }
        if (keySeparator) {
          var resTypeIsArray = resType === "[object Array]";
          var copy2 = resTypeIsArray ? [] : {};
          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (var m3 in res) {
            if (Object.prototype.hasOwnProperty.call(res, m3)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m3);
              copy2[m3] = this.translate(deepKey, _objectSpread3({}, options, {
                joinArrays: false,
                ns: namespaces2
              }));
              if (copy2[m3] === deepKey)
                copy2[m3] = res[m3];
            }
          }
          res = copy2;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
        res = res.join(joinArrays);
        if (res)
          res = this.extendTranslation(res, keys2, options, lastKey);
      } else {
        var usedDefault = false;
        var usedKey = false;
        var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        var hasDefaultValue = Translator2.hasDefaultValue(options);
        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count) : "";
        var defaultValue = options["defaultValue".concat(defaultValueSuffix)] || options.defaultValue;
        if (!this.isValidLookup(res) && hasDefaultValue) {
          usedDefault = true;
          res = defaultValue;
        }
        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }
        var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace2, key, updateMissing ? defaultValue : res);
          if (keySeparator) {
            var fk2 = this.resolve(key, _objectSpread3({}, options, {
              keySeparator: false
            }));
            if (fk2 && fk2.res)
              this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
            for (var i3 = 0; i3 < fallbackLngs.length; i3++) {
              lngs.push(fallbackLngs[i3]);
            }
          } else if (this.options.saveMissingTo === "all") {
            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
          } else {
            lngs.push(options.lng || this.language);
          }
          var send = function send2(l3, k3, fallbackValue) {
            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l3, namespace2, k3, updateMissing ? fallbackValue : res, updateMissing, options);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l3, namespace2, k3, updateMissing ? fallbackValue : res, updateMissing, options);
            }
            _this2.emit("missingKey", l3, namespace2, k3, res);
          };
          if (this.options.saveMissing) {
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function(language) {
                _this2.pluralResolver.getSuffixes(language).forEach(function(suffix) {
                  send([language], key + suffix, options["defaultValue".concat(suffix)] || defaultValue);
                });
              });
            } else {
              send(lngs, key, defaultValue);
            }
          }
        }
        res = this.extendTranslation(res, keys2, options, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
          res = "".concat(namespace2, ":").concat(key);
        if (usedKey && this.options.parseMissingKeyHandler)
          res = this.options.parseMissingKeyHandler(res);
      }
      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options, resolved, lastKey) {
      var _this3 = this;
      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, options, resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      } else if (!options.skipInterpolation) {
        if (options.interpolation)
          this.interpolator.init(_objectSpread3({}, options, {
            interpolation: _objectSpread3({}, this.options.interpolation, options.interpolation)
          }));
        var skipOnVariables = options.interpolation && options.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
        var nestBef;
        if (skipOnVariables) {
          var nb2 = res.match(this.interpolator.nestingRegexp);
          nestBef = nb2 && nb2.length;
        }
        var data = options.replace && typeof options.replace !== "string" ? options.replace : options;
        if (this.options.interpolation.defaultVariables)
          data = _objectSpread3({}, this.options.interpolation.defaultVariables, data);
        res = this.interpolator.interpolate(res, data, options.lng || this.language, options);
        if (skipOnVariables) {
          var na2 = res.match(this.interpolator.nestingRegexp);
          var nestAft = na2 && na2.length;
          if (nestBef < nestAft)
            options.nest = false;
        }
        if (options.nest !== false)
          res = this.interpolator.nest(res, function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (lastKey && lastKey[0] === args[0] && !options.context) {
              _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
              return null;
            }
            return _this3.translate.apply(_this3, args.concat([key]));
          }, options);
        if (options.interpolation)
          this.interpolator.reset();
      }
      var postProcess = options.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
      if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread3({
          i18nResolved: resolved
        }, options) : options, this);
      }
      return res;
    }
  }, {
    key: "resolve",
    value: function resolve(keys2) {
      var _this4 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var found;
      var usedKey;
      var exactUsedKey;
      var usedLng;
      var usedNS;
      if (typeof keys2 === "string")
        keys2 = [keys2];
      keys2.forEach(function(k3) {
        if (_this4.isValidLookup(found))
          return;
        var extracted = _this4.extractFromKey(k3, options);
        var key = extracted.key;
        usedKey = key;
        var namespaces2 = extracted.namespaces;
        if (_this4.options.fallbackNS)
          namespaces2 = namespaces2.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        var needsContextHandling = options.context !== void 0 && (typeof options.context === "string" || typeof options.context === "number") && options.context !== "";
        var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
        namespaces2.forEach(function(ns) {
          if (_this4.isValidLookup(found))
            return;
          usedNS = ns;
          if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;
            _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          }
          codes.forEach(function(code2) {
            if (_this4.isValidLookup(found))
              return;
            usedLng = code2;
            var finalKey = key;
            var finalKeys = [finalKey];
            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code2, ns, options);
            } else {
              var pluralSuffix;
              if (needsPluralHandling)
                pluralSuffix = _this4.pluralResolver.getSuffix(code2, options.count);
              if (needsPluralHandling && needsContextHandling)
                finalKeys.push(finalKey + pluralSuffix);
              if (needsContextHandling)
                finalKeys.push(finalKey += "".concat(_this4.options.contextSeparator).concat(options.context));
              if (needsPluralHandling)
                finalKeys.push(finalKey += pluralSuffix);
            }
            var possibleKey;
            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code2, ns, possibleKey, options);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
  }, {
    key: "getResource",
    value: function getResource(code2, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource)
        return this.i18nFormat.getResource(code2, ns, key, options);
      return this.resourceStore.getResource(code2, ns, key, options);
    }
  }], [{
    key: "hasDefaultValue",
    value: function hasDefaultValue(options) {
      var prefix2 = "defaultValue";
      for (var option in options) {
        if (Object.prototype.hasOwnProperty.call(options, option) && prefix2 === option.substring(0, prefix2.length) && options[option] !== void 0) {
          return true;
        }
      }
      return false;
    }
  }]);
  return Translator2;
}(EventEmitter);
function capitalize2(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
var LanguageUtil = function() {
  function LanguageUtil2(options) {
    _classCallCheck3(this, LanguageUtil2);
    this.options = options;
    this.whitelist = this.options.supportedLngs || false;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  _createClass3(LanguageUtil2, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code2) {
      if (!code2 || code2.indexOf("-") < 0)
        return null;
      var p3 = code2.split("-");
      if (p3.length === 2)
        return null;
      p3.pop();
      if (p3[p3.length - 1].toLowerCase() === "x")
        return null;
      return this.formatLanguageCode(p3.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code2) {
      if (!code2 || code2.indexOf("-") < 0)
        return code2;
      var p3 = code2.split("-");
      return this.formatLanguageCode(p3[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code2) {
      if (typeof code2 === "string" && code2.indexOf("-") > -1) {
        var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
        var p3 = code2.split("-");
        if (this.options.lowerCaseLng) {
          p3 = p3.map(function(part) {
            return part.toLowerCase();
          });
        } else if (p3.length === 2) {
          p3[0] = p3[0].toLowerCase();
          p3[1] = p3[1].toUpperCase();
          if (specialCases.indexOf(p3[1].toLowerCase()) > -1)
            p3[1] = capitalize2(p3[1].toLowerCase());
        } else if (p3.length === 3) {
          p3[0] = p3[0].toLowerCase();
          if (p3[1].length === 2)
            p3[1] = p3[1].toUpperCase();
          if (p3[0] !== "sgn" && p3[2].length === 2)
            p3[2] = p3[2].toUpperCase();
          if (specialCases.indexOf(p3[1].toLowerCase()) > -1)
            p3[1] = capitalize2(p3[1].toLowerCase());
          if (specialCases.indexOf(p3[2].toLowerCase()) > -1)
            p3[2] = capitalize2(p3[2].toLowerCase());
        }
        return p3.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code2.toLowerCase() : code2;
    }
  }, {
    key: "isWhitelisted",
    value: function isWhitelisted(code2) {
      this.logger.deprecate("languageUtils.isWhitelisted", `function "isWhitelisted" will be renamed to "isSupportedCode" in the next major - please make sure to rename it's usage asap.`);
      return this.isSupportedCode(code2);
    }
  }, {
    key: "isSupportedCode",
    value: function isSupportedCode(code2) {
      if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
        code2 = this.getLanguagePartFromCode(code2);
      }
      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code2) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function getBestMatchFromCodes(codes) {
      var _this = this;
      if (!codes)
        return null;
      var found;
      codes.forEach(function(code2) {
        if (found)
          return;
        var cleanedLng = _this.formatLanguageCode(code2);
        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng))
          found = cleanedLng;
      });
      if (!found && this.options.supportedLngs) {
        codes.forEach(function(code2) {
          if (found)
            return;
          var lngOnly = _this.getLanguagePartFromCode(code2);
          if (_this.isSupportedCode(lngOnly))
            return found = lngOnly;
          found = _this.options.supportedLngs.find(function(supportedLng) {
            if (supportedLng.indexOf(lngOnly) === 0)
              return supportedLng;
          });
        });
      }
      if (!found)
        found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code2) {
      if (!fallbacks)
        return [];
      if (typeof fallbacks === "function")
        fallbacks = fallbacks(code2);
      if (typeof fallbacks === "string")
        fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
        return fallbacks;
      if (!code2)
        return fallbacks["default"] || [];
      var found = fallbacks[code2];
      if (!found)
        found = fallbacks[this.getScriptPartFromCode(code2)];
      if (!found)
        found = fallbacks[this.formatLanguageCode(code2)];
      if (!found)
        found = fallbacks[this.getLanguagePartFromCode(code2)];
      if (!found)
        found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code2, fallbackCode) {
      var _this2 = this;
      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code2);
      var codes = [];
      var addCode = function addCode2(c4) {
        if (!c4)
          return;
        if (_this2.isSupportedCode(c4)) {
          codes.push(c4);
        } else {
          _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c4));
        }
      };
      if (typeof code2 === "string" && code2.indexOf("-") > -1) {
        if (this.options.load !== "languageOnly")
          addCode(this.formatLanguageCode(code2));
        if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
          addCode(this.getScriptPartFromCode(code2));
        if (this.options.load !== "currentOnly")
          addCode(this.getLanguagePartFromCode(code2));
      } else if (typeof code2 === "string") {
        addCode(this.formatLanguageCode(code2));
      }
      fallbackCodes.forEach(function(fc2) {
        if (codes.indexOf(fc2) < 0)
          addCode(_this2.formatLanguageCode(fc2));
      });
      return codes;
    }
  }]);
  return LanguageUtil2;
}();
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _(n4) {
    return Number(n4 > 1);
  },
  2: function _2(n4) {
    return Number(n4 != 1);
  },
  3: function _3(n4) {
    return 0;
  },
  4: function _4(n4) {
    return Number(n4 % 10 == 1 && n4 % 100 != 11 ? 0 : n4 % 10 >= 2 && n4 % 10 <= 4 && (n4 % 100 < 10 || n4 % 100 >= 20) ? 1 : 2);
  },
  5: function _5(n4) {
    return Number(n4 == 0 ? 0 : n4 == 1 ? 1 : n4 == 2 ? 2 : n4 % 100 >= 3 && n4 % 100 <= 10 ? 3 : n4 % 100 >= 11 ? 4 : 5);
  },
  6: function _6(n4) {
    return Number(n4 == 1 ? 0 : n4 >= 2 && n4 <= 4 ? 1 : 2);
  },
  7: function _7(n4) {
    return Number(n4 == 1 ? 0 : n4 % 10 >= 2 && n4 % 10 <= 4 && (n4 % 100 < 10 || n4 % 100 >= 20) ? 1 : 2);
  },
  8: function _8(n4) {
    return Number(n4 == 1 ? 0 : n4 == 2 ? 1 : n4 != 8 && n4 != 11 ? 2 : 3);
  },
  9: function _9(n4) {
    return Number(n4 >= 2);
  },
  10: function _10(n4) {
    return Number(n4 == 1 ? 0 : n4 == 2 ? 1 : n4 < 7 ? 2 : n4 < 11 ? 3 : 4);
  },
  11: function _11(n4) {
    return Number(n4 == 1 || n4 == 11 ? 0 : n4 == 2 || n4 == 12 ? 1 : n4 > 2 && n4 < 20 ? 2 : 3);
  },
  12: function _12(n4) {
    return Number(n4 % 10 != 1 || n4 % 100 == 11);
  },
  13: function _13(n4) {
    return Number(n4 !== 0);
  },
  14: function _14(n4) {
    return Number(n4 == 1 ? 0 : n4 == 2 ? 1 : n4 == 3 ? 2 : 3);
  },
  15: function _15(n4) {
    return Number(n4 % 10 == 1 && n4 % 100 != 11 ? 0 : n4 % 10 >= 2 && (n4 % 100 < 10 || n4 % 100 >= 20) ? 1 : 2);
  },
  16: function _16(n4) {
    return Number(n4 % 10 == 1 && n4 % 100 != 11 ? 0 : n4 !== 0 ? 1 : 2);
  },
  17: function _17(n4) {
    return Number(n4 == 1 || n4 % 10 == 1 && n4 % 100 != 11 ? 0 : 1);
  },
  18: function _18(n4) {
    return Number(n4 == 0 ? 0 : n4 == 1 ? 1 : 2);
  },
  19: function _19(n4) {
    return Number(n4 == 1 ? 0 : n4 == 0 || n4 % 100 > 1 && n4 % 100 < 11 ? 1 : n4 % 100 > 10 && n4 % 100 < 20 ? 2 : 3);
  },
  20: function _20(n4) {
    return Number(n4 == 1 ? 0 : n4 == 0 || n4 % 100 > 0 && n4 % 100 < 20 ? 1 : 2);
  },
  21: function _21(n4) {
    return Number(n4 % 100 == 1 ? 1 : n4 % 100 == 2 ? 2 : n4 % 100 == 3 || n4 % 100 == 4 ? 3 : 0);
  },
  22: function _22(n4) {
    return Number(n4 == 1 ? 0 : n4 == 2 ? 1 : (n4 < 0 || n4 > 10) && n4 % 10 == 0 ? 2 : 3);
  }
};
function createRules() {
  var rules = {};
  sets.forEach(function(set3) {
    set3.lngs.forEach(function(l3) {
      rules[l3] = {
        numbers: set3.nr,
        plurals: _rulesPluralsTypes[set3.fc]
      };
    });
  });
  return rules;
}
var PluralResolver = function() {
  function PluralResolver2(languageUtils) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck3(this, PluralResolver2);
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    this.rules = createRules();
  }
  _createClass3(PluralResolver2, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code2) {
      return this.rules[code2] || this.rules[this.languageUtils.getLanguagePartFromCode(code2)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code2) {
      var rule = this.getRule(code2);
      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code2, key) {
      return this.getSuffixes(code2).map(function(suffix) {
        return key + suffix;
      });
    }
  }, {
    key: "getSuffixes",
    value: function getSuffixes(code2) {
      var _this = this;
      var rule = this.getRule(code2);
      if (!rule) {
        return [];
      }
      return rule.numbers.map(function(number) {
        return _this.getSuffix(code2, number);
      });
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code2, count) {
      var _this2 = this;
      var rule = this.getRule(code2);
      if (rule) {
        var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
        var suffix = rule.numbers[idx];
        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
          if (suffix === 2) {
            suffix = "plural";
          } else if (suffix === 1) {
            suffix = "";
          }
        }
        var returnSuffix = function returnSuffix2() {
          return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
        };
        if (this.options.compatibilityJSON === "v1") {
          if (suffix === 1)
            return "";
          if (typeof suffix === "number")
            return "_plural_".concat(suffix.toString());
          return returnSuffix();
        } else if (this.options.compatibilityJSON === "v2") {
          return returnSuffix();
        } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
          return returnSuffix();
        }
        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
      }
      this.logger.warn("no plural rule found for: ".concat(code2));
      return "";
    }
  }]);
  return PluralResolver2;
}();
var Interpolator = function() {
  function Interpolator2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck3(this, Interpolator2);
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || function(value) {
      return value;
    };
    this.init(options);
  }
  _createClass3(Interpolator2, [{
    key: "init",
    value: function init3() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!options.interpolation)
        options.interpolation = {
          escapeValue: true
        };
      var iOpts = options.interpolation;
      this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape2;
      this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
      this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
      this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
      this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.options)
        this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, "g");
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
    }
  }, {
    key: "interpolate",
    value: function interpolate2(str, data, lng, options) {
      var _this = this;
      var match;
      var value;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function regexSafe(val) {
        return val.replace(/\$/g, "$$$$");
      }
      var handleFormat = function handleFormat2(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path = getPathWithDefaults(data, defaultData, key);
          return _this.alwaysFormat ? _this.format(path, void 0, lng, _objectSpread3({}, options, data, {
            interpolationkey: key
          })) : path;
        }
        var p3 = key.split(_this.formatSeparator);
        var k3 = p3.shift().trim();
        var f3 = p3.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data, defaultData, k3), f3, lng, _objectSpread3({}, options, data, {
          interpolationkey: k3
        }));
      };
      this.resetRegExp();
      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
      var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
      var todos = [{
        regex: this.regexpUnescape,
        safeValue: function safeValue(val) {
          return regexSafe(val);
        }
      }, {
        regex: this.regexp,
        safeValue: function safeValue(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }
      }];
      todos.forEach(function(todo) {
        replaces = 0;
        while (match = todo.regex.exec(str)) {
          value = handleFormat(match[1].trim());
          if (value === void 0) {
            if (typeof missingInterpolationHandler === "function") {
              var temp = missingInterpolationHandler(str, match, options);
              value = typeof temp === "string" ? temp : "";
            } else if (skipOnVariables) {
              value = match[0];
              continue;
            } else {
              _this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
              value = "";
            }
          } else if (typeof value !== "string" && !_this.useRawValueToEscape) {
            value = makeString(value);
          }
          var safeValue = todo.safeValue(value);
          str = str.replace(match[0], safeValue);
          if (skipOnVariables) {
            todo.regex.lastIndex += safeValue.length;
            todo.regex.lastIndex -= match[0].length;
          } else {
            todo.regex.lastIndex = 0;
          }
          replaces++;
          if (replaces >= _this.maxReplaces) {
            break;
          }
        }
      });
      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc2) {
      var _this2 = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var match;
      var value;
      var clonedOptions = _objectSpread3({}, options);
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      function handleHasOptions(key, inheritedOptions) {
        var sep2 = this.nestingOptionsSeparator;
        if (key.indexOf(sep2) < 0)
          return key;
        var c4 = key.split(new RegExp("".concat(sep2, "[ ]*{")));
        var optionsString = "{".concat(c4[1]);
        key = c4[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        optionsString = optionsString.replace(/'/g, '"');
        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions)
            clonedOptions = _objectSpread3({}, inheritedOptions, clonedOptions);
        } catch (e3) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key), e3);
          return "".concat(key).concat(sep2).concat(optionsString);
        }
        delete clonedOptions.defaultValue;
        return key;
      }
      while (match = this.nestingRegexp.exec(str)) {
        var formatters = [];
        var doReduce = false;
        if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
          var r4 = match[1].split(this.formatSeparator).map(function(elem) {
            return elem.trim();
          });
          match[1] = r4.shift();
          formatters = r4;
          doReduce = true;
        }
        value = fc2(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
        if (value && match[0] === str && typeof value !== "string")
          return value;
        if (typeof value !== "string")
          value = makeString(value);
        if (!value) {
          this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
          value = "";
        }
        if (doReduce) {
          value = formatters.reduce(function(v3, f3) {
            return _this2.format(v3, f3, options.lng, _objectSpread3({}, options, {
              interpolationkey: match[1].trim()
            }));
          }, value.trim());
        }
        str = str.replace(match[0], value);
        this.regexp.lastIndex = 0;
      }
      return str;
    }
  }]);
  return Interpolator2;
}();
function remove(arr, what) {
  var found = arr.indexOf(what);
  while (found !== -1) {
    arr.splice(found, 1);
    found = arr.indexOf(what);
  }
}
var Connector = function(_EventEmitter) {
  _inherits2(Connector2, _EventEmitter);
  function Connector2(backend, store2, services) {
    var _this;
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    _classCallCheck3(this, Connector2);
    _this = _possibleConstructorReturn2(this, _getPrototypeOf(Connector2).call(this));
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.backend = backend;
    _this.store = store2;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options;
    _this.logger = baseLogger.create("backendConnector");
    _this.state = {};
    _this.queue = [];
    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options.backend, options);
    }
    return _this;
  }
  _createClass3(Connector2, [{
    key: "queueLoad",
    value: function queueLoad(languages, namespaces2, options, callback) {
      var _this2 = this;
      var toLoad = [];
      var pending = [];
      var toLoadLanguages = [];
      var toLoadNamespaces = [];
      languages.forEach(function(lng) {
        var hasAllNamespaces = true;
        namespaces2.forEach(function(ns) {
          var name = "".concat(lng, "|").concat(ns);
          if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
            _this2.state[name] = 2;
          } else if (_this2.state[name] < 0)
            ;
          else if (_this2.state[name] === 1) {
            if (pending.indexOf(name) < 0)
              pending.push(name);
          } else {
            _this2.state[name] = 1;
            hasAllNamespaces = false;
            if (pending.indexOf(name) < 0)
              pending.push(name);
            if (toLoad.indexOf(name) < 0)
              toLoad.push(name);
            if (toLoadNamespaces.indexOf(ns) < 0)
              toLoadNamespaces.push(ns);
          }
        });
        if (!hasAllNamespaces)
          toLoadLanguages.push(lng);
      });
      if (toLoad.length || pending.length) {
        this.queue.push({
          pending,
          loaded: {},
          errors: [],
          callback
        });
      }
      return {
        toLoad,
        pending,
        toLoadLanguages,
        toLoadNamespaces
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err, data) {
      var s2 = name.split("|");
      var lng = s2[0];
      var ns = s2[1];
      if (err)
        this.emit("failedLoading", lng, ns, err);
      if (data) {
        this.store.addResourceBundle(lng, ns, data);
      }
      this.state[name] = err ? -1 : 2;
      var loaded2 = {};
      this.queue.forEach(function(q3) {
        pushPath(q3.loaded, [lng], ns);
        remove(q3.pending, name);
        if (err)
          q3.errors.push(err);
        if (q3.pending.length === 0 && !q3.done) {
          Object.keys(q3.loaded).forEach(function(l3) {
            if (!loaded2[l3])
              loaded2[l3] = [];
            if (q3.loaded[l3].length) {
              q3.loaded[l3].forEach(function(ns2) {
                if (loaded2[l3].indexOf(ns2) < 0)
                  loaded2[l3].push(ns2);
              });
            }
          });
          q3.done = true;
          if (q3.errors.length) {
            q3.callback(q3.errors);
          } else {
            q3.callback();
          }
        }
      });
      this.emit("loaded", loaded2);
      this.queue = this.queue.filter(function(q3) {
        return !q3.done;
      });
    }
  }, {
    key: "read",
    value: function read3(lng, ns, fcName) {
      var _this3 = this;
      var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 350;
      var callback = arguments.length > 5 ? arguments[5] : void 0;
      if (!lng.length)
        return callback(null, {});
      return this.backend[fcName](lng, ns, function(err, data) {
        if (err && data && tried < 5) {
          setTimeout(function() {
            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }
        callback(err, data);
      });
    }
  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages, namespaces2) {
      var _this4 = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend) {
        this.logger.warn("No backend was added via i18next.use. Will not load resources.");
        return callback && callback();
      }
      if (typeof languages === "string")
        languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces2 === "string")
        namespaces2 = [namespaces2];
      var toLoad = this.queueLoad(languages, namespaces2, options, callback);
      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length)
          callback();
        return null;
      }
      toLoad.toLoad.forEach(function(name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages, namespaces2, callback) {
      this.prepareLoading(languages, namespaces2, {}, callback);
    }
  }, {
    key: "reload",
    value: function reload(languages, namespaces2, callback) {
      this.prepareLoading(languages, namespaces2, {
        reload: true
      }, callback);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;
      var prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var s2 = name.split("|");
      var lng = s2[0];
      var ns = s2[1];
      this.read(lng, ns, "read", void 0, void 0, function(err, data) {
        if (err)
          _this5.logger.warn("".concat(prefix2, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
        if (!err && data)
          _this5.logger.log("".concat(prefix2, "loaded namespace ").concat(ns, " for language ").concat(lng), data);
        _this5.loaded(name, err, data);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages, namespace2, key, fallbackValue, isUpdate) {
      var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace2)) {
        this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace2, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (key === void 0 || key === null || key === "")
        return;
      if (this.backend && this.backend.create) {
        this.backend.create(languages, namespace2, key, fallbackValue, null, _objectSpread3({}, options, {
          isUpdate
        }));
      }
      if (!languages || !languages[0])
        return;
      this.store.addResource(languages[0], namespace2, key, fallbackValue);
    }
  }]);
  return Connector2;
}(EventEmitter);
function get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    whitelist: false,
    nonExplicitWhitelist: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle2(args) {
      var ret = {};
      if (_typeof2(args[1]) === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (_typeof2(args[2]) === "object" || _typeof2(args[3]) === "object") {
        var options = args[3] || args[2];
        Object.keys(options).forEach(function(key) {
          ret[key] = options[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format(value, _format, lng, options) {
        return value;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: false
    }
  };
}
function transformOptions(options) {
  if (typeof options.ns === "string")
    options.ns = [options.ns];
  if (typeof options.fallbackLng === "string")
    options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === "string")
    options.fallbackNS = [options.fallbackNS];
  if (options.whitelist) {
    if (options.whitelist && options.whitelist.indexOf("cimode") < 0) {
      options.whitelist = options.whitelist.concat(["cimode"]);
    }
    options.supportedLngs = options.whitelist;
  }
  if (options.nonExplicitWhitelist) {
    options.nonExplicitSupportedLngs = options.nonExplicitWhitelist;
  }
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
}
function noop3() {
}
var I18n = function(_EventEmitter) {
  _inherits2(I18n2, _EventEmitter);
  function I18n2() {
    var _this;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : void 0;
    _classCallCheck3(this, I18n2);
    _this = _possibleConstructorReturn2(this, _getPrototypeOf(I18n2).call(this));
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.options = transformOptions(options);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };
    if (callback && !_this.isInitialized && !options.isClone) {
      if (!_this.options.initImmediate) {
        _this.init(options, callback);
        return _possibleConstructorReturn2(_this, _assertThisInitialized(_this));
      }
      setTimeout(function() {
        _this.init(options, callback);
      }, 0);
    }
    return _this;
  }
  _createClass3(I18n2, [{
    key: "init",
    value: function init3() {
      var _this2 = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : void 0;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (options.whitelist && !options.supportedLngs) {
        this.logger.deprecate("whitelist", 'option "whitelist" will be renamed to "supportedLngs" in the next major - please make sure to rename this option asap.');
      }
      if (options.nonExplicitWhitelist && !options.nonExplicitSupportedLngs) {
        this.logger.deprecate("whitelist", 'options "nonExplicitWhitelist" will be renamed to "nonExplicitSupportedLngs" in the next major - please make sure to rename this option asap.');
      }
      this.options = _objectSpread3({}, get(), this.options, transformOptions(options));
      this.format = this.options.interpolation.format;
      if (!callback)
        callback = noop3;
      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject)
          return null;
        if (typeof ClassOrObject === "function")
          return new ClassOrObject();
        return ClassOrObject;
      }
      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }
        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s2 = this.services;
        s2.logger = baseLogger;
        s2.resourceStore = this.store;
        s2.languageUtils = lu;
        s2.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        s2.interpolator = new Interpolator(this.options);
        s2.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s2.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s2.resourceStore, s2, this.options);
        s2.backendConnector.on("*", function(event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        if (this.modules.languageDetector) {
          s2.languageDetector = createClassOnDemand(this.modules.languageDetector);
          s2.languageDetector.init(s2, this.options.detection, this.options);
        }
        if (this.modules.i18nFormat) {
          s2.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s2.i18nFormat.init)
            s2.i18nFormat.init(this);
        }
        this.translator = new Translator(this.services, this.options);
        this.translator.on("*", function(event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        this.modules.external.forEach(function(m3) {
          if (m3.init)
            m3.init(_this2);
        });
      }
      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        if (codes.length > 0 && codes[0] !== "dev")
          this.options.lng = codes[0];
      }
      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn("init: no languageDetector is used and no lng is defined");
      }
      var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store;
          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      storeApiChained.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store2;
          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
          return _this2;
        };
      });
      var deferred = defer();
      var load = function load2() {
        var finish = function finish2(err, t4) {
          if (_this2.isInitialized && !_this2.initializedStoreOnce)
            _this2.logger.warn("init: i18next is already initialized. You should call init just once!");
          _this2.isInitialized = true;
          if (!_this2.options.isClone)
            _this2.logger.log("initialized", _this2.options);
          _this2.emit("initialized", _this2.options);
          deferred.resolve(t4);
          callback(err, t4);
        };
        if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized)
          return finish(null, _this2.t.bind(_this2));
        _this2.changeLanguage(_this2.options.lng, finish);
      };
      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }
      return deferred;
    }
  }, {
    key: "loadResources",
    value: function loadResources(language) {
      var _this3 = this;
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop3;
      var usedCallback = callback;
      var usedLng = typeof language === "string" ? language : this.language;
      if (typeof language === "function")
        usedCallback = language;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode")
          return usedCallback();
        var toLoad = [];
        var append = function append2(lng) {
          if (!lng)
            return;
          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
          lngs.forEach(function(l3) {
            if (toLoad.indexOf(l3) < 0)
              toLoad.push(l3);
          });
        };
        if (!usedLng) {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function(l3) {
            return append(l3);
          });
        } else {
          append(usedLng);
        }
        if (this.options.preload) {
          this.options.preload.forEach(function(l3) {
            return append(l3);
          });
        }
        this.services.backendConnector.load(toLoad, this.options.ns, usedCallback);
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources(lngs, ns, callback) {
      var deferred = defer();
      if (!lngs)
        lngs = this.languages;
      if (!ns)
        ns = this.options.ns;
      if (!callback)
        callback = noop3;
      this.services.backendConnector.reload(lngs, ns, function(err) {
        deferred.resolve();
        callback(err);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use2(module2) {
      if (!module2)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module2.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      if (module2.type === "backend") {
        this.modules.backend = module2;
      }
      if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
        this.modules.logger = module2;
      }
      if (module2.type === "languageDetector") {
        this.modules.languageDetector = module2;
      }
      if (module2.type === "i18nFormat") {
        this.modules.i18nFormat = module2;
      }
      if (module2.type === "postProcessor") {
        postProcessor.addPostProcessor(module2);
      }
      if (module2.type === "3rdParty") {
        this.modules.external.push(module2);
      }
      return this;
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage(lng, callback) {
      var _this4 = this;
      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit("languageChanging", lng);
      var done = function done2(err, l3) {
        if (l3) {
          _this4.language = l3;
          _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l3);
          _this4.translator.changeLanguage(l3);
          _this4.isLanguageChangingTo = void 0;
          _this4.emit("languageChanged", l3);
          _this4.logger.log("languageChanged", l3);
        } else {
          _this4.isLanguageChangingTo = void 0;
        }
        deferred.resolve(function() {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback)
          callback(err, function() {
            return _this4.t.apply(_this4, arguments);
          });
      };
      var setLng = function setLng2(lngs) {
        if (!lng && !lngs && _this4.services.languageDetector)
          lngs = [];
        var l3 = typeof lngs === "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
        if (l3) {
          if (!_this4.language) {
            _this4.language = l3;
            _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l3);
          }
          if (!_this4.translator.language)
            _this4.translator.changeLanguage(l3);
          if (_this4.services.languageDetector)
            _this4.services.languageDetector.cacheUserLanguage(l3);
        }
        _this4.loadResources(l3, function(err) {
          done(err, l3);
        });
      };
      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        this.services.languageDetector.detect(setLng);
      } else {
        setLng(lng);
      }
      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT(lng, ns) {
      var _this5 = this;
      var fixedT = function fixedT2(key, opts) {
        var options;
        if (_typeof2(opts) !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }
          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options = _objectSpread3({}, opts);
        }
        options.lng = options.lng || fixedT2.lng;
        options.lngs = options.lngs || fixedT2.lngs;
        options.ns = options.ns || fixedT2.ns;
        return _this5.t(key, options);
      };
      if (typeof lng === "string") {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }
      fixedT.ns = ns;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t4() {
      var _this$translator;
      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists() {
      var _this$translator2;
      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace(ns) {
      this.options.defaultNS = ns;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace2(ns) {
      var _this6 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized) {
        this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
        return false;
      }
      if (!this.languages || !this.languages.length) {
        this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
        return false;
      }
      var lng = this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode")
        return true;
      var loadNotPending = function loadNotPending2(l3, n4) {
        var loadState = _this6.services.backendConnector.state["".concat(l3, "|").concat(n4)];
        return loadState === -1 || loadState === 2;
      };
      if (options.precheck) {
        var preResult = options.precheck(this, loadNotPending);
        if (preResult !== void 0)
          return preResult;
      }
      if (this.hasResourceBundle(lng, ns))
        return true;
      if (!this.services.backendConnector.backend)
        return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
        return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces2(ns, callback) {
      var _this7 = this;
      var deferred = defer();
      if (!this.options.ns) {
        callback && callback();
        return Promise.resolve();
      }
      if (typeof ns === "string")
        ns = [ns];
      ns.forEach(function(n4) {
        if (_this7.options.ns.indexOf(n4) < 0)
          _this7.options.ns.push(n4);
      });
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages(lngs, callback) {
      var deferred = defer();
      if (typeof lngs === "string")
        lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function(lng) {
        return preloaded.indexOf(lng) < 0;
      });
      if (!newLngs.length) {
        if (callback)
          callback();
        return Promise.resolve();
      }
      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng)
        lng = this.languages && this.languages.length > 0 ? this.languages[0] : this.language;
      if (!lng)
        return "rtl";
      var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam"];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? "rtl" : "ltr";
    }
  }, {
    key: "createInstance",
    value: function createInstance2() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : void 0;
      return new I18n2(options, callback);
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop3;
      var mergedOptions = _objectSpread3({}, this.options, options, {
        isClone: true
      });
      var clone2 = new I18n2(mergedOptions);
      var membersToCopy = ["store", "services", "language"];
      membersToCopy.forEach(function(m3) {
        clone2[m3] = _this8[m3];
      });
      clone2.services = _objectSpread3({}, this.services);
      clone2.services.utils = {
        hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
      };
      clone2.translator = new Translator(clone2.services, clone2.options);
      clone2.translator.on("*", function(event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        clone2.emit.apply(clone2, [event].concat(args));
      });
      clone2.init(mergedOptions, callback);
      clone2.translator.options = clone2.options;
      clone2.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
      };
      return clone2;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages
      };
    }
  }]);
  return I18n2;
}(EventEmitter);
var i18next = new I18n();
var i18next_default = i18next;

// build/common-messages.js
var common_messages_default = {
  common: {
    fullName: "{{givenName}} {{familyName}}",
    unknownUser: "Anonymous",
    add: "Add",
    yes: "Yes",
    no: "No",
    create: "Create",
    save: "Save",
    revert: "Revert",
    cancel: "Cancel",
    continue: "Continue",
    close: "Close",
    delete: "Delete",
    remove: "Remove",
    search: "Search",
    noSearchResults: "No search results",
    noSearchResultsInstructions: "Click on the search bar above to search",
    next: "Next",
    back: "Back",
    finish: "Finish",
    skipCustomizationAndFinish: "Skip customization and finish",
    export: "Export",
    action: "Action",
    download: "Download",
    resourceFile: "Resource file",
    clear: "Clear",
    clearFile: "Clear this file",
    clearFileExplain: "Are you sure you want to clear this file?",
    on: "On",
    off: "Off",
    enabled: "Enabled",
    disabled: "Disabled",
    disable: "Disable",
    selectOne: "Select an option",
    choose: "Choose...",
    any: "Any",
    none: "None",
    signOut: "Sign out",
    manageAccount: "Manage account",
    serverInfo: "Server info",
    realmInfo: "Realm info",
    help: "Help",
    helpLabel: "More help for {{label}}",
    helpEnabled: "Help on",
    helpDisabled: "Help off",
    documentation: "Documentation",
    enableHelpMode: "Enable help mode",
    learnMore: "Learn more",
    test: "Test",
    name: "Name",
    role: "Role",
    description: "Description",
    type: "Type",
    category: "Category",
    priority: "Priority",
    unexpectedError: "An unexpected error occurred: '{{error}}'",
    retry: "Retry",
    plus: "Plus",
    minus: "Minus",
    clientScope: {
      default: "Default",
      optional: "Optional",
      none: "None"
    },
    home: "Home",
    manage: "Manage",
    clients: "Clients",
    clientScopes: "Client scopes",
    realmRoles: "Realm roles",
    users: "Users",
    groups: "Groups",
    sessions: "Sessions",
    events: "Events",
    mappers: "Mappers",
    configure: "Configure",
    realmSettings: "Realm settings",
    authentication: "Authentication",
    identityProviders: "Identity providers",
    userFederation: "User federation",
    settings: "Settings",
    required: "Required field",
    maxLength: "Max length {{length}}",
    createRealm: "Create Realm",
    recent: "Recent",
    jumpToSection: "Jump to section",
    Sunday: "Sunday",
    Monday: "Monday",
    Tuesday: "Tuesday",
    Wednesday: "Wednesday",
    Thursday: "Thursday",
    Friday: "Friday",
    Saturday: "Saturday",
    unitLabel: "Select a time unit",
    times: {
      seconds: "Seconds",
      minutes: "Minutes",
      hours: "Hours",
      days: "Days",
      years: "Years"
    },
    attributes: "Attributes",
    clientId: "Client ID",
    id: "ID",
    addMapper: "Add mapper",
    createNewMapper: "Create new mapper",
    searchForMapper: "Search for mapper",
    mapperType: "Mapper type",
    mappingDeletedSuccess: "Mapping successfully deleted",
    mappingDeletedError: "Could not delete mapping: '{{error}}'",
    mappingDetails: "Mapper details",
    mappingUpdatedSuccess: "Mapping successfully updated",
    mappingUpdatedError: "Could not update mapping: '{{error}}'",
    mappingCreatedSuccess: "Mapping successfully created",
    mappingCreatedError: "Could not create mapping: '{{error}}'",
    deleteMappingTitle: "Delete mapping?",
    deleteMappingConfirm: "Are you sure you want to delete this mapping?",
    emptyMappers: "No mappers",
    emptyMappersInstructions: "If you want to add mappers, please click the button below to add some predefined mappers or to configure a new mapper.",
    emptyPrimaryAction: "Add predefined mapper",
    leaveDirtyTitle: "Leave without saving?",
    leaveDirtyConfirm: "Do you want to leave this page without saving? Any unsaved changes will be lost.",
    leave: "Leave",
    reorder: "Reorder",
    onDragStart: "Dragging started for item {{item}}",
    onDragMove: "Dragging item {{item}}",
    onDragCancel: "Dragging cancelled. List is unchanged.",
    onDragFinish: "Dragging finished {{list}}"
  }
};

// build/common-help.js
var common_help_default = {
  "common-help": {
    helpToggleInfo: "This toggle will enable / disable part of the help info in the console. Includes any help text, links and popovers.",
    showPassword: "Show password field in clear text",
    helpFileUpload: "Upload a JSON file",
    dragHelp: "Press space or enter to begin dragging, and use the arrow keys to navigate up or down. Press enter to confirm the drag, or any other key to cancel the drag operation."
  }
};

// build/dashboard/messages.js
var messages_default = {
  dashboard: {
    welcome: "Welcome to",
    introduction: "If you want to leave this page and mange this realm, please click the corresponding menu items in the left navigation bar.",
    serverInfo: "Server info",
    version: "Version",
    product: "Product",
    profile: "Profile",
    enabledFeatures: "Enabled features",
    experimental: "Experimental",
    preview: "Preview",
    infoEnabledFeatures: "Something about what enabled features are.",
    infoDisabledFeatures: "Something about what disabled features are.",
    disabledFeatures: "Disabled features"
  }
};

// build/clients/messages.js
var messages_default2 = {
  clients: {
    clientType: "Client type",
    clientAuthorization: "Authorization",
    implicitFlow: "Implicit flow",
    createClient: "Create client",
    importClient: "Import client",
    homeURL: "Home URL",
    webOrigins: "Web origins",
    addWebOrigins: "Add web origins",
    adminURL: "Admin URL",
    formatOption: "Format option",
    encryptAssertions: "Encrypt assertions",
    clientSignature: "Client signature required",
    downloadAdaptorTitle: "Download adaptor configs",
    keys: "Keys",
    credentials: "Credentials",
    roles: "Roles",
    createRole: "Create role",
    noRoles: "No roles for this client",
    noRolesInstructions: "You haven't created any roles for this client. Create a role to get started.",
    clientScopes: "Client scopes",
    addClientScope: "Add client scope",
    addClientScopesTo: "Add client scopes to {{clientId}}",
    clientScopeRemoveSuccess: "Scope mapping successfully removed",
    clientScopeRemoveError: "Could not remove the scope mapping {{error}}",
    clientScopeSuccess: "Scope mapping successfully updated",
    clientScopeError: "Could not update the scope mapping {{error}}",
    searchByName: "Search by name",
    setup: "Setup",
    evaluate: "Evaluate",
    changeTypeTo: "Change type to",
    assignRole: "Assign role",
    unAssignRole: "Unassign",
    removeMappingTitle: "Remove mapping?",
    removeMappingConfirm: "Are you sure you want to remove this mapping?",
    removeMappingConfirm_plural: "Are you sure you want to remove {{count}} mappings",
    clientScopeSearch: {
      client: "Client scope",
      assigned: "Assigned type"
    },
    assignedClientScope: "Assigned client scope",
    assignedType: "Assigned type",
    hideInheritedRoles: "Hide inherited roles",
    inherentFrom: "Inherited from",
    emptyClientScopes: "This client doesn't have any added client scopes",
    emptyClientScopesInstructions: "There are currently no client scopes linked to this client. You can add existing client scopes to this client to share protocol mappers and roles.",
    emptyClientScopesPrimaryAction: "Add client scopes",
    scopeParameter: "Scope parameter",
    scopeParameterPlaceholder: "Select scope parameters",
    effectiveProtocolMappers: "Effective protocol mappers",
    effectiveRoleScopeMappings: "Effective role scope mappings",
    generatedAccessToken: "Generated access token",
    searchForProtocol: "Search protocol mapper",
    parentClientScope: "Parent client scope",
    searchForRole: "Search role",
    origin: "Origin",
    user: "User",
    details: "Details",
    noGeneratedAccessToken: "No generated access token",
    generatedAccessTokenIsDisabled: "Generated access token is disabled when no user is selected",
    clientList: "Clients",
    clientsList: "Clients list",
    initialAccessToken: "Initial access token",
    clientSettings: "Client details",
    selectEncryptionType: "Select Encryption type",
    generalSettings: "General Settings",
    capabilityConfig: "Capability config",
    clientsExplain: "Clients are applications and services that can request authentication of a user",
    createSuccess: "Client created successfully",
    createError: "Could not create client: '{{error}}'",
    clientImportError: "Could not import client: {{error}}",
    clientSaveSuccess: "Client successfully updated",
    clientSaveError: "Client could not be updated:",
    clientImportSuccess: "Client imported successfully",
    clientDelete: "Delete {{clientId}} ?",
    clientDeletedSuccess: "The client has been deleted",
    clientDeleteError: "Could not delete client: {{error}}",
    clientDeleteConfirmTitle: "Delete client?",
    disableConfirmTitle: "Disable client?",
    downloadAdapterConfig: "Download adapter config",
    disableConfirm: "If you disable this client, you cannot initiate a login or obtain access tokens.",
    clientDeleteConfirm: "If you delete this client, all associated data will be removed.",
    searchInitialAccessToken: "Search token",
    createToken: "Create initial access token",
    tokenDeleteConfirm: "Are you sure you want to permanently delete the initial access token {{id}}",
    tokenDeleteConfirmTitle: "Delete initial access token?",
    tokenDeleteSuccess: "initial access token created successfully",
    tokenDeleteError: "Could not delete initial access token: '{{error}}'",
    timestamp: "Created date",
    created: "Created",
    lastUpdated: "Last updated",
    expires: "Expires",
    count: "Count",
    remainingCount: "Remaining count",
    expiration: "Expiration",
    noTokens: "No initial access tokens",
    noTokensInstructions: `You haven't created any initial access tokens. Create an initial access token by clicking "Create".`,
    tokenSaveSuccess: "New initial access token has been created",
    tokenSaveError: "Could not create initial access token {{error}}",
    initialAccessTokenDetails: "Initial access token details",
    copyInitialAccessToken: "Please copy and paste the initial access token before closing as it can not be retrieved later.",
    clientAuthentication: "Client authentication",
    authentication: "Authentication",
    authenticationFlow: "Authentication flow",
    standardFlow: "Standard flow",
    directAccess: "Direct access grants",
    serviceAccount: "Service accounts roles",
    enableServiceAccount: "Enable service account roles",
    assignRolesTo: "Assign roles to {{client}} account",
    searchByRoleName: "Search by role name",
    filterByOrigin: "Filter by Origin",
    realmRoles: "Realm roles",
    clients: "Clients",
    assign: "Assign",
    roleMappingUpdatedSuccess: "Role mapping updated",
    roleMappingUpdatedError: "Could not update role mapping {{error}}",
    displayOnClient: "Display client on screen",
    consentScreenText: "Client consent screen text",
    loginSettings: "Login settings",
    accessSettings: "Access settings",
    rootUrl: "Root URL",
    validRedirectUri: "Valid redirect URIs",
    addRedirectUri: "Add valid redirect URIs",
    loginTheme: "Login theme",
    consentRequired: "Consent required",
    clientAuthenticator: "Client Authenticator",
    changeAuthenticatorConfirmTitle: "Change to {{clientAuthenticatorType}}",
    changeAuthenticatorConfirm: "If you change authenticator to {{clientAuthenticatorType}}, the keycloak database will be updated and you may need to download a new adapter configuration for this client",
    signedJWTConfirm: 'You should configure JWKS URL or keys in the "Keys" tab to change the parameters of Signed JWT authenticator.',
    anyAlgorithm: "Any algorithm",
    clientSecret: "Client secret",
    regenerate: "Regenerate",
    confirmClientSecretTitle: "Regenerate secret for this client?",
    confirmClientSecretBody: "If you regenerate secret, the Keycloak database will be updated and you will need to download a new adapter for this client.",
    confirmAccessTokenTitle: "Regenerate registration access token?",
    confirmAccessTokenBody: "If you regenerate registration access token, the access data regarding the client registration service will be updated.",
    clientSecretSuccess: "Client secret regenerated",
    clientSecretError: "Could not regenerate client secret due to: {{error}}",
    registrationAccessToken: "Registration access token",
    accessTokenSuccess: "Access token regenerated",
    accessTokenError: "Could not regenerate access token due to: {{error}}",
    signatureAlgorithm: "Signature algorithm",
    subject: "Subject DN",
    searchForClient: "Search for client",
    advanced: "Advanced",
    revocation: "Revocation",
    clustering: "Clustering",
    notBefore: "Not before",
    setToNow: "Set to now",
    noAdminUrlSet: "No push sent. No admin URI configured or no registered cluster nodes available",
    notBeforeSetToNow: "Not Before set for client",
    notBeforeNowClear: "Not Before cleared for client",
    notBeforePushFail: 'Failed to push "not before" to: {{failedNodes}}',
    notBeforePushSuccess: 'Successfully push "not before" to: {{successNodes}}',
    testClusterFail: "Failed verified availability for: {{failedNodes}}. Fix or unregister failed cluster nodes and try again",
    testClusterSuccess: "Successfully verified availability for: {{successNodes}}",
    deleteNode: "Delete node?",
    deleteNodeBody: 'Are you sure you want to permanently delete the node "{{node}}"',
    deleteNodeSuccess: "Node successfully removed",
    deleteNodeFail: "Could not delete node: '{{error}}'",
    addedNodeSuccess: "Node successfully added",
    addedNodeFail: "Could not add node: '{{error}}'",
    addNode: "Add node",
    push: "Push",
    clear: "Clear",
    nodeReRegistrationTimeout: "Node Re-registration timeout",
    registeredClusterNodes: "Registered cluster nodes",
    nodeHost: "Node host",
    noNodes: "No nodes registered",
    noNodesInstructions: "There are no nodes registered, you can add one manually.",
    lastRegistration: "Last registration",
    testClusterAvailability: "Test cluster availability",
    registerNodeManually: "Register node manually",
    fineGrainOpenIdConnectConfiguration: "Fine grain OpenID connect configuration",
    fineGrainSamlEndpointConfig: "Fine Grain SAML Endpoint Configuration",
    accessTokenSignatureAlgorithm: "Access token signature algorithm",
    idTokenSignatureAlgorithm: "ID token signature algorithm",
    idTokenEncryptionKeyManagementAlgorithm: "ID token encryption key management algorithm",
    idTokenEncryptionContentEncryptionAlgorithm: "ID token encryption content encryption algorithm",
    userInfoSignedResponseAlgorithm: "User info signed response algorithm",
    requestObjectSignatureAlgorithm: "Request object signature algorithm",
    requestObjectRequired: "Request object required",
    requestObject: {
      "not required": "Not required",
      "request or request_uri": "Request or Request URI",
      "request only": "Request only",
      "request_uri only": "Request URI only"
    },
    openIdConnectCompatibilityModes: "Open ID Connect Compatibly Modes",
    excludeSessionStateFromAuthenticationResponse: "Exclude Session State From Authentication Response",
    assertionConsumerServicePostBindingURL: "Assertion Consumer Service POST Binding URL",
    assertionConsumerServiceRedirectBindingURL: "Assertion Consumer Service Redirect Binding URL",
    logoutServicePostBindingURL: "Logout Service POST Binding URL",
    logoutServiceRedirectBindingURL: "Logout Service Redirect Binding URL",
    advancedSettings: "Advanced Settings",
    assertionLifespan: "Assertion Lifespan",
    accessTokenLifespan: "Access Token Lifespan",
    oAuthMutual: "OAuth 2.0 Mutual TLS Certificate Bound Access Tokens Enabled",
    keyForCodeExchange: "Proof Key for Code Exchange Code Challenge Method",
    authenticationOverrides: "Authentication flow overrides",
    browserFlow: "Browser Flow",
    directGrant: "Direct Grant Flow",
    jwksUrlConfig: "JWKS URL configs",
    keysIntro: 'If "Use JWKS URL switch" is on, you need to fill a valid JWKS URL. After saving, admin can download keys from the JWKS URL or keys will be downloaded automatically by Keycloak server when see the stuff signed by the unknown KID',
    useJwksUrl: "Use JWKS URL",
    certificate: "Certificate",
    jwksUrl: "JWKS URL",
    generateNewKeys: "Generate new keys",
    generateKeys: "Generate keys?",
    generate: "Generate",
    archiveFormat: "Archive format",
    keyAlias: "Key alias",
    keyPassword: "Key password",
    storePassword: "Store password",
    generateSuccess: "New key pair and certificate generated successfully",
    generateError: "Could not generate new key pair and certificate {{error}}",
    import: "Import",
    importFile: "Import file",
    importSuccess: "New certificate imported",
    importError: "Could not import certificate {{error}}",
    tokenLifespan: {
      expires: "Expires in",
      never: "Never expires"
    }
  }
};

// build/clients/help.js
var help_default = {
  "clients-help": {
    enableDisable: "Disabled clients cannot initiate a login or have obtained access tokens.",
    clientType: "'OpenID connect' allows Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server.'SAML' enables web-based authentication and authorization scenarios including cross-domain single sign-on (SSO) and uses security tokens containing assertions to pass information.",
    serviceAccount: "Allows you to authenticate this client to Keycloak and retrieve access token dedicated to this client. In terms of OAuth2 specification, this enables support of 'Client Credentials Grant' for this client.",
    authentication: "This defines the type of the OIDC client. When it's ON, the OIDC type is set to confidential access type. When it's OFF, it is set to public access type",
    authorization: "Enable/Disable fine-grained authorization support for a client",
    directAccess: "This enables support for Direct Access Grants, which means that client has access to username/password of user and exchange it directly with Keycloak server for access token. In terms of OAuth2 specification, this enables support of 'Resource Owner Password Credentials Grant' for this client.",
    standardFlow: "This enables standard OpenID Connect redirect based authentication with authorization code. In terms of OpenID Connect or OAuth2 specifications, this enables support of 'Authorization Code Flow' for this client.",
    implicitFlow: "This enables support for OpenID Connect redirect based authentication without authorization code. In terms of OpenID Connect or OAuth2 specifications, this enables support of 'Implicit Flow' for this client.",
    rootURL: "Root URL appended to relative URLs",
    validRedirectURIs: "Valid URI pattern a browser can redirect to after a successful login or logout. Simple wildcards are allowed such as 'http://example.com/*'. Relative path can be specified too such as /my/relative/path/*. Relative paths are relative to the client root URL, or if none is specified the auth server root URL is used. For SAML, you must set valid URI patterns if you are relying on the consumer service URL embedded with the login request.",
    webOrigins: "Allowed CORS origins. To permit all origins of Valid Redirect URIs, add '+'. This does not include the '*' wildcard though. To permit all origins, explicitly add '*'.",
    homeURL: "Default URL to use when the auth server needs to redirect or link back to the client.",
    adminURL: "URL to the admin interface of the client. Set this if the client supports the adapter REST API. This REST API allows the auth server to push revocation policies and other administrative tasks. Usually this is set to the base URL of the client.",
    clientId: "Specifies ID referenced in URI and tokens. For example 'my-client'. For SAML this is also the expected issuer value from authn requests",
    clientName: "Specifies display name of the client. For example 'My Client'. Supports keys for localized values as well. For example: ${my_client}",
    description: "Specifies description of the client. For example 'My Client for TimeSheets'. Supports keys for localized values as well. For example: ${my_client_description}",
    loginTheme: "Select theme for login, OTP, grant, registration, and forgot password pages.",
    encryptAssertions: "Should SAML assertions be encrypted with client's public key using AES?",
    clientSignature: "Will the client sign their saml requests and responses? And should they be validated?",
    downloadType: "this is information about the download type",
    details: "this is information about the details",
    createToken: "An initial access token can only be used to create clients",
    expiration: "Specifies how long the token should be valid",
    count: "Specifies how many clients can be created using the token",
    "client-authenticator-type": "Client Authenticator used for authentication of this client against Keycloak server",
    "registration-access-token": "The registration access token provides access for clients to the client registration service.",
    "signature-algorithm": "JWA algorithm, which the client needs to use when signing a JWT for authentication. If left blank, the client is allowed to use any algorithm.",
    subject: 'A regular expression for validating Subject DN in the Client Certificate. Use "(.*?)(?:$)" to match all kind of expressions.',
    evaluateExplain: "This page allows you to see all protocol mappers and role scope mappings",
    effectiveProtocolMappers: "Contains all default client scopes and selected optional scopes. All protocol mappers and role scope mappings of all those client scopes will be used when generating access token issued for your client",
    effectiveRoleScopeMappings: "Selected Optional Client Scopes, which will be used when issuing access token for this client. You can see above what value of OAuth Scope Parameter needs to be used when you want to have these optional client scopes applied when the initial OpenID Connect Authentication request will be sent from your client adapter",
    generatedAccessToken: "Example access token",
    scopeParameter: "You can copy/paste this value of scope parameter and use it in initial OpenID Connect Authentication Request sent from this client adapter. Default client scopes and selected optional client scopes will be used when generating token issued for this client",
    user: "Optionally select user, for whom the example access token will be generated. If you do not select a user, example access token will not be generated during evaluation",
    notBefore: "Revoke any tokens issued before this date for this client.",
    notBeforeIntro: "In order to successfully push a revocation policy to the client, you need to set an Admin URL under the <1>Settings</1> tab for this client first",
    nodeReRegistrationTimeout: "Interval to specify max time for registered clients cluster nodes to re-register. If cluster node will not send re-registration request to Keycloak within this time, it will be unregistered from Keycloak",
    fineGrainOpenIdConnectConfiguration: "This section is used to configure advanced settings of this client related to OpenID connect protocol.",
    fineGrainSamlEndpointConfig: "This section to configure exact URLs for Assertion Consumer and Single Logout Service.",
    accessTokenSignatureAlgorithm: "JWA algorithm used for signing access tokens.",
    idTokenSignatureAlgorithm: "JWA algorithm used for signing ID tokens.",
    idTokenEncryptionKeyManagementAlgorithm: "JWA Algorithm used for key management in encrypting ID tokens. This option is needed if you want encrypted ID tokens. If left empty, ID Tokens are just signed, but not encrypted.",
    idTokenEncryptionContentEncryptionAlgorithm: "JWA Algorithm used for content encryption in encrypting ID tokens. This option is needed just if you want encrypted ID tokens. If left empty, ID Tokens are just signed, but not encrypted.",
    userInfoSignedResponseAlgorithm: "JWA algorithm used for signed User Info Endpoint response. If set to 'unsigned', User Info Response won't be signed and will be returned in application/json format.",
    requestObjectSignatureAlgorithm: "JWA algorithm, which client needs to use when sending OIDC request object specified by 'request' or 'request_uri' parameters. If set to 'any', Request object can be signed by any algorithm (including 'none' ).",
    requestObjectRequired: 'Specifies if the client needs to provide a request object with their authorization requests, and what method they can use for this. If set to "not required", providing a request object is optional. In all other cases, providing a request object is mandatory. If set to "request", the request object must be provided by value. If set to "request_uri", the request object must be provided by reference. If set to "request or request_uri", either method can be used.',
    openIdConnectCompatibilityModes: "This section is used to configure settings for backward compatibility with older OpenID Connect / OAuth 2 adaptors. It's useful especially if your client uses older version of Keycloak / RH-SSO adapter.",
    excludeSessionStateFromAuthenticationResponse: "If this is on, the parameter 'session_state' will not be included in OpenID Connect Authentication Response. It is useful if your client uses older OIDC / OAuth2 adapter, which does not support 'session_state' parameter.",
    "advancedSettingsOpenid-connect": "This section is used to configure advanced settings of this client related to OpenID Connect protocol",
    advancedSettingsSaml: "This section is used to configure advanced settings of this client",
    assertionLifespan: 'Lifespan set in the SAML assertion conditions. After that time the assertion will be invalid. The "SessionNotOnOrAfter" attribute is not modified and continue using the "SSO Session Max" time defined at realm level.',
    accessTokenLifespan: "Max time before an access token is expired. This value is recommended to be short relative to the SSO timeout.",
    oAuthMutual: "This enables support for OAuth 2.0 Mutual TLS Certificate Bound Access Tokens, which means that keycloak bind an access token and a refresh token with a X.509 certificate of a token requesting client exchanged in mutual TLS between keycloak's Token Endpoint and this client. These tokens can be treated as Holder-of-Key tokens instead of bearer tokens.",
    keyForCodeExchange: "Choose which code challenge method for PKCE is used. If not specified, keycloak does not applies PKCE to a client unless the client sends an authorization request with appropriate code challenge and code exchange method.",
    assertionConsumerServicePostBindingURL: "SAML POST Binding URL for the client's assertion consumer service (login responses). You can leave this blank if you do not have a URL for this binding.",
    assertionConsumerServiceRedirectBindingURL: "SAML Redirect Binding URL for the client's assertion consumer service (login responses). You can leave this blank if you do not have a URL for this binding.",
    logoutServicePostBindingURL: "SAML POST Binding URL for the client's single logout service. You can leave this blank if you are using a different binding",
    logoutServiceRedirectBindingURL: "SAML Redirect Binding URL for the client's single logout service. You can leave this blank if you are using a different binding.",
    authenticationOverrides: "Override realm authentication flow bindings.",
    browserFlow: "Select the flow you want to use for browser authentication.",
    directGrant: "Select the flow you want to use for direct grant authentication.",
    useJwksUrl: "If the switch is on, client public keys will be downloaded from given JWKS URL. This allows great flexibility because new keys will be always re-downloaded again when client generates new keypair. If the switch is off, public key (or certificate) from the Keycloak DB is used, so when client keypair changes, you always need to import new key (or certificate) to the Keycloak DB as well.",
    certificate: "Client Certificate for validate JWT issued by client and signed by Client private key from your keystore.",
    jwksUrl: `URL where client keys in JWK format are stored. See JWK specification for more details. If you use Keycloak client adapter with "jwt" credential, you can use URL of your app with '/k_jwks' suffix. For example 'http://www.myhost.com/myapp/k_jwks' .`,
    generateKeysDescription: "If you generate new keys, you can download the keystore with the private key automatically and save it on your client's side. Keycloak server will save just the certificate and public key, but not the private key.",
    archiveFormat: "Java keystore or PKCS12 archive format.",
    keyAlias: "Archive alias for your private key and certificate.",
    keyPassword: "Password to access the private key in the archive",
    storePassword: "Password to access the archive itself"
  }
};

// build/client-scopes/messages.js
var messages_default3 = {
  "client-scopes": {
    createClientScope: "Create client scope",
    clientScopeList: "Client scopes",
    grantedClientScopes: "Granted client scopes",
    clientScopeDetails: "Client scope details",
    clientScopeExplain: "Client scopes allow you to define a common set of protocol mappers and roles, which are shared between multiple clients",
    searchFor: "Search for client scope",
    protocol: "Protocol",
    displayOrder: "Display order",
    type: "Type",
    deleteClientScope: "Delete client scope {{name}}",
    deleteClientScope_plural: "Delete {{count}} client scopes",
    deleteConfirm: "Are you sure you want to delete this client scope",
    changeType: "Change type",
    changeTypeIntro: "{{count}} selected client scopes will be changed to",
    clientScopeSuccess: "Scope mapping updated",
    clientScopeError: "Could not update scope mapping {{error}}",
    deletedSuccess: "The client scope has been deleted",
    deleteError: "Could not delete client scope: {{error}}",
    includeInTokenScope: "Include in token scope",
    realmRolePrefix: "Realm role prefix",
    multiValued: "Multivalued",
    tokenClaimName: "Token claim name",
    claimJsonType: "Claim JSON type",
    addClaimTo: "Add claim to",
    idToken: "ID token",
    accessToken: "Access token",
    userInfo: "User info",
    createSuccess: "Client scope created",
    createError: "Could not create client scope: '{{error}}'",
    updateSuccess: "Client scope updated",
    updateError: "Could not update client scope: '{{error}}'",
    addMapperExplain: "If you want more fine-grain control, you can create protocol mapper on this client",
    realmRoles: "Realm roles",
    selectARole: "Select a role",
    clientRoles: "Client roles",
    selectASourceOfRoles: "Select a source of roles",
    newRoleName: "New role name",
    searchClientByName: "Search client by name",
    clients: "Clients",
    mapperCreateSuccess: "New mapping has been added",
    mapperCreateError: "Could not create mapping: {{error}}",
    fromPredefinedMapper: "From predefined mappers",
    byConfiguration: "By configuration",
    emptyBuiltInMappersInstructions: "All built in mappers were added to this client",
    emptySecondaryAction: "Configure a new mapper",
    displayOnConsentScreen: "Display on consent screen",
    consentScreenText: "Consent screen text",
    guiOrder: "Display Order",
    shouldBeANumber: "Should be a number",
    chooseAMapperType: "Choose a mapper type",
    predefinedMappingDescription: "Choose one of the predefined mappings from this table",
    mappingTable: "Table with predefined mapping",
    roleGroup: "Use a realm role from:",
    clientGroup: "Use a client role from:",
    scope: "Scope",
    roleMappingUpdatedSuccess: "Role mapping updated",
    roleMappingUpdatedError: "Could not update role mapping {{error}}"
  }
};

// build/client-scopes/help.js
var help_default2 = {
  "client-scopes-help": {
    name: "Name of the client scope. Must be unique in the realm. Name should not contain space characters as it is used as value of scope parameter",
    description: "Description of the client scope",
    protocol: "Which SSO protocol configuration is being supplied by this client scope",
    type: "Client scopes, which will be added as default scopes to each created client",
    displayOnConsentScreen: "If on, and this client scope is added to some client with consent required, the text specified by 'Consent Screen Text' will be displayed on consent screen. If off, this client scope will not be displayed on the consent screen",
    consentScreenText: "Text that will be shown on the consent screen when this client scope is added to some client with consent required. Defaults to name of client scope if it is not filled",
    includeInTokenScope: "If on, the name of this client scope will be added to the access token property 'scope' as well as to the Token Introspection Endpoint response. If off, this client scope will be omitted from the token and from the Token Introspection Endpoint response.",
    guiOrder: "Specify order of the provider in GUI (such as in Consent page) as integer",
    prefix: "A prefix for each Realm Role (optional).",
    multiValued: "Indicates if attribute supports multiple values. If true, the list of all values of this attribute will be set as claim. If false, just first value will be set as claim",
    tokenClaimName: "Name of the claim to insert into the token. This can be a fully qualified name like 'address.street'. In this case, a nested json object will be created. To prevent nesting and use dot literally, escape the dot with backslash (\\.).",
    claimJsonType: "JSON type that should be used to populate the json claim in the token. long, int, boolean, String and JSON are valid values.",
    protocolMapper: "Protocol...",
    mapperName: "Name of the mapper",
    role: "Role name you want changed. Click 'Select Role' button to browse roles, or just type it in the textbox. To reference an application role the syntax is appname.approle, i.e. myapp.myrole",
    newRoleName: "The new role name.  The new name format corresponds to where in the access token the role will be mapped to.  So, a new name of 'myapp.newname' will map the role to that position in the access token.  A new name of 'newname' will map the role to the realm roles in the token."
  }
};

// build/groups/messages.js
var messages_default4 = {
  groups: {
    groups: "Groups",
    groupDetails: "Group details",
    childGroups: "Child groups",
    createGroup: "Create group",
    groupName: "Group name",
    searchForGroups: "Search for groups",
    searchGroups: "Search groups",
    searchGroup: "Search group",
    renameGroup: "Rename group",
    deleteGroup: "Delete group",
    leave: "Leave group",
    usersLeft: "{{count}} user left the group",
    usersLeft_plural: "{{count}} users left the group",
    usersLeftError: "Could not remove users from the group: {{error}}",
    usersAdded: "{{count}} user added to the group",
    usersAdded_plural: "{{count}} users added to the group",
    usersAddedError: "Could not add users to the group: {{error}}",
    search: "Search",
    members: "Members",
    searchMembers: "Search members",
    addMember: "Add member",
    includeSubGroups: "Include sub-group users",
    path: "Path",
    moveTo: "Move to",
    moveToGroup: "Move {{group1}} to {{group2}}",
    root: "Root",
    moveHere: "Move here",
    moveGroupEmpty: "No sub groups",
    moveGroupEmptyInstructions: "There are no sub groups, select 'Move here' to move the selected group as a subgroup of this group",
    moveGroupSuccess: "Group moved",
    moveGroupError: "Could not move group {{error}}",
    tableOfGroups: "Table of groups",
    groupsDescription: "Description goes here",
    groupCreated: "Group created",
    couldNotCreateGroup: "Could not create group {{error}}",
    createAGroup: "Create a group",
    renameAGroup: "Rename group",
    create: "Create",
    rename: "Rename",
    email: "Email",
    lastName: "Last name",
    firstName: "First name",
    membership: "Membership",
    noSearchResults: "No search results",
    noSearchResultsInstructions: "Click on the search bar above to search for groups",
    noGroupsInThisRealm: "No groups in this realm",
    noGroupsInThisRealmInstructions: "You haven't created any groups in this realm. Create a group to get started.",
    noGroupsInThisSubGroup: "No groups in this sub group",
    noGroupsInThisSubGroupInstructions: "You haven't created any groups in this sub group.",
    deleteConfirmTitle: "Delete group?",
    deleteConfirmTitle_plural: "Delete groups?",
    deleteConfirm: "Are you sure you want to delete this group",
    deleteConfirm_plural: "Are you sure you want to delete this groups.",
    groupDeleted: "Group deleted",
    groupDeleted_plural: "Groups deleted",
    groupDeleteError: "Error deleting group {error}",
    attributes: "Attributes",
    groupUpdated: "Group updated",
    groupUpdateError: "Error updating group {error}"
  }
};

// build/realm/messages.js
var messages_default5 = {
  realm: {
    uploadFile: "Upload JSON file",
    realmName: "Realm name",
    enabled: "Enabled",
    createRealm: "Create realm",
    realmExplain: "A realm manages a set of users, credentials, roles, and groups. A user belongs to and logs into a realm. Realms are isolated from one another and can only manage and authenticate the users that they control.",
    noRealmRoles: "No realm roles",
    emptyStateText: "There aren't any realm roles in this realm. Create a realm role to get started.",
    saveRealmSuccess: "Realm created successfully",
    saveRealmError: "Could not create realm {{error}}"
  }
};

// build/realm-roles/messages.js
var messages_default6 = {
  roles: {
    addAttributeText: "Add an attribute",
    deleteAttributeText: "Delete an attribute",
    associatedRolesText: "Associated roles",
    addAssociatedRolesText: "Add associated roles",
    addAssociatedRolesSuccess: "Associated roles have been added",
    addAssociatedRolesError: "Could not associate roles {{error}}",
    associatedRolesModalTitle: "Add roles to {{name}}",
    title: "Realm roles",
    addRole: "Add role",
    createRole: "Create role",
    importRole: "Import role",
    roleID: "Role ID",
    homeURL: "Home URL",
    filterByClients: "Filter by clients",
    filterByRoles: "Filter by roles",
    roleExplain: "Realm-level roles are a global namespace to define your roles.",
    roleCreateExplain: "This is some description",
    roleName: "Role name",
    roleDetails: "Role details",
    composite: "Composite",
    deleteRole: "Delete this role",
    details: "Details",
    inheritedFrom: "Inherited from",
    roleList: "Role list",
    searchFor: "Search role by name",
    generalSettings: "General Settings",
    capabilityConfig: "Capability config",
    roleImportError: "Could not import role",
    roleCreated: "Role created",
    roleCreateError: "Could not create role: {{error}}",
    roleImportSuccess: "Role import successful",
    roleDeleteConfirm: "Delete role?",
    roleDeleteConfirmDialog: "This action will permanently delete the role {{selectedRoleName}} and cannot be undone.",
    roleDeletedSuccess: "The role has been deleted",
    roleDeleteError: "Could not delete role: {{error}}",
    defaultRole: "This role serves as a container for both realm and client default roles. It cannot be removed.",
    defaultRoleDeleteError: "You cannot delete a default role.",
    roleSaveSuccess: "The role has been saved",
    roleSaveError: "Could not save role: {{error}}",
    noRoles: "No roles in this realm",
    noRolesInstructions: "You haven't created any roles in this realm. Create a role to get started.",
    roleAuthentication: "Role authentication",
    removeAllAssociatedRoles: "Remove all associated roles",
    removeAssociatedRoles: "Remove associated roles",
    removeRoles: "Remove roles",
    removeAllAssociatedRolesConfirmDialog: "This action will remove the associated roles of {{name}}. Users who have permission to {{name}} will no longer have access to these roles.",
    roleRemoveAssociatedRoleConfirm: "Remove associated role?",
    roleRemoveAssociatedText: "This action will remove {{role}} from {{roleName}}. All the associated roles of {{role}} will also be removed.",
    compositeRoleOff: "Composite role turned off",
    associatedRolesRemoved: "Associated roles have been removed",
    compositesRemovedAlertDescription: "All the associated roles have been removed",
    whoWillAppearLinkText: "Who will appear in this user list?",
    whoWillAppearPopoverText: "This tab shows only the users who are assigned directly to this role. To see users who are assigned this role as an associated role or through a group, go to",
    whoWillAppearPopoverFooterText: "Users who have this role as an effective role cannot be added on this tab.",
    usersInRole: "Users in role",
    addUser: "Add user",
    removeUser: "Remove users",
    removeUserText: "Do you want to remove {{numSelected}} users?. These users will no longer have permissions of the role {{role}} and the associated roles of it.",
    noDirectUsers: "No direct users",
    noUsersEmptyStateDescription: "Only the users with this role directly assigned will appear under this tab. If you need to find users assigned to this role, go to",
    noUsersEmptyStateDescriptionContinued: "to find them. Users that already have this role as an effective role cannot be added here.",
    groups: "Groups",
    or: "or",
    users: "Users",
    userName: "Username",
    email: "Email",
    lastName: "Last name",
    firstName: "First name",
    clearAllFilters: "Clear all filters"
  }
};

// build/user/messages.js
var messages_default7 = {
  users: {
    title: "Users",
    searchForUser: "Search user",
    startBySearchingAUser: "Start by searching for users",
    createUser: "Create user",
    createNewUser: "Create new user",
    noUsersFound: "No users found",
    noUsersFoundError: "No users found due to {{error}}",
    noGroups: "No groups",
    noGroupsText: "You haven't added this user to any groups. Join a group to get started.",
    joinGroup: "Join Group",
    joinGroups: "Join Groups",
    join: "Join",
    joinGroupsFor: "Join groups for user {{username}}",
    selectGroups: "Select groups to join",
    searchForGroups: "Search for groups",
    leave: "Leave",
    leaveGroup: "Leave group {{name}}?",
    leaveGroupConfirmDialog: "Are you sure you want to remove {{username}} from the group {{groupname}}?",
    directMembership: "Direct membership",
    groupMembership: "Group membership",
    addedGroupMembership: "Added group membership",
    addedGroupMembershipError: "Error adding group membership",
    removedGroupMembership: "Removed group membership",
    removedGroupMembershipError: "Error removing group membership",
    path: "Path",
    emptyInstructions: "Change your search criteria or add a user",
    createdAt: "Created at",
    username: "Username",
    email: "Email",
    emailVerified: "Email verified",
    lastName: "Last name",
    firstName: "First name",
    status: "Status",
    disabled: "Disabled",
    emailInvalid: "You must enter a valid email.",
    temporaryDisabled: "Temporarily disabled",
    notVerified: "Not verified",
    requiredUserActions: "Required user actions",
    addUser: "Add user",
    deleteUser: "Delete user",
    deleteConfirm: "Delete user?",
    deleteConfirmDialog: "Are you sure you want to permanently delete {{count}} selected user",
    deleteConfirmDialog_plural: "Are you sure you want to permanently delete {{count}} selected users",
    userCreated: "The user has been created",
    userSaved: "The user has been saved",
    userDetails: "User details",
    userCreateError: "Could not create user: {{error}}",
    userDeletedSuccess: "The user has been deleted",
    userDeletedError: "The user could not be deleted {{error}}",
    configureOTP: "Configure OTP",
    updatePassword: "Update Password",
    updateProfile: "Update Profile",
    verifyEmail: "Verify Email",
    updateUserLocale: "Update User Locale",
    consents: "Consents",
    noConsents: "No consents",
    noConsentsText: "The consents will only be recorded when users try to access a client that is configured to require consent. In that case, users will get a consent page which asks them to grant access to the client.",
    whoWillAppearLinkText: "Who will appear in this group list?",
    whoWillAppearPopoverText: "Groups are hierarchical. When you select Direct Membership, you see only the child group that the user joined. Ancestor groups are not included.",
    revoke: "Revoke",
    revokeClientScopesTitle: "Revoke all granted client scopes?",
    revokeClientScopes: "Are you sure you want to revoke all granted client scopes for {{clientId}}?",
    deleteGrantsSuccess: "Grants successfully revoked.",
    deleteGrantsError: "Error deleting grants."
  }
};

// build/user/help.js
var help_default3 = {
  "users-help": {
    disabled: "A disabled user cannot log in.",
    emailVerified: "Has the user's email been verified?",
    requiredUserActions: "Require an action when the user logs in. 'Verify email' sends an email to the user to verify their email address. 'Update profile' requires user to enter in new personal information. 'Update password' requires user to enter in a new password. 'Configure OTP' requires setup of a mobile password generator.",
    groups: "Groups where the user has membership. To leave a group, select it and click Leave."
  }
};

// build/sessions/messages.js
var messages_default8 = {
  sessions: {
    title: "Sessions",
    sessionExplain: "Some description about sessions",
    searchForSession: "Search session",
    subject: "Subject",
    lastAccess: "Last access",
    startDate: "Start date",
    accessedClients: "Accessed clients",
    sessionsType: {
      allSessions: "All session types",
      regularSSO: "Regular SSO",
      offline: "Offline",
      directGrant: "Direct grant",
      serviceAccount: "Service account"
    },
    emptyTitle: "No sessions",
    emptyInstructions: "There are no active sessions on this realm"
  }
};

// build/events/messages.js
var messages_default9 = {
  events: {
    title: "Events",
    eventExplain: "If you want to configure user events, Admin events or Event listeners, please enter <1>Event configs</1> page realm settings to configure.",
    eventConfigs: "Event configs",
    userEvents: "User events",
    adminEvents: "Admin events",
    searchForEvent: "Search user event",
    refresh: "Refresh",
    emptyEvents: "No events logged",
    emptyEventsInstructions: "Configure event logging in the realm settings",
    time: "Time",
    user: "User",
    eventType: "Event type",
    ipAddress: "IP address",
    client: "Client",
    resourcePath: "Resource path",
    resourceType: "Resource type",
    operationType: "Operation type",
    auth: "Auth",
    attribute: "Attribute",
    value: "Value",
    representation: "Representation"
  }
};

// build/realm-settings/messages.js
var messages_default10 = {
  "realm-settings": {
    partialImport: "Partial import",
    partialExport: "Partial export",
    deleteRealm: "Delete realm",
    deleteConfirmTitle: "Delete realm?",
    deleteConfirm: "If you delete this realm, all associated data will be removed.",
    deleteProviderTitle: "Delete key provider?",
    deleteProviderConfirm: "Are you sure you want to permanently delete the key provider ",
    deleteProviderSuccess: "Success. The provider has been deleted.",
    deleteProviderError: "Error deleting the provider",
    deletedSuccess: "The realm has been deleted",
    deleteError: "Could not delete realm: {{error}}",
    disableConfirmTitle: "Disable realm?",
    disableConfirm: "User and clients can't access the realm if it's disabled. Are you sure you want to continue?",
    editProvider: "Edit provider",
    saveSuccess: "Realm successfully updated",
    saveProviderSuccess: "The provider has been saved successfully.",
    saveProviderError: "Error saving provider: ",
    saveError: "Realm could not be updated: {error}",
    general: "General",
    login: "Login",
    themes: "Themes",
    events: "Events",
    userEventsConfig: "User events configuration",
    userEventsSettings: "User events settings",
    adminEventsConfig: "Admin events config",
    adminEventsSettings: "Admin events settings",
    saveEvents: "Save events",
    expiration: "Expiration",
    clearEvents: "Clear user events",
    includeRepresentation: "Include representation",
    email: "Email",
    template: "Template",
    connectionAndAuthentication: "Connection & Authentication",
    from: "From",
    fromDisplayName: "From display name",
    replyTo: "Reply to",
    replyToDisplayName: "Reply to display name",
    envelopeFrom: "Envelope from",
    host: "Host",
    port: "Port",
    encryption: "Encryption",
    authentication: "Authentication",
    enableSSL: "Enable SSL",
    enableStartTLS: "Enable StartTLS",
    username: "Username",
    password: "Password",
    keys: "Keys",
    keysList: "Keys list",
    searchKey: "Search key",
    keystore: "Keystore",
    keystorePassword: "Keystore password",
    keyAlias: "Key alias",
    keyPassword: "Key password",
    providers: "Providers",
    algorithm: "Algorithm",
    aesGenerated: "aes-generated",
    ecdsaGenerated: "ecdsca-generated",
    hmacGenerated: "hmac-generated",
    javaKeystore: "java-keystore",
    rsa: "rsa",
    rsaGenerated: "rsa-generated",
    consoleDisplayName: "Console Display Name",
    AESKeySize: "AES Key Size",
    active: "Active",
    privateRSAKey: "Private RSA Key",
    x509Certificate: "X509 Certificate",
    ellipticCurve: "Elliptic Curve",
    secretSize: "Secret size",
    type: "Type",
    name: "Name",
    providerId: "ID",
    kid: "Kid",
    provider: "Provider",
    providerDescription: "Provider description",
    addProvider: "Add provider",
    publicKeys: "Public keys",
    activeKeys: "Active keys",
    passiveKeys: "Passive keys",
    disabledKeys: "Disabled keys",
    noKeys: "No keys",
    noKeysDescription: "You haven't created any ",
    certificate: "Certificate",
    userRegistration: "User registration",
    userRegistrationHelpText: "Enable/disable the registration page. A link for registration will show on login page too.",
    forgotPassword: "Forgot password",
    forgotPasswordHelpText: "Show a link on login page for user to click when they have forgotten their credentials.",
    rememberMe: "Remember me",
    rememberMeHelpText: "Show checkbox on login page to allow user to remain logged in between browser restarts until session expires.",
    emailAsUsername: "Email as username",
    emailAsUsernameHelpText: "Allow users to set email as username.",
    loginWithEmail: "Login with email",
    loginWithEmailHelpText: "Allow users to log in with their email address.",
    duplicateEmails: "Duplicate emails",
    duplicateEmailsHelpText: "Allow multiple users to have the same email address. Changing this setting will also clear the user's cache. It is recommended to manually update email constraints of existing users in the database after switching off support for duplicate email addresses.",
    provideEmailTitle: "Provide your email address",
    provideEmail: "To test connection, you should provide your email address first.",
    verifyEmail: "Verify email",
    verifyEmailHelpText: "Require user to verify their email address after initial login or after address changes are submitted.",
    testConnection: "Test connection",
    testConnectionSuccess: "Success! SMTP connection successful. E-mail was sent!",
    testConnectionError: "Error! Failed to send email.",
    realmId: "Realm ID",
    displayName: "Display name",
    htmlDisplayName: "HTML Display name",
    frontendUrl: "Frontend URL",
    requireSsl: "Require SSL",
    sslType: {
      all: "All requests",
      external: "External requests",
      none: "None"
    },
    selectATheme: "Select a theme",
    allSupportedLocales: {
      ca: "Catal",
      cs: "etina",
      da: "Dansk",
      de: "Deutsch",
      en: "English",
      es: "Espaol",
      fr: "Franais",
      hu: "Magyar",
      it: "Italiano",
      ja: "",
      lt: "Lietuvi kalba",
      nl: "Nederlands",
      no: "Norsk",
      pl: "Polski",
      "pt-BR": "Portugus (Brasil)",
      ru: "",
      sk: "Slovenina",
      sv: "Svenska",
      tr: "Trke",
      "zh-CN": ""
    },
    placeholderText: "Select one",
    userManagedAccess: "User-managed access",
    endpoints: "Endpoints",
    openIDEndpointConfiguration: "OpenID Endpoint Configuration",
    samlIdentityProviderMetadata: "SAML 2.0 Identity Provider Metadata",
    loginTheme: "Login theme",
    accountTheme: "Account theme",
    adminTheme: "Admin console theme",
    emailTheme: "Email theme",
    internationalization: "Internationalization",
    localization: "Localization",
    sessions: "Sessions",
    SSOSessionSettings: "SSO Session Settings",
    SSOSessionIdle: "SSO Session Idle",
    SSOSessionMax: "SSO Session Max",
    SSOSessionIdleRememberMe: "SSO Session Idle Remember Me",
    SSOSessionMaxRememberMe: "SSO Session Max Remember Me",
    clientSessionSettings: "Client session settings",
    clientSessionIdle: "Client Session Idle",
    clientSessionMax: "Client Session Max",
    offlineSessionSettings: "Offline session settings",
    offlineSessionIdle: "Offline Session Idle",
    offlineSessionMaxLimited: "Offline Session Max Limited",
    offlineSessionMax: "Offline Session Max",
    loginSettings: "Login settings",
    loginTimeout: "Login timeout",
    loginActionTimeout: "Login action timeout",
    refreshTokens: "Refresh tokens",
    accessTokens: "Access tokens",
    actionTokens: "Action tokens",
    overrideActionTokens: "Override Action Tokens",
    defaultSigAlg: "Default Signature Algorithm",
    revokeRefreshToken: "Revoke Refresh Token",
    refreshTokenMaxReuse: "Refresh Token Max Reuse",
    accessTokenLifespan: "Access Token Lifespan",
    accessTokenLifespanImplicitFlow: "Access Token Lifespan For Implicit Flow",
    clientLoginTimeout: "Client Login Timeout",
    userInitiatedActionLifespan: "User-Initiated Action Lifespan",
    defaultAdminInitiated: "Default Admin-Initated Action Lifespan",
    emailVerification: "Email Verification",
    idpAccountEmailVerification: "IdP account email verification",
    executeActions: "Execute actions",
    tokens: "Tokens",
    key: "Key",
    value: "Value",
    convertedToYearsValue: "{{convertedToYears}}",
    convertedToDaysValue: "{{convertedToDays}}",
    convertedToHoursValue: "{{convertedToHours}}",
    convertedToMinutesValue: "{{convertedToMinutes}}",
    convertedToSecondsValue: "{{convertedToSeconds}}",
    pairCreatedSuccess: "Success! The localization text has been created.",
    pairCreatedError: "Error creating localization text.",
    supportedLocales: "Supported locales",
    defaultLocale: "Default locale",
    addMessageBundle: "Add message bundle",
    eventType: "Event saved type",
    searchEventType: "Search saved event type",
    addSavedTypes: "Add saved types",
    addTypes: "Add types",
    eventTypes: {
      SEND_RESET_PASSWORD: {
        name: "Send reset password",
        description: "Send reset password"
      },
      UPDATE_CONSENT_ERROR: {
        name: "Update consent error",
        description: "Update consent error"
      },
      GRANT_CONSENT: {
        name: "Grant consent",
        description: "Grant consent"
      },
      REMOVE_TOTP: {name: "Remove totp", description: "Remove totp"},
      REVOKE_GRANT: {name: "Revoke grant", description: "Revoke grant"},
      UPDATE_TOTP: {name: "Update totp", description: "Update totp"},
      LOGIN_ERROR: {name: "Login error", description: "Login error"},
      CLIENT_LOGIN: {name: "Client login", description: "Client login"},
      RESET_PASSWORD_ERROR: {
        name: "Reset password error",
        description: "Reset password error"
      },
      IMPERSONATE_ERROR: {
        name: "Impersonate error",
        description: "Impersonate error"
      },
      CODE_TO_TOKEN_ERROR: {
        name: "Code to token error",
        description: "Code to token error"
      },
      CUSTOM_REQUIRED_ACTION: {
        name: "Custom required action",
        description: "Custom required action"
      },
      RESTART_AUTHENTICATION: {
        name: "Restart authentication",
        description: "Restart authentication"
      },
      IMPERSONATE: {name: "Impersonate", description: "Impersonate"},
      UPDATE_PROFILE_ERROR: {
        name: "Update profile error",
        description: "Update profile error"
      },
      LOGIN: {name: "Login", description: "Login"},
      UPDATE_PASSWORD_ERROR: {
        name: "Update password error",
        description: "Update password error"
      },
      CLIENT_INITIATED_ACCOUNT_LINKING: {
        name: "Client initiated account linking",
        description: "Client initiated account linking"
      },
      TOKEN_EXCHANGE: {
        name: "Token exchange",
        description: "Token exchange"
      },
      LOGOUT: {name: "Logout", description: "Logout"},
      REGISTER: {name: "Register", description: "Register"},
      DELETE_ACCOUNT_ERROR: {
        name: "Delete account error",
        description: "Delete account error"
      },
      CLIENT_REGISTER: {
        name: "Client register",
        description: "Client register"
      },
      IDENTITY_PROVIDER_LINK_ACCOUNT: {
        name: "Identity provider link account",
        description: "Identity provider link account"
      },
      DELETE_ACCOUNT: {
        name: "Delete account",
        description: "Delete account"
      },
      UPDATE_PASSWORD: {
        name: "Update password",
        description: "Update password"
      },
      CLIENT_DELETE: {
        name: "Client delete",
        description: "Client delete"
      },
      FEDERATED_IDENTITY_LINK_ERROR: {
        name: "Federated identity link error",
        description: "Federated identity link error"
      },
      IDENTITY_PROVIDER_FIRST_LOGIN: {
        name: "Identity provider first login",
        description: "Identity provider first login"
      },
      CLIENT_DELETE_ERROR: {
        name: "Client delete error",
        description: "Client delete error"
      },
      VERIFY_EMAIL: {name: "Verify email", description: "Verify email"},
      CLIENT_LOGIN_ERROR: {
        name: "Client login error",
        description: "Client login error"
      },
      RESTART_AUTHENTICATION_ERROR: {
        name: "Restart authentication error",
        description: "Restart authentication error"
      },
      EXECUTE_ACTIONS: {
        name: "Execute actions",
        description: "Execute actions"
      },
      REMOVE_FEDERATED_IDENTITY_ERROR: {
        name: "Remove federated identity error",
        description: "Remove federated identity error"
      },
      TOKEN_EXCHANGE_ERROR: {
        name: "Token exchange error",
        description: "Token exchange error"
      },
      PERMISSION_TOKEN: {
        name: "Permission token",
        description: "Permission token"
      },
      SEND_IDENTITY_PROVIDER_LINK_ERROR: {
        name: "Send identity provider link error",
        description: "Send identity provider link error"
      },
      EXECUTE_ACTION_TOKEN_ERROR: {
        name: "Execute action token error",
        description: "Execute action token error"
      },
      SEND_VERIFY_EMAIL: {
        name: "Send verify email",
        description: "Send verify email"
      },
      EXECUTE_ACTIONS_ERROR: {
        name: "Execute actions error",
        description: "Execute actions error"
      },
      REMOVE_FEDERATED_IDENTITY: {
        name: "Remove federated identity",
        description: "Remove federated identity"
      },
      IDENTITY_PROVIDER_POST_LOGIN: {
        name: "Identity provider post login",
        description: "Identity provider post login"
      },
      IDENTITY_PROVIDER_LINK_ACCOUNT_ERROR: {
        name: "Identity provider link account error",
        description: "Identity provider link account error"
      },
      UPDATE_EMAIL: {name: "Update email", description: "Update email"},
      REGISTER_ERROR: {
        name: "Register error",
        description: "Register error"
      },
      REVOKE_GRANT_ERROR: {
        name: "Revoke grant error",
        description: "Revoke grant error"
      },
      EXECUTE_ACTION_TOKEN: {
        name: "Execute action token",
        description: "Execute action token"
      },
      LOGOUT_ERROR: {name: "Logout error", description: "Logout error"},
      UPDATE_EMAIL_ERROR: {
        name: "Update email error",
        description: "Update email error"
      },
      CLIENT_UPDATE_ERROR: {
        name: "Client update error",
        description: "Client update error"
      },
      UPDATE_PROFILE: {
        name: "Update profile",
        description: "Update profile"
      },
      CLIENT_REGISTER_ERROR: {
        name: "Client register error",
        description: "Client register error"
      },
      FEDERATED_IDENTITY_LINK: {
        name: "Federated identity link",
        description: "Federated identity link"
      },
      SEND_IDENTITY_PROVIDER_LINK: {
        name: "Send identity provider link",
        description: "Send identity provider link"
      },
      SEND_VERIFY_EMAIL_ERROR: {
        name: "Send verify email error",
        description: "Send verify email error"
      },
      RESET_PASSWORD: {
        name: "Reset password",
        description: "Reset password"
      },
      CLIENT_INITIATED_ACCOUNT_LINKING_ERROR: {
        name: "Client initiated account linking error",
        description: "Client initiated account linking error"
      },
      UPDATE_CONSENT: {
        name: "Update consent",
        description: "Update consent"
      },
      REMOVE_TOTP_ERROR: {
        name: "Remove totp error",
        description: "Remove totp error"
      },
      VERIFY_EMAIL_ERROR: {
        name: "Verify email error",
        description: "Verify email error"
      },
      SEND_RESET_PASSWORD_ERROR: {
        name: "Send reset password error",
        description: "Send reset password error"
      },
      CLIENT_UPDATE: {
        name: "Client update",
        description: "Client update"
      },
      CUSTOM_REQUIRED_ACTION_ERROR: {
        name: "Custom required action error",
        description: "Custom required action error"
      },
      IDENTITY_PROVIDER_POST_LOGIN_ERROR: {
        name: "Identity provider post login error",
        description: "Identity provider post login error"
      },
      UPDATE_TOTP_ERROR: {
        name: "Update totp error",
        description: "Update totp error"
      },
      CODE_TO_TOKEN: {
        name: "Code to token",
        description: "Code to token"
      },
      GRANT_CONSENT_ERROR: {
        name: "Grant consent error",
        description: "Grant consent error"
      },
      IDENTITY_PROVIDER_FIRST_LOGIN_ERROR: {
        name: "Identity provider first login error",
        description: "Identity provider first login error"
      },
      REGISTER_NODE_ERROR: {
        name: "Register node error",
        description: "Register node error"
      },
      PERMISSION_TOKEN_ERROR: {
        name: "Permission token error",
        description: "Permission token error"
      },
      IDENTITY_PROVIDER_RETRIEVE_TOKEN_ERROR: {
        name: "Identity provider retrieve token error",
        description: "Identity provider retrieve token error"
      },
      CLIENT_INFO: {
        name: "Client info",
        description: "Client info"
      },
      VALIDATE_ACCESS_TOKEN: {
        name: "Validate access token",
        description: "Validate access token"
      },
      IDENTITY_PROVIDER_LOGIN: {
        name: "Identity provider login",
        description: "Identity provider login"
      },
      CLIENT_INFO_ERROR: {
        name: "Client info error",
        description: "Client info error"
      },
      INTROSPECT_TOKEN_ERROR: {
        name: "Introspect token error",
        description: "Introspect token error"
      },
      INTROSPECT_TOKEN: {
        name: "Introspect token",
        description: "Introspect token"
      },
      UNREGISTER_NODE: {
        name: "Unregister node",
        description: "Unregister node"
      },
      REGISTER_NODE: {
        name: "Register node",
        description: "Register node"
      },
      INVALID_SIGNATURE: {
        name: "Invalid signature",
        description: "Invalid signature"
      },
      USER_INFO_REQUEST_ERROR: {
        name: "User info request error",
        description: "User info request error"
      },
      REFRESH_TOKEN: {
        name: "Refresh token",
        description: "Refresh token"
      },
      IDENTITY_PROVIDER_RESPONSE: {
        name: "Identity provider response",
        description: "Identity provider response"
      },
      IDENTITY_PROVIDER_RETRIEVE_TOKEN: {
        name: "Identity provider retrieve token",
        description: "Identity provider retrieve token"
      },
      UNREGISTER_NODE_ERROR: {
        name: "Unregister node error",
        description: "Unregister node error"
      },
      VALIDATE_ACCESS_TOKEN_ERROR: {
        name: "Validate access token error",
        description: "Validate access token error"
      },
      INVALID_SIGNATURE_ERROR: {
        name: "Invalid signature error",
        description: "Invalid signature error"
      },
      USER_INFO_REQUEST: {
        name: "User info request",
        description: "User info request"
      },
      IDENTITY_PROVIDER_RESPONSE_ERROR: {
        name: "Identity provider response error",
        description: "Identity provider response error"
      },
      IDENTITY_PROVIDER_LOGIN_ERROR: {
        name: "Identity provider login error",
        description: "Identity provider login error"
      },
      REFRESH_TOKEN_ERROR: {
        name: "Refresh token error",
        description: "Refresh token error"
      }
    },
    emptyEvents: "Nothing to add",
    emptyEventsInstructions: "There are no more events types left to add",
    eventConfigSuccessfully: "Successfully saved configuration",
    eventConfigError: "Could not save event configuration {{error}}",
    deleteEvents: "Clear events",
    deleteEventsConfirm: "If you clear all events of this realm, all records will be permanently cleared in the database",
    "admin-events-cleared": "The admin events have been cleared",
    "admin-events-cleared-error": "Could not clear the admin events {{error}}",
    "user-events-cleared": "The user events have been cleared",
    "user-events-cleared-error": "Could not clear the user events {{error}}",
    "events-disable-title": "Unsave events?",
    "events-disable-confirm": 'If "Save events" is disabled, subsequent events will not be displayed in the "Events" menu',
    confirm: "Confirm",
    noMessageBundles: "No message bundles",
    noMessageBundlesInstructions: "Add a message bundle to get started.",
    messageBundleDescription: "You can edit the supported locales. If you haven't selected supported locales yet, you can only edit the English locale.",
    defaultRoles: "Default roles",
    defaultGroups: "Default groups",
    securityDefences: "Security defenses",
    headers: "Headers",
    bruteForceDetection: "Brute force detection",
    xFrameOptions: "X-Frame-Options",
    contentSecurityPolicy: "Content-Security-Policy",
    contentSecurityPolicyReportOnly: "Content-Security-Policy-Report-Only",
    xContentTypeOptions: "X-Content-Type-Options",
    xRobotsTag: "X-Robots-Tag",
    xXSSProtection: "X-XSS-Protection",
    strictTransportSecurity: "HTTP Strict Transport Security (HSTS)",
    failureFactor: "Max login failures",
    permanentLockout: "Permanent lockout",
    waitIncrement: "Wait increment",
    maxFailureWait: "Max wait",
    maxDeltaTime: "Failure reset time",
    quickLoginCheckMilliSeconds: "Quick login check milliseconds",
    minimumQuickLoginWaitSeconds: "Minimum quick login wait"
  },
  "partial-import": {
    partialImportHeaderText: "Partial import allows you to import users, clients, and other resources from a previously exported json file.",
    selectRealm: "Select realm",
    chooseResources: "Choose the resources you want to import",
    selectIfResourceExists: "If a resource already exists, specify what should be done",
    import: "Import",
    FAIL: "Fail import",
    SKIP: "Skip",
    OVERWRITE: "Overwrite"
  }
};

// build/realm-settings/help.js
var help_default4 = {
  "realm-settings-help": {
    fromDisplayName: "A user-friendly name for the 'From' address (optional).",
    replyToDisplayName: "A user-friendly name for the 'Reply-To' address (optional).",
    envelopeFrom: "An email address used for bounces (optional).",
    password: "SMTP password. This field is able to obtain its value from vault, use ${vault.ID} format.",
    frontendUrl: "Set the frontend URL for the realm. Use in combination with the default hostname provider to override the base URL for frontend requests for a specific realm.",
    requireSsl: "Is HTTPS required? 'None' means HTTPS is not required for any client IP address. 'External requests' means localhost and private IP addresses can access without HTTPS. 'All requests' means HTTPS is required for all IP addresses.",
    userManagedAccess: "If enabled, users are allowed to manage their resources and permissions using the Account Management Console.",
    endpoints: "Shows the configuration of the protocol endpoints",
    loginTheme: "Select theme for login, OTP, grant, registration and forgot password pages.",
    accountTheme: "Select theme for user account management pages.",
    adminConsoleTheme: "Select theme for admin console.",
    emailTheme: "Select theme for emails that are sent by the server.",
    displayName: "Display name of provider when linked in admin console",
    priority: "Priority of the provider",
    enabled: "Set if the keys are enabled",
    active: "Set if the keys can be used for signing",
    AESKeySize: "Size in bytes for the generated AES key. Size 16 is for AES-128, Size 24 for AES-192, and Size 32 for AES-256. WARN: Bigger keys than 128 are not allowed on some JDK implementations.",
    "save-user-events": "If enabled, login events are saved to the database, which makes events available to the admin and account management consoles.",
    "save-admin-events": "If enabled, admin events are saved to the database, which makes events available to the admin console.",
    expiration: "Sets the expiration for events. Expired events are periodically deleted from the database.",
    "admin-clearEvents": "Deletes all admin events in the database.",
    includeRepresentation: "Include JSON representation for create and update requests.",
    "user-clearEvents": "Deletes all user events in the database.",
    ellipticCurve: "Elliptic curve used in ECDSA",
    secretSize: "Size in bytes for the generated secret",
    algorithm: "Intended algorithm for the key",
    keystore: "Path to keys file",
    keystorePassword: "Password for the keys",
    keyAlias: "Alias for the private key",
    keyPassword: "Password for the private key",
    privateRSAKey: "Private RSA Key encoded in PEM format",
    x509Certificate: "X509 Certificate encoded in PEM format",
    xFrameOptions: "Default value prevents pages from being included by non-origin iframes <1>Learn more</1>",
    contentSecurityPolicy: "Default value prevents pages from being included by non-origin iframes <1>Learn more</1>",
    contentSecurityPolicyReportOnly: "For testing Content Security Policies <1>Learn more</1>",
    xContentTypeOptions: "Default value prevents Internet Explorer and Google Chrome from MIME-sniffing a response away from the declared content-type <1>Learn more</1>",
    xRobotsTag: "Prevent pages from appearing in search engines <1>Learn more</1>",
    xXSSProtection: "Prevent pages from appearing in search engines <1>Learn more</1>",
    strictTransportSecurity: "The Strict-Transport-Security HTTP header tells browsers to always use HTTPS. Once a browser sees this header, it will only visit the site over HTTPS for the time specified (1 year) at max-age, including the subdomains. <1>Learn more</1>",
    failureFactor: "How many failures before wait is triggered.",
    permanentLockout: "Lock the user permanently when the user exceeds the maximum login failures.",
    waitIncrement: "When failure threshold has been met, how much time should the user be locked out?",
    maxFailureWait: "Max time a user will be locked out.",
    maxDeltaTime: "When will failure count be reset?",
    quickLoginCheckMilliSeconds: "If a failure happens concurrently too quickly, lock out the user.",
    minimumQuickLoginWait: "How long to wait after a quick login failure.",
    ssoSessionIdle: "Time a session is allowed to be idle before it expires. Tokens and browser sessions are invalidated when a session is expired.",
    ssoSessionMax: "Max time before a session is expired. Tokens and browser sessions are invalidated when a session is expired.",
    ssoSessionIdleRememberMe: "Time a remember me session is allowed to be idle before it expires. Tokens and browser sessions are invalidated when a session is expired. If not set it uses the standard SSO Session Idle value.",
    ssoSessionMaxRememberMe: "Max time before a session is expired when a user has set the remember me option. Tokens and browser sessions are invalidated when a session is expired. If not set it uses the standard SSO Session Max value.",
    clientSessionIdle: "Time a client session is allowed to be idle before it expires. Tokens are invalidated when a client session is expired. If not set it uses the standard SSO Session Idle value.",
    clientSessionMax: "Max time before a client session is expired. Tokens are invalidated when a session is expired. If not set it uses the standard SSO Session Max value.",
    offlineSessionIdle: "Time an offline session is allowed to be idle before it expires. You need to use offline token to refresh at least once within this period; otherwise offline session will expire.",
    offlineSessionMaxLimited: "Enable offline session max",
    offlineSessionMax: "Max time before an offline session is expired regardless of activity.",
    loginTimeout: "Max time a user has to complete a login. This is recommended to be relatively long, such as 30 minutes or more",
    loginActionTimeout: "Max time a user has to complete login related actions like update password or configure totp. This is recommended to be relatively long, such as 5 minutes or more",
    defaultSigAlg: "Default algorithm used to sign tokens for the realm",
    revokeRefreshToken: "If enabled a refresh token can only be used up to 'Refresh Token Max Reuse' and is revoked when a different token is used. Otherwise refresh tokens are not revoked when used and can be used multiple times.",
    refreshTokenMaxReuse: "Maximum number of times a refresh token can be reused. When a different token is used, revocation is immediate.",
    accessTokenLifespan: "Max time before an access token is expired. This value is recommended to be short relative to the SSO timeout",
    accessTokenLifespanImplicitFlow: "Max time before an access token issued during OpenID Connect Implicit Flow is expired. This value is recommended to be shorter than the SSO timeout. There is no possibility to refresh token during implicit flow, that's why there is a separate timeout different to 'Access Token Lifespan'",
    clientLoginTimeout: "Max time a client has to finish the access token protocol. This should normally be 1 minute.",
    userInitiatedActionLifespan: "Maximum time before an action permit sent by a user (such as a forgot password e-mail) is expired. This value is recommended to be short because it's expected that the user would react to self-created action quickly.",
    defaultAdminInitiatedActionLifespan: "Maximum time before an action permit sent to a user by administrator is expired. This value is recommended to be long to allow administrators to send e-mails for users that are currently offline. The default timeout can be overridden immediately before issuing the token.",
    overrideActionTokens: "Override default settings of maximum time before an action permit sent by a user (such as a forgot password e-mail) is expired for specific action. This value is recommended to be short because it's expected that the user would react to self-created action quickly."
  }
};

// build/authentication/messages.js
var messages_default11 = {
  authentication: {
    title: "Authentication",
    flows: "Flows",
    flowName: "Flow name",
    usedBy: "Used by",
    buildIn: "Built-in",
    appliedByProviders: "Applied by the following providers",
    appliedByClients: "Applied by the following clients",
    specificProviders: "Specific providers",
    specificClients: "Specific clients",
    default: "Default",
    notInUse: "Not in use",
    duplicate: "Duplicate",
    deleteConfirmFlow: "Delete flow?",
    deleteConfirmFlowMessage: 'Are you sure you want to permanently delete the flow "<1>{{flow}}</1>".',
    deleteFlowSuccess: "Flow successfully deleted",
    deleteFlowError: "Could not delete flow: {{error}}",
    duplicateFlow: "Duplicate flow",
    updateFlowSuccess: "Flow successfully updated",
    updateFlowError: "Could not update flow: {{error}}",
    copyOf: "Copy of {{name}}",
    copyFlowSuccess: "Flow successfully duplicated",
    copyFlowError: "Could not duplicate flow: {{error}}",
    createFlow: "Create flow",
    flowType: "Flow type",
    "flow-type": {
      "basic-flow": "Basic flow",
      "client-flow": "Client flow"
    },
    flowCreatedSuccess: "Flow created",
    flowCreateError: "Could not create flow: {{error}}",
    flowDetails: "Flow details",
    tableView: "Table view",
    diagramView: "Diagram view",
    emptyExecution: "No steps",
    emptyExecutionInstructions: "You can start defining this flow by adding a sub-flow or an execution",
    addExecutionTitle: "Add an execution",
    addExecution: "Add execution",
    addSubFlowTitle: "Add a sub-flow",
    addSubFlow: "Add sub-flow",
    steps: "Steps",
    requirement: "Requirement",
    requirements: {
      REQUIRED: "Required",
      ALTERNATIVE: "Alternative",
      DISABLED: "Disabled",
      CONDITIONAL: "Conditional"
    }
  }
};

// build/authentication/help.js
var help_default5 = {
  "authentication-help": {
    name: "Help text for the name of the new flow",
    description: "Help text for the description of the new flow",
    createFlow: "You can create a top level flow within this from",
    flowType: "What kind of top level flow is it? Type 'client' is used for authentication of clients (applications) when generic is for users and everything else",
    addExecution: "Execution can have a wide range of actions, from sending a reset email to validating an OTP",
    addSubFlow: "Sub-Flows can be either generic or form. The form type is used to construct a sub-flow that generates a single flow for the user. Sub-flows are a special type of execution that evaluate as successful depending on how the executions they contain evaluate."
  }
};

// build/user-federation/messages.js
var messages_default12 = {
  "user-federation": {
    userFederation: "User federation",
    descriptionLanding: "This is the description for the user federation landing page",
    userFederationExplanation: "Keycloak can federate external user databases. Out of the box we have support for LDAP and Active Directory.",
    getStarted: "To get started, select a provider from the list below.",
    providers: "Add providers",
    addKerberos: "Add Kerberos providers",
    addLdap: "Add LDAP providers",
    addOneLdap: "Add LDAP provider",
    addKerberosWizardTitle: "Add Kerberos user federation provider",
    addLdapWizardTitle: "Add LDAP user federation provider",
    syncChangedUsers: "Sync changed users",
    syncAllUsers: "Sync all users",
    unlinkUsers: "Unlink users",
    removeImported: "Remove imported",
    deleteProvider: "Delete provider",
    generalOptions: "General options",
    consoleDisplayName: "Console display name",
    vendor: "Vendor",
    connectionAndAuthenticationSettings: "Connection and authentication settings",
    connectionURL: "Connection URL",
    enableStartTls: "Enable StartTLS",
    useTruststoreSpi: "Use Truststore SPI",
    connectionPooling: "Connection pooling",
    connectionTimeout: "Connection timeout",
    bindType: "Bind type",
    bindDn: "Bind DN",
    bindCredentials: "Bind credentials",
    ldapSearchingAndUpdatingSettings: "LDAP searching and updating",
    editMode: "Edit mode",
    usersDN: "Users DN",
    usernameLdapAttribute: "Username LDAP attribute",
    rdnLdapAttribute: "RDN LDAP attribute",
    uuidLdapAttribute: "UUID LDAP attribute",
    userObjectClasses: "User object classes",
    userLdapFilter: "User LDAP filter",
    searchScope: "Search scope",
    readTimeout: "Read timeout",
    pagination: "Pagination",
    synchronizationSettings: "Synchronization settings",
    importUsers: "Import users",
    batchSize: "Batch size",
    periodicFullSync: "Periodic full sync",
    fullSyncPeriod: "Full sync period",
    periodicChangedUsersSync: "Periodic changed users sync",
    changedUsersSyncPeriod: "Changed users sync period",
    kerberosIntegration: "Kerberos integration",
    allowKerberosAuthentication: "Allow Kerberos authentication",
    useKerberosForPasswordAuthentication: "Use Kerberos for password authentication",
    cacheSettings: "Cache settings",
    cachePolicy: "Cache policy",
    evictionDay: "Eviction day",
    evictionHour: "Eviction hour",
    evictionMinute: "Eviction minute",
    maxLifespan: "Max lifespan",
    advancedSettings: "Advanced settings",
    enableLdapv3Password: "Enable the LDAPv3 password modify extended operation",
    validatePasswordPolicy: "Validate password policy",
    trustEmail: "Trust email",
    requiredSettings: "Required Settings",
    kerberosRealm: "Kerberos realm",
    serverPrincipal: "Server principal",
    keyTab: "Key tab",
    debug: "Debug",
    allowPasswordAuthentication: "Allow password authentication",
    updateFirstLogin: "Update first login",
    always: "Always",
    never: "Never",
    onlyLdaps: "Only for ldaps",
    oneLevel: "One Level",
    subtree: "Subtree",
    saveSuccess: "User federation provider successfully saved",
    saveError: "User federation provider could not be saved: {{error}}",
    createSuccess: "User federation provider successfully created",
    createError: "User federation provider could not be created: {{error}}",
    testSuccess: "Successfully connected to LDAP",
    testError: "Error when trying to connect to LDAP. See server.log for details. {{error}}",
    learnMore: "Learn more",
    addNewProvider: "Add new provider",
    userFedDeletedSuccess: "The user federation provider has been deleted.",
    userFedDeleteError: "Could not delete user federation provider: '{{error}}'",
    userFedDeleteConfirmTitle: "Delete user federation provider?",
    userFedDeleteConfirm: "If you delete this user federation provider, all associated data will be removed.",
    userFedDisableConfirmTitle: "Disable user federation provider?",
    userFedDisableConfirm: "If you disable this user federation provider, it will not be considered for queries and imported users will be disabled and read-only until the provider is enabled again.",
    removeImportedUsers: "Remove imported users?",
    removeImportedUsersMessage: `Do you really want to remove all imported users? The option "Unlink users" makes sense just for the Edit Mode "Unsynced" and there should be a warning that "unlinked" users without the password in the Keycloak database won't be able to authenticate.`,
    removeImportedUsersSuccess: "Imported users have been removed.",
    removeImportedUsersError: "Could not remove imported users: '{{error}}'",
    syncUsersSuccess: "Sync of users finished successfully.",
    syncUsersError: "Could not sync users: '{{error}}'",
    unlinkUsersSuccess: "Unlink of users finished successfully.",
    unlinkUsersError: "Could not unlink users: '{{error}}'",
    validateName: "You must enter a name",
    validateRealm: "You must enter a realm",
    validateServerPrincipal: "You must enter a server principal",
    validateKeyTab: "You must enter a key tab",
    validateConnectionUrl: "You must enter a connection URL",
    validateBindDn: "You must enter the DN of the LDAP admin",
    validateBindCredentials: "You must enter the password of the LDAP admin",
    validateUuidLDAPAttribute: "You must enter a UUID LDAP attribute",
    validateUserObjectClasses: "You must enter one or more user object classes",
    validateUsersDn: "You must enter users DN",
    validateUsernameLDAPAttribute: "You must enter a username LDAP attribute",
    validateRdnLdapAttribute: "You must enter an RDN LDAP attribute",
    validateCustomUserSearchFilter: "Filter must be enclosed in parentheses, for example: (filter)",
    mapperTypeMsadUserAccountControlManager: "msad-user-account-control-mapper",
    mapperTypeMsadLdsUserAccountControlMapper: "msad-user-account-control-mapper",
    mapperTypeGroupLdapMapper: "group-ldap-mapper",
    mapperTypeUserAttributeLdapMapper: "user-attribute-ldap-mapper",
    mapperTypeRoleLdapMapper: "role-ldap-mapper",
    mapperTypeHardcodedAttributeMapper: "hardcoded-attribute-mapper",
    mapperTypeHardcodedLdapRoleMapper: "hardcoded-ldap-role-mapper",
    mapperTypeCertificateLdapMapper: "certificate-ldap-mapper",
    mapperTypeFullNameLdapMapper: "full-name-ldap-mapper",
    mapperTypeHardcodedLdapGroupMapper: "hardcoded-ldap-group-mapper",
    mapperTypeLdapAttributeMapper: "hardcoded-ldap-attribute-mapper",
    ldapMappersList: "LDAP Mappers",
    ldapFullNameAttribute: "LDAP full name attribute",
    writeOnly: "Write only",
    ldapGroupsDn: "LDAP groups DN",
    groupNameLdapAttribute: "Group name LDAP attribute",
    groupObjectClasses: "Group object classes",
    preserveGroupInheritance: "Preserve group inheritance",
    ignoreMissingGroups: "Ignore missing groups",
    userGroupsRetrieveStrategy: "User groups retrieve strategy",
    mappedGroupAttributes: "Mapped group attributes",
    dropNonexistingGroupsDuringSync: "Drop non-existing groups during sync",
    groupsPath: "Groups path",
    membershipLdapAttribute: "Membership LDAP attribute",
    membershipAttributeType: "Membership attribute type",
    membershipUserLdapAttribute: "Membership user LDAP attribute",
    ldapFilter: "LDAP filter",
    mode: "Mode",
    memberofLdapAttribute: "Member-of LDAP attribute",
    ldapRolesDn: "LDAP roles DN",
    roleNameLdapAttribute: "Role name LDAP attribute",
    roleObjectClasses: "Role object classes",
    userRolesRetrieveStrategy: "User roles retrieve strategy",
    useRealmRolesMapping: "Use realm roles mapping",
    ldapAttributeName: "LDAP attribute name",
    ldapAttributeValue: "LDAP attribute value",
    userModelAttribute: "User model attribute",
    ldapAttribute: "LDAP attribute",
    readOnly: "Read only",
    alwaysReadValueFromLdap: "Always read value from LDAP",
    isMandatoryInLdap: "Is mandatory in LDAP",
    isBinaryAttribute: "Is binary attribute",
    derFormatted: "DER formatted",
    passwordPolicyHintsEnabled: "Password policy hints enabled",
    userModelAttributeName: "User model attribute name",
    attributeValue: "Attribute value",
    selectRole: "Select role",
    group: "Group"
  }
};

// build/user-federation/help.js
var help_default6 = {
  "user-federation-help": {
    addKerberosWizardDescription: "Text needed here",
    addLdapWizardDescription: "Text needed here",
    ldapGeneralOptionsSettingsDescription: "This section contains a few basic options common to all user storage providers.",
    consoleDisplayNameHelp: "Display name of provider when linked in admin console",
    vendorHelp: "LDAP vendor (provider)",
    ldapConnectionAndAuthorizationSettingsDescription: "This section contains options related to the configuration of the connection to the LDAP server. It also contains options related to authentication of the LDAP connection to the LDAP server.",
    consoleDisplayConnectionUrlHelp: "Connection URL to your LDAP server",
    enableStartTlsHelp: "Encrypts the connection to LDAP using STARTTLS, which will disable connection pooling",
    useTruststoreSpiHelp: "Specifies whether LDAP connection will use the Truststore SPI with the truststore configured in standalone.xml/domain.sml. 'Always' means that it will always use it. 'Never' means that it will not use it. 'Only for ldaps' means that it will use it if your connection URL use ldaps. Note that even if standalone.xml/domain.xml is not configured, the default java cacerts or certificate specified by 'javax.net.ssl.trustStore' property will be used.",
    connectionPoolingHelp: "Determines if Keycloak should use connection pooling for accessing LDAP server.",
    connectionTimeoutHelp: "LDAP connection timeout in milliseconds",
    bindTypeHelp: "Type of the authentication method used during LDAP bind operation. It is used in most of the requests sent to the LDAP server. Currently only 'none' (anonymous LDAP authentication) or 'simple' (bind credential + bind password authentication) mechanisms are available.",
    bindDnHelp: "DN of the LDAP admin, which will be used by Keycloak to access LDAP server",
    bindCredentialsHelp: "Password of LDAP admin. This field is able to obtain its value from vault, use ${vault.ID} format.",
    ldapSearchingAndUpdatingSettingsDescription: "This section contains options related to searching the LDAP server for the available users.",
    editModeLdapHelp: "READ_ONLY is a read-only LDAP store. WRITABLE means data will be synced back to LDAP on demand. UNSYNCED means user data will be imported, but not synced back to LDAP.",
    usersDNHelp: "Full DN of LDAP tree where your users are. This DN is the parent of LDAP users. It could be for example 'ou=users,dc=example,dc=com' assuming that your typical user will have DN like 'uid='john',ou=users,dc=example,dc=com'.",
    usernameLdapAttributeHelp: "Name of the LDAP attribute, which is mapped as Keycloak username. For many LDAP server vendors it can be 'uid'. For Active directory it can be 'sAMAccountName' or 'cn'. The attribute should be filled for all LDAP user records you want to import from LDAP to Keycloak.",
    rdnLdapAttributeHelp: "Name of the LDAP attribute, which is used as RDN (top attribute) of typical user DN. Usually it's the same as the Username LDAP attribute, however it is not required. For example for Active directory, it is common to use 'cn' as RDN attribute when username attribute might be 'sAMAccountName'.",
    uuidLdapAttributeHelp: "Name of the LDAP attribute, which is used as a unique object identifier (UUID) for objects in LDAP. For many LDAP server vendors, it is 'entryUUID'; however some are different. For example, for Active directory it should be 'objectGUID'. If your LDAP server does not support the notion of UUID, you can use any other attribute that is supposed to be unique among LDAP users in tree. For example 'uid' or 'entryDN'.",
    userObjectClassesHelp: "All values of LDAP objectClass attribute for users in LDAP, divided by commas. For example: 'inetOrgPerson, organizationalPerson'. Newly created Keycloak users will be written to LDAP with all those object classes and existing LDAP user records are found just if they contain all those object classes.",
    userLdapFilterHelp: "Additional LDAP filter for filtering searched users. Leave this empty if you don't need an additional filter. Make sure that it starts with '(' and ends with ')'.",
    searchScopeHelp: "For one level, the search applies only for users in the DNs specified by User DNs. For subtree, the search applies to the whole subtree. See LDAP documentation for more details.",
    readTimeoutHelp: "LDAP read timeout in milliseconds. This timeout applies for LDAP read operations.",
    paginationHelp: "Whether the LDAP server supports pagination",
    ldapSynchronizationSettingsDescription: "This section contains options related to synchronization of users from LDAP to the Keycloak database.",
    importUsersHelp: "If true, LDAP users will be imported into the Keycloak DB and synced by the configured sync policies.",
    batchSizeHelp: "Count of LDAP users to be imported from LDAP to Keycloak within a single transaction",
    periodicFullSyncHelp: "Whether periodic full synchronization of LDAP users to Keycloak should be enabled or not",
    fullSyncPeriodHelp: "Period for full synchronization in seconds",
    periodicChangedUsersSyncHelp: "Whether periodic synchronization of changed or newly created LDAP users to Keycloak should be enabled or not",
    changedUsersSyncHelp: "Period for synchronization of changed or newly created LDAP users in seconds",
    ldapKerberosSettingsDescription: "This section contains options useful for the Kerberos integration. This is used only when the LDAP server is used together with Kerberos/SPNEGO for user authentication.",
    allowKerberosAuthenticationHelp: "Enable/disable HTTP authentication of users with SPNEGO/Kerberos tokens. The data about authenticated users will be provisioned from this LDAP server.",
    useKerberosForPasswordAuthenticationHelp: "User Kerberos login module for authenticating username/password against Kerberos server instead of authenticating against LDAP server with Directory Service API",
    cacheSettingsDescription: "This section contains options useful for caching users, which were loaded from this user storage provider.",
    cachePolicyHelp: "Cache Policy for this storage provider. 'DEFAULT' is whatever the default settings are for the global cache. 'EVICT_DAILY' is a time of day every day that the cache will be invalidated. 'EVICT_WEEKLY' is a day of the week and time the cache will be invalidated. 'MAX_LIFESPAN' is the time in milliseconds that will be the lifespan of a cache entry.",
    evictionDayHelp: "Day of the week the entry will become invalid",
    evictionHourHelp: "Hour of the day the entry will become invalid",
    evictionMinuteHelp: "Minute of the hour the entry will become invalid",
    maxLifespanHelp: "Max lifespan of cache entry in milliseconds",
    ldapAdvancedSettingsDescription: "This section contains all the other options for more fine-grained configuration of the LDAP storage provider.",
    enableLdapv3PasswordHelp: "Use the LDAPv3 Password Modify Extended Operation (RFC-3062). The password modify extended operation usually requires that LDAP user already has password in the LDAP server. So when this is used with 'Sync Registrations', it can be good to add also 'Hardcoded LDAP attribute mapper' with randomly generated initial password.",
    validatePasswordPolicyHelp: "Determines if Keycloak should validate the password with the realm password policy before updating it",
    trustEmailHelp: "If enabled, email provided by this provider is not verified even if verification is enabled for the realm.",
    "IDK-periodicChangedUsersSyncHelp": "Should newly created users be created within LDAP store? Priority affects which provider is chosen to sync the new user.",
    kerberosWizardDescription: "Text needed here.",
    kerberosRequiredSettingsDescription: "This section contains a few basic options common to all user storage providers.",
    kerberosRealmHelp: "Name of kerberos realm. For example, FOO.ORG",
    serverPrincipalHelp: "Full name of server principal for HTTP service including server and domain name. For example, HTTP/host.foo.org@FOO.ORG",
    keyTabHelp: "Location of Kerberos KeyTab file containing the credentials of server principal. For example, /etc/krb5.keytab",
    debugHelp: "Enable/disable debug logging to standard output for Krb5LoginModule.",
    allowPasswordAuthenticationHelp: "Enable/disable possibility of username/password authentication against Kerberos database",
    editModeKerberosHelp: "READ_ONLY means that password updates are not allowed and user always authenticates with Kerberos password. UNSYNCED means that the user can change the password in the Keycloak database and this one will be used instead of the Kerberos password.",
    updateFirstLoginHelp: "Update profile on first login",
    mapperTypeMsadUserAccountControlManagerHelp: "Mapper specific to MSAD. It's able to integrate the MSAD user account state into Keycloak account state (account enabled, password is expired etc). It's using userAccountControl and pwdLastSet MSAD attributes for that. For example if pwdLastSet is 0, the Keycloak user is required to update the password; if userAccountControl is 514 (disabled account) the Keycloak user is disabled as well etc. Mapper is also able to handle the exception code from LDAP user authentication.",
    mapperTypeMsadLdsUserAccountControlMapperHelp: "Mapper specific to MSAD LDS. It's able to integrate the MSAD LDS user account state into Keycloak account state (account enabled, password is expired etc). It's using msDS-UserAccountDisabled and pwdLastSet is 0, the Keycloak user is required to update password, if msDS-UserAccountDisabled is 'TRUE' the Keycloak user is disabled as well etc. Mapper is also able to handle exception code from LDAP user authentication.",
    mapperTypeGroupLdapMapperHelp: "Used to map group mappings of groups from some LDAP DN to Keycloak group mappings",
    mapperTypeUserAttributeLdapMapperHelp: "Used to map single attribute from LDAP user to attribute of UserModel in Keycloak DB",
    mapperTypeRoleLdapMapperHelp: "Used to map role mappings of roles from some LDAP DN to Keycloak role mappings of either realm roles or client roles of particular client",
    mapperTypeHardcodedAttributeMapperHelp: "This mapper will hardcode any model user attribute and some property (like emailVerified or enabled) when importing user from LDAP.",
    mapperTypeHardcodedLdapRoleMapperHelp: "Users imported from LDAP will be automatically added into this configured role.",
    mapperTypeCertificateLdapMapperHelp: "Used to map single attribute which contains a certificate from LDAP user to attribute of UserModel in Keycloak DB",
    mapperTypeFullNameLdapMapperHelp: "Used to map the full-name of a user from single attribute in LDAP (usually 'cn' attribute) to firstName and lastName attributes of UserModel in Keycloak DB",
    mapperTypeHardcodedLdapGroupMapperHelp: "Users imported from LDAP will be automatically added into this configured group.",
    mapperTypeLdapAttributeMapperHelp: "This mapper is supported just if syncRegistrations is enabled. New users registered in Keycloak will be written to the LDAP with the hardcoded value of some specified attribute.",
    passwordPolicyHintsEnabledHelp: "Applicable just for writable MSAD. If on, then updating password of MSAD user will use LDAP_SERVER_POLICY_HINTS_OID extension, which means that advanced MSAD password policies like 'password history' or 'minimal password age' will be applied. This extension works just for MSAD 2008 R2 or newer.",
    nameHelp: "Name of the mapper",
    mapperTypeHelp: "Used to map single attribute from LDAP user to attribute of UserModel in Keycloak DB",
    userModelAttributeHelp: "Name of the UserModel property or attribute you want to map the LDAP attribute into. For example 'firstName', 'lastName, 'email', 'street' etc.",
    ldapAttributeHelp: "Name of mapped attribute on LDAP object. For example 'cn', 'sn', 'mail', 'street', etc.",
    readOnlyHelp: "Read-only attribute is imported from LDAP to UserModel, but it's not saved back to LDAP when user is updated in Keycloak.",
    alwaysReadValueFromLdapHelp: "If on, then during reading of the LDAP attribute value will always used instead of the value from Keycloak DB.",
    isMandatoryInLdapHelp: "If true, attribute is mandatory in LDAP. Hence if there is no value in Keycloak DB, the empty value will be set to be propagated to LDAP.",
    isBinaryAttributeHelp: "Should be true for binary LDAP attributes.",
    derFormattedHelp: "Activate this if the certificate is DER formatted in LDAP and not PEM formatted.",
    ldapFullNameAttributeHelp: "Name of LDAP attribute, which contains fullName of user. Usually it will be 'cn',",
    fullNameLdapMapperReadOnlyHelp: "For Read-only, data is imported from LDAP to Keycloak DB, but it's not saved back to LDAP when user is updated in Keycloak.",
    fullNameLdapMapperWriteOnlyHelp: "For Write-only, is data propagated to LDAP when user is created or updated in Keycloak. But this mapper is not used to propagate data from LDAP back into Keycloak. This setting is useful if you configured separate firstName and lastName attribute mappers and you want to use those to read attribute from LDAP into Keycloak",
    ldapGroupsDnHelp: "LDAP DN where groups of this tree are saved. For example 'ou=groups,dc=example,dc=org'",
    groupNameLdapAttributeHelp: "Name of LDAP attribute, which is used in group objects for name and RDN of group. Usually it will be 'cn'. In this case typical group/role object may have DN like 'cn=Group1,ouu=groups,dc=example,dc=org'.",
    groupObjectClassesHelp: "Object class (or classes) of the group object. It's divided by commas if more classes needed. In typical LDAP deployment it could be 'groupOfNames'. In Active Directory it's usually 'group'.",
    preserveGroupInheritanceHelp: "Flag whether group inheritance from LDAP should be propagated to Keycloak. If false, then all LDAP groups will be mapped as flat top-level groups in Keycloak. Otherwise group inheritance is preserved into Keycloak, but the group sync might fail if LDAP structure contains recursions or multiple parent groups per child groups.",
    ignoreMissingGroupsHelp: "Ignore missing groups in the group hierarchy.",
    userGroupsRetrieveStrategyHelp: "Specify how to retrieve groups of user. LOAD_GROUPS_BY_MEMBER_ATTRIBUTE means that roles of user will be retrieved by sending LDAP query to retrieve all groups where 'member' is our user. GET_GROUPS_FROM_USER_MEMBEROF_ATTRIBUTE means that groups of user will be retrieved from 'memberOf' attribute of our user or from the other attribute specified by 'Member-Of LDAP Attribute'.",
    mappedGroupAttributesHelp: "List of names of attributes divided by commas. This points to the list of attributes on LDAP group, which will be mapped as attributes of Group in Keycloak. Leave this empty if no additional group attributes are required to be mapped in Keycloak.",
    dropNonexistingGroupsDuringSyncHelp: "If this flag is true, then during sync of groups from LDAP to Keycloak, we will keep just those Keycloak groups that still exist in LDAP. The rest will be deleted.",
    groupsPathHelp: "Keycloak group path the LDAP groups are added to. For example if value '/Applications/App1' is used, then LDAP groups will be available in Keycloak under group 'App1', which is child of top level group 'Applications'. The default value is '/' so LDAP groups will be mapped to the Keycloak groups at the top level. The configured group path must already exist in the Keycloak when creating this mapper.",
    ldapRolesDnHelp: "LDAP DN where roles of this tree are saved. For example, 'ou=finance,dc=example,dc=org'",
    roleNameLdapAttributeHelp: "Name of LDAP attribute, which is used in role objects for name and RDN of role. Usually it will be 'cn'. In this case typical group/role object may have DN like 'cn=role1,ou=finance,dc=example,dc=org'.",
    roleObjectClassesHelp: "Object class (or classes) of the role object. It's divided by commas if more classes are needed. In typical LDAP deployment it could be 'groupOfNames'. In Active Directory it's usually 'group'.",
    userRolesRetrieveStrategyHelp: "Specify how to retrieve roles of user. LOAD_ROLES_BY_MEMBER_ATTRIBUTE means that roles fo user will be retrieved by sending LDAP query to retrieve all roles where 'member' is our user. GET_ROLES_FROM_USER_MEMBEROF means that roles of user will be retrieved from 'memberOf' attribute of our user. Or from the other attributes specified by 'Member-Of LDAP Attribute'. LOAD_ROLES_BY_MEMBER_ATTRIBUTE is applicable just in Active Directory and it means that roles of user will be retrieved recursively with usage of LDAP_MATCHING_RULE_IN_CHAIN LDAP extension.",
    useRealmRolesMappingHelp: "If true, then LDAP role mappings will be mapped to realm role mappings in Keycloak. Otherwise it will be mapped to client role mappings.",
    clientIdHelp: "Client ID of client to which LDAP role mappings will be mapped. Applicable only if 'Use Realm Roles Mapping' is false.",
    membershipLdapAttributeHelp: "Name of LDAP attribute on group, which is used for membership mappings. Usually it will be 'member'. However when 'Membership Attribute Type' is 'UID', then 'Membership LDAP Attribute' could be typically 'memberUid'.",
    membershipAttributeTypeHelp: "DN means that LDAP group has it's members declared in form of their full DN. For example 'member: uid=john,ou=users,dc=example,dc=com'. UID means that LDAP group has it's members declared in form of pure user uids. For example 'memberUid: john'.",
    membershipUserLdapAttributeHelp: "Used just if Membership Attribute Type is UID. It is the name of the LDAP attribute on user, which is used for membership mappings. Usually it will be 'uid'. For example if the value of 'Membership User LDAP Attribute' is 'uid' and  LDAP group has 'memberUid: john', then it is expected that particular LDAP user will have attribute 'uid: john'.",
    ldapFilterHelp: "LDAP Filter adds an additional custom filter to the whole query for retrieve LDAP groups. Leave this empty if no additional filtering is needed and you want to retrieve all groups from LDAP. Otherwise make sure that filter starts with '(' and ends with ')'.",
    modeHelp: "LDAP_ONLY means that all group mappings of users are retrieved from LDAP and saved into LDAP. READ_ONLY is Read-only LDAP mode where group mappings are retrieved from both LDAP and DB and merged together. New group joins are not saved to LDAP but to DB. IMPORT is Read-only LDAP mode where group mappings are retrieved from LDAP just at the time when user is imported from LDAP and then they are saved to local keycloak DB.",
    memberofLdapAttributeHelp: "Used just when 'User Roles Retrieve Strategy' is GET_GROUPS_FROM_USER_MEMBEROF_ATTRIBUTE. It specifies the name of the LDAP attribute on the LDAP user, which contains the groups, which the user is member of. Usually it will be the default 'memberOf'.",
    userModelAttributeNameHelp: "Name of the model attribute to be added when importing user from LDAP",
    attributeValueHelp: "Value of the model attribute to be added when importing user from LDAP",
    roleHelp: "Role to grant to user.  Click 'Select Role' button to browse roles, or just type it in the textbox.  To reference an application role the syntax is appname.approle, i.e. myapp.myrole.",
    groupHelp: "Users imported from LDAP will be automatically added into this configured group.",
    ldapAttributeNameHelp: "Name of the LDAP attribute, which will be added to the new user during registration",
    ldapAttributeValueHelp: "Value of the LDAP attribute, which will be added to the new user during registration. You can either hardcode any value like 'foo' but you can also use some special tokens. Only supported token right now is '${RANDOM}', which will be replaced with some randomly generated string."
  }
};

// build/identity-providers/messages.js
var messages_default13 = {
  "identity-providers": {
    listExplain: "Through Identity Brokering it's easy to allow users to authenticate to Keycloak using external Identity Provider or Social Networks.",
    searchForProvider: "Search for provider",
    provider: "Provider details",
    addProvider: "Add provider",
    addKeycloakOpenIdProvider: "Add Keycloak OpenID Connect provider",
    addOpenIdProvider: "Add OpenID Connect provider",
    manageDisplayOrder: "Manage display order",
    deleteProvider: "Delete provider?",
    deleteConfirm: "Are you sure you want to permanently delete the provider '{{provider}}'",
    deletedSuccess: "Provider successfully deleted",
    deleteError: "Could not delete the provider {{error}}",
    disableProvider: "Disable provider?",
    disableConfirm: "Are you sure you want to disable the provider '{{provider}}'",
    disableSuccess: "Provider successfully disabled",
    disableError: "Could not disable the provider {{error}}",
    updateSuccess: "Provider successfully updated",
    updateError: "Could not update the provider {{error}}",
    getStarted: "To get started, select a provider from the list below.",
    addIdentityProvider: "Add {{provider}} provider",
    redirectURI: "Redirect URI",
    clientId: "Client ID",
    clientSecret: "Client Secret",
    displayOrder: "Display order",
    createSuccess: "Identity provider successfully created",
    createError: "Could not create the identity provider: {{error}}",
    oderDialogIntro: "The order that the providers are listed in the login page or the account console. You can drag the row handles to change the order.",
    manageOrderTableAria: "List of identity providers in the order listed on the login page",
    manageOrderItemAria: "Press space or enter to begin dragging, and use the arrow keys to navigate up or down. Press enter to confirm the drag, or any other key to cancel the drag operation.",
    orderChangeSuccess: "Successfully changed display order of identity providers",
    orderChangeError: "Could not change display order of identity providers {{error}}",
    alias: "Alias",
    displayName: "Display name",
    useDiscoveryEndpoint: "Use discovery endpoint",
    discoveryEndpoint: "Discovery endpoint",
    importConfig: "Import config from file",
    showMetaData: "Show metadata",
    hideMetaData: "Hide metadata",
    noValidMetaDataFound: "No valid metadata was found at this URL",
    advanced: "Advanced",
    metadataOfDiscoveryEndpoint: "Metadata of the discovery endpoint",
    authorizationUrl: "Authorization URL",
    passLoginHint: "Pass login_hint",
    passCurrentLocale: "Pass current locale",
    tokenUrl: "Token URL",
    logoutUrl: "Logout URL",
    backchannelLogout: "Backchannel logout",
    disableUserInfo: "Disable user info",
    userInfoUrl: "User Info URL",
    issuer: "Issuer",
    scopes: "Scopes",
    prompt: "Prompt",
    prompts: {
      unspecified: "Unspecified",
      none: "None",
      consent: "Consent",
      login: "Login",
      select_account: "Select account"
    },
    clientAuthentication: "Client authentication",
    clientAuthentications: {
      clientAuth_post: "Client secret sent as post",
      clientAuth_basic: "Client secret sent as basic auth",
      clientAuth_secret_jwt: "Client secret as jwt",
      clientAuth_privatekey_jwt: "JWT signed with private key"
    },
    acceptsPromptNone: "Accepts prompt=none forward from client",
    validateSignature: "Validate Signatures",
    useJwksUrl: "Use JWKS URL",
    jwksUrl: "JWKS URL",
    allowedClockSkew: "Allowed clock skew",
    forwardParameters: "Forwarded query parameters",
    generalSettings: "General settings",
    oidcSettings: "OpenId Connect settings",
    advancedSettings: "Advanced settings",
    storeTokens: "Store tokens",
    trustEmail: "Trust Email",
    accountLinkingOnly: "Account linking only",
    hideOnLoginPage: "Hide on login page",
    firstBrokerLoginFlowAlias: "First login flow",
    postBrokerLoginFlowAlias: "Post login flow",
    syncMode: "Sync mode",
    syncModes: {
      import: "Import",
      legacy: "Legacy",
      force: "Force"
    }
  }
};

// build/identity-providers/help.js
var help_default7 = {
  "identity-providers-help": {
    redirectURI: "The redirect uri to use when configuring the identity provider.",
    alias: "The alias uniquely identifies an identity provider and it is also used to build the redirect uri.",
    displayName: "Friendly name for Identity Providers.",
    clientId: "The client identifier registered with the identity provider.",
    clientSecret: "The client secret registered with the identity provider. This field is able to obtain its value from vault, use ${vault.ID} format.",
    displayOrder: "Number defining the order of the providers in GUI (for example, on the Login page). The lowest number will be applied first.",
    useDiscoveryEndpoint: "If this setting is enabled, the discovery endpoint will be used to fetch the provider config. Keycloak can load the config from the endpoint and automatically update the config if the source has any updates",
    discoveryEndpoint: "Import metadata from a remote IDP discovery descriptor.",
    importConfig: "Import metadata from a downloaded IDP discovery descriptor.",
    passLoginHint: "Pass login_hint to identity provider.",
    passCurrentLocale: "Pass the current locale to the identity provider as a ui_locales parameter.",
    logoutUrl: "End session endpoint to use to logout user from external IDP.",
    backchannelLogout: "Does the external IDP support backchannel logout?",
    disableUserInfo: "Disable usage of User Info service to obtain additional user information?  Default is to use this OIDC service.",
    userInfoUrl: "The User Info Url. This is optional.",
    issuer: "The issuer identifier for the issuer of the response. If not provided, no validation will be performed.",
    scopes: "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to 'openid'.",
    prompt: "Specifies whether the Authorization Server prompts the End-User for reauthentication and consent.",
    acceptsPromptNone: "This is just used together with Identity Provider Authenticator or when kc_idp_hint points to this identity provider. In case that client sends a request with prompt=none and user is not yet authenticated, the error will not be directly returned to client, but the request with prompt=none will be forwarded to this identity provider.",
    validateSignature: "Enable/disable signature validation of external IDP signatures.",
    useJwksUrl: "If the switch is on, identity provider public keys will be downloaded from given JWKS URL. This allows great flexibility because new keys will be always re-downloaded again when identity provider generates new keypair. If the switch is off, public key (or certificate) from the Keycloak DB is used, so when the identity provider keypair changes, you always need to import the new key to the Keycloak DB as well.",
    jwksUrl: "URL where identity provider keys in JWK format are stored. See JWK specification for more details. If you use external Keycloak identity provider, you can use URL like 'http://broker-keycloak:8180/auth/realms/test/protocol/openid-connect/certs' assuming your brokered Keycloak is running on 'http://broker-keycloak:8180' and its realm is 'test' .",
    allowedClockSkew: "Clock skew in seconds that is tolerated when validating identity provider tokens. Default value is zero.",
    forwardParameters: "Non OpenID Connect/OAuth standard query parameters to be forwarded to external IDP from the initial application request to Authorization Endpoint. Multiple parameters can be entered, separated by comma (,).",
    clientAuthentication: "The client authentication method (cfr. https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication). In case of JWT signed with private key, the realm private key is used.",
    storeTokens: "Enable/disable if tokens must be stored after authenticating users.",
    trustEmail: "If enabled, email provided by this provider is not verified even if verification is enabled for the realm.",
    accountLinkingOnly: "If true, users cannot log in through this provider.  They can only link to this provider.  This is useful if you don't want to allow login from the provider, but want to integrate with a provider",
    hideOnLoginPage: "If hidden, login with this provider is possible only if requested explicitly, for example using the 'kc_idp_hint' parameter.",
    firstBrokerLoginFlowAlias: "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that no Keycloak account is currently linked to the authenticated identity provider account.",
    postBrokerLoginFlowAlias: 'Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this to "None" if you need no any additional authenticators to be triggered after login with this identity provider. Also note that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it.',
    syncMode: "Default sync mode for all mappers. The sync mode determines when user data will be synced using the mappers. Possible values are: 'legacy' to keep the behaviour before this option was introduced, 'import' to only import the user once during first login of the user with this identity provider, 'force' to always update the user during every login with this identity provider."
  }
};

// build/i18n.js
var initOptions = {
  defaultNS: "common",
  resources: {
    en: {
      ...common_messages_default,
      ...common_help_default,
      ...messages_default,
      ...messages_default2,
      ...help_default,
      ...messages_default3,
      ...help_default2,
      ...messages_default4,
      ...messages_default5,
      ...messages_default6,
      ...messages_default4,
      ...messages_default7,
      ...help_default3,
      ...messages_default8,
      ...messages_default12,
      ...messages_default9,
      ...messages_default10,
      ...help_default4,
      ...messages_default11,
      ...help_default5,
      ...messages_default13,
      ...help_default7,
      ...messages_default12,
      ...help_default6
    }
  },
  lng: "en",
  fallbackLng: "en",
  interpolation: {
    escapeValue: false
  }
};
i18next_default.use(initReactI18next).init(initOptions);
var i18n_default = i18next_default;

// build/context/whoami/WhoAmI.js
var WhoAmI = class {
  constructor(me2) {
    this.me = me2;
    if (this.me !== void 0 && this.me.locale) {
      i18n_default.changeLanguage(this.me.locale, (error2) => {
        if (error2)
          console.error("Unable to set locale to", this.me?.locale);
      });
    }
  }
  getDisplayName() {
    if (this.me === void 0)
      return "";
    return this.me.displayName;
  }
  getUserId() {
    if (this.me === void 0)
      return "";
    return this.me.userId;
  }
  canCreateRealm() {
    return this.me !== void 0 && this.me.createRealm;
  }
  getRealmAccess() {
    if (this.me === void 0)
      return {};
    return this.me.realm_access;
  }
};
var WhoAmIContext = react.createContext(void 0);
var useWhoAmI = () => useRequiredContext(WhoAmIContext);
var WhoAmIContextProvider = ({children: children2}) => {
  const adminClient = useAdminClient();
  const [whoAmI2, setWhoAmI] = useState(new WhoAmI());
  const [key, setKey] = useState(0);
  useFetch(() => adminClient.whoAmI.find({realm: environment_default.loginRealm}), (me2) => {
    const whoAmI22 = new WhoAmI(me2);
    setWhoAmI(whoAmI22);
  }, [key]);
  return /* @__PURE__ */ react.createElement(WhoAmIContext.Provider, {
    value: {refresh: () => setKey(key + 1), whoAmI: whoAmI2}
  }, children2);
};

// build/PageHeader.js
var Header = () => {
  const {realm: realm2} = useRealm();
  const adminClient = useAdminClient();
  const {t: t4} = useTranslation();
  const ManageAccountDropdownItem = () => {
    return /* @__PURE__ */ react.createElement(react.Fragment, null, adminClient.keycloak && /* @__PURE__ */ react.createElement(DropdownItem, {
      key: "manage account",
      id: "manage-account",
      onClick: () => adminClient.keycloak.accountManagement()
    }, t4("manageAccount")));
  };
  const SignOutDropdownItem = () => {
    return /* @__PURE__ */ react.createElement(react.Fragment, null, adminClient.keycloak && /* @__PURE__ */ react.createElement(DropdownItem, {
      id: "sign-out",
      key: "sign out",
      onClick: () => adminClient.keycloak.logout({redirectUri: ""})
    }, t4("signOut")));
  };
  const ServerInfoDropdownItem = () => {
    const {realm: realm22} = useRealm();
    const {t: t22} = useTranslation();
    return /* @__PURE__ */ react.createElement(DropdownItem, {
      key: "server info",
      component: Link,
      to: toDashboard({realm: realm22})
    }, t22("realmInfo"));
  };
  const HelpDropdownItem = () => {
    const {t: t22} = useTranslation();
    const {enabled, toggleHelp} = useHelp();
    return /* @__PURE__ */ react.createElement(DropdownItem, {
      icon: /* @__PURE__ */ react.createElement(HelpIcon, null),
      onClick: toggleHelp
    }, enabled ? t22("helpEnabled") : t22("helpDisabled"));
  };
  const kebabDropdownItems = [
    /* @__PURE__ */ react.createElement(ManageAccountDropdownItem, {
      key: "kebab Manage Account"
    }),
    /* @__PURE__ */ react.createElement(ServerInfoDropdownItem, {
      key: "kebab Server Info"
    }),
    /* @__PURE__ */ react.createElement(HelpDropdownItem, {
      key: "kebab Help"
    }),
    /* @__PURE__ */ react.createElement(DropdownSeparator, {
      key: "kebab sign out separator"
    }),
    /* @__PURE__ */ react.createElement(SignOutDropdownItem, {
      key: "kebab Sign out"
    })
  ];
  const userDropdownItems = [
    /* @__PURE__ */ react.createElement(ManageAccountDropdownItem, {
      key: "Manage Account"
    }),
    /* @__PURE__ */ react.createElement(ServerInfoDropdownItem, {
      key: "Server info"
    }),
    /* @__PURE__ */ react.createElement(DropdownSeparator, {
      key: "sign out separator"
    }),
    /* @__PURE__ */ react.createElement(SignOutDropdownItem, {
      key: "Sign out"
    })
  ];
  const headerTools = () => {
    return /* @__PURE__ */ react.createElement(PageHeaderTools, null, /* @__PURE__ */ react.createElement(PageHeaderToolsGroup, {
      visibility: {
        default: "hidden",
        md: "visible"
      }
    }, /* @__PURE__ */ react.createElement(PageHeaderToolsItem, null, /* @__PURE__ */ react.createElement(HelpHeader, null))), /* @__PURE__ */ react.createElement(PageHeaderToolsGroup, null, /* @__PURE__ */ react.createElement(PageHeaderToolsItem, {
      visibility: {
        md: "hidden"
      }
    }, /* @__PURE__ */ react.createElement(KebabDropdown, null)), /* @__PURE__ */ react.createElement(PageHeaderToolsItem, {
      visibility: {
        default: "hidden",
        md: "visible"
      }
    }, /* @__PURE__ */ react.createElement(UserDropdown, null))), /* @__PURE__ */ react.createElement(Avatar, {
      src: environment_default.resourceUrl + "/img_avatar.svg",
      alt: "Avatar image"
    }));
  };
  const KebabDropdown = () => {
    const [isDropdownOpen, setDropdownOpen] = useState(false);
    const onDropdownToggle = () => {
      setDropdownOpen(!isDropdownOpen);
    };
    return /* @__PURE__ */ react.createElement(Dropdown, {
      id: "user-dropdown-kebab",
      isPlain: true,
      position: "right",
      toggle: /* @__PURE__ */ react.createElement(KebabToggle, {
        onToggle: onDropdownToggle
      }),
      isOpen: isDropdownOpen,
      dropdownItems: kebabDropdownItems
    });
  };
  const UserDropdown = () => {
    const {whoAmI: whoAmI2} = useWhoAmI();
    const [isDropdownOpen, setDropdownOpen] = useState(false);
    const onDropdownToggle = () => {
      setDropdownOpen(!isDropdownOpen);
    };
    return /* @__PURE__ */ react.createElement(Dropdown, {
      isPlain: true,
      position: "right",
      id: "user-dropdown",
      isOpen: isDropdownOpen,
      toggle: /* @__PURE__ */ react.createElement(DropdownToggle, {
        onToggle: onDropdownToggle
      }, whoAmI2.getDisplayName()),
      dropdownItems: userDropdownItems
    });
  };
  return /* @__PURE__ */ react.createElement(PageHeader, {
    showNavToggle: true,
    logo: /* @__PURE__ */ react.createElement(Link, {
      to: toDashboard({realm: realm2})
    }, /* @__PURE__ */ react.createElement(Brand, {
      src: environment_default.resourceUrl + "/logo.svg",
      id: "masthead-logo",
      alt: "Logo",
      className: "keycloak__pageheader_brand"
    })),
    logoComponent: "div",
    headerTools: headerTools()
  });
};

// build/_snowpack/pkg/react-hook-form.js
var isHTMLElement2 = (value) => value instanceof HTMLElement;
var EVENTS = {
  BLUR: "blur",
  CHANGE: "change",
  INPUT: "input"
};
var VALIDATION_MODE = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
};
var SELECT = "select";
var UNDEFINED = "undefined";
var INPUT_VALIDATION_RULES = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
};
function attachEventListeners({ref}, shouldAttachChangeEvent, handleChange) {
  if (isHTMLElement2(ref) && handleChange) {
    ref.addEventListener(shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);
    ref.addEventListener(EVENTS.BLUR, handleChange);
  }
}
var isNullOrUndefined = (value) => value == null;
var isObjectType = (value) => typeof value === "object";
var isObject2 = (value) => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !(value instanceof Date);
var isKey = (value) => /^\w*$/.test(value);
var compact = (value) => value.filter(Boolean);
var stringToPath = (input) => compact(input.replace(/["|']/g, "").replace(/\[/g, ".").replace(/\]/g, "").split("."));
function set(object, path, value) {
  let index3 = -1;
  const tempPath = isKey(path) ? [path] : stringToPath(path);
  const length = tempPath.length;
  const lastIndex = length - 1;
  while (++index3 < length) {
    const key = tempPath[index3];
    let newValue = value;
    if (index3 !== lastIndex) {
      const objValue = object[key];
      newValue = isObject2(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index3 + 1]) ? [] : {};
    }
    object[key] = newValue;
    object = object[key];
  }
  return object;
}
var transformToNestObject = (data, value = {}) => {
  for (const key in data) {
    !isKey(key) ? set(value, key, data[key]) : value[key] = data[key];
  }
  return value;
};
var isUndefined2 = (val) => val === void 0;
var get2 = (obj = {}, path, defaultValue) => {
  const result = compact(path.split(/[,[\].]+?/)).reduce((result2, key) => isNullOrUndefined(result2) ? result2 : result2[key], obj);
  return isUndefined2(result) || result === obj ? isUndefined2(obj[path]) ? defaultValue : obj[path] : result;
};
var focusOnErrorField = (fields, fieldErrors) => {
  for (const key in fields) {
    if (get2(fieldErrors, key)) {
      const field = fields[key];
      if (field) {
        if (field.ref.focus && isUndefined2(field.ref.focus())) {
          break;
        } else if (field.options) {
          field.options[0].ref.focus();
          break;
        }
      }
    }
  }
};
var removeAllEventListeners = (ref, validateWithStateUpdate) => {
  if (isHTMLElement2(ref) && ref.removeEventListener) {
    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);
    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);
    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);
  }
};
var defaultReturn = {
  isValid: false,
  value: null
};
var getRadioValue = (options) => Array.isArray(options) ? options.reduce((previous, option) => option && option.ref.checked ? {
  isValid: true,
  value: option.ref.value
} : previous, defaultReturn) : defaultReturn;
var getMultipleSelectValue = (options) => [...options].filter(({selected}) => selected).map(({value}) => value);
var isRadioInput = (element) => element.type === "radio";
var isFileInput = (element) => element.type === "file";
var isCheckBoxInput = (element) => element.type === "checkbox";
var isMultipleSelect = (element) => element.type === `${SELECT}-multiple`;
var defaultResult = {
  value: false,
  isValid: false
};
var validResult = {value: true, isValid: true};
var getCheckboxValue = (options) => {
  if (Array.isArray(options)) {
    if (options.length > 1) {
      const values2 = options.filter((option) => option && option.ref.checked).map(({ref: {value: value2}}) => value2);
      return {value: values2, isValid: !!values2.length};
    }
    const {checked, value, attributes} = options[0].ref;
    return checked ? attributes && !isUndefined2(attributes.value) ? isUndefined2(value) || value === "" ? validResult : {value, isValid: true} : validResult : defaultResult;
  }
  return defaultResult;
};
function getFieldValue(fieldsRef, name, shallowFieldsStateRef, excludeDisabled, shouldKeepRawValue) {
  const field = fieldsRef.current[name];
  if (field) {
    const {ref: {value, disabled}, ref, valueAsNumber, valueAsDate, setValueAs} = field;
    if (disabled && excludeDisabled) {
      return;
    }
    if (isFileInput(ref)) {
      return ref.files;
    }
    if (isRadioInput(ref)) {
      return getRadioValue(field.options).value;
    }
    if (isMultipleSelect(ref)) {
      return getMultipleSelectValue(ref.options);
    }
    if (isCheckBoxInput(ref)) {
      return getCheckboxValue(field.options).value;
    }
    return shouldKeepRawValue ? value : valueAsNumber ? value === "" ? NaN : +value : valueAsDate ? ref.valueAsDate : setValueAs ? setValueAs(value) : value;
  }
  if (shallowFieldsStateRef) {
    return get2(shallowFieldsStateRef.current, name);
  }
}
function isDetached(element) {
  if (!element) {
    return true;
  }
  if (!(element instanceof HTMLElement) || element.nodeType === Node.DOCUMENT_NODE) {
    return false;
  }
  return isDetached(element.parentNode);
}
var isEmptyObject = (value) => isObject2(value) && !Object.keys(value).length;
var isBoolean = (value) => typeof value === "boolean";
function baseGet(object, updatePath) {
  const length = updatePath.slice(0, -1).length;
  let index3 = 0;
  while (index3 < length) {
    object = isUndefined2(object) ? index3++ : object[updatePath[index3++]];
  }
  return object;
}
function unset(object, path) {
  const updatePath = isKey(path) ? [path] : stringToPath(path);
  const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);
  const key = updatePath[updatePath.length - 1];
  let previousObjRef;
  if (childObject) {
    delete childObject[key];
  }
  for (let k3 = 0; k3 < updatePath.slice(0, -1).length; k3++) {
    let index3 = -1;
    let objectRef;
    const currentPaths = updatePath.slice(0, -(k3 + 1));
    const currentPathsLength = currentPaths.length - 1;
    if (k3 > 0) {
      previousObjRef = object;
    }
    while (++index3 < currentPaths.length) {
      const item = currentPaths[index3];
      objectRef = objectRef ? objectRef[item] : object[item];
      if (currentPathsLength === index3 && (isObject2(objectRef) && isEmptyObject(objectRef) || Array.isArray(objectRef) && !objectRef.filter((data) => isObject2(data) && !isEmptyObject(data) || isBoolean(data)).length)) {
        previousObjRef ? delete previousObjRef[item] : delete object[item];
      }
      previousObjRef = objectRef;
    }
  }
  return object;
}
var isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;
function findRemovedFieldAndRemoveListener(fieldsRef, handleChange, field, shallowFieldsStateRef, shouldUnregister, forceDelete) {
  const {ref, ref: {name}} = field;
  const fieldRef = fieldsRef.current[name];
  if (!shouldUnregister) {
    const value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);
    !isUndefined2(value) && set(shallowFieldsStateRef.current, name, value);
  }
  if (!ref.type || !fieldRef) {
    delete fieldsRef.current[name];
    return;
  }
  if (isRadioInput(ref) || isCheckBoxInput(ref)) {
    if (Array.isArray(fieldRef.options) && fieldRef.options.length) {
      compact(fieldRef.options).forEach((option = {}, index3) => {
        if (isDetached(option.ref) && isSameRef(option, option.ref) || forceDelete) {
          removeAllEventListeners(option.ref, handleChange);
          unset(fieldRef.options, `[${index3}]`);
        }
      });
      if (fieldRef.options && !compact(fieldRef.options).length) {
        delete fieldsRef.current[name];
      }
    } else {
      delete fieldsRef.current[name];
    }
  } else if (isDetached(ref) && isSameRef(fieldRef, ref) || forceDelete) {
    removeAllEventListeners(ref, handleChange);
    delete fieldsRef.current[name];
  }
}
var isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);
function deepMerge(target, source2) {
  if (isPrimitive(target) || isPrimitive(source2)) {
    return source2;
  }
  for (const key in source2) {
    const targetValue = target[key];
    const sourceValue = source2[key];
    try {
      target[key] = isObject2(targetValue) && isObject2(sourceValue) || Array.isArray(targetValue) && Array.isArray(sourceValue) ? deepMerge(targetValue, sourceValue) : sourceValue;
    } catch (_a) {
    }
  }
  return target;
}
function deepEqual(object1, object2, isErrorObject) {
  if (isPrimitive(object1) || isPrimitive(object2) || object1 instanceof Date || object2 instanceof Date) {
    return object1 === object2;
  }
  if (!react.isValidElement(object1)) {
    const keys1 = Object.keys(object1);
    const keys2 = Object.keys(object2);
    if (keys1.length !== keys2.length) {
      return false;
    }
    for (const key of keys1) {
      const val1 = object1[key];
      if (!(isErrorObject && key === "ref")) {
        const val2 = object2[key];
        if ((isObject2(val1) || Array.isArray(val1)) && (isObject2(val2) || Array.isArray(val2)) ? !deepEqual(val1, val2, isErrorObject) : val1 !== val2) {
          return false;
        }
      }
    }
  }
  return true;
}
function setDirtyFields(values2, defaultValues, dirtyFields, parentNode, parentName) {
  let index3 = -1;
  while (++index3 < values2.length) {
    for (const key in values2[index3]) {
      if (Array.isArray(values2[index3][key])) {
        !dirtyFields[index3] && (dirtyFields[index3] = {});
        dirtyFields[index3][key] = [];
        setDirtyFields(values2[index3][key], get2(defaultValues[index3] || {}, key, []), dirtyFields[index3][key], dirtyFields[index3], key);
      } else {
        deepEqual(get2(defaultValues[index3] || {}, key), values2[index3][key]) ? set(dirtyFields[index3] || {}, key) : dirtyFields[index3] = Object.assign(Object.assign({}, dirtyFields[index3]), {[key]: true});
      }
    }
    parentNode && !dirtyFields.length && delete parentNode[parentName];
  }
  return dirtyFields;
}
var setFieldArrayDirtyFields = (values2, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values2, defaultValues, dirtyFields.slice(0, values2.length)), setDirtyFields(defaultValues, values2, dirtyFields.slice(0, values2.length)));
var isString2 = (value) => typeof value === "string";
var getFieldsValues = (fieldsRef, shallowFieldsState, shouldUnregister, excludeDisabled, search) => {
  const output2 = {};
  for (const name in fieldsRef.current) {
    if (isUndefined2(search) || (isString2(search) ? name.startsWith(search) : Array.isArray(search) && search.find((data) => name.startsWith(data)))) {
      output2[name] = getFieldValue(fieldsRef, name, void 0, excludeDisabled);
    }
  }
  return shouldUnregister ? transformToNestObject(output2) : deepMerge(shallowFieldsState, transformToNestObject(output2));
};
var isErrorStateChanged = ({errors, name, error: error2, validFields, fieldsWithValidation}) => {
  const isValid = isUndefined2(error2);
  const previousError = get2(errors, name);
  return isValid && !!previousError || !isValid && !deepEqual(previousError, error2, true) || isValid && get2(fieldsWithValidation, name) && !get2(validFields, name);
};
var isRegex2 = (value) => value instanceof RegExp;
var getValueAndMessage = (validationData) => isObject2(validationData) && !isRegex2(validationData) ? validationData : {
  value: validationData,
  message: ""
};
var isFunction2 = (value) => typeof value === "function";
var isMessage = (value) => isString2(value) || react.isValidElement(value);
function getValidateError(result, ref, type = "validate") {
  if (isMessage(result) || isBoolean(result) && !result) {
    return {
      type,
      message: isMessage(result) ? result : "",
      ref
    };
  }
}
var appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria ? Object.assign(Object.assign({}, errors[name]), {types: Object.assign(Object.assign({}, errors[name] && errors[name].types ? errors[name].types : {}), {[type]: message || true})}) : {};
var validateField = async (fieldsRef, validateAllFieldCriteria, {ref, ref: {value}, options, required, maxLength, minLength, min: min2, max: max2, pattern, validate}, shallowFieldsStateRef) => {
  const name = ref.name;
  const error2 = {};
  const isRadio3 = isRadioInput(ref);
  const isCheckBox = isCheckBoxInput(ref);
  const isRadioOrCheckbox = isRadio3 || isCheckBox;
  const isEmpty2 = value === "";
  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error2);
  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
    const message = exceedMax ? maxLengthMessage : minLengthMessage;
    error2[name] = Object.assign({
      type: exceedMax ? maxType : minType,
      message,
      ref
    }, exceedMax ? appendErrorsCurry(maxType, message) : appendErrorsCurry(minType, message));
  };
  if (required && (!isRadio3 && !isCheckBox && (isEmpty2 || isNullOrUndefined(value)) || isBoolean(value) && !value || isCheckBox && !getCheckboxValue(options).isValid || isRadio3 && !getRadioValue(options).isValid)) {
    const {value: value2, message} = isMessage(required) ? {value: !!required, message: required} : getValueAndMessage(required);
    if (value2) {
      error2[name] = Object.assign({type: INPUT_VALIDATION_RULES.required, message, ref: isRadioOrCheckbox ? ((fieldsRef.current[name].options || [])[0] || {}).ref : ref}, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));
      if (!validateAllFieldCriteria) {
        return error2;
      }
    }
  }
  if ((!isNullOrUndefined(min2) || !isNullOrUndefined(max2)) && value !== "") {
    let exceedMax;
    let exceedMin;
    const maxOutput = getValueAndMessage(max2);
    const minOutput = getValueAndMessage(min2);
    if (!isNaN(value)) {
      const valueNumber = ref.valueAsNumber || parseFloat(value);
      if (!isNullOrUndefined(maxOutput.value)) {
        exceedMax = valueNumber > maxOutput.value;
      }
      if (!isNullOrUndefined(minOutput.value)) {
        exceedMin = valueNumber < minOutput.value;
      }
    } else {
      const valueDate = ref.valueAsDate || new Date(value);
      if (isString2(maxOutput.value)) {
        exceedMax = valueDate > new Date(maxOutput.value);
      }
      if (isString2(minOutput.value)) {
        exceedMin = valueDate < new Date(minOutput.value);
      }
    }
    if (exceedMax || exceedMin) {
      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
      if (!validateAllFieldCriteria) {
        return error2;
      }
    }
  }
  if (isString2(value) && !isEmpty2 && (maxLength || minLength)) {
    const maxLengthOutput = getValueAndMessage(maxLength);
    const minLengthOutput = getValueAndMessage(minLength);
    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && value.length > maxLengthOutput.value;
    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && value.length < minLengthOutput.value;
    if (exceedMax || exceedMin) {
      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
      if (!validateAllFieldCriteria) {
        return error2;
      }
    }
  }
  if (isString2(value) && pattern && !isEmpty2) {
    const {value: patternValue, message} = getValueAndMessage(pattern);
    if (isRegex2(patternValue) && !patternValue.test(value)) {
      error2[name] = Object.assign({
        type: INPUT_VALIDATION_RULES.pattern,
        message,
        ref
      }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));
      if (!validateAllFieldCriteria) {
        return error2;
      }
    }
  }
  if (validate) {
    const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef, false, true);
    const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;
    if (isFunction2(validate)) {
      const result = await validate(fieldValue);
      const validateError = getValidateError(result, validateRef);
      if (validateError) {
        error2[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));
        if (!validateAllFieldCriteria) {
          return error2;
        }
      }
    } else if (isObject2(validate)) {
      let validationResult = {};
      for (const [key, validateFunction] of Object.entries(validate)) {
        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
          break;
        }
        const validateResult = await validateFunction(fieldValue);
        const validateError = getValidateError(validateResult, validateRef, key);
        if (validateError) {
          validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));
          if (validateAllFieldCriteria) {
            error2[name] = validationResult;
          }
        }
      }
      if (!isEmptyObject(validationResult)) {
        error2[name] = Object.assign({ref: validateRef}, validationResult);
        if (!validateAllFieldCriteria) {
          return error2;
        }
      }
    }
  }
  return error2;
};
var getPath2 = (rootPath, values2, paths = []) => {
  for (const property2 in values2) {
    const rootName = rootPath + (isObject2(values2) ? `.${property2}` : `[${property2}]`);
    isPrimitive(values2[property2]) ? paths.push(rootName) : getPath2(rootName, values2[property2], paths);
  }
  return paths;
};
var assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {
  let value = void 0;
  watchFields.add(fieldName);
  if (!isEmptyObject(fieldValues)) {
    value = get2(fieldValues, fieldName);
    if (isObject2(value) || Array.isArray(value)) {
      getPath2(fieldName, value).forEach((name) => watchFields.add(name));
    }
  }
  return isUndefined2(value) ? isSingleField ? inputValue : get2(inputValue, fieldName) : value;
};
var skipValidation = ({isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll}) => {
  if (isOnAll) {
    return false;
  } else if (!isSubmitted && isOnTouch) {
    return !(isTouched || isBlurEvent);
  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {
    return !isBlurEvent;
  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {
    return isBlurEvent;
  }
  return true;
};
var getFieldArrayParentName = (name) => name.substring(0, name.indexOf("["));
var isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}([|.)\\d+`.replace(/\[/g, "\\[").replace(/\]/g, "\\]")).test(name);
var isNameInFieldArray = (names, name) => [...names].some((current) => isMatchFieldArrayName(name, current));
var isSelectInput = (element) => element.type === `${SELECT}-one`;
function onDomRemove(fieldsRef, removeFieldEventListenerAndRef) {
  const observer = new MutationObserver(() => {
    for (const field of Object.values(fieldsRef.current)) {
      if (field && field.options) {
        for (const option of field.options) {
          if (option && option.ref && isDetached(option.ref)) {
            removeFieldEventListenerAndRef(field);
          }
        }
      } else if (field && isDetached(field.ref)) {
        removeFieldEventListenerAndRef(field);
      }
    }
  });
  observer.observe(window.document, {
    childList: true,
    subtree: true
  });
  return observer;
}
var isWeb = typeof window !== UNDEFINED && typeof document !== UNDEFINED;
function cloneObject(data) {
  var _a;
  let copy2;
  if (isPrimitive(data) || isWeb && (data instanceof File || isHTMLElement2(data))) {
    return data;
  }
  if (!["Set", "Map", "Object", "Date", "Array"].includes((_a = data.constructor) === null || _a === void 0 ? void 0 : _a.name)) {
    return data;
  }
  if (data instanceof Date) {
    copy2 = new Date(data.getTime());
    return copy2;
  }
  if (data instanceof Set) {
    copy2 = new Set();
    for (const item of data) {
      copy2.add(item);
    }
    return copy2;
  }
  if (data instanceof Map) {
    copy2 = new Map();
    for (const key of data.keys()) {
      copy2.set(key, cloneObject(data.get(key)));
    }
    return copy2;
  }
  copy2 = Array.isArray(data) ? [] : {};
  for (const key in data) {
    copy2[key] = cloneObject(data[key]);
  }
  return copy2;
}
var modeChecker = (mode) => ({
  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
  isOnBlur: mode === VALIDATION_MODE.onBlur,
  isOnChange: mode === VALIDATION_MODE.onChange,
  isOnAll: mode === VALIDATION_MODE.all,
  isOnTouch: mode === VALIDATION_MODE.onTouched
});
var isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);
var isWindowUndefined = typeof window === UNDEFINED;
var isProxyEnabled = isWeb ? "Proxy" in window : typeof Proxy !== UNDEFINED;
function useForm({mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, resolver, context: context2, defaultValues = {}, shouldFocusError = true, shouldUnregister = true, criteriaMode} = {}) {
  const fieldsRef = react.useRef({});
  const fieldArrayDefaultValuesRef = react.useRef({});
  const fieldArrayValuesRef = react.useRef({});
  const watchFieldsRef = react.useRef(new Set());
  const useWatchFieldsRef = react.useRef({});
  const useWatchRenderFunctionsRef = react.useRef({});
  const fieldsWithValidationRef = react.useRef({});
  const validFieldsRef = react.useRef({});
  const defaultValuesRef = react.useRef(defaultValues);
  const isUnMount = react.useRef(false);
  const isWatchAllRef = react.useRef(false);
  const handleChangeRef = react.useRef();
  const shallowFieldsStateRef = react.useRef({});
  const resetFieldArrayFunctionRef = react.useRef({});
  const contextRef = react.useRef(context2);
  const resolverRef = react.useRef(resolver);
  const fieldArrayNamesRef = react.useRef(new Set());
  const modeRef = react.useRef(modeChecker(mode));
  const {isOnSubmit, isOnTouch} = modeRef.current;
  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;
  const [formState, setFormState] = react.useState({
    isDirty: false,
    isValidating: false,
    dirtyFields: {},
    isSubmitted: false,
    submitCount: 0,
    touched: {},
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: !isOnSubmit,
    errors: {}
  });
  const readFormStateRef = react.useRef({
    isDirty: !isProxyEnabled,
    dirtyFields: !isProxyEnabled,
    touched: !isProxyEnabled || isOnTouch,
    isValidating: !isProxyEnabled,
    isSubmitting: !isProxyEnabled,
    isValid: !isProxyEnabled
  });
  const formStateRef = react.useRef(formState);
  const observerRef = react.useRef();
  const {isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange} = react.useRef(modeChecker(reValidateMode)).current;
  contextRef.current = context2;
  resolverRef.current = resolver;
  formStateRef.current = formState;
  shallowFieldsStateRef.current = shouldUnregister ? {} : isEmptyObject(shallowFieldsStateRef.current) ? cloneObject(defaultValues) : shallowFieldsStateRef.current;
  const updateFormState = react.useCallback((state = {}) => {
    if (!isUnMount.current) {
      formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), state);
      setFormState(formStateRef.current);
    }
  }, []);
  const updateIsValidating = () => readFormStateRef.current.isValidating && updateFormState({
    isValidating: true
  });
  const shouldRenderBaseOnError = react.useCallback((name, error2, shouldRender = false, state = {}, isValid) => {
    let shouldReRender = shouldRender || isErrorStateChanged({
      errors: formStateRef.current.errors,
      error: error2,
      name,
      validFields: validFieldsRef.current,
      fieldsWithValidation: fieldsWithValidationRef.current
    });
    const previousError = get2(formStateRef.current.errors, name);
    if (error2) {
      unset(validFieldsRef.current, name);
      shouldReRender = shouldReRender || !previousError || !deepEqual(previousError, error2, true);
      set(formStateRef.current.errors, name, error2);
    } else {
      if (get2(fieldsWithValidationRef.current, name) || resolverRef.current) {
        set(validFieldsRef.current, name, true);
        shouldReRender = shouldReRender || previousError;
      }
      unset(formStateRef.current.errors, name);
    }
    if (shouldReRender && !isNullOrUndefined(shouldRender) || !isEmptyObject(state) || readFormStateRef.current.isValidating) {
      updateFormState(Object.assign(Object.assign(Object.assign({}, state), resolverRef.current ? {isValid: !!isValid} : {}), {isValidating: false}));
    }
  }, []);
  const setFieldValue = react.useCallback((name, rawValue) => {
    const {ref, options} = fieldsRef.current[name];
    const value = isWeb && isHTMLElement2(ref) && isNullOrUndefined(rawValue) ? "" : rawValue;
    if (isRadioInput(ref)) {
      (options || []).forEach(({ref: radioRef}) => radioRef.checked = radioRef.value === value);
    } else if (isFileInput(ref) && !isString2(value)) {
      ref.files = value;
    } else if (isMultipleSelect(ref)) {
      [...ref.options].forEach((selectRef) => selectRef.selected = value.includes(selectRef.value));
    } else if (isCheckBoxInput(ref) && options) {
      options.length > 1 ? options.forEach(({ref: checkboxRef}) => checkboxRef.checked = Array.isArray(value) ? !!value.find((data) => data === checkboxRef.value) : value === checkboxRef.value) : options[0].ref.checked = !!value;
    } else {
      ref.value = value;
    }
  }, []);
  const isFormDirty = react.useCallback((name, data) => {
    if (readFormStateRef.current.isDirty) {
      const formValues = getValues();
      name && data && set(formValues, name, data);
      return !deepEqual(formValues, defaultValuesRef.current);
    }
    return false;
  }, []);
  const updateAndGetDirtyState = react.useCallback((name, shouldRender = true) => {
    if (readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) {
      const isFieldDirty = !deepEqual(get2(defaultValuesRef.current, name), getFieldValue(fieldsRef, name, shallowFieldsStateRef));
      const isDirtyFieldExist = get2(formStateRef.current.dirtyFields, name);
      const previousIsDirty = formStateRef.current.isDirty;
      isFieldDirty ? set(formStateRef.current.dirtyFields, name, true) : unset(formStateRef.current.dirtyFields, name);
      const state = {
        isDirty: isFormDirty(),
        dirtyFields: formStateRef.current.dirtyFields
      };
      const isChanged = readFormStateRef.current.isDirty && previousIsDirty !== state.isDirty || readFormStateRef.current.dirtyFields && isDirtyFieldExist !== get2(formStateRef.current.dirtyFields, name);
      isChanged && shouldRender && updateFormState(state);
      return isChanged ? state : {};
    }
    return {};
  }, []);
  const executeValidation = react.useCallback(async (name, skipReRender) => {
    const error2 = (await validateField(fieldsRef, isValidateAllFieldCriteria, fieldsRef.current[name], shallowFieldsStateRef))[name];
    shouldRenderBaseOnError(name, error2, skipReRender);
    return isUndefined2(error2);
  }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);
  const executeSchemaOrResolverValidation = react.useCallback(async (names) => {
    const {errors} = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);
    const previousFormIsValid = formStateRef.current.isValid;
    if (Array.isArray(names)) {
      const isInputsValid = names.map((name) => {
        const error2 = get2(errors, name);
        error2 ? set(formStateRef.current.errors, name, error2) : unset(formStateRef.current.errors, name);
        return !error2;
      }).every(Boolean);
      updateFormState({
        isValid: isEmptyObject(errors),
        isValidating: false
      });
      return isInputsValid;
    } else {
      const error2 = get2(errors, names);
      shouldRenderBaseOnError(names, error2, previousFormIsValid !== isEmptyObject(errors), {}, isEmptyObject(errors));
      return !error2;
    }
  }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);
  const trigger = react.useCallback(async (name) => {
    const fields = name || Object.keys(fieldsRef.current);
    updateIsValidating();
    if (resolverRef.current) {
      return executeSchemaOrResolverValidation(fields);
    }
    if (Array.isArray(fields)) {
      !name && (formStateRef.current.errors = {});
      const result = await Promise.all(fields.map(async (data) => await executeValidation(data, null)));
      updateFormState({
        isValidating: false
      });
      return result.every(Boolean);
    }
    return await executeValidation(fields);
  }, [executeSchemaOrResolverValidation, executeValidation]);
  const setInternalValues = react.useCallback((name, value, {shouldDirty, shouldValidate}) => {
    const data = {};
    set(data, name, value);
    for (const fieldName of getPath2(name, value)) {
      if (fieldsRef.current[fieldName]) {
        setFieldValue(fieldName, get2(data, fieldName));
        shouldDirty && updateAndGetDirtyState(fieldName);
        shouldValidate && trigger(fieldName);
      }
    }
  }, [trigger, setFieldValue, updateAndGetDirtyState]);
  const setInternalValue = react.useCallback((name, value, config2) => {
    !shouldUnregister && !isPrimitive(value) && set(shallowFieldsStateRef.current, name, Array.isArray(value) ? [...value] : Object.assign({}, value));
    if (fieldsRef.current[name]) {
      setFieldValue(name, value);
      config2.shouldDirty && updateAndGetDirtyState(name);
      config2.shouldValidate && trigger(name);
    } else if (!isPrimitive(value)) {
      setInternalValues(name, value, config2);
      if (fieldArrayNamesRef.current.has(name)) {
        const parentName = getFieldArrayParentName(name) || name;
        set(fieldArrayDefaultValuesRef.current, name, value);
        resetFieldArrayFunctionRef.current[parentName]({
          [parentName]: get2(fieldArrayDefaultValuesRef.current, parentName)
        });
        if ((readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) && config2.shouldDirty) {
          set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get2(defaultValuesRef.current, name, []), get2(formStateRef.current.dirtyFields, name, [])));
          updateFormState({
            isDirty: !deepEqual(Object.assign(Object.assign({}, getValues()), {[name]: value}), defaultValuesRef.current)
          });
        }
      }
    }
    !shouldUnregister && set(shallowFieldsStateRef.current, name, value);
  }, [updateAndGetDirtyState, setFieldValue, setInternalValues]);
  const isFieldWatched = (name) => isWatchAllRef.current || watchFieldsRef.current.has(name) || watchFieldsRef.current.has((name.match(/\w+/) || [])[0]);
  const renderWatchedInputs = (name) => {
    let found = true;
    if (!isEmptyObject(useWatchFieldsRef.current)) {
      for (const key in useWatchFieldsRef.current) {
        if (!name || !useWatchFieldsRef.current[key].size || useWatchFieldsRef.current[key].has(name) || useWatchFieldsRef.current[key].has(getFieldArrayParentName(name))) {
          useWatchRenderFunctionsRef.current[key]();
          found = false;
        }
      }
    }
    return found;
  };
  function setValue(name, value, config2) {
    setInternalValue(name, value, config2 || {});
    isFieldWatched(name) && updateFormState();
    renderWatchedInputs(name);
  }
  handleChangeRef.current = handleChangeRef.current ? handleChangeRef.current : async ({type, target}) => {
    let name = target.name;
    const field = fieldsRef.current[name];
    let error2;
    let isValid;
    if (field) {
      const isBlurEvent = type === EVENTS.BLUR;
      const shouldSkipValidation = skipValidation(Object.assign({
        isBlurEvent,
        isReValidateOnChange,
        isReValidateOnBlur,
        isTouched: !!get2(formStateRef.current.touched, name),
        isSubmitted: formStateRef.current.isSubmitted
      }, modeRef.current));
      let state = updateAndGetDirtyState(name, false);
      let shouldRender = !isEmptyObject(state) || !isBlurEvent && isFieldWatched(name);
      if (isBlurEvent && !get2(formStateRef.current.touched, name) && readFormStateRef.current.touched) {
        set(formStateRef.current.touched, name, true);
        state = Object.assign(Object.assign({}, state), {touched: formStateRef.current.touched});
      }
      if (!shouldUnregister && isCheckBoxInput(target)) {
        set(shallowFieldsStateRef.current, name, getFieldValue(fieldsRef, name));
      }
      if (shouldSkipValidation) {
        !isBlurEvent && renderWatchedInputs(name);
        return (!isEmptyObject(state) || shouldRender && isEmptyObject(state)) && updateFormState(state);
      }
      updateIsValidating();
      if (resolverRef.current) {
        const {errors} = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);
        const previousFormIsValid = formStateRef.current.isValid;
        error2 = get2(errors, name);
        if (isCheckBoxInput(target) && !error2 && resolverRef.current) {
          const parentNodeName = getFieldArrayParentName(name);
          const currentError = get2(errors, parentNodeName, {});
          currentError.type && currentError.message && (error2 = currentError);
          if (parentNodeName && (currentError || get2(formStateRef.current.errors, parentNodeName))) {
            name = parentNodeName;
          }
        }
        isValid = isEmptyObject(errors);
        previousFormIsValid !== isValid && (shouldRender = true);
      } else {
        error2 = (await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef))[name];
      }
      !isBlurEvent && renderWatchedInputs(name);
      shouldRenderBaseOnError(name, error2, shouldRender, state, isValid);
    }
  };
  function setFieldArrayDefaultValues(data) {
    if (!shouldUnregister) {
      let copy2 = cloneObject(data);
      for (const value of fieldArrayNamesRef.current) {
        if (isKey(value) && !copy2[value]) {
          copy2 = Object.assign(Object.assign({}, copy2), {[value]: []});
        }
      }
      return copy2;
    }
    return data;
  }
  function getValues(payload) {
    if (isString2(payload)) {
      return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);
    }
    if (Array.isArray(payload)) {
      const data = {};
      for (const name of payload) {
        set(data, name, getFieldValue(fieldsRef, name, shallowFieldsStateRef));
      }
      return data;
    }
    return setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister));
  }
  const validateResolver = react.useCallback(async (values2 = {}) => {
    const newDefaultValues = isEmptyObject(fieldsRef.current) ? defaultValuesRef.current : {};
    const {errors} = await resolverRef.current(Object.assign(Object.assign(Object.assign({}, newDefaultValues), getValues()), values2), contextRef.current, isValidateAllFieldCriteria) || {};
    const isValid = isEmptyObject(errors);
    formStateRef.current.isValid !== isValid && updateFormState({
      isValid
    });
  }, [isValidateAllFieldCriteria]);
  const removeFieldEventListener = react.useCallback((field, forceDelete) => {
    findRemovedFieldAndRemoveListener(fieldsRef, handleChangeRef.current, field, shallowFieldsStateRef, shouldUnregister, forceDelete);
    if (shouldUnregister) {
      unset(validFieldsRef.current, field.ref.name);
      unset(fieldsWithValidationRef.current, field.ref.name);
    }
  }, [shouldUnregister]);
  const updateWatchedValue = react.useCallback((name) => {
    if (isWatchAllRef.current) {
      updateFormState();
    } else {
      for (const watchField of watchFieldsRef.current) {
        if (watchField.startsWith(name)) {
          updateFormState();
          break;
        }
      }
      renderWatchedInputs(name);
    }
  }, []);
  const removeFieldEventListenerAndRef = react.useCallback((field, forceDelete) => {
    if (field) {
      removeFieldEventListener(field, forceDelete);
      if (shouldUnregister && !compact(field.options || []).length) {
        unset(formStateRef.current.errors, field.ref.name);
        set(formStateRef.current.dirtyFields, field.ref.name, true);
        updateFormState({
          isDirty: isFormDirty()
        });
        readFormStateRef.current.isValid && resolverRef.current && validateResolver();
        updateWatchedValue(field.ref.name);
      }
    }
  }, [validateResolver, removeFieldEventListener]);
  function clearErrors(name) {
    name && (Array.isArray(name) ? name : [name]).forEach((inputName) => fieldsRef.current[inputName] && isKey(inputName) ? delete formStateRef.current.errors[inputName] : unset(formStateRef.current.errors, inputName));
    updateFormState({
      errors: name ? formStateRef.current.errors : {}
    });
  }
  function setError(name, error2) {
    const ref = (fieldsRef.current[name] || {}).ref;
    set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error2), {ref}));
    updateFormState({
      isValid: false
    });
    error2.shouldFocus && ref && ref.focus && ref.focus();
  }
  const watchInternal = react.useCallback((fieldNames, defaultValue, watchId) => {
    const watchFields = watchId ? useWatchFieldsRef.current[watchId] : watchFieldsRef.current;
    let fieldValues = getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister, false, fieldNames);
    if (isString2(fieldNames)) {
      const parentNodeName = getFieldArrayParentName(fieldNames) || fieldNames;
      if (fieldArrayNamesRef.current.has(parentNodeName)) {
        fieldValues = Object.assign(Object.assign({}, fieldArrayValuesRef.current), fieldValues);
      }
      return assignWatchFields(fieldValues, fieldNames, watchFields, isUndefined2(get2(defaultValuesRef.current, fieldNames)) ? defaultValue : get2(defaultValuesRef.current, fieldNames), true);
    }
    const combinedDefaultValues = isUndefined2(defaultValue) ? defaultValuesRef.current : defaultValue;
    if (Array.isArray(fieldNames)) {
      return fieldNames.reduce((previous, name) => Object.assign(Object.assign({}, previous), {[name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues)}), {});
    }
    isWatchAllRef.current = isUndefined2(watchId);
    return transformToNestObject(!isEmptyObject(fieldValues) && fieldValues || combinedDefaultValues);
  }, []);
  function watch(fieldNames, defaultValue) {
    return watchInternal(fieldNames, defaultValue);
  }
  function unregister(name) {
    for (const fieldName of Array.isArray(name) ? name : [name]) {
      removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true);
    }
  }
  function registerFieldRef(ref, options = {}) {
    const {name, type, value} = ref;
    const fieldRefAndValidationOptions = Object.assign({ref}, options);
    const fields = fieldsRef.current;
    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);
    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);
    const compareRef = (currentRef) => isWeb && (!isHTMLElement2(ref) || currentRef === ref);
    let field = fields[name];
    let isEmptyDefaultValue = true;
    let defaultValue;
    if (field && (isRadioOrCheckbox ? Array.isArray(field.options) && compact(field.options).find((option) => {
      return value === option.ref.value && compareRef(option.ref);
    }) : compareRef(field.ref))) {
      fields[name] = Object.assign(Object.assign({}, field), options);
      return;
    }
    if (type) {
      field = isRadioOrCheckbox ? Object.assign({options: [
        ...compact(field && field.options || []),
        {
          ref
        }
      ], ref: {type, name}}, options) : Object.assign({}, fieldRefAndValidationOptions);
    } else {
      field = fieldRefAndValidationOptions;
    }
    fields[name] = field;
    const isEmptyUnmountFields = isUndefined2(get2(shallowFieldsStateRef.current, name));
    if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {
      defaultValue = get2(isEmptyUnmountFields ? defaultValuesRef.current : shallowFieldsStateRef.current, name);
      isEmptyDefaultValue = isUndefined2(defaultValue);
      if (!isEmptyDefaultValue && !isFieldArray) {
        setFieldValue(name, defaultValue);
      }
    }
    if (!isEmptyObject(options)) {
      set(fieldsWithValidationRef.current, name, true);
      if (!isOnSubmit && readFormStateRef.current.isValid) {
        validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef).then((error2) => {
          const previousFormIsValid = formStateRef.current.isValid;
          isEmptyObject(error2) ? set(validFieldsRef.current, name, true) : unset(validFieldsRef.current, name);
          previousFormIsValid !== isEmptyObject(error2) && updateFormState();
        });
      }
    }
    if (shouldUnregister && !(isFieldArray && isEmptyDefaultValue)) {
      !isFieldArray && unset(formStateRef.current.dirtyFields, name);
    }
    if (type) {
      attachEventListeners(isRadioOrCheckbox && field.options ? field.options[field.options.length - 1] : field, isRadioOrCheckbox || isSelectInput(ref), handleChangeRef.current);
    }
  }
  function register(refOrRegisterOptions, options) {
    if (!isWindowUndefined) {
      if (isString2(refOrRegisterOptions)) {
        registerFieldRef({name: refOrRegisterOptions}, options);
      } else if (isObject2(refOrRegisterOptions) && "name" in refOrRegisterOptions) {
        registerFieldRef(refOrRegisterOptions, options);
      } else {
        return (ref) => ref && registerFieldRef(ref, refOrRegisterOptions);
      }
    }
  }
  const handleSubmit = react.useCallback((onValid, onInvalid) => async (e3) => {
    if (e3 && e3.preventDefault) {
      e3.preventDefault();
      e3.persist();
    }
    let fieldErrors = {};
    let fieldValues = setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister, true));
    readFormStateRef.current.isSubmitting && updateFormState({
      isSubmitting: true
    });
    try {
      if (resolverRef.current) {
        const {errors, values: values2} = await resolverRef.current(fieldValues, contextRef.current, isValidateAllFieldCriteria);
        formStateRef.current.errors = fieldErrors = errors;
        fieldValues = values2;
      } else {
        for (const field of Object.values(fieldsRef.current)) {
          if (field) {
            const {name} = field.ref;
            const fieldError = await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef);
            if (fieldError[name]) {
              set(fieldErrors, name, fieldError[name]);
              unset(validFieldsRef.current, name);
            } else if (get2(fieldsWithValidationRef.current, name)) {
              unset(formStateRef.current.errors, name);
              set(validFieldsRef.current, name, true);
            }
          }
        }
      }
      if (isEmptyObject(fieldErrors) && Object.keys(formStateRef.current.errors).every((name) => name in fieldsRef.current)) {
        updateFormState({
          errors: {},
          isSubmitting: true
        });
        await onValid(fieldValues, e3);
      } else {
        formStateRef.current.errors = Object.assign(Object.assign({}, formStateRef.current.errors), fieldErrors);
        onInvalid && await onInvalid(formStateRef.current.errors, e3);
        shouldFocusError && focusOnErrorField(fieldsRef.current, formStateRef.current.errors);
      }
    } finally {
      formStateRef.current.isSubmitting = false;
      updateFormState({
        isSubmitted: true,
        isSubmitting: false,
        isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),
        submitCount: formStateRef.current.submitCount + 1
      });
    }
  }, [shouldFocusError, isValidateAllFieldCriteria]);
  const resetRefs = ({errors, isDirty, isSubmitted, touched, isValid, submitCount, dirtyFields}) => {
    if (!isValid) {
      validFieldsRef.current = {};
      fieldsWithValidationRef.current = {};
    }
    fieldArrayDefaultValuesRef.current = {};
    watchFieldsRef.current = new Set();
    isWatchAllRef.current = false;
    updateFormState({
      submitCount: submitCount ? formStateRef.current.submitCount : 0,
      isDirty: isDirty ? formStateRef.current.isDirty : false,
      isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,
      isValid: isValid ? formStateRef.current.isValid : false,
      dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},
      touched: touched ? formStateRef.current.touched : {},
      errors: errors ? formStateRef.current.errors : {},
      isSubmitting: false,
      isSubmitSuccessful: false
    });
  };
  const reset = (values2, omitResetState = {}) => {
    if (isWeb) {
      for (const field of Object.values(fieldsRef.current)) {
        if (field) {
          const {ref, options} = field;
          const inputRef = isRadioOrCheckboxFunction(ref) && Array.isArray(options) ? options[0].ref : ref;
          if (isHTMLElement2(inputRef)) {
            try {
              inputRef.closest("form").reset();
              break;
            } catch (_a) {
            }
          }
        }
      }
    }
    fieldsRef.current = {};
    defaultValuesRef.current = Object.assign({}, values2 || defaultValuesRef.current);
    values2 && renderWatchedInputs("");
    Object.values(resetFieldArrayFunctionRef.current).forEach((resetFieldArray) => isFunction2(resetFieldArray) && resetFieldArray());
    shallowFieldsStateRef.current = shouldUnregister ? {} : cloneObject(values2 || defaultValuesRef.current);
    resetRefs(omitResetState);
  };
  react.useEffect(() => {
    resolver && readFormStateRef.current.isValid && validateResolver();
    observerRef.current = observerRef.current || !isWeb ? observerRef.current : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);
  }, [removeFieldEventListenerAndRef, defaultValuesRef.current]);
  react.useEffect(() => () => {
    observerRef.current && observerRef.current.disconnect();
    isUnMount.current = true;
    Object.values(fieldsRef.current).forEach((field) => removeFieldEventListenerAndRef(field, true));
  }, []);
  if (!resolver && readFormStateRef.current.isValid) {
    formState.isValid = deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) && isEmptyObject(formStateRef.current.errors);
  }
  const commonProps = {
    trigger,
    setValue: react.useCallback(setValue, [setInternalValue, trigger]),
    getValues: react.useCallback(getValues, []),
    register: react.useCallback(register, [defaultValuesRef.current]),
    unregister: react.useCallback(unregister, []),
    formState: isProxyEnabled ? new Proxy(formState, {
      get: (obj, prop) => {
        if (prop in obj) {
          readFormStateRef.current[prop] = true;
          return obj[prop];
        }
        return void 0;
      }
    }) : formState
  };
  const control = react.useMemo(() => Object.assign({
    isFormDirty,
    updateWatchedValue,
    shouldUnregister,
    updateFormState,
    removeFieldEventListener,
    watchInternal,
    mode: modeRef.current,
    reValidateMode: {
      isReValidateOnBlur,
      isReValidateOnChange
    },
    validateResolver: resolver ? validateResolver : void 0,
    fieldsRef,
    resetFieldArrayFunctionRef,
    useWatchFieldsRef,
    useWatchRenderFunctionsRef,
    fieldArrayDefaultValuesRef,
    validFieldsRef,
    fieldsWithValidationRef,
    fieldArrayNamesRef,
    readFormStateRef,
    formStateRef,
    defaultValuesRef,
    shallowFieldsStateRef,
    fieldArrayValuesRef
  }, commonProps), [
    defaultValuesRef.current,
    updateWatchedValue,
    shouldUnregister,
    removeFieldEventListener,
    watchInternal
  ]);
  return Object.assign({
    watch,
    control,
    handleSubmit,
    reset: react.useCallback(reset, []),
    clearErrors: react.useCallback(clearErrors, []),
    setError: react.useCallback(setError, []),
    errors: formState.errors
  }, commonProps);
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __rest2(s2, e3) {
  var t4 = {};
  for (var p3 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p3) && e3.indexOf(p3) < 0)
      t4[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s2); i3 < p3.length; i3++) {
      if (e3.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i3]))
        t4[p3[i3]] = s2[p3[i3]];
    }
  return t4;
}
var FormContext = react.createContext(null);
FormContext.displayName = "RHFContext";
var useFormContext = () => react.useContext(FormContext);
var FormProvider = (_a) => {
  var {children: children2} = _a, props = __rest2(_a, ["children"]);
  return react.createElement(FormContext.Provider, {value: Object.assign({}, props)}, children2);
};
var generateId = () => {
  const d3 = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1e3;
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c4) => {
    const r4 = (Math.random() * 16 + d3) % 16 | 0;
    return (c4 == "x" ? r4 : r4 & 3 | 8).toString(16);
  });
};
function removeAtIndexes(data, indexes) {
  let i3 = 0;
  const temp = [...data];
  for (const index3 of indexes) {
    temp.splice(index3 - i3, 1);
    i3++;
  }
  return compact(temp).length ? temp : [];
}
var removeArrayAt = (data, index3) => isUndefined2(index3) ? [] : removeAtIndexes(data, (Array.isArray(index3) ? index3 : [index3]).sort((a2, b3) => a2 - b3));
var moveArrayAt = (data, from, to) => {
  if (Array.isArray(data)) {
    if (isUndefined2(data[to])) {
      data[to] = void 0;
    }
    data.splice(to, 0, data.splice(from, 1)[0]);
    return data;
  }
  return [];
};
var swapArrayAt = (data, indexA, indexB) => {
  const temp = [data[indexB], data[indexA]];
  data[indexA] = temp[0];
  data[indexB] = temp[1];
};
function prepend(data, value) {
  return [...Array.isArray(value) ? value : [value || void 0], ...data];
}
function insert(data, index3, value) {
  return [
    ...data.slice(0, index3),
    ...Array.isArray(value) ? value : [value || void 0],
    ...data.slice(index3)
  ];
}
var fillEmptyArray = (value) => Array.isArray(value) ? Array(value.length).fill(void 0) : void 0;
var fillBooleanArray = (value) => (Array.isArray(value) ? value : [value]).map((data) => {
  if (isObject2(data)) {
    const object = {};
    for (const key in data) {
      object[key] = true;
    }
    return object;
  }
  return true;
});
var mapIds = (values2 = [], keyName, skipWarn) => {
  return values2.map((value) => Object.assign({[keyName]: value[keyName] || generateId()}, value));
};
var useFieldArray = ({control, name, keyName = "id"}) => {
  const methods = useFormContext();
  const focusIndexRef = react.useRef(-1);
  const isUnMount = react.useRef(false);
  const {isFormDirty, updateWatchedValue, resetFieldArrayFunctionRef, fieldArrayNamesRef, fieldsRef, defaultValuesRef, removeFieldEventListener, formStateRef, shallowFieldsStateRef, updateFormState, readFormStateRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValuesRef, validateResolver, getValues, shouldUnregister, fieldArrayValuesRef} = control || methods.control;
  const getDefaultValues = (values2) => get2(shouldUnregister ? values2 : shallowFieldsStateRef.current, name, []);
  const fieldArrayParentName = getFieldArrayParentName(name);
  const memoizedDefaultValues = react.useRef([
    ...get2(fieldArrayDefaultValuesRef.current, fieldArrayParentName) ? getDefaultValues(fieldArrayDefaultValuesRef.current) : getDefaultValues(defaultValuesRef.current)
  ]);
  const [fields, setFields] = react.useState(mapIds(memoizedDefaultValues.current, keyName));
  set(fieldArrayValuesRef.current, name, compact(fields));
  const omitKey = (fields2) => fields2.map((_a = {}) => {
    var _b = keyName, omitted = _a[_b], rest = __rest2(_a, [typeof _b === "symbol" ? _b : _b + ""]);
    return rest;
  });
  fieldArrayNamesRef.current.add(name);
  const getFieldArrayValue = react.useCallback(() => get2(fieldArrayValuesRef.current, name, []), [name]);
  const getCurrentFieldsValues = () => mapIds(get2(getValues(), name, getFieldArrayValue()).map((item, index3) => Object.assign(Object.assign({}, getFieldArrayValue()[index3]), item)), keyName);
  fieldArrayNamesRef.current.add(name);
  if (fieldArrayParentName && !get2(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {
    set(fieldArrayDefaultValuesRef.current, fieldArrayParentName, cloneObject(get2(defaultValuesRef.current, fieldArrayParentName)));
  }
  const setFieldAndValidState = (fieldsValues) => {
    setFields(fieldsValues);
    set(fieldArrayValuesRef.current, name, fieldsValues);
    if (readFormStateRef.current.isValid && validateResolver) {
      const values2 = getValues();
      set(values2, name, fieldsValues);
      validateResolver(values2);
    }
  };
  const resetFields = () => {
    for (const key in fieldsRef.current) {
      if (isMatchFieldArrayName(key, name)) {
        removeFieldEventListener(fieldsRef.current[key], true);
        delete fieldsRef.current[key];
      }
    }
  };
  const cleanup2 = (ref) => !compact(get2(ref, name, [])).length && unset(ref, name);
  const updateDirtyFieldsWithDefaultValues = (updatedFieldArrayValues) => {
    if (updatedFieldArrayValues) {
      set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get2(defaultValuesRef.current, name, []), get2(formStateRef.current.dirtyFields, name, [])));
    }
  };
  const batchStateUpdate = (method, args, updatedFieldValues, updatedFormValues = [], shouldSet = true, shouldUpdateValid = false) => {
    if (get2(shallowFieldsStateRef.current, name)) {
      const output2 = method(get2(shallowFieldsStateRef.current, name), args.argA, args.argB);
      shouldSet && set(shallowFieldsStateRef.current, name, output2);
    }
    if (get2(fieldArrayDefaultValuesRef.current, name)) {
      const output2 = method(get2(fieldArrayDefaultValuesRef.current, name), args.argA, args.argB);
      shouldSet && set(fieldArrayDefaultValuesRef.current, name, output2);
    }
    if (Array.isArray(get2(formStateRef.current.errors, name))) {
      const output2 = method(get2(formStateRef.current.errors, name), args.argA, args.argB);
      shouldSet && set(formStateRef.current.errors, name, output2);
      cleanup2(formStateRef.current.errors);
    }
    if (readFormStateRef.current.touched && get2(formStateRef.current.touched, name)) {
      const output2 = method(get2(formStateRef.current.touched, name), args.argA, args.argB);
      shouldSet && set(formStateRef.current.touched, name, output2);
      cleanup2(formStateRef.current.touched);
    }
    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {
      set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFormValues), get2(defaultValuesRef.current, name, []), get2(formStateRef.current.dirtyFields, name, [])));
      updateDirtyFieldsWithDefaultValues(updatedFieldValues);
      cleanup2(formStateRef.current.dirtyFields);
    }
    if (shouldUpdateValid && readFormStateRef.current.isValid && !validateResolver) {
      set(validFieldsRef.current, name, method(get2(validFieldsRef.current, name, []), args.argA));
      cleanup2(validFieldsRef.current);
      set(fieldsWithValidationRef.current, name, method(get2(fieldsWithValidationRef.current, name, []), args.argA));
      cleanup2(fieldsWithValidationRef.current);
    }
    if (!isUnMount.current && readFormStateRef.current.isDirty) {
      updateFormState({
        isDirty: isFormDirty(name, omitKey(updatedFormValues))
      });
    }
  };
  const append = (value, shouldFocus = true) => {
    const appendValue = Array.isArray(value) ? value : [value];
    const updateFormValues = [
      ...getCurrentFieldsValues(),
      ...mapIds(appendValue, keyName)
    ];
    setFieldAndValidState(updateFormValues);
    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {
      updateDirtyFieldsWithDefaultValues(updateFormValues);
      updateFormState({
        isDirty: true,
        dirtyFields: formStateRef.current.dirtyFields
      });
    }
    !shouldUnregister && set(shallowFieldsStateRef.current, name, [
      ...get2(shallowFieldsStateRef.current, name) || [],
      ...cloneObject(appendValue)
    ]);
    focusIndexRef.current = shouldFocus ? get2(fieldArrayValuesRef.current, name).length - 1 : -1;
  };
  const prepend$1 = (value, shouldFocus = true) => {
    const emptyArray = fillEmptyArray(value);
    const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), mapIds(Array.isArray(value) ? value : [value], keyName));
    setFieldAndValidState(updatedFieldArrayValues);
    resetFields();
    batchStateUpdate(prepend, {
      argA: emptyArray,
      argC: fillBooleanArray(value)
    }, updatedFieldArrayValues);
    focusIndexRef.current = shouldFocus ? 0 : -1;
  };
  const remove3 = (index3) => {
    const fieldValues = getCurrentFieldsValues();
    const updatedFieldValues = removeArrayAt(fieldValues, index3);
    setFieldAndValidState(updatedFieldValues);
    resetFields();
    batchStateUpdate(removeArrayAt, {
      argA: index3,
      argC: index3
    }, updatedFieldValues, removeArrayAt(fieldValues, index3), true, true);
  };
  const insert$1 = (index3, value, shouldFocus = true) => {
    const emptyArray = fillEmptyArray(value);
    const fieldValues = getCurrentFieldsValues();
    const updatedFieldArrayValues = insert(fieldValues, index3, mapIds(Array.isArray(value) ? value : [value], keyName));
    setFieldAndValidState(updatedFieldArrayValues);
    resetFields();
    batchStateUpdate(insert, {
      argA: index3,
      argB: emptyArray,
      argC: index3,
      argD: fillBooleanArray(value)
    }, updatedFieldArrayValues, insert(fieldValues, index3));
    focusIndexRef.current = shouldFocus ? index3 : -1;
  };
  const swap = (indexA, indexB) => {
    const fieldValues = getCurrentFieldsValues();
    swapArrayAt(fieldValues, indexA, indexB);
    resetFields();
    setFieldAndValidState([...fieldValues]);
    batchStateUpdate(swapArrayAt, {
      argA: indexA,
      argB: indexB,
      argC: indexA,
      argD: indexB
    }, void 0, fieldValues, false);
  };
  const move = (from, to) => {
    const fieldValues = getCurrentFieldsValues();
    moveArrayAt(fieldValues, from, to);
    resetFields();
    setFieldAndValidState([...fieldValues]);
    batchStateUpdate(moveArrayAt, {
      argA: from,
      argB: to,
      argC: from,
      argD: to
    }, void 0, fieldValues, false);
  };
  react.useEffect(() => {
    const defaultValues = get2(fieldArrayDefaultValuesRef.current, name);
    if (defaultValues && fields.length < defaultValues.length) {
      set(fieldArrayDefaultValuesRef.current, name, defaultValues.slice(1));
    }
    updateWatchedValue(name);
    if (focusIndexRef.current > -1) {
      for (const key in fieldsRef.current) {
        const field = fieldsRef.current[key];
        if (key.startsWith(`${name}[${focusIndexRef.current}]`) && field.ref.focus) {
          field.ref.focus();
          break;
        }
      }
    }
    focusIndexRef.current = -1;
  }, [fields, name]);
  react.useEffect(() => {
    const resetFunctions = resetFieldArrayFunctionRef.current;
    const fieldArrayNames = fieldArrayNamesRef.current;
    if (!getFieldArrayParentName(name)) {
      resetFunctions[name] = (data) => {
        resetFields();
        !data && unset(fieldArrayDefaultValuesRef.current, name);
        unset(shallowFieldsStateRef.current, name);
        memoizedDefaultValues.current = get2(data || defaultValuesRef.current, name);
        if (!isUnMount.current) {
          setFields(mapIds(memoizedDefaultValues.current, keyName));
        }
      };
    }
    return () => {
      isUnMount.current = true;
      shouldUnregister && remove3();
      resetFields();
      delete resetFunctions[name];
      unset(fieldArrayValuesRef.current, name);
      fieldArrayNames.delete(name);
    };
  }, []);
  return {
    swap: react.useCallback(swap, [name]),
    move: react.useCallback(move, [name]),
    prepend: react.useCallback(prepend$1, [name]),
    append: react.useCallback(append, [name]),
    remove: react.useCallback(remove3, [name]),
    insert: react.useCallback(insert$1, [name]),
    fields: compact(fields)
  };
};
var getInputValue = (event) => isPrimitive(event) || !isObject2(event.target) || isObject2(event.target) && !event.type ? event : isUndefined2(event.target.value) ? event.target.checked : event.target.value;
function useController({name, rules, defaultValue, control, onFocus}) {
  const methods = useFormContext();
  const {defaultValuesRef, setValue, register, unregister, trigger, mode, reValidateMode: {isReValidateOnBlur, isReValidateOnChange}, formState, formStateRef: {current: {isSubmitted, touched, errors}}, updateFormState, readFormStateRef, fieldsRef, fieldArrayNamesRef, shallowFieldsStateRef} = control || methods.control;
  const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);
  const getInitialValue = () => !isUndefined2(get2(shallowFieldsStateRef.current, name)) && isNotFieldArray ? get2(shallowFieldsStateRef.current, name) : isUndefined2(defaultValue) ? get2(defaultValuesRef.current, name) : defaultValue;
  const [value, setInputStateValue] = react.useState(getInitialValue());
  const valueRef = react.useRef(value);
  const ref = react.useRef({
    focus: () => null
  });
  const onFocusRef = react.useRef(onFocus || (() => {
    if (isFunction2(ref.current.focus)) {
      ref.current.focus();
    }
  }));
  const shouldValidate = react.useCallback((isBlurEvent) => !skipValidation(Object.assign({
    isBlurEvent,
    isReValidateOnBlur,
    isReValidateOnChange,
    isSubmitted,
    isTouched: !!get2(touched, name)
  }, mode)), [
    isReValidateOnBlur,
    isReValidateOnChange,
    isSubmitted,
    touched,
    name,
    mode
  ]);
  const commonTask = react.useCallback(([event]) => {
    const data = getInputValue(event);
    setInputStateValue(data);
    valueRef.current = data;
    return data;
  }, []);
  const registerField = react.useCallback((shouldUpdateValue) => {
    if (fieldsRef.current[name]) {
      fieldsRef.current[name] = Object.assign({ref: fieldsRef.current[name].ref}, rules);
    } else {
      register(Object.defineProperties({
        name,
        focus: onFocusRef.current
      }, {
        value: {
          set(data) {
            setInputStateValue(data);
            valueRef.current = data;
          },
          get() {
            return valueRef.current;
          }
        }
      }), rules);
      shouldUpdateValue = isUndefined2(get2(defaultValuesRef.current, name));
    }
    shouldUpdateValue && isNotFieldArray && setInputStateValue(getInitialValue());
  }, [rules, name, register]);
  react.useEffect(() => () => unregister(name), [name]);
  react.useEffect(() => {
    registerField();
  }, [registerField]);
  react.useEffect(() => {
    !fieldsRef.current[name] && registerField(true);
  });
  const onBlur = react.useCallback(() => {
    if (readFormStateRef.current.touched && !get2(touched, name)) {
      set(touched, name, true);
      updateFormState({
        touched
      });
    }
    shouldValidate(true) && trigger(name);
  }, [name, updateFormState, shouldValidate, trigger, readFormStateRef]);
  const onChange = react.useCallback((...event) => setValue(name, commonTask(event), {
    shouldValidate: shouldValidate(),
    shouldDirty: true
  }), [setValue, name, shouldValidate]);
  return {
    field: {
      onChange,
      onBlur,
      name,
      value,
      ref
    },
    meta: Object.defineProperties({
      invalid: !!get2(errors, name)
    }, {
      isDirty: {
        get() {
          return !!get2(formState.dirtyFields, name);
        }
      },
      isTouched: {
        get() {
          return !!get2(formState.touched, name);
        }
      }
    })
  };
}
function useWatch({control, name, defaultValue}) {
  const methods = useFormContext();
  const {useWatchFieldsRef, useWatchRenderFunctionsRef, watchInternal, defaultValuesRef} = control || methods.control;
  const updateValue = react.useState()[1];
  const idRef = react.useRef();
  const defaultValueRef = react.useRef(defaultValue);
  react.useEffect(() => {
    const id3 = idRef.current = generateId();
    const watchFieldsHookRender = useWatchRenderFunctionsRef.current;
    const watchFieldsHook = useWatchFieldsRef.current;
    watchFieldsHook[id3] = new Set();
    watchFieldsHookRender[id3] = () => updateValue({});
    watchInternal(name, defaultValueRef.current, id3);
    return () => {
      delete watchFieldsHook[id3];
      delete watchFieldsHookRender[id3];
    };
  }, [
    name,
    useWatchRenderFunctionsRef,
    useWatchFieldsRef,
    watchInternal,
    defaultValueRef
  ]);
  return idRef.current ? watchInternal(name, defaultValueRef.current, idRef.current) : isUndefined2(defaultValue) ? isString2(name) ? get2(defaultValuesRef.current, name) : Array.isArray(name) ? name.reduce((previous, inputName) => Object.assign(Object.assign({}, previous), {[inputName]: get2(defaultValuesRef.current, inputName)}), {}) : defaultValuesRef.current : defaultValue;
}
var Controller = (props) => {
  const {rules, as, render: render4, defaultValue, control, onFocus} = props, rest = __rest2(props, ["rules", "as", "render", "defaultValue", "control", "onFocus"]);
  const {field, meta} = useController(props);
  const componentProps = Object.assign(Object.assign({}, rest), field);
  return as ? react.isValidElement(as) ? react.cloneElement(as, componentProps) : react.createElement(as, componentProps) : render4 ? render4(field, meta) : null;
};

// build/components/alert/AlertPanel.js
function AlertPanel({alerts, onCloseAlert}) {
  return /* @__PURE__ */ react.createElement(AlertGroup, {
    isToast: true
  }, alerts.map(({key, variant, message, description}) => /* @__PURE__ */ react.createElement(Alert, {
    key,
    isLiveRegion: true,
    variant: AlertVariant[variant],
    variantLabel: "",
    title: message,
    actionClose: /* @__PURE__ */ react.createElement(AlertActionCloseButton, {
      title: message,
      onClose: () => onCloseAlert(key)
    })
  }, description && /* @__PURE__ */ react.createElement("p", null, description))));
}

// build/components/alert/Alerts.js
var AlertContext2 = createContext(void 0);
var useAlerts = () => useRequiredContext(AlertContext2);
var AlertProvider = ({children: children2}) => {
  const {t: t4} = useTranslation();
  const [alerts, setAlerts] = useState([]);
  const createId = () => new Date().getTime();
  const hideAlert = (key) => {
    setAlerts((alerts2) => [...alerts2.filter((el) => el.key !== key)]);
  };
  const addAlert = (message, variant = AlertVariant.success, description) => {
    const key = createId();
    setTimeout(() => hideAlert(key), 8e3);
    setAlerts([{key, message, variant, description}, ...alerts]);
  };
  const addError = (message, error2) => {
    addAlert(t4(message, {
      error: "response" in error2 ? error2.response?.data?.errorMessage || error2.response?.data?.error : error2
    }), AlertVariant.danger);
  };
  return /* @__PURE__ */ react.createElement(AlertContext2.Provider, {
    value: {addAlert, addError}
  }, /* @__PURE__ */ react.createElement(AlertPanel, {
    alerts,
    onCloseAlert: hideAlert
  }), children2);
};

// build/context/access/Access.js
var AccessContext = createContext(void 0);
var useAccess = () => useRequiredContext(AccessContext);
var AccessContextProvider = ({children: children2}) => {
  const {whoAmI: whoAmI2} = useWhoAmI();
  const {realm: realm2} = useRealm();
  const [access, setAccess] = useState([]);
  useEffect(() => {
    if (whoAmI2.getRealmAccess()[realm2]) {
      setAccess(whoAmI2.getRealmAccess()[realm2]);
    }
  }, [whoAmI2, realm2]);
  const hasAccess = (...types2) => {
    return types2.every((type) => type === "anyone" || access.includes(type));
  };
  const hasSomeAccess = (...types2) => {
    return types2.some((type) => type === "anyone" || access.includes(type));
  };
  return /* @__PURE__ */ react.createElement(AccessContext.Provider, {
    value: {hasAccess, hasSomeAccess}
  }, children2);
};

// build/components/form-access/FormAccess.js
var FormAccess = ({
  children: children2,
  role,
  fineGrainedAccess = false,
  unWrap = false,
  ...rest
}) => {
  const {hasAccess} = useAccess();
  const recursiveCloneChildren = (children22, newProps) => {
    return Children.map(children22, (child) => {
      if (!isValidElement(child)) {
        return child;
      }
      if (child.props) {
        const element = child;
        if (child.type === Controller) {
          return cloneElement(child, {
            ...element.props,
            render: (props) => {
              const renderElement = element.props.render(props);
              return cloneElement(renderElement, {
                ...renderElement.props,
                ...newProps
              });
            }
          });
        }
        const children3 = recursiveCloneChildren(element.props.children, newProps);
        if (child.type === TextArea) {
          return cloneElement(child, {
            readOnly: newProps.isDisabled,
            children: children3
          });
        }
        return cloneElement(child, child.type === FormGroup || child.type === GridItem || child.type === Grid || child.type === ActionGroup || child.type === ClipboardCopy || child.type === Stack || child.type === StackItem ? {children: children3} : {...newProps, children: children3});
      }
      return child;
    });
  };
  const isDisabled = !hasAccess(role) && !fineGrainedAccess;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, !unWrap && /* @__PURE__ */ react.createElement(Form, {
    ...rest,
    className: "keycloak__form " + (rest.className || "")
  }, recursiveCloneChildren(children2, isDisabled ? {isDisabled} : {})), unWrap && recursiveCloneChildren(children2, isDisabled ? {isDisabled} : {}));
};

// build/components/json-file-upload/JsonFileUpload.js
var JsonFileUpload = ({
  id: id3,
  onChange,
  helpText = "common-help:helpFileUpload",
  unWrap = false,
  ...rest
}) => {
  const {t: t4} = useTranslation();
  const defaultUpload = {
    value: "",
    filename: "",
    isLoading: false,
    modal: false
  };
  const [fileUpload2, setFileUpload] = useState(defaultUpload);
  const removeDialog = () => setFileUpload({...fileUpload2, modal: false});
  const handleChange = (value, filename, event) => {
    if (event.nativeEvent instanceof MouseEvent && !(event.nativeEvent instanceof DragEvent)) {
      setFileUpload({...fileUpload2, modal: true});
    } else {
      setFileUpload({
        ...fileUpload2,
        value,
        filename
      });
      if (value) {
        let obj = {};
        try {
          obj = JSON.parse(value);
        } catch (error2) {
          console.warn("Invalid json, ignoring value using {}");
        }
        onChange(obj);
      }
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, fileUpload2.modal && /* @__PURE__ */ react.createElement(Modal, {
    variant: ModalVariant.small,
    title: t4("clearFile"),
    isOpen: true,
    onClose: removeDialog,
    actions: [
      /* @__PURE__ */ react.createElement(Button, {
        key: "confirm",
        variant: "primary",
        onClick: () => {
          setFileUpload(defaultUpload);
          onChange({});
        }
      }, t4("clear")),
      /* @__PURE__ */ react.createElement(Button, {
        key: "cancel",
        variant: "link",
        onClick: removeDialog
      }, t4("cancel"))
    ]
  }, t4("clearFileExplain")), unWrap && /* @__PURE__ */ react.createElement(FileUpload, {
    id: id3,
    ...rest,
    type: "text",
    value: fileUpload2.value,
    filename: fileUpload2.filename,
    onChange: handleChange,
    onReadStarted: () => setFileUpload({...fileUpload2, isLoading: true}),
    onReadFinished: () => setFileUpload({...fileUpload2, isLoading: false}),
    isLoading: fileUpload2.isLoading,
    dropzoneProps: {
      accept: ".json"
    }
  }), !unWrap && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("resourceFile"),
    fieldId: id3,
    helperText: t4(helpText)
  }, /* @__PURE__ */ react.createElement(FileUpload, {
    id: id3,
    ...rest,
    type: "text",
    value: fileUpload2.value,
    filename: fileUpload2.filename,
    onChange: handleChange,
    onReadStarted: () => setFileUpload({...fileUpload2, isLoading: true}),
    onReadFinished: () => setFileUpload({...fileUpload2, isLoading: false}),
    isLoading: fileUpload2.isLoading,
    dropzoneProps: {
      accept: ".json"
    }
  })));
};

// build/components/external-link/FormattedLink.js
var FormattedLink = ({
  title: title3,
  href,
  isInline,
  ...rest
}) => {
  return /* @__PURE__ */ react.createElement("a", {
    href,
    target: "_blank",
    rel: "noreferrer noopener",
    className: isInline ? "pf-m-link pf-m-inline" : "",
    ...rest
  }, title3 ? title3 : href, " ", href?.startsWith("http") && /* @__PURE__ */ react.createElement(ExternalLinkAltIcon, null));
};
var formattedLinkTableCell = () => (data) => {
  return data ? /* @__PURE__ */ react.createElement(FormattedLink, {
    href: data.toString()
  }) : void 0;
};

// build/components/view-header/ViewHeader.js
var ViewHeader = ({
  actionsDropdownId,
  titleKey,
  badges,
  subKey,
  subKeyLinkProps,
  dropdownItems,
  lowerDropdownMenuTitle,
  lowerDropdownItems,
  isEnabled = true,
  onToggle,
  divider: divider2 = true,
  helpTextKey
}) => {
  const {t: t4} = useTranslation();
  const {enabled} = useHelp();
  const [isDropdownOpen, setDropdownOpen] = useState(false);
  const [isLowerDropdownOpen, setIsLowerDropdownOpen] = useState(false);
  const onDropdownToggle = () => {
    setDropdownOpen(!isDropdownOpen);
  };
  const onLowerDropdownToggle = () => {
    setIsLowerDropdownOpen(!isLowerDropdownOpen);
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(Level, {
    hasGutter: true
  }, /* @__PURE__ */ react.createElement(LevelItem, null, /* @__PURE__ */ react.createElement(Level, null, /* @__PURE__ */ react.createElement(LevelItem, null, /* @__PURE__ */ react.createElement(TextContent, {
    className: "pf-u-mr-sm"
  }, /* @__PURE__ */ react.createElement(Text, {
    component: "h1"
  }, t4(titleKey)))), badges && /* @__PURE__ */ react.createElement(LevelItem, null, badges.map((badge2, index3) => /* @__PURE__ */ react.createElement(Fragment, {
    key: index3
  }, !isValidElement(badge2.text) && /* @__PURE__ */ react.createElement(Fragment, {
    key: badge2.text
  }, /* @__PURE__ */ react.createElement(Badge, {
    "data-testid": badge2.id,
    isRead: badge2.readonly
  }, badge2.text), " "), isValidElement(badge2.text) && /* @__PURE__ */ react.createElement(react.Fragment, null, badge2.text), " "))))), /* @__PURE__ */ react.createElement(LevelItem, null, /* @__PURE__ */ react.createElement(Toolbar, {
    className: "pf-u-p-0"
  }, /* @__PURE__ */ react.createElement(ToolbarContent, null, onToggle && /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Switch, {
    id: `${titleKey}-switch`,
    label: t4("common:enabled"),
    labelOff: t4("common:disabled"),
    className: "pf-u-mr-lg",
    isChecked: isEnabled,
    onChange: (value) => {
      if (onToggle) {
        onToggle(value);
      }
    }
  }), helpTextKey && /* @__PURE__ */ react.createElement(HelpItem, {
    helpText: t4(helpTextKey),
    forLabel: t4("common:enabled"),
    forID: `${titleKey}-switch`
  })), dropdownItems && /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Dropdown, {
    position: DropdownPosition.right,
    toggle: /* @__PURE__ */ react.createElement(DropdownToggle, {
      id: actionsDropdownId,
      onToggle: onDropdownToggle
    }, t4("common:action")),
    isOpen: isDropdownOpen,
    dropdownItems,
    "data-testid": "action-dropdown"
  })))))), enabled && /* @__PURE__ */ react.createElement(TextContent, {
    id: "view-header-subkey"
  }, /* @__PURE__ */ react.createElement(Text, null, react.isValidElement(subKey) ? subKey : subKey ? t4(subKey) : "", subKeyLinkProps && /* @__PURE__ */ react.createElement(FormattedLink, {
    ...subKeyLinkProps,
    isInline: true,
    className: "pf-u-ml-md"
  }))), lowerDropdownItems && /* @__PURE__ */ react.createElement(Dropdown, {
    className: "keycloak__user-federation__dropdown",
    toggle: /* @__PURE__ */ react.createElement(DropdownToggle, {
      onToggle: () => onLowerDropdownToggle(),
      isPrimary: true,
      id: "ufToggleId"
    }, t4(lowerDropdownMenuTitle)),
    isOpen: isLowerDropdownOpen,
    dropdownItems: lowerDropdownItems
  })), divider2 && /* @__PURE__ */ react.createElement(Divider, {
    component: "div"
  }));
};

// build/realm/add/NewRealmForm.js
var NewRealmForm = () => {
  const {t: t4} = useTranslation("realm");
  const history = useHistory();
  const {refresh} = useWhoAmI();
  const {refresh: realmRefresh} = useRealm();
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const {register, handleSubmit, control, errors, setValue} = useForm({mode: "onChange"});
  const handleFileChange = (obj) => {
    const defaultRealm = {id: "", realm: "", enabled: true};
    Object.entries(obj || defaultRealm).map((entry) => setValue(entry[0], entry[1]));
  };
  const save = async (realm2) => {
    try {
      await adminClient.realms.create(realm2);
      addAlert(t4("saveRealmSuccess"), AlertVariant.success);
      refresh();
      await adminClient.keycloak?.updateToken(Number.MAX_VALUE);
      await realmRefresh();
      history.push(`/${realm2.realm}`);
    } catch (error2) {
      addError("realm:saveRealmError", error2);
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: "realm:createRealm",
    subKey: "realm:realmExplain"
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    onSubmit: handleSubmit(save),
    role: "manage-realm"
  }, /* @__PURE__ */ react.createElement(JsonFileUpload, {
    id: "kc-realm-filename",
    allowEditingUploadedText: true,
    onChange: handleFileChange
  }), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("realmName"),
    isRequired: true,
    fieldId: "kc-realm-name",
    validated: errors.realm ? "error" : "default",
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-realm-name",
    name: "realm",
    validated: errors.realm ? "error" : "default",
    ref: register({required: true})
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("enabled"),
    fieldId: "kc-realm-enabled-switch"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "enabled",
    defaultValue: true,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-realm-enabled-switch",
      name: "enabled",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value,
      onChange
    })
  })), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "primary",
    type: "submit"
  }, t4("common:create")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: () => history.goBack()
  }, t4("common:cancel"))))));
};

// build/realm/routes/AddRealm.js
var AddRealmRoute = {
  path: "/:realm/add-realm",
  component: NewRealmForm,
  breadcrumb: (t4) => t4("realm:createRealm"),
  access: "manage-realm"
};
var toAddRealm = (params) => ({
  pathname: generatePath(AddRealmRoute.path, params)
});

// build/components/realm-selector/RealmSelector.js
var RealmSelector = () => {
  const {realm: realm2, setRealm, realms: realms2} = useRealm();
  const {whoAmI: whoAmI2} = useWhoAmI();
  const [open2, setOpen] = useState(false);
  const [search, setSearch] = useState("");
  const history = useHistory();
  const {t: t4} = useTranslation("common");
  const recentUsed = new RecentUsed();
  const all2 = recentUsed.used.filter((r4) => r4 !== realm2).map((name) => {
    return {name, used: true};
  }).concat(realms2.filter((r4) => !recentUsed.used.includes(r4.realm)).map((r4) => {
    return {name: r4.realm, used: false};
  }));
  const filteredItems = useMemo(() => {
    if (search === "") {
      return void 0;
    }
    return all2.filter((r4) => r4.name.toLowerCase().includes(search.toLowerCase()));
  }, [search, all2]);
  const RealmText = ({value}) => /* @__PURE__ */ react.createElement(Split, {
    className: "keycloak__realm_selector__list-item-split"
  }, /* @__PURE__ */ react.createElement(SplitItem, {
    isFilled: true
  }, toUpperCase(value)), /* @__PURE__ */ react.createElement(SplitItem, null, value === realm2 && /* @__PURE__ */ react.createElement(CheckIcon, null)));
  const AddRealm = () => /* @__PURE__ */ react.createElement(Button, {
    "data-testid": "add-realm",
    component: "div",
    isBlock: true,
    onClick: () => {
      history.push(toAddRealm({realm: realm2}));
      setOpen(!open2);
    }
  }, t4("createRealm"));
  const selectRealm = (realm22) => {
    setRealm(realm22);
    setOpen(!open2);
    history.push(`/${realm22}/`);
  };
  const dropdownItems = realms2.map((r4) => /* @__PURE__ */ react.createElement(DropdownItem, {
    key: `realm-dropdown-item-${r4.realm}`,
    onClick: () => {
      selectRealm(r4.realm);
    }
  }, /* @__PURE__ */ react.createElement(RealmText, {
    value: r4.realm
  })));
  const addRealmComponent = /* @__PURE__ */ react.createElement(react.Fragment, {
    key: "Add Realm"
  }, whoAmI2.canCreateRealm() && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Divider, {
    key: "divider"
  }), /* @__PURE__ */ react.createElement(DropdownItem, {
    key: "add"
  }, /* @__PURE__ */ react.createElement(AddRealm, null))));
  return /* @__PURE__ */ react.createElement(react.Fragment, null, realms2.length > 5 && /* @__PURE__ */ react.createElement(ContextSelector, {
    "data-testid": "realmSelector",
    toggleText: toUpperCase(realm2),
    isOpen: open2,
    screenReaderLabel: toUpperCase(realm2),
    onToggle: () => setOpen(!open2),
    onSelect: (_23, r4) => {
      let element;
      if (Array.isArray(r4)) {
        element = r4[0];
      } else {
        element = r4;
      }
      const value = element.props.value;
      if (value) {
        selectRealm(value);
      }
    },
    searchInputValue: search,
    onSearchInputChange: (value) => setSearch(value),
    className: "keycloak__realm_selector__context_selector",
    footer: /* @__PURE__ */ react.createElement(ContextSelectorItem, {
      key: "add"
    }, /* @__PURE__ */ react.createElement(AddRealm, null))
  }, (filteredItems || all2).map((item) => /* @__PURE__ */ react.createElement(ContextSelectorItem, {
    key: item.name
  }, /* @__PURE__ */ react.createElement(RealmText, {
    value: item.name
  }), " ", item.used && /* @__PURE__ */ react.createElement(Label, null, t4("recent"))))), realms2.length <= 5 && /* @__PURE__ */ react.createElement(Dropdown, {
    id: "realm-select",
    "data-testid": "realmSelector",
    className: "keycloak__realm_selector__dropdown",
    isOpen: open2,
    toggle: /* @__PURE__ */ react.createElement(DropdownToggle, {
      "data-testid": "realmSelectorToggle",
      onToggle: () => setOpen(!open2),
      className: "keycloak__realm_selector_dropdown__toggle"
    }, toUpperCase(realm2)),
    dropdownItems: [...dropdownItems, addRealmComponent]
  }));
};

// build/_snowpack/pkg/common/_baseIsEqual-c84a3118.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear;
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq;
function assocIndexOf(array2, key) {
  var length = array2.length;
  while (length--) {
    if (eq_1(array2[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index3 = _assocIndexOf(data, key);
  if (index3 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index3 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index3, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete;
function listCacheGet(key) {
  var data = this.__data__, index3 = _assocIndexOf(data, key);
  return index3 < 0 ? void 0 : data[index3][1];
}
var _listCacheGet = listCacheGet;
function listCacheHas(key) {
  return _assocIndexOf(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas;
function listCacheSet(key, value) {
  var data = this.__data__, index3 = _assocIndexOf(data, key);
  if (index3 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index3][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet;
function ListCache(entries) {
  var index3 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index3 < length) {
    var entry = entries[index3];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = _listCacheClear;
ListCache.prototype["delete"] = _listCacheDelete;
ListCache.prototype.get = _listCacheGet;
ListCache.prototype.has = _listCacheHas;
ListCache.prototype.set = _listCacheSet;
var _ListCache = ListCache;
function stackClear() {
  this.__data__ = new _ListCache();
  this.size = 0;
}
var _stackClear = stackClear;
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete;
function stackGet(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet;
function stackHas(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas;
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = _freeGlobal || freeSelf || Function("return this")();
var _root = root;
var Symbol2 = _root.Symbol;
var _Symbol = Symbol2;
var objectProto = Object.prototype;
var hasOwnProperty2 = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = _Symbol ? _Symbol.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e3) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var _getRawTag = getRawTag;
var objectProto$1 = Object.prototype;
var nativeObjectToString$1 = objectProto$1.toString;
function objectToString(value) {
  return nativeObjectToString$1.call(value);
}
var _objectToString = objectToString;
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag$1 && symToStringTag$1 in Object(value) ? _getRawTag(value) : _objectToString(value);
}
var _baseGetTag = baseGetTag;
function isObject3(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject3;
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction3(value) {
  if (!isObject_1(value)) {
    return false;
  }
  var tag = _baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction3;
var coreJsData = _root["__core-js_shared__"];
var _coreJsData = coreJsData;
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked;
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e3) {
    }
    try {
      return func + "";
    } catch (e3) {
    }
  }
  return "";
}
var _toSource = toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype;
var objectProto$2 = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject_1(value) || _isMasked(value)) {
    return false;
  }
  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(_toSource(value));
}
var _baseIsNative = baseIsNative;
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue;
function getNative(object, key) {
  var value = _getValue(object, key);
  return _baseIsNative(value) ? value : void 0;
}
var _getNative = getNative;
var Map2 = _getNative(_root, "Map");
var _Map = Map2;
var nativeCreate = _getNative(Object, "create");
var _nativeCreate = nativeCreate;
function hashClear() {
  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
  this.size = 0;
}
var _hashClear = hashClear;
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (_nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty$2.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet;
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate ? data[key] !== void 0 : hasOwnProperty$3.call(data, key);
}
var _hashHas = hashHas;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = _nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet;
function Hash(entries) {
  var index3 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index3 < length) {
    var entry = entries[index3];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = _hashClear;
Hash.prototype["delete"] = _hashDelete;
Hash.prototype.get = _hashGet;
Hash.prototype.has = _hashHas;
Hash.prototype.set = _hashSet;
var _Hash = Hash;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    hash: new _Hash(),
    map: new (_Map || _ListCache)(),
    string: new _Hash()
  };
}
var _mapCacheClear = mapCacheClear;
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable;
function getMapData(map3, key) {
  var data = map3.__data__;
  return _isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData;
function mapCacheDelete(key) {
  var result = _getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete;
function mapCacheGet(key) {
  return _getMapData(this, key).get(key);
}
var _mapCacheGet = mapCacheGet;
function mapCacheHas(key) {
  return _getMapData(this, key).has(key);
}
var _mapCacheHas = mapCacheHas;
function mapCacheSet(key, value) {
  var data = _getMapData(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet;
function MapCache(entries) {
  var index3 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index3 < length) {
    var entry = entries[index3];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = _mapCacheClear;
MapCache.prototype["delete"] = _mapCacheDelete;
MapCache.prototype.get = _mapCacheGet;
MapCache.prototype.has = _mapCacheHas;
MapCache.prototype.set = _mapCacheSet;
var _MapCache = MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof _ListCache) {
    var pairs = data.__data__;
    if (!_Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new _MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet;
function Stack2(entries) {
  var data = this.__data__ = new _ListCache(entries);
  this.size = data.size;
}
Stack2.prototype.clear = _stackClear;
Stack2.prototype["delete"] = _stackDelete;
Stack2.prototype.get = _stackGet;
Stack2.prototype.has = _stackHas;
Stack2.prototype.set = _stackSet;
var _Stack = Stack2;
var defineProperty2 = function() {
  try {
    var func = _getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e3) {
  }
}();
var _defineProperty5 = defineProperty2;
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && _defineProperty5) {
    _defineProperty5(object, key, {
      configurable: true,
      enumerable: true,
      value,
      writable: true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue;
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq_1(object[key], value) || value === void 0 && !(key in object)) {
    _baseAssignValue(object, key, value);
  }
}
var _assignMergeValue = assignMergeValue;
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index3 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index3];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor;
var baseFor = _createBaseFor();
var _baseFor = baseFor;
var _cloneBuffer = createCommonjsModule(function(module2, exports2) {
  var freeExports = exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? _root.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module2.exports = cloneBuffer;
});
var Uint8Array2 = _root.Uint8Array;
var _Uint8Array = Uint8Array2;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer;
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray;
function copyArray(source2, array2) {
  var index3 = -1, length = source2.length;
  array2 || (array2 = Array(length));
  while (++index3 < length) {
    array2[index3] = source2[index3];
  }
  return array2;
}
var _copyArray = copyArray;
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject_1(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate;
function overArg(func, transform3) {
  return function(arg) {
    return func(transform3(arg));
  };
}
var _overArg = overArg;
var getPrototype = _overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype;
var objectProto$5 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
  return value === proto;
}
var _isPrototype = isPrototype;
function initCloneObject(object) {
  return typeof object.constructor == "function" && !_isPrototype(object) ? _baseCreate(_getPrototype(object)) : {};
}
var _initCloneObject = initCloneObject;
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike;
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
}
var _baseIsArguments = baseIsArguments;
var objectProto$6 = Object.prototype;
var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;
var isArguments = _baseIsArguments(function() {
  return arguments;
}()) ? _baseIsArguments : function(value) {
  return isObjectLike_1(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_1 = isArguments;
var isArray3 = Array.isArray;
var isArray_1 = isArray3;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength;
function isArrayLike(value) {
  return value != null && isLength_1(value.length) && !isFunction_1(value);
}
var isArrayLike_1 = isArrayLike;
function isArrayLikeObject(value) {
  return isObjectLike_1(value) && isArrayLike_1(value);
}
var isArrayLikeObject_1 = isArrayLikeObject;
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
var isBuffer_1 = createCommonjsModule(function(module2, exports2) {
  var freeExports = exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? _root.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse_1;
  module2.exports = isBuffer2;
});
var objectTag = "[object Object]";
var funcProto$2 = Function.prototype;
var objectProto$7 = Object.prototype;
var funcToString$2 = funcProto$2.toString;
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
var objectCtorString = funcToString$2.call(Object);
function isPlainObject2(value) {
  if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = _getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$5.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject2;
var argsTag$1 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag$1 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag$1 = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_1(value) && isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
}
var _baseIsTypedArray = baseIsTypedArray;
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary;
var _nodeUtil = createCommonjsModule(function(module2, exports2) {
  var freeExports = exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && _freeGlobal.process;
  var nodeUtil = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e3) {
    }
  }();
  module2.exports = nodeUtil;
});
var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;
var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;
var isTypedArray_1 = isTypedArray;
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var _safeGet = safeGet;
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$6.call(object, key) && eq_1(objValue, value)) || value === void 0 && !(key in object)) {
    _baseAssignValue(object, key, value);
  }
}
var _assignValue = assignValue;
function copyObject(source2, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index3 = -1, length = props.length;
  while (++index3 < length) {
    var key = props[index3];
    var newValue = customizer ? customizer(object[key], source2[key], key, object, source2) : void 0;
    if (newValue === void 0) {
      newValue = source2[key];
    }
    if (isNew) {
      _baseAssignValue(object, key, newValue);
    } else {
      _assignValue(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject;
function baseTimes(n4, iteratee) {
  var index3 = -1, result = Array(n4);
  while (++index3 < n4) {
    result[index3] = iteratee(index3);
  }
  return result;
}
var _baseTimes = baseTimes;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex;
var objectProto$9 = Object.prototype;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_1(value), isArg = !isArr && isArguments_1(value), isBuff = !isArr && !isArg && isBuffer_1(value), isType = !isArr && !isArg && !isBuff && isTypedArray_1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? _baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$7.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || _isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys;
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn;
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_1(object)) {
    return _nativeKeysIn(object);
  }
  var isProto = _isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$8.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn;
function keysIn(object) {
  return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
}
var keysIn_1 = keysIn;
function toPlainObject(value) {
  return _copyObject(value, keysIn_1(value));
}
var toPlainObject_1 = toPlainObject;
function baseMergeDeep(object, source2, key, srcIndex, mergeFunc, customizer, stack2) {
  var objValue = _safeGet(object, key), srcValue = _safeGet(source2, key), stacked = stack2.get(srcValue);
  if (stacked) {
    _assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source2, stack2) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_1(srcValue), isBuff = !isArr && isBuffer_1(srcValue), isTyped = !isArr && !isBuff && isTypedArray_1(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_1(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_1(objValue)) {
        newValue = _copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = _cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = _cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_1(srcValue) || isArguments_1(srcValue)) {
      newValue = objValue;
      if (isArguments_1(objValue)) {
        newValue = toPlainObject_1(objValue);
      } else if (!isObject_1(objValue) || isFunction_1(objValue)) {
        newValue = _initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack2.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
    stack2["delete"](srcValue);
  }
  _assignMergeValue(object, key, newValue);
}
var _baseMergeDeep = baseMergeDeep;
function baseMerge(object, source2, srcIndex, customizer, stack2) {
  if (object === source2) {
    return;
  }
  _baseFor(source2, function(srcValue, key) {
    stack2 || (stack2 = new _Stack());
    if (isObject_1(srcValue)) {
      _baseMergeDeep(object, source2, key, srcIndex, baseMerge, customizer, stack2);
    } else {
      var newValue = customizer ? customizer(_safeGet(object, key), srcValue, key + "", object, source2, stack2) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      _assignMergeValue(object, key, newValue);
    }
  }, keysIn_1);
}
var _baseMerge = baseMerge;
function identity(value) {
  return value;
}
var identity_1 = identity;
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply;
var nativeMax = Math.max;
function overRest(func, start3, transform3) {
  start3 = nativeMax(start3 === void 0 ? func.length - 1 : start3, 0);
  return function() {
    var args = arguments, index3 = -1, length = nativeMax(args.length - start3, 0), array2 = Array(length);
    while (++index3 < length) {
      array2[index3] = args[start3 + index3];
    }
    index3 = -1;
    var otherArgs = Array(start3 + 1);
    while (++index3 < start3) {
      otherArgs[index3] = args[index3];
    }
    otherArgs[start3] = transform3(array2);
    return _apply(func, this, otherArgs);
  };
}
var _overRest = overRest;
function constant(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant;
var baseSetToString = !_defineProperty5 ? identity_1 : function(func, string) {
  return _defineProperty5(func, "toString", {
    configurable: true,
    enumerable: false,
    value: constant_1(string),
    writable: true
  });
};
var _baseSetToString = baseSetToString;
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut;
var setToString = _shortOut(_baseSetToString);
var _setToString = setToString;
function baseRest(func, start3) {
  return _setToString(_overRest(func, start3, identity_1), func + "");
}
var _baseRest = baseRest;
function isIterateeCall(value, index3, object) {
  if (!isObject_1(object)) {
    return false;
  }
  var type = typeof index3;
  if (type == "number" ? isArrayLike_1(object) && _isIndex(index3, object.length) : type == "string" && index3 in object) {
    return eq_1(object[index3], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall;
function createAssigner(assigner) {
  return _baseRest(function(object, sources) {
    var index3 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index3 < length) {
      var source2 = sources[index3];
      if (source2) {
        assigner(object, source2, index3, customizer);
      }
    }
    return object;
  });
}
var _createAssigner = createAssigner;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED$2);
  return this;
}
var _setCacheAdd = setCacheAdd;
function setCacheHas(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas;
function SetCache(values2) {
  var index3 = -1, length = values2 == null ? 0 : values2.length;
  this.__data__ = new _MapCache();
  while (++index3 < length) {
    this.add(values2[index3]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
SetCache.prototype.has = _setCacheHas;
var _SetCache = SetCache;
function arraySome(array2, predicate) {
  var index3 = -1, length = array2 == null ? 0 : array2.length;
  while (++index3 < length) {
    if (predicate(array2[index3], index3, array2)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome;
function cacheHas(cache3, key) {
  return cache3.has(key);
}
var _cacheHas = cacheHas;
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array2, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack2.get(array2);
  var othStacked = stack2.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array2;
  }
  var index3 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new _SetCache() : void 0;
  stack2.set(array2, other);
  stack2.set(other, array2);
  while (++index3 < arrLength) {
    var arrValue = array2[index3], othValue = other[index3];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index3, other, array2, stack2) : customizer(arrValue, othValue, index3, array2, other, stack2);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!_arraySome(other, function(othValue2, othIndex) {
        if (!_cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
      result = false;
      break;
    }
  }
  stack2["delete"](array2);
  stack2["delete"](other);
  return result;
}
var _equalArrays = equalArrays;
function mapToArray(map3) {
  var index3 = -1, result = Array(map3.size);
  map3.forEach(function(value, key) {
    result[++index3] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray;
function setToArray(set3) {
  var index3 = -1, result = Array(set3.size);
  set3.forEach(function(value) {
    result[++index3] = value;
  });
  return result;
}
var _setToArray = setToArray;
var COMPARE_PARTIAL_FLAG$1 = 1;
var COMPARE_UNORDERED_FLAG$1 = 2;
var boolTag$1 = "[object Boolean]";
var dateTag$1 = "[object Date]";
var errorTag$1 = "[object Error]";
var mapTag$1 = "[object Map]";
var numberTag$1 = "[object Number]";
var regexpTag$1 = "[object RegExp]";
var setTag$1 = "[object Set]";
var stringTag$1 = "[object String]";
var symbolTag = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]";
var dataViewTag$1 = "[object DataView]";
var symbolProto = _Symbol ? _Symbol.prototype : void 0;
var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
  switch (tag) {
    case dataViewTag$1:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag$1:
      if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
        return false;
      }
      return true;
    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      return eq_1(+object, +other);
    case errorTag$1:
      return object.name == other.name && object.message == other.message;
    case regexpTag$1:
    case stringTag$1:
      return object == other + "";
    case mapTag$1:
      var convert = _mapToArray;
    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
      convert || (convert = _setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack2.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$1;
      stack2.set(object, other);
      var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
      stack2["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag;
function arrayPush(array2, values2) {
  var index3 = -1, length = values2.length, offset2 = array2.length;
  while (++index3 < length) {
    array2[offset2 + index3] = values2[index3];
  }
  return array2;
}
var _arrayPush = arrayPush;
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys;
function arrayFilter(array2, predicate) {
  var index3 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
  while (++index3 < length) {
    var value = array2[index3];
    if (predicate(value, index3, array2)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter;
function stubArray() {
  return [];
}
var stubArray_1 = stubArray;
var objectProto$b = Object.prototype;
var propertyIsEnumerable$1 = objectProto$b.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return _arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable$1.call(object, symbol);
  });
};
var _getSymbols = getSymbols;
var nativeKeys = _overArg(Object.keys, Object);
var _nativeKeys = nativeKeys;
var objectProto$c = Object.prototype;
var hasOwnProperty$9 = objectProto$c.hasOwnProperty;
function baseKeys(object) {
  if (!_isPrototype(object)) {
    return _nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$9.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys;
function keys(object) {
  return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
}
var keys_1 = keys;
function getAllKeys(object) {
  return _baseGetAllKeys(object, keys_1, _getSymbols);
}
var _getAllKeys = getAllKeys;
var COMPARE_PARTIAL_FLAG$2 = 1;
var objectProto$d = Object.prototype;
var hasOwnProperty$a = objectProto$d.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2, objProps = _getAllKeys(object), objLength = objProps.length, othProps = _getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index3 = objLength;
  while (index3--) {
    var key = objProps[index3];
    if (!(isPartial ? key in other : hasOwnProperty$a.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack2.get(object);
  var othStacked = stack2.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack2.set(object, other);
  stack2.set(other, object);
  var skipCtor = isPartial;
  while (++index3 < objLength) {
    key = objProps[index3];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack2["delete"](object);
  stack2["delete"](other);
  return result;
}
var _equalObjects = equalObjects;
var DataView2 = _getNative(_root, "DataView");
var _DataView = DataView2;
var Promise2 = _getNative(_root, "Promise");
var _Promise = Promise2;
var Set2 = _getNative(_root, "Set");
var _Set = Set2;
var WeakMap2 = _getNative(_root, "WeakMap");
var _WeakMap = WeakMap2;
var mapTag$2 = "[object Map]";
var objectTag$2 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag$2 = "[object Set]";
var weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = _toSource(_DataView);
var mapCtorString = _toSource(_Map);
var promiseCtorString = _toSource(_Promise);
var setCtorString = _toSource(_Set);
var weakMapCtorString = _toSource(_WeakMap);
var getTag = _baseGetTag;
if (_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$2 || _Map && getTag(new _Map()) != mapTag$2 || _Promise && getTag(_Promise.resolve()) != promiseTag || _Set && getTag(new _Set()) != setTag$2 || _WeakMap && getTag(new _WeakMap()) != weakMapTag$1) {
  getTag = function(value) {
    var result = _baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? _toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$2;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var _getTag = getTag;
var COMPARE_PARTIAL_FLAG$3 = 1;
var argsTag$2 = "[object Arguments]";
var arrayTag$1 = "[object Array]";
var objectTag$3 = "[object Object]";
var objectProto$e = Object.prototype;
var hasOwnProperty$b = objectProto$e.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
  var objIsArr = isArray_1(object), othIsArr = isArray_1(other), objTag = objIsArr ? arrayTag$1 : _getTag(object), othTag = othIsArr ? arrayTag$1 : _getTag(other);
  objTag = objTag == argsTag$2 ? objectTag$3 : objTag;
  othTag = othTag == argsTag$2 ? objectTag$3 : othTag;
  var objIsObj = objTag == objectTag$3, othIsObj = othTag == objectTag$3, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_1(object)) {
    if (!isBuffer_1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack2 || (stack2 = new _Stack());
    return objIsArr || isTypedArray_1(object) ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
    var objIsWrapped = objIsObj && hasOwnProperty$b.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$b.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack2 || (stack2 = new _Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack2 || (stack2 = new _Stack());
  return _equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
}
var _baseIsEqualDeep = baseIsEqualDeep;
function baseIsEqual(value, other, bitmask, customizer, stack2) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_1(value) && !isObjectLike_1(other)) {
    return value !== value && other !== other;
  }
  return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
}
var _baseIsEqual = baseIsEqual;

// build/_snowpack/pkg/@patternfly/react-table.js
var Bullseye = (_a) => {
  var {children: children2 = null, className = "", component = "div"} = _a, props = __rest(_a, ["children", "className", "component"]);
  const Component = component;
  return react.createElement(Component, Object.assign({className: css(styles.bullseye, className)}, props), children2);
};
Bullseye.displayName = "Bullseye";
var ArrowsAltVIconConfig = {
  name: "ArrowsAltVIcon",
  height: 512,
  width: 256,
  svgPath: "M214.059 377.941H168V134.059h46.059c21.382 0 32.09-25.851 16.971-40.971L144.971 7.029c-9.373-9.373-24.568-9.373-33.941 0L24.971 93.088c-15.119 15.119-4.411 40.971 16.971 40.971H88v243.882H41.941c-21.382 0-32.09 25.851-16.971 40.971l86.059 86.059c9.373 9.373 24.568 9.373 33.941 0l86.059-86.059c15.12-15.119 4.412-40.971-16.97-40.971z",
  yOffset: 0,
  xOffset: 0
};
var ArrowsAltVIcon = createIcon(ArrowsAltVIconConfig);
var EllipsisHIconConfig = {
  name: "EllipsisHIcon",
  height: 512,
  width: 512,
  svgPath: "M328 256c0 39.8-32.2 72-72 72s-72-32.2-72-72 32.2-72 72-72 72 32.2 72 72zm104-72c-39.8 0-72 32.2-72 72s32.2 72 72 72 72-32.2 72-72-32.2-72-72-72zm-352 0c-39.8 0-72 32.2-72 72s32.2 72 72 72 72-32.2 72-72-32.2-72-72-72z",
  yOffset: 0,
  xOffset: 0
};
var EllipsisHIcon = createIcon(EllipsisHIconConfig);
var LongArrowAltDownIconConfig = {
  name: "LongArrowAltDownIcon",
  height: 512,
  width: 256,
  svgPath: "M168 345.941V44c0-6.627-5.373-12-12-12h-56c-6.627 0-12 5.373-12 12v301.941H41.941c-21.382 0-32.09 25.851-16.971 40.971l86.059 86.059c9.373 9.373 24.569 9.373 33.941 0l86.059-86.059c15.119-15.119 4.411-40.971-16.971-40.971H168z",
  yOffset: 0,
  xOffset: 0
};
var LongArrowAltDownIcon = createIcon(LongArrowAltDownIconConfig);
var LongArrowAltUpIconConfig = {
  name: "LongArrowAltUpIcon",
  height: 512,
  width: 256,
  svgPath: "M88 166.059V468c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12V166.059h46.059c21.382 0 32.09-25.851 16.971-40.971l-86.059-86.059c-9.373-9.373-24.569-9.373-33.941 0l-86.059 86.059c-15.119 15.119-4.411 40.971 16.971 40.971H88z",
  yOffset: 0,
  xOffset: 0
};
var LongArrowAltUpIcon = createIcon(LongArrowAltUpIconConfig);
var PencilAltIconConfig = {
  name: "PencilAltIcon",
  height: 512,
  width: 512,
  svgPath: "M497.9 142.1l-46.1 46.1c-4.7 4.7-12.3 4.7-17 0l-111-111c-4.7-4.7-4.7-12.3 0-17l46.1-46.1c18.7-18.7 49.1-18.7 67.9 0l60.1 60.1c18.8 18.7 18.8 49.1 0 67.9zM284.2 99.8L21.6 362.4.4 483.9c-2.9 16.4 11.4 30.6 27.8 27.8l121.5-21.3 262.6-262.6c4.7-4.7 4.7-12.3 0-17l-111-111c-4.8-4.7-12.4-4.7-17.1 0zM124.1 339.9c-5.5-5.5-5.5-14.3 0-19.8l154-154c5.5-5.5 14.3-5.5 19.8 0s5.5 14.3 0 19.8l-154 154c-5.5 5.5-14.3 5.5-19.8 0zM88 424h48v36.3l-64.5 11.3-31.1-31.1L51.7 376H88v48z",
  yOffset: 0,
  xOffset: 0
};
var PencilAltIcon = createIcon(PencilAltIconConfig);
var table = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    button: "pf-c-button",
    modifiers: {
      hidden: "pf-m-hidden",
      hiddenOnSm: "pf-m-hidden-on-sm",
      visibleOnSm: "pf-m-visible-on-sm",
      hiddenOnMd: "pf-m-hidden-on-md",
      visibleOnMd: "pf-m-visible-on-md",
      hiddenOnLg: "pf-m-hidden-on-lg",
      visibleOnLg: "pf-m-visible-on-lg",
      hiddenOnXl: "pf-m-hidden-on-xl",
      visibleOnXl: "pf-m-visible-on-xl",
      hiddenOn_2xl: "pf-m-hidden-on-2xl",
      visibleOn_2xl: "pf-m-visible-on-2xl",
      fixed: "pf-m-fixed",
      stickyHeader: "pf-m-sticky-header",
      ghostRow: "pf-m-ghost-row",
      center: "pf-m-center",
      help: "pf-m-help",
      favorite: "pf-m-favorite",
      truncate: "pf-m-truncate",
      wrap: "pf-m-wrap",
      nowrap: "pf-m-nowrap",
      fitContent: "pf-m-fit-content",
      breakWord: "pf-m-break-word",
      noBorderRows: "pf-m-no-border-rows",
      expanded: "pf-m-expanded",
      hoverable: "pf-m-hoverable",
      selected: "pf-m-selected",
      dragOver: "pf-m-drag-over",
      favorited: "pf-m-favorited",
      noPadding: "pf-m-no-padding",
      compact: "pf-m-compact",
      width_10: "pf-m-width-10",
      width_15: "pf-m-width-15",
      width_20: "pf-m-width-20",
      width_25: "pf-m-width-25",
      width_30: "pf-m-width-30",
      width_35: "pf-m-width-35",
      width_40: "pf-m-width-40",
      width_45: "pf-m-width-45",
      width_50: "pf-m-width-50",
      width_60: "pf-m-width-60",
      width_70: "pf-m-width-70",
      width_80: "pf-m-width-80",
      width_90: "pf-m-width-90",
      width_100: "pf-m-width-100"
    },
    table: "pf-c-table",
    tableAction: "pf-c-table__action",
    tableButton: "pf-c-table__button",
    tableButtonContent: "pf-c-table__button-content",
    tableCheck: "pf-c-table__check",
    tableColumnHelp: "pf-c-table__column-help",
    tableColumnHelpAction: "pf-c-table__column-help-action",
    tableCompoundExpansionToggle: "pf-c-table__compound-expansion-toggle",
    tableControlRow: "pf-c-table__control-row",
    tableDraggable: "pf-c-table__draggable",
    tableExpandableRow: "pf-c-table__expandable-row",
    tableExpandableRowContent: "pf-c-table__expandable-row-content",
    tableFavorite: "pf-c-table__favorite",
    tableIcon: "pf-c-table__icon",
    tableIconInline: "pf-c-table__icon-inline",
    tableInlineEditAction: "pf-c-table__inline-edit-action",
    tableSort: "pf-c-table__sort",
    tableSortIndicator: "pf-c-table__sort-indicator",
    tableText: "pf-c-table__text",
    tableToggle: "pf-c-table__toggle",
    tableToggleIcon: "pf-c-table__toggle-icon"
  };
});
var styles3 = /* @__PURE__ */ getDefaultExportFromCjs(table);
var tableGrid = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    button: "pf-c-button",
    modifiers: {
      grid: "pf-m-grid",
      compact: "pf-m-compact",
      expanded: "pf-m-expanded",
      selected: "pf-m-selected",
      noPadding: "pf-m-no-padding",
      hoverable: "pf-m-hoverable",
      nowrap: "pf-m-nowrap",
      fitContent: "pf-m-fit-content",
      truncate: "pf-m-truncate",
      gridMd: "pf-m-grid-md",
      gridLg: "pf-m-grid-lg",
      gridXl: "pf-m-grid-xl",
      grid_2xl: "pf-m-grid-2xl"
    },
    table: "pf-c-table",
    tableAction: "pf-c-table__action",
    tableButton: "pf-c-table__button",
    tableCheck: "pf-c-table__check",
    tableCompoundExpansionToggle: "pf-c-table__compound-expansion-toggle",
    tableExpandableRow: "pf-c-table__expandable-row",
    tableExpandableRowContent: "pf-c-table__expandable-row-content",
    tableFavorite: "pf-c-table__favorite",
    tableIcon: "pf-c-table__icon",
    tableInlineEditAction: "pf-c-table__inline-edit-action",
    tableText: "pf-c-table__text",
    tableToggle: "pf-c-table__toggle",
    tableToggleIcon: "pf-c-table__toggle-icon"
  };
});
var stylesGrid2 = /* @__PURE__ */ getDefaultExportFromCjs(tableGrid);
var tableTreeView = createCommonjsModule(function(module2, exports2) {
  exports2.__esModule = true;
  exports2.default = {
    dropdown: "pf-c-dropdown",
    modifiers: {
      treeView: "pf-m-tree-view",
      treeViewGrid: "pf-m-tree-view-grid",
      treeViewDetailsExpanded: "pf-m-tree-view-details-expanded",
      treeViewGridMd: "pf-m-tree-view-grid-md",
      treeViewGridLg: "pf-m-tree-view-grid-lg",
      treeViewGridXl: "pf-m-tree-view-grid-xl",
      treeViewGrid_2xl: "pf-m-tree-view-grid-2xl"
    },
    table: "pf-c-table",
    tableAction: "pf-c-table__action",
    tableCheck: "pf-c-table__check",
    tableToggle: "pf-c-table__toggle",
    tableToggleIcon: "pf-c-table__toggle-icon",
    tableTreeViewDetailsToggle: "pf-c-table__tree-view-details-toggle",
    tableTreeViewIcon: "pf-c-table__tree-view-icon",
    tableTreeViewMain: "pf-c-table__tree-view-main",
    tableTreeViewText: "pf-c-table__tree-view-text",
    tableTreeViewTitleCell: "pf-c-table__tree-view-title-cell",
    tableTreeViewTitleHeaderCell: "pf-c-table__tree-view-title-header-cell"
  };
});
var stylesTreeView = /* @__PURE__ */ getDefaultExportFromCjs(tableTreeView);
var hasCompoundParentsExpanded = (parentId2, compoundParent, rows) => {
  for (const i3 of rows) {
    if (rows[parentId2].hasOwnProperty("parent")) {
      parentId2 = rows[parentId2].parent;
    } else {
      return rows[parentId2].cells[compoundParent].props.isOpen;
    }
  }
  return false;
};
var hasParentsExpanded = (parentId2, rows) => {
  for (const i3 of rows) {
    if (rows[parentId2].hasOwnProperty("parent")) {
      parentId2 = rows[parentId2].parent;
    } else {
      return rows[parentId2].isOpen;
    }
  }
  return false;
};
var isRowExpanded = (row, rows) => {
  if (row.parent !== void 0) {
    if (row.hasOwnProperty("compoundParent")) {
      return hasCompoundParentsExpanded(row.parent, row.compoundParent, rows);
    }
    return hasParentsExpanded(row.parent, rows) && rows[row.parent].isOpen;
  }
  return void 0;
};
var camelize3 = (s2) => s2.toUpperCase().replace("-", "").replace("_", "");
var toCamel2 = (s2) => s2.replace(/([-_][a-z])/gi, camelize3);
function capitalize3(input) {
  return input[0].toUpperCase() + input.substring(1);
}
var TableGridBreakpoint;
(function(TableGridBreakpoint2) {
  TableGridBreakpoint2["none"] = "";
  TableGridBreakpoint2["grid"] = "grid";
  TableGridBreakpoint2["gridMd"] = "grid-md";
  TableGridBreakpoint2["gridLg"] = "grid-lg";
  TableGridBreakpoint2["gridXl"] = "grid-xl";
  TableGridBreakpoint2["grid2xl"] = "grid-2xl";
})(TableGridBreakpoint || (TableGridBreakpoint = {}));
var TableVariant;
(function(TableVariant2) {
  TableVariant2["compact"] = "compact";
})(TableVariant || (TableVariant = {}));
var TableComposableBase = (_a) => {
  var _b, _c;
  var {children: children2, className, variant, borders = true, isStickyHeader = false, gridBreakPoint = TableGridBreakpoint.gridMd, "aria-label": ariaLabel, role = "grid", innerRef, ouiaId, ouiaSafe = true, isTreeTable = false} = _a, props = __rest(_a, ["children", "className", "variant", "borders", "isStickyHeader", "gridBreakPoint", "aria-label", "role", "innerRef", "ouiaId", "ouiaSafe", "isTreeTable"]);
  const ouiaProps = useOUIAProps("Table", ouiaId, ouiaSafe);
  const grid2 = (_b = stylesGrid2.modifiers) === null || _b === void 0 ? void 0 : _b[toCamel2(gridBreakPoint || "").replace(/-?2xl/, "_2xl")];
  const breakPointPrefix = `treeView${gridBreakPoint.charAt(0).toUpperCase() + gridBreakPoint.slice(1)}`;
  const treeGrid = (_c = stylesTreeView.modifiers) === null || _c === void 0 ? void 0 : _c[toCamel2(breakPointPrefix || "").replace(/-?2xl/, "_2xl")];
  return react.createElement("table", Object.assign({"aria-label": ariaLabel, role, className: css(className, styles3.table, isTreeTable ? treeGrid : grid2, styles3.modifiers[variant], !borders && styles3.modifiers.noBorderRows, isStickyHeader && styles3.modifiers.stickyHeader, isTreeTable && stylesTreeView.modifiers.treeView), ref: innerRef}, isTreeTable && {role: "treegrid"}, ouiaProps, props), children2);
};
var TableComposable = react.forwardRef((props, ref) => react.createElement(TableComposableBase, Object.assign({}, props, {innerRef: ref})));
TableComposable.displayName = "TableComposable";
var TheadBase = (_a) => {
  var {children: children2, className, noWrap = false, innerRef} = _a, props = __rest(_a, ["children", "className", "noWrap", "innerRef"]);
  return react.createElement("thead", Object.assign({className: css(className, noWrap && styles3.modifiers.nowrap), ref: innerRef}, props), children2);
};
var Thead = react.forwardRef((props, ref) => react.createElement(TheadBase, Object.assign({}, props, {innerRef: ref})));
Thead.displayName = "Thead";
var TbodyBase = (_a) => {
  var {children: children2, className, isExpanded, innerRef} = _a, props = __rest(_a, ["children", "className", "isExpanded", "innerRef"]);
  return react.createElement("tbody", Object.assign({role: "rowgroup", className: css(className, isExpanded && styles3.modifiers.expanded), ref: innerRef}, props), children2);
};
var Tbody = react.forwardRef((props, ref) => react.createElement(TbodyBase, Object.assign({}, props, {innerRef: ref})));
Tbody.displayName = "Tbody";
var TrBase = (_a) => {
  var {children: children2, className, isExpanded, isEditable, isHidden: isHidden3 = false, innerRef, ouiaId, ouiaSafe = true} = _a, props = __rest(_a, ["children", "className", "isExpanded", "isEditable", "isHidden", "innerRef", "ouiaId", "ouiaSafe"]);
  const ouiaProps = useOUIAProps("TableRow", ouiaId, ouiaSafe);
  return react.createElement("tr", Object.assign({className: css(className, isExpanded !== void 0 && styles3.tableExpandableRow, isExpanded && styles3.modifiers.expanded, isEditable && inlineStyles.modifiers.inlineEditable), hidden: isHidden3 || isExpanded !== void 0 && !isExpanded, ref: innerRef}, ouiaProps, props), children2);
};
var Tr = react.forwardRef((props, ref) => react.createElement(TrBase, Object.assign({}, props, {innerRef: ref})));
Tr.displayName = "Tr";
var TableTextVariant;
(function(TableTextVariant2) {
  TableTextVariant2["div"] = "div";
  TableTextVariant2["nav"] = "nav";
})(TableTextVariant || (TableTextVariant = {}));
var WrapModifier;
(function(WrapModifier2) {
  WrapModifier2["wrap"] = "wrap";
  WrapModifier2["nowrap"] = "nowrap";
  WrapModifier2["truncate"] = "truncate";
  WrapModifier2["breakWord"] = "breakWord";
  WrapModifier2["fitContent"] = "fitContent";
})(WrapModifier || (WrapModifier = {}));
var TableText = (_a) => {
  var {children: children2 = null, className = "", variant = "span", wrapModifier = null, tooltip: tooltipProp = "", tooltipProps = {}, onMouseEnter: onMouseEnterProp = () => {
  }} = _a, props = __rest(_a, ["children", "className", "variant", "wrapModifier", "tooltip", "tooltipProps", "onMouseEnter"]);
  const Component = variant;
  const [tooltip2, setTooltip] = react.useState("");
  const onMouseEnter = (event) => {
    if (event.target.offsetWidth < event.target.scrollWidth) {
      setTooltip(tooltipProp || event.target.innerText);
    } else {
      setTooltip("");
    }
    onMouseEnterProp(event);
  };
  const text = react.createElement(Component, Object.assign({onMouseEnter, className: css(className, wrapModifier && styles3.modifiers[wrapModifier], styles3.tableText)}, props), children2);
  return tooltip2 !== "" ? react.createElement(Tooltip, Object.assign({content: tooltip2, isVisible: true}, tooltipProps), text) : text;
};
TableText.displayName = "TableText";
var HeaderCellInfoWrapper = ({children: children2, info: info2, className, variant = "tooltip", popoverProps, tooltipProps, ariaLabel}) => react.createElement("div", {className: css(styles3.tableColumnHelp, className)}, typeof children2 === "string" ? react.createElement(TableText, null, children2) : children2, react.createElement("span", {className: css(styles3.tableColumnHelpAction)}, variant === "tooltip" ? react.createElement(Tooltip, Object.assign({content: info2}, tooltipProps), react.createElement(Button, {variant: "plain", "aria-label": ariaLabel || typeof info2 === "string" && info2 || "More info"}, react.createElement(HelpIcon, {noVerticalAlign: true}))) : react.createElement(Popover, Object.assign({bodyContent: info2}, popoverProps), react.createElement(Button, {variant: "plain", "aria-label": ariaLabel || typeof info2 === "string" && info2 || "More info"}, react.createElement(HelpIcon, {noVerticalAlign: true})))));
HeaderCellInfoWrapper.displayName = "HeaderCellInfoWrapper";
var info = ({tooltip: tooltip2, tooltipProps, popover: popover2, popoverProps, className, ariaLabel}) => {
  const infoObj = (value) => ({
    className: styles3.modifiers.help,
    children: tooltip2 ? react.createElement(HeaderCellInfoWrapper, {variant: "tooltip", info: tooltip2, tooltipProps, ariaLabel, className}, value) : react.createElement(HeaderCellInfoWrapper, {variant: "popover", info: popover2, popoverProps, ariaLabel, className}, value)
  });
  return infoObj;
};
var SortByDirection;
(function(SortByDirection2) {
  SortByDirection2["asc"] = "asc";
  SortByDirection2["desc"] = "desc";
})(SortByDirection || (SortByDirection = {}));
var SortColumn = (_a) => {
  var {children: children2 = null, className = "", isSortedBy = false, onSort = null, sortDirection = "", type = "button"} = _a, props = __rest(_a, ["children", "className", "isSortedBy", "onSort", "sortDirection", "type"]);
  let SortedByIcon;
  if (isSortedBy) {
    SortedByIcon = sortDirection === SortByDirection.asc ? LongArrowAltUpIcon : LongArrowAltDownIcon;
  } else {
    SortedByIcon = ArrowsAltVIcon;
  }
  return react.createElement("button", Object.assign({}, props, {type, className: css(className, styles3.tableButton), onClick: (event) => onSort && onSort(event)}), react.createElement("div", {className: css(className, styles3.tableButtonContent)}, react.createElement(TableText, null, children2), react.createElement("span", {className: css(styles3.tableSortIndicator)}, react.createElement(SortedByIcon, null))));
};
SortColumn.displayName = "SortColumn";
var sortableFavorites = (sort2) => () => sortable(react.createElement(StarIcon, {"aria-hidden": true}), {
  columnIndex: sort2.columnIndex,
  className: styles3.modifiers.favorite,
  ariaLabel: "Sort favorites",
  column: {
    extraParams: {
      sortBy: sort2.sortBy,
      onSort: sort2 === null || sort2 === void 0 ? void 0 : sort2.onSort
    }
  }
});
var sortable = (label2, {columnIndex, column, property: property2, className, ariaLabel}) => {
  const {extraParams: {sortBy: sortBy2, onSort}} = column;
  const extraData = {
    columnIndex,
    column,
    property: property2
  };
  const isSortedBy = sortBy2 && columnIndex === sortBy2.index;
  function sortClicked(event) {
    let reversedDirection;
    if (!isSortedBy) {
      reversedDirection = SortByDirection.asc;
    } else {
      reversedDirection = sortBy2.direction === SortByDirection.asc ? SortByDirection.desc : SortByDirection.asc;
    }
    onSort && onSort(event, columnIndex, reversedDirection, extraData);
  }
  return {
    className: css(styles3.tableSort, isSortedBy && styles3.modifiers.selected, className),
    "aria-sort": isSortedBy ? `${sortBy2.direction}ending` : "none",
    children: react.createElement(SortColumn, {isSortedBy, sortDirection: isSortedBy ? sortBy2.direction : "", onSort: sortClicked, "aria-label": ariaLabel}, label2)
  };
};
var RowSelectVariant;
(function(RowSelectVariant2) {
  RowSelectVariant2["radio"] = "radio";
  RowSelectVariant2["checkbox"] = "checkbox";
})(RowSelectVariant || (RowSelectVariant = {}));
var SelectColumn = (_a) => {
  var {
    children: children2 = null,
    className,
    onSelect = null,
    selectVariant
  } = _a, props = __rest(_a, ["children", "className", "onSelect", "selectVariant"]);
  return react.createElement(react.Fragment, null, react.createElement("input", Object.assign({}, props, {type: selectVariant, onChange: onSelect})), children2);
};
SelectColumn.displayName = "SelectColumn";
var selectable = (label2, {rowIndex, columnIndex, rowData, column, property: property2}) => {
  const {extraParams: {onSelect, selectVariant, allRowsSelected}} = column;
  const extraData = {
    rowIndex,
    columnIndex,
    column,
    property: property2
  };
  if (rowData && rowData.hasOwnProperty("parent") && !rowData.showSelect && !rowData.fullWidth) {
    return {
      component: "td",
      isVisible: true
    };
  }
  const rowId = rowIndex !== void 0 ? rowIndex : -1;
  function selectClick(event) {
    const selected = rowIndex === void 0 ? event.currentTarget.checked : rowData && !rowData.selected;
    onSelect && onSelect(event, selected, rowId, rowData, extraData);
  }
  const customProps = Object.assign(Object.assign({}, rowId !== -1 ? {
    checked: rowData && !!rowData.selected,
    "aria-label": `Select row ${rowIndex}`
  } : {
    checked: allRowsSelected,
    "aria-label": "Select all rows"
  }), rowData && (rowData.disableCheckbox || rowData.disableSelection) && {
    disabled: true,
    className: checkStyles.checkInput
  });
  let selectName = "check-all";
  if (rowId !== -1 && selectVariant === RowSelectVariant.checkbox) {
    selectName = `checkrow${rowIndex}`;
  } else if (rowId !== -1) {
    selectName = "radioGroup";
  }
  return {
    className: css(styles3.tableCheck),
    component: "td",
    isVisible: !rowData || !rowData.fullWidth,
    children: react.createElement(SelectColumn, Object.assign({}, customProps, {selectVariant, onSelect: selectClick, name: selectName}), label2)
  };
};
var cellWidth = (width2) => () => ({
  className: css(styles3.modifiers[typeof width2 === "number" ? `width_${width2}` : `width${capitalize3(width2)}`])
});
var visibilityModifiers = [
  "hidden",
  "hiddenOnSm",
  "hiddenOnMd",
  "hiddenOnLg",
  "hiddenOnXl",
  "hiddenOn_2xl",
  "visibleOnSm",
  "visibleOnMd",
  "visibleOnLg",
  "visibleOnXl",
  "visibleOn_2xl"
];
var Visibility = visibilityModifiers.filter((key) => styles3.modifiers[key]).reduce((acc, curr) => {
  const key2 = curr.replace("_2xl", "2Xl");
  acc[key2] = styles3.modifiers[curr];
  return acc;
}, {});
var classNames = (...classes) => () => ({
  className: css(...classes)
});
var mergeWith = _createAssigner(function(object, source2, srcIndex, customizer) {
  _baseMerge(object, source2, srcIndex, customizer);
});
var mergeWith_1 = mergeWith;
function mergeProps2(...props) {
  const firstProps = props[0];
  const restProps = props.slice(1);
  if (!restProps.length) {
    return mergeWith_1({}, firstProps);
  }
  return mergeWith_1(mergeWith_1({}, firstProps), ...restProps, (a2, b3, key) => {
    if (key === "children") {
      if (a2 && b3) {
        return react.cloneElement(a2, {
          children: b3
        });
      }
      return Object.assign(Object.assign({}, b3), a2);
    }
    if (key === "className") {
      return css(a2, b3);
    }
    return void 0;
  });
}
var ThBase = (_a) => {
  var {children: children2, className, component = "th", dataLabel, scope = "col", textCenter = false, sort: sort2 = null, modifier, select: select3 = null, tooltip: tooltip2 = "", onMouseEnter: onMouseEnterProp = () => {
  }, width: width2, visibility, innerRef, info: infoProps} = _a, props = __rest(_a, ["children", "className", "component", "dataLabel", "scope", "textCenter", "sort", "modifier", "select", "tooltip", "onMouseEnter", "width", "visibility", "innerRef", "info"]);
  const [showTooltip, setShowTooltip] = react.useState(false);
  const onMouseEnter = (event) => {
    if (event.target.offsetWidth < event.target.scrollWidth) {
      !showTooltip && setShowTooltip(true);
    } else {
      showTooltip && setShowTooltip(false);
    }
    onMouseEnterProp(event);
  };
  let sortParams = null;
  if (sort2) {
    if (sort2.isFavorites) {
      sortParams = sortableFavorites({
        onSort: sort2 === null || sort2 === void 0 ? void 0 : sort2.onSort,
        columnIndex: sort2.columnIndex,
        sortBy: sort2.sortBy
      })();
    } else {
      sortParams = sortable(children2, {
        columnIndex: sort2.columnIndex,
        column: {
          extraParams: {
            sortBy: sort2.sortBy,
            onSort: sort2 === null || sort2 === void 0 ? void 0 : sort2.onSort
          }
        }
      });
    }
  }
  const selectParams = select3 ? selectable(children2, {
    column: {
      extraParams: {
        onSelect: select3 === null || select3 === void 0 ? void 0 : select3.onSelect,
        selectVariant: "checkbox",
        allRowsSelected: select3.isSelected
      }
    }
  }) : null;
  const widthParams = width2 ? cellWidth(width2)() : null;
  const visibilityParams = visibility ? classNames(...visibility.map((vis) => Visibility[vis]))() : null;
  let transformedChildren = (sortParams === null || sortParams === void 0 ? void 0 : sortParams.children) || (selectParams === null || selectParams === void 0 ? void 0 : selectParams.children) || children2;
  let infoParams = null;
  if (infoProps) {
    infoParams = info(infoProps)(transformedChildren);
    transformedChildren = infoParams.children;
  }
  const merged = mergeProps2(sortParams, selectParams, widthParams, visibilityParams, infoParams);
  const {
    children: mergedChildren = null,
    isVisible = null,
    className: mergedClassName = "",
    component: MergedComponent = component
  } = merged, mergedProps = __rest(merged, ["children", "isVisible", "className", "component"]);
  const cell = react.createElement(MergedComponent, Object.assign({"data-label": dataLabel, onMouseEnter: tooltip2 !== null ? onMouseEnter : onMouseEnterProp, scope: component === "th" && children2 ? scope : null, ref: innerRef, className: css(className, textCenter && styles3.modifiers.center, modifier && styles3.modifiers[modifier], mergedClassName)}, mergedProps, props), transformedChildren);
  const canDefault = tooltip2 === "" ? typeof children2 === "string" : true;
  return tooltip2 !== null && canDefault && showTooltip ? react.createElement(Tooltip, {content: tooltip2 || tooltip2 === "" && children2, isVisible: true}, cell) : cell;
};
var Th2 = react.forwardRef((props, ref) => react.createElement(ThBase, Object.assign({}, props, {innerRef: ref})));
Th2.displayName = "Th";
var ActionsColumn = class extends react.Component {
  constructor(props) {
    super(props);
    this.onToggle = (isOpen) => {
      this.setState({
        isOpen
      });
    };
    this.onClick = (event, onClick) => {
      const {rowData, extraData} = this.props;
      if (onClick) {
        event.preventDefault();
        onClick(event, extraData && extraData.rowIndex, rowData, extraData);
      }
    };
    this.state = {
      isOpen: false
    };
  }
  render() {
    const {isOpen} = this.state;
    const {items, children: children2, dropdownPosition, dropdownDirection, isDisabled, rowData, actionsToggle} = this.props;
    const actionsToggleClone = actionsToggle ? actionsToggle({onToggle: this.onToggle, isOpen, isDisabled}) : react.createElement(KebabToggle, {isDisabled, onToggle: this.onToggle});
    return react.createElement(react.Fragment, null, items.filter((item) => item.isOutsideDropdown).map((_a, key) => {
      var {title: title3, itemKey, onClick, isOutsideDropdown} = _a, props = __rest(_a, ["title", "itemKey", "onClick", "isOutsideDropdown"]);
      return typeof title3 === "string" ? react.createElement(Button, Object.assign({onClick: (event) => this.onClick(event, onClick)}, props, {isDisabled, key: itemKey || `outside_dropdown_${key}`, "data-key": itemKey || `outside_dropdown_${key}`}), title3) : react.cloneElement(title3, Object.assign({onClick, isDisabled}, props));
    }), react.createElement(Dropdown, Object.assign({toggle: actionsToggleClone, position: dropdownPosition, direction: dropdownDirection, isOpen, dropdownItems: items.filter((item) => !item.isOutsideDropdown).map((_a, key) => {
      var {title: title3, itemKey, onClick, isSeparator} = _a, props = __rest(_a, ["title", "itemKey", "onClick", "isSeparator"]);
      return isSeparator ? react.createElement(DropdownSeparator, Object.assign({}, props, {key: itemKey || key, "data-key": itemKey || key})) : react.createElement(DropdownItem, Object.assign({component: "button", onClick: (event) => {
        this.onClick(event, onClick);
        this.onToggle(!isOpen);
      }}, props, {key: itemKey || key, "data-key": itemKey || key}), title3);
    }), isPlain: true}, rowData && rowData.actionProps)), children2);
  }
};
ActionsColumn.displayName = "ActionsColumn";
ActionsColumn.defaultProps = {
  children: null,
  items: [],
  dropdownPosition: DropdownPosition.right,
  dropdownDirection: DropdownDirection.down,
  rowData: {},
  extraData: {}
};
var resolveOrDefault = (resolver, defaultValue, rowData, extraData) => typeof resolver === "function" ? resolver(rowData, extraData) : defaultValue;
var cellActions = (actions2, actionResolver, areActionsDisabled) => (label2, {rowData, column, rowIndex, columnIndex, column: {extraParams: {dropdownPosition, dropdownDirection, actionsToggle}}, property: property2}) => {
  const extraData = {
    rowIndex,
    columnIndex,
    column,
    property: property2
  };
  const resolvedActions = resolveOrDefault(actionResolver, actions2, rowData, extraData);
  const resolvedIsDisabled = resolveOrDefault(areActionsDisabled, rowData && rowData.disableActions, rowData, extraData);
  const renderProps = resolvedActions && resolvedActions.length > 0 ? {
    children: react.createElement(ActionsColumn, {items: resolvedActions, dropdownPosition, dropdownDirection, isDisabled: resolvedIsDisabled, rowData, extraData, actionsToggle}, label2)
  } : {};
  return Object.assign({className: css(styles3.tableAction), style: {width: "auto", paddingRight: 0}, isVisible: true}, renderProps);
};
var CollapseColumn = (_a) => {
  var {className = "", children: children2 = null, isOpen, onToggle} = _a, props = __rest(_a, ["className", "children", "isOpen", "onToggle"]);
  return react.createElement(react.Fragment, null, isOpen !== void 0 && react.createElement(Button, Object.assign({className: css(className, isOpen && styles3.modifiers.expanded)}, props, {variant: "plain", "aria-label": "Details", onClick: onToggle, "aria-expanded": isOpen}), react.createElement("div", {className: css(styles3.tableToggleIcon)}, react.createElement(AngleDownIcon, null))), children2);
};
CollapseColumn.displayName = "CollapseColumn";
var ExpandableRowContent = (_a) => {
  var {children: children2 = null} = _a, props = __rest(_a, ["children"]);
  return react.createElement("div", Object.assign({}, props, {className: css(styles3.tableExpandableRowContent)}), children2);
};
ExpandableRowContent.displayName = "ExpandableRowContent";
var collapsible = (value, {rowIndex, columnIndex, rowData, column, property: property2}) => {
  const {extraParams: {onCollapse, rowLabeledBy = "simple-node", expandId = "expand-toggle"}} = column;
  const extraData = {
    rowIndex,
    columnIndex,
    column,
    property: property2
  };
  function onToggle(event) {
    onCollapse && onCollapse(event, rowIndex, rowData && !rowData.isOpen, rowData, extraData);
  }
  return {
    className: rowData.isOpen !== void 0 && css(styles3.tableToggle),
    isVisible: !rowData.fullWidth,
    children: react.createElement(CollapseColumn, {"aria-labelledby": `${rowLabeledBy}${rowIndex} ${expandId}${rowIndex}`, onToggle, id: expandId + rowIndex, isOpen: rowData && rowData.isOpen}, value)
  };
};
var expandable = (value, {rowData}) => rowData && rowData.hasOwnProperty("parent") ? react.createElement(ExpandableRowContent, null, value) : value;
var expandedRow = (colSpan) => {
  const expandedRowFormatter = (value, {columnIndex, rowIndex, rowData, column: {extraParams: {contentId = "expanded-content"}}}) => value && rowData.hasOwnProperty("parent") && {
    colSpan: !rowData.cells || rowData.cells.length === 1 ? colSpan + !!rowData.fullWidth : 1,
    id: contentId + rowIndex + (columnIndex ? "-" + columnIndex : ""),
    className: rowData.noPadding && css(styles3.modifiers.noPadding)
  };
  return expandedRowFormatter;
};
var compoundExpand = (value, {rowIndex, columnIndex, rowData, column, property: property2}) => {
  if (!value) {
    return null;
  }
  const {title: title3, props} = value;
  const {extraParams: {onExpand}} = column;
  const extraData = {
    rowIndex,
    columnIndex,
    column,
    property: property2
  };
  function onToggle(event) {
    onExpand && onExpand(event, rowIndex, columnIndex, props.isOpen, rowData, extraData);
  }
  return {
    className: css(styles3.tableCompoundExpansionToggle, props.isOpen && styles3.modifiers.expanded),
    children: props.isOpen !== void 0 && react.createElement("button", {type: "button", className: css(styles3.tableButton), onClick: onToggle, "aria-expanded": props.isOpen, "aria-controls": props.ariaControls}, react.createElement(TableText, null, title3))
  };
};
var FavoritesCell = (_a) => {
  var {className = "", onFavorite, isFavorited, rowIndex} = _a, props = __rest(_a, ["className", "onFavorite", "isFavorited", "rowIndex"]);
  const ariaProps = rowIndex === void 0 ? {} : {
    id: `favorites-button-${rowIndex}`,
    "aria-labelledby": `favorites-button-${rowIndex}`
  };
  return react.createElement(Button, Object.assign({variant: "plain", className, type: "button", "aria-label": isFavorited ? "Starred" : "Not starred", onClick: onFavorite}, ariaProps, props), react.createElement(StarIcon, {"aria-hidden": true}));
};
FavoritesCell.displayName = "FavoritesCell";
var favoritable = (value, {rowIndex, columnIndex, rowData, column, property: property2}) => {
  const {extraParams: {onFavorite}} = column;
  const extraData = {
    rowIndex,
    columnIndex,
    column,
    property: property2
  };
  if (rowData && rowData.hasOwnProperty("parent") && !rowData.fullWidth) {
    return {
      component: "td",
      isVisible: true
    };
  }
  function favoritesClick(event) {
    onFavorite && onFavorite(event, rowData && !rowData.favorited, rowIndex, rowData, extraData);
  }
  const additionalProps = rowData.favoritesProps || {};
  return {
    className: css(styles3.tableFavorite, rowData && rowData.favorited && styles3.modifiers.favorited),
    isVisible: !rowData || !rowData.fullWidth,
    children: react.createElement(FavoritesCell, Object.assign({rowIndex, onFavorite: favoritesClick, isFavorited: rowData && rowData.favorited}, additionalProps))
  };
};
var DraggableCell = (_a) => {
  var {className, onClick, "aria-label": ariaLabel, id: id3} = _a, props = __rest(_a, ["className", "onClick", "aria-label", "id"]);
  return react.createElement(Button, Object.assign({id: id3, variant: "plain", className, type: "button", "aria-label": ariaLabel || `Draggable row draggable button`, onClick}, props), react.createElement(GripVerticalIcon, {"aria-hidden": true}));
};
DraggableCell.displayName = "DraggableCell";
var draggable = (value, {rowData}) => {
  const {id: id3} = rowData;
  return {
    className: "",
    children: react.createElement(DraggableCell, {id: id3})
  };
};
var treeRow = (onCollapse, onCheckChange, onToggleRowDetails) => (value, {rowIndex, rowData}) => {
  const {isExpanded, isDetailsExpanded, "aria-level": level2, "aria-setsize": setsize, toggleAriaLabel, checkAriaLabel, showDetailsAriaLabel, isChecked, checkboxId, icon} = rowData.props;
  const content2 = value.title || value;
  const text = react.createElement("div", {className: css(stylesTreeView.tableTreeViewText)}, icon && react.createElement("span", {className: css(stylesTreeView.tableTreeViewIcon)}, icon), react.createElement("span", {className: "pf-c-table__text"}, content2));
  const onChange = (isChecked2, event) => {
    onCheckChange(event, isChecked2, rowIndex, content2, rowData);
  };
  return {
    component: "th",
    className: "pf-c-table__tree-view-title-cell",
    children: level2 !== void 0 ? react.createElement("div", {className: css(stylesTreeView.tableTreeViewMain)}, setsize > 0 && react.createElement("span", {className: css(stylesTreeView.tableToggle)}, react.createElement(Button, {variant: "plain", onClick: (event) => onCollapse && onCollapse(event, rowIndex, content2, rowData), className: css(isExpanded && styles3.modifiers.expanded), "aria-expanded": isExpanded, "aria-label": toggleAriaLabel || `${isExpanded ? "Collapse" : "Expand"} row ${rowIndex}`}, react.createElement("div", {className: css(stylesTreeView.tableToggleIcon)}, react.createElement(AngleDownIcon, {"aria-hidden": "true"})))), !!onCheckChange && react.createElement("span", {className: css(stylesTreeView.tableCheck)}, react.createElement(Checkbox, {id: checkboxId || `checkbox_${rowIndex}`, "aria-label": checkAriaLabel || `Row ${rowIndex} checkbox`, isChecked, onChange})), text, !!onToggleRowDetails && react.createElement("span", {className: css(stylesTreeView.tableTreeViewDetailsToggle)}, react.createElement(Button, {variant: "plain", "aria-expanded": isDetailsExpanded, "aria-label": showDetailsAriaLabel || "Show row details", onClick: (event) => onToggleRowDetails && onToggleRowDetails(event, rowIndex, content2, rowData)}, react.createElement("span", {className: "pf-c-table__details-toggle-icon"}, react.createElement(EllipsisHIcon, {"aria-hidden": true}))))) : text
  };
};
var TdBase = (_a) => {
  var {children: children2, className, component = "td", dataLabel, textCenter = false, modifier, select: select3 = null, actions: actions2 = null, expand = null, treeRow: treeRowProp = null, compoundExpand: compoundExpandProp = null, noPadding, width: width2, visibility, innerRef, favorites = null, draggableRow: draggableRowProp = null} = _a, props = __rest(_a, ["children", "className", "component", "dataLabel", "textCenter", "modifier", "select", "actions", "expand", "treeRow", "compoundExpand", "noPadding", "width", "visibility", "innerRef", "favorites", "draggableRow"]);
  const selectParams = select3 ? selectable(children2, {
    rowIndex: select3.rowIndex,
    rowData: {
      selected: select3.isSelected,
      disableSelection: select3 === null || select3 === void 0 ? void 0 : select3.disable,
      props: select3 === null || select3 === void 0 ? void 0 : select3.props
    },
    column: {
      extraParams: {
        onSelect: select3 === null || select3 === void 0 ? void 0 : select3.onSelect,
        selectVariant: select3.variant || "checkbox"
      }
    }
  }) : null;
  const favoriteParams = favorites ? favoritable(null, {
    rowIndex: favorites === null || favorites === void 0 ? void 0 : favorites.rowIndex,
    rowData: {
      favorited: favorites.isFavorited,
      favoritesProps: favorites === null || favorites === void 0 ? void 0 : favorites.props
    },
    column: {
      extraParams: {
        onFavorite: favorites === null || favorites === void 0 ? void 0 : favorites.onFavorite
      }
    }
  }) : null;
  const draggableParams = draggableRowProp !== null ? draggable(null, {
    rowData: {
      id: draggableRowProp.id
    }
  }) : null;
  const actionParamsFunc = actions2 ? cellActions(actions2.items, null, null) : null;
  const actionParams = actionParamsFunc ? actionParamsFunc(null, {
    rowData: {
      disableActions: actions2 === null || actions2 === void 0 ? void 0 : actions2.disable
    },
    column: {
      extraParams: {
        dropdownPosition: actions2 === null || actions2 === void 0 ? void 0 : actions2.dropdownPosition,
        dropdownDirection: actions2 === null || actions2 === void 0 ? void 0 : actions2.dropdownDirection,
        actionsToggle: actions2 === null || actions2 === void 0 ? void 0 : actions2.actionsToggle
      }
    }
  }) : null;
  const expandableParams = expand !== null ? collapsible(null, {
    rowIndex: expand.rowIndex,
    columnIndex: expand === null || expand === void 0 ? void 0 : expand.columnIndex,
    rowData: {
      isOpen: expand.isExpanded
    },
    column: {
      extraParams: {
        onCollapse: expand === null || expand === void 0 ? void 0 : expand.onToggle
      }
    }
  }) : null;
  const compoundParams = compoundExpandProp !== null ? compoundExpand({
    title: children2,
    props: {
      isOpen: compoundExpandProp.isExpanded
    }
  }, {
    column: {
      extraParams: {
        onExpand: compoundExpandProp === null || compoundExpandProp === void 0 ? void 0 : compoundExpandProp.onToggle
      }
    }
  }) : null;
  const widthParams = width2 ? cellWidth(width2)() : null;
  const visibilityParams = visibility ? classNames(...visibility.map((vis) => Visibility[vis]))() : null;
  const treeRowParams = treeRowProp !== null ? treeRow(treeRowProp.onCollapse, treeRowProp.onCheckChange, treeRowProp.onToggleRowDetails)({
    title: children2
  }, {
    rowIndex: treeRowProp.rowIndex,
    rowData: {
      props: treeRowProp.props
    }
  }) : null;
  const merged = mergeProps2(selectParams, actionParams, expandableParams, compoundParams, widthParams, visibilityParams, favoriteParams, treeRowParams, draggableParams);
  const {
    isVisible = null,
    children: mergedChildren = null,
    className: mergedClassName = "",
    component: MergedComponent = component
  } = merged, mergedProps = __rest(merged, ["isVisible", "children", "className", "component"]);
  const treeTableTitleCell = className && className.includes("pf-c-table__tree-view-title-cell") || mergedClassName && mergedClassName.includes("pf-c-table__tree-view-title-cell");
  return react.createElement(MergedComponent, Object.assign({}, !treeTableTitleCell && {"data-label": dataLabel}, {className: css(className, textCenter && styles3.modifiers.center, noPadding && styles3.modifiers.noPadding, styles3.modifiers[modifier], draggableParams && styles3.tableDraggable, mergedClassName), ref: innerRef}, mergedProps, props), mergedChildren || children2);
};
var Td2 = react.forwardRef((props, ref) => react.createElement(TdBase, Object.assign({}, props, {innerRef: ref})));
Td2.displayName = "Td";
var TableDefaults = {
  renderers: {
    table: TableComposable,
    header: {
      wrapper: Thead,
      row: Tr,
      cell: Th2
    },
    body: {
      wrapper: Tbody,
      row: Tr,
      cell: Td2
    }
  }
};
var ProviderContext = react.createContext({
  columns: null,
  renderers: null
});
var Provider = class extends react.Component {
  render() {
    const _a = this.props, {columns, renderers, components: components3, children: children2} = _a, props = __rest(_a, ["columns", "renderers", "components", "children"]);
    let finalRenderers = renderers;
    if (components3) {
      console.warn("`components` have been deprecated in favor of `renderers` and will be removed in the next major version, please rename!");
      finalRenderers = components3;
    }
    const provider = react.createElement(renderers.table || TableDefaults.renderers.table, props, children2);
    return react.createElement(ProviderContext.Provider, {value: {
      columns,
      renderers: {
        table: finalRenderers.table || TableDefaults.renderers.table,
        header: Object.assign(Object.assign({}, TableDefaults.renderers.header), finalRenderers.header),
        body: Object.assign(Object.assign({}, TableDefaults.renderers.body), finalRenderers.body)
      }
    }}, provider);
  }
};
Provider.displayName = "Provider";
Provider.defaultProps = {
  renderers: TableDefaults.renderers
};
function evaluateFormatters(formatters) {
  return (value, extra) => formatters.reduce((parameters, formatter) => ({
    value: formatter(parameters.value, parameters.extra),
    extra
  }), {value, extra}).value;
}
function evaluateTransforms(transforms = [], value, extraParameters = {}) {
  if (transforms.length === 0) {
    return {};
  }
  return mergeProps2(...transforms.map((transform3) => transform3(value, extraParameters)));
}
var HeaderRow = ({rowData, rowIndex, renderers, onRow = () => ({})}) => react.createElement(renderers.row, onRow(rowData, {rowIndex}), rowData.map((column, columnIndex) => {
  const {property: property2, header = {}, props = {}} = column;
  const evaluatedProperty = property2 || header && header.property;
  const {label: label2, transforms = [], formatters = [], info: info2 = {}} = header;
  const extraParameters = {
    columnIndex,
    property: evaluatedProperty,
    column
  };
  const transformedProps = evaluateTransforms(transforms, label2, extraParameters);
  if (!transformedProps) {
    console.warn("Table.Header - Failed to receive a transformed result");
  }
  let cellNode;
  const {tooltip: tooltip2, tooltipProps, popover: popover2, popoverProps, ariaLabel, className} = info2;
  if (tooltip2) {
    cellNode = react.createElement(HeaderCellInfoWrapper, {variant: "tooltip", info: tooltip2, tooltipProps, ariaLabel, className}, transformedProps.children || evaluateFormatters(formatters)(label2, extraParameters));
  } else if (popover2) {
    cellNode = react.createElement(HeaderCellInfoWrapper, {variant: "popover", info: popover2, popoverProps, ariaLabel, className}, transformedProps.children || evaluateFormatters(formatters)(label2, extraParameters));
  } else {
    cellNode = transformedProps.children || evaluateFormatters(formatters)(label2, extraParameters);
  }
  return react.createElement(renderers.cell, Object.assign({key: `${columnIndex}-header`}, mergeProps2(props, header && header.props, transformedProps)), cellNode);
}));
HeaderRow.displayName = "HeaderRow";
var BaseHeader = class extends react.Component {
  render() {
    const _a = this.props, {children: children2, headerRows, onRow, renderers, columns} = _a, props = __rest(_a, ["children", "headerRows", "onRow", "renderers", "columns"]);
    return react.createElement(renderers.header.wrapper, props, [
      (headerRows || [columns]).map((rowData, rowIndex) => react.createElement(HeaderRow, {
        key: `${rowIndex}-header-row`,
        renderers: renderers.header,
        onRow,
        rowData,
        rowIndex
      }))
    ].concat(children2));
  }
};
var Header2 = (props) => react.createElement(ProviderContext.Consumer, null, ({columns, renderers}) => react.createElement(BaseHeader, Object.assign({columns, renderers}, props)));
function isEqual2(value, other) {
  return _baseIsEqual(value, other);
}
var isEqual_1 = isEqual2;
function resolveRowKey({rowData, rowIndex, rowKey}) {
  if (typeof rowKey === "function") {
    return `${rowKey({rowData, rowIndex})}-row`;
  }
  if (rowData[rowKey] === 0) {
    return `${rowData[rowKey]}-row`;
  }
  return `${rowData[rowKey] || rowIndex}-row`;
}
function isEqualWith(value, other, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  var result = customizer ? customizer(value, other) : void 0;
  return result === void 0 ? _baseIsEqual(value, other, void 0, customizer) : !!result;
}
var isEqualWith_1 = isEqualWith;
function columnsAreEqual(oldColumns, newColumns) {
  return isEqualWith_1(oldColumns, newColumns, (a2, b3) => {
    if (typeof a2 === "function" && typeof b3 === "function") {
      return a2 === b3;
    }
    return void 0;
  });
}
var BodyRow = class extends react.Component {
  shouldComponentUpdate(nextProps) {
    const {columns, rowData} = this.props;
    const {renderers} = nextProps;
    if (renderers && renderers.row && renderers.row.shouldComponentUpdate) {
      if (typeof renderers.row.shouldComponentUpdate === "function") {
        return renderers.row.shouldComponentUpdate.call(this, nextProps, {}, {});
      }
      return true;
    }
    return !(columnsAreEqual(columns, nextProps.columns) && isEqual_1(rowData, nextProps.rowData));
  }
  render() {
    const {columns, renderers, onRow, rowKey, rowIndex, rowData} = this.props;
    return react.createElement(renderers.row, onRow(rowData, {rowIndex, rowKey}), columns.map((column, columnIndex) => {
      const {property: property2, cell, props} = column;
      const evaluatedProperty = property2 || cell && cell.property;
      const {transforms = [], formatters = []} = cell || {};
      const extraParameters = {
        columnIndex,
        property: evaluatedProperty,
        column,
        rowData,
        rowIndex,
        rowKey
      };
      const transformed = evaluateTransforms(transforms, rowData[evaluatedProperty], extraParameters);
      if (!transformed) {
        console.warn("Table.Body - Failed to receive a transformed result");
      }
      let additionalFormaters = [];
      if (rowData[evaluatedProperty]) {
        additionalFormaters = rowData[evaluatedProperty].formatters;
      }
      return react.createElement(renderers.cell, Object.assign({key: `col-${columnIndex}-row-${rowIndex}`}, mergeProps2(props, cell && cell.props, transformed)), !rowData.fullWidth && transformed.children || evaluateFormatters([...formatters, ...additionalFormaters])(rowData[`_${evaluatedProperty}`] || rowData[evaluatedProperty], extraParameters));
    }));
  }
};
BodyRow.displayName = "BodyRow";
BodyRow.defaultProps = {
  onRow: (...args) => ({})
};
var BaseBody = class extends react.Component {
  constructor() {
    super(...arguments);
    this.omitOnRow = (props) => {
      const ret = __rest(props, ["onRow"]);
      return ret;
    };
  }
  shouldComponentUpdate(nextProps) {
    const {renderers} = nextProps;
    if (renderers && renderers.body && renderers.body.wrapper && renderers.body.wrapper.shouldComponentUpdate) {
      if (typeof renderers.body.wrapper.shouldComponentUpdate === "function") {
        return renderers.body.wrapper.shouldComponentUpdate.call(this, nextProps, {}, {});
      }
      return true;
    }
    return !isEqual_1(this.omitOnRow(this.props), this.omitOnRow(nextProps));
  }
  render() {
    const _a = this.props, {onRow, rows, rowKey, columns, renderers} = _a, props = __rest(_a, ["onRow", "rows", "rowKey", "columns", "renderers"]);
    const children2 = rows.map((rowData, index3) => {
      const key = resolveRowKey({rowData, rowIndex: index3, rowKey});
      return react.createElement(BodyRow, {
        key,
        renderers: renderers.body,
        onRow,
        rowKey: key,
        rowIndex: index3,
        rowData,
        columns
      });
    });
    return react.createElement(renderers.body.wrapper, props, children2);
  }
};
BaseBody.defaultProps = {
  onRow: (...args) => ({})
};
var Body = (props) => react.createElement(ProviderContext.Consumer, null, ({columns, renderers}) => react.createElement(BaseBody, Object.assign({columns, renderers}, props)));
var BodyCell = (_a) => {
  var {
    "data-label": dataLabel = "",
    className = "",
    colSpan,
    component = "td",
    isVisible,
    parentId: parentId2,
    textCenter = false,
    tooltip: tooltipProp = "",
    onMouseEnter: onMouseEnterProp = () => {
    },
    children: children2,
    errorText,
    isValid,
    isOpen,
    ariaControls,
    editableValue,
    editableSelectProps,
    options,
    isSelectOpen,
    value,
    name
  } = _a, props = __rest(_a, ["data-label", "className", "colSpan", "component", "isVisible", "parentId", "textCenter", "tooltip", "onMouseEnter", "children", "errorText", "isValid", "isOpen", "ariaControls", "editableValue", "editableSelectProps", "options", "isSelectOpen", "value", "name"]);
  const [tooltip2, setTooltip] = react.useState("");
  const onMouseEnter = (event) => {
    if (event.target.offsetWidth < event.target.scrollWidth) {
      if (tooltipProp) {
        setTooltip(tooltipProp);
      } else if (typeof children2 === "string") {
        setTooltip(children2);
      }
    } else {
      setTooltip("");
    }
    onMouseEnterProp(event);
  };
  let isEmptyStateCell = false;
  if (children2) {
    isEmptyStateCell = children2.type === Bullseye && children2.props.children && children2.props.children.type === EmptyState || children2.type === EmptyState;
  }
  const cell = react.createElement(Td2, Object.assign({className, component, dataLabel: dataLabel && parentId2 == null && !isEmptyStateCell ? dataLabel : null, onMouseEnter, textCenter, colSpan}, props), children2);
  const bodyCell = tooltip2 !== "" ? react.createElement(Tooltip, {content: tooltip2, isVisible: true}, cell) : cell;
  return parentId2 !== void 0 && colSpan === void 0 || !isVisible ? null : bodyCell;
};
BodyCell.displayName = "BodyCell";
var HeaderCell = (_a) => {
  var {
    className = "",
    component = "th",
    scope = "",
    textCenter = false,
    tooltip: tooltip2 = "",
    onMouseEnter = () => {
    },
    children: children2,
    isVisible,
    dataLabel = ""
  } = _a, props = __rest(_a, ["className", "component", "scope", "textCenter", "tooltip", "onMouseEnter", "children", "isVisible", "dataLabel"]);
  return react.createElement(Th2, Object.assign({}, props, {scope, tooltip: tooltip2, onMouseEnter, textCenter, component, className}), children2);
};
HeaderCell.displayName = "HeaderCell";
var RowWrapper = class extends react.Component {
  constructor(props) {
    super(props);
    this.handleScroll = (event) => {
      if (!this._unmounted) {
        this.props.onScroll(event);
      }
    };
    this.handleResize = (event) => {
      if (!this._unmounted) {
        this.props.onResize(event);
      }
    };
    if (props.onScroll) {
      this.handleScroll = debounce(this.handleScroll, 100);
    }
    if (props.onResize) {
      this.handleResize = debounce(this.handleResize, 100);
    }
  }
  componentDidMount() {
    this._unmounted = false;
    if (canUseDOM) {
      if (this.props.onScroll) {
        window.addEventListener("scroll", this.handleScroll);
      }
      if (this.props.onResize) {
        window.addEventListener("resize", this.handleResize);
      }
    }
  }
  componentWillUnmount() {
    this._unmounted = true;
    if (canUseDOM) {
      if (this.props.onScroll) {
        window.removeEventListener("scroll", this.handleScroll);
      }
      if (this.props.onResize) {
        window.removeEventListener("resize", this.handleResize);
      }
    }
  }
  render() {
    const _a = this.props, {
      onScroll,
      onResize,
      row: {isExpanded, isEditable},
      rowProps,
      trRef,
      className,
      ouiaId
    } = _a, props = __rest(_a, ["onScroll", "onResize", "row", "rowProps", "trRef", "className", "ouiaId"]);
    return react.createElement(Tr, Object.assign({}, props, {ref: trRef, isExpanded, isEditable, className, ouiaId}));
  }
};
RowWrapper.displayName = "RowWrapper";
RowWrapper.defaultProps = {
  className: "",
  row: {
    isOpen: void 0,
    isExpanded: void 0,
    isHeightAuto: void 0,
    isEditable: void 0
  },
  rowProps: null
};
var emptyTD = () => ({
  component: "td"
});
var scopeColTransformer = () => ({
  scope: "col"
});
var emptyCol = (label2) => Object.assign({}, label2 ? {} : {scope: ""});
var parentId = (_value, {rowData}) => ({
  parentId: rowData.parent
});
var mapProps = (_label, {property: property2, rowData}) => Object.assign({}, rowData[property2] && rowData[property2].props);
var EditColumn = (_a) => {
  var {
    onClick = null,
    className = "",
    editing,
    valid,
    saveAriaLabel,
    cancelAriaLabel,
    editAriaLabel
  } = _a, props = __rest(_a, ["onClick", "className", "editing", "valid", "saveAriaLabel", "cancelAriaLabel", "editAriaLabel"]);
  return react.createElement(react.Fragment, null, react.createElement("div", {className: css(inlineStyles.inlineEditGroup, inlineStyles.modifiers.iconGroup, "pf-m-action-group")}, react.createElement("div", {className: css(inlineStyles.inlineEditAction)}, react.createElement(Button, Object.assign({"aria-label": saveAriaLabel}, props, {onClick: (e3) => onClick(e3, "save"), variant: "plain"}), react.createElement(CheckIcon, null))), react.createElement("div", {className: css(inlineStyles.inlineEditAction)}, react.createElement(Button, Object.assign({"aria-label": cancelAriaLabel}, props, {onClick: (e3) => onClick(e3, "cancel"), variant: "plain"}), react.createElement(TimesIcon, null)))), react.createElement("div", {className: css(inlineStyles.inlineEditAction, inlineStyles.modifiers.enableEditable)}, react.createElement(Button, Object.assign({"aria-label": editAriaLabel}, props, {onClick: (e3) => onClick(e3, "edit"), variant: "plain"}), react.createElement(PencilAltIcon, null))));
};
EditColumn.displayName = "EditColumn";
var editable = (label2, {rowIndex, rowData, column}) => {
  const {extraParams: {onRowEdit}} = column;
  const toggleEditMode = (event, type) => {
    let validationErrors = {};
    if (type === "save") {
      validationErrors = rowData.rowEditValidationRules && rowData.rowEditValidationRules.reduce((acc, rule) => {
        const invalidCells = rowData.cells.filter((cellData) => {
          const testValue = cellData.props.editableValue === "" ? "" : cellData.props.editableValue || cellData.props.value;
          let failedValidation = false;
          if (Array.isArray(testValue) && testValue.length) {
            failedValidation = testValue.reduce((hasInvalidSelection, el) => {
              if (hasInvalidSelection === true) {
                return true;
              }
              return !rule.validator(el);
            }, failedValidation);
          } else if (Array.isArray(testValue) && !testValue.length) {
            failedValidation = !rule.validator("");
          } else {
            failedValidation = !rule.validator(testValue);
          }
          if (failedValidation) {
            cellData.props.isValid = false;
          }
          return failedValidation;
        });
        if (invalidCells.length) {
          acc[rule.name] = invalidCells.map((cell) => cell.props.name);
        }
        return acc;
      }, {});
    }
    onRowEdit(event, type, rowData && rowData.isEditable, rowIndex, validationErrors);
  };
  function getAriaLabelTxt(identifier, actionType) {
    let result;
    switch (actionType) {
      case "cancel":
        result = `Cancel row edits for row ${identifier}`;
        break;
      case "save":
        result = `Save row edits for row ${identifier}`;
        break;
      default:
        result = `Place row ${identifier} in edit mode`;
    }
    return result;
  }
  return {
    className: styles3.tableInlineEditAction,
    component: "td",
    isVisible: true,
    children: react.createElement(EditColumn, {saveAriaLabel: rowData && rowData.rowSaveBtnAriaLabel && rowData.rowSaveBtnAriaLabel(rowIndex) || getAriaLabelTxt(rowIndex, "save"), cancelAriaLabel: rowData && rowData.rowCancelBtnAriaLabel && rowData.rowCancelBtnAriaLabel(rowIndex) || getAriaLabelTxt(rowIndex, "cancel"), editAriaLabel: rowData && rowData.rowEditBtnAriaLabel && rowData.rowEditBtnAriaLabel(rowIndex) || getAriaLabelTxt(rowIndex, "edit"), valid: rowData && rowData.isValid, editing: rowData && rowData.isEditable, onClick: toggleEditMode})
  };
};
var wrappable = () => ({
  className: styles3.modifiers.wrap
});
var defaultTitle = (data) => data && data.hasOwnProperty("title") ? data.title : data;
var generateHeader = ({transforms: origTransforms, formatters: origFormatters, columnTransforms, header}, title3) => Object.assign(Object.assign({}, header), {label: title3, transforms: [
  scopeColTransformer,
  emptyCol,
  ...origTransforms || [],
  ...columnTransforms || [],
  ...header && header.hasOwnProperty("transforms") ? header.transforms : []
], formatters: [...origFormatters || [], ...header && header.hasOwnProperty("formatters") ? header.formatters : []]});
var generateCell = ({cellFormatters, cellTransforms, columnTransforms, cell}, extra) => Object.assign(Object.assign({}, cell), {transforms: [
  ...cellTransforms || [],
  ...columnTransforms || [],
  ...cell && cell.hasOwnProperty("transforms") ? cell.transforms : [],
  mapProps
], formatters: [
  defaultTitle,
  ...cellFormatters || [],
  ...cell && cell.hasOwnProperty("formatters") ? cell.formatters : []
]});
var mapHeader = (column, extra, key, ...props) => {
  const title3 = column.hasOwnProperty("title") ? column.title : column;
  let dataLabel = `column-${key}`;
  if (column.hasOwnProperty("dataLabel")) {
    dataLabel = column.dataLabel;
  } else if (typeof title3 === "string") {
    dataLabel = title3;
  }
  return {
    property: typeof title3 === "string" && title3.toLowerCase().trim().replace(/\s/g, "-") || `column-${key}`,
    extraParams: extra,
    data: column.data,
    header: generateHeader(column, title3),
    cell: generateCell(column),
    props: Object.assign(Object.assign({"data-label": dataLabel, "data-key": key}, column.hasOwnProperty("props") ? column.props : {}), props)
  };
};
var selectableTransforms = ({onSelect, canSelectAll}) => [
  ...onSelect ? [
    {
      title: "",
      transforms: canSelectAll && [selectable] || null,
      cellTransforms: [selectable]
    }
  ] : []
];
var favoritesTransforms = ({onFavorite, onSort, sortBy: sortBy2, canSortFavorites, firstUserColumnIndex}) => [
  ...onFavorite ? [
    {
      title: "",
      transforms: onSort && canSortFavorites ? [
        sortableFavorites({
          onSort,
          columnIndex: firstUserColumnIndex - 1,
          sortBy: sortBy2
        })
      ] : [emptyTD],
      cellTransforms: [favoritable]
    }
  ] : []
];
var actionsTransforms = ({actions: actions2, actionResolver, areActionsDisabled}) => [
  ...actionResolver || actions2 ? [
    {
      title: "",
      transforms: [emptyTD],
      cellTransforms: [cellActions(actions2, actionResolver, areActionsDisabled)]
    }
  ] : []
];
var collapsibleTransforms = (header, {onCollapse}) => [
  ...onCollapse ? [
    {
      title: "",
      transforms: [emptyTD],
      cellTransforms: [collapsible, expandedRow(header.length)]
    }
  ] : []
];
var addAdditionalCellTranforms = (cell, additional) => Object.assign(Object.assign({}, cell.hasOwnProperty("title") ? cell : {title: cell}), {cellTransforms: [...cell.hasOwnProperty("cellTransforms") ? cell.cellTransforms : [], additional]});
var expandContent = (header, extra) => {
  if (!extra.onCollapse && !extra.onExpand) {
    return header;
  }
  return header.map((cell) => {
    const parentIdCell = addAdditionalCellTranforms(cell, parentId);
    return addAdditionalCellTranforms(parentIdCell, expandedRow(header.length));
  });
};
var mapOpenedRows = (rows, children2) => rows.reduce((acc, curr, key) => {
  if (curr.hasOwnProperty("parent")) {
    const parent = acc.length > 0 && acc[acc.length - 1];
    if (parent) {
      acc[acc.length - 1].rows = [...acc[acc.length - 1].rows, children2[key]];
      if (curr.hasOwnProperty("compoundParent")) {
        acc[acc.length - 1].isOpen = acc[acc.length - 1].rows.some((oneRow) => oneRow.props.rowData.cells.some((oneCell) => oneCell.props && oneCell.props.isOpen));
      }
    }
  } else {
    acc = [...acc, Object.assign(Object.assign({}, curr), {rows: [children2[key]]})];
  }
  return acc;
}, []);
var rowEditTransforms = ({onRowEdit}) => [
  ...onRowEdit ? [
    {
      title: "",
      cellTransforms: [editable]
    }
  ] : []
];
var calculateColumns = (headerRows, extra) => headerRows && [
  ...collapsibleTransforms(headerRows, extra),
  ...selectableTransforms(extra),
  ...favoritesTransforms(extra),
  ...expandContent(headerRows, extra),
  ...rowEditTransforms(extra),
  ...actionsTransforms(extra)
].map((oneCol, key) => Object.assign({}, mapHeader(oneCol, extra, key)));
var BodyWrapper = (_a) => {
  var {
    mappedRows,
    tbodyRef,
    rows = [],
    onCollapse,
    headerRows
  } = _a, props = __rest(_a, ["mappedRows", "tbodyRef", "rows", "onCollapse", "headerRows"]);
  if (mappedRows && mappedRows.some((row) => row.hasOwnProperty("parent"))) {
    return react.createElement(react.Fragment, null, mapOpenedRows(mappedRows, props.children).map((oneRow, key) => react.createElement(Tbody, Object.assign({}, props, {isExpanded: oneRow.isOpen, key: `tbody-${key}`, ref: tbodyRef}), oneRow.rows)));
  }
  return react.createElement(Tbody, Object.assign({}, props, {ref: tbodyRef}));
};
BodyWrapper.displayName = "BodyWrapper";
var TableContext = react.createContext({
  headerData: null,
  headerRows: null,
  rows: []
});
var TreeRowWrapper = (_a) => {
  var {
    className,
    rowProps,
    row
  } = _a, props = __rest(_a, ["className", "rowProps", "row"]);
  const {"aria-level": level2, "aria-posinset": posinset, "aria-setsize": setsize, isExpanded, isDetailsExpanded, isHidden: isHidden3} = row.props;
  return react.createElement(Tr, Object.assign({"aria-level": level2, "aria-posinset": posinset, "aria-setsize": setsize, "aria-expanded": !!isExpanded, isHidden: isHidden3, className: css(className, isExpanded && styles3.modifiers.expanded, isDetailsExpanded && stylesTreeView.modifiers.treeViewDetailsExpanded)}, props));
};
TreeRowWrapper.displayName = "TreeRowWrapper";
var Table = class extends react.Component {
  constructor() {
    super(...arguments);
    this.state = {
      ouiaStateId: getDefaultOUIAId(Table.displayName)
    };
    this.isSelected = (row) => row.selected === true;
    this.areAllRowsSelected = (rows) => {
      if (rows === void 0 || rows.length === 0) {
        return false;
      }
      return rows.every((row) => this.isSelected(row) || row.hasOwnProperty("parent") && !row.showSelect);
    };
  }
  componentDidMount() {
    if (this.props.onRowEdit && false) {
      console.warn("You are using a beta component feature (onRowEdit). These api parts are subject to change in the future.");
      Table.hasWarnBeta = true;
    }
  }
  render() {
    const _a = this.props, {"aria-label": ariaLabel, caption, header, onSort, onSelect, canSelectAll, selectVariant, sortBy: sortBy2, children: children2, actions: actions2, actionResolver, areActionsDisabled, onCollapse, onExpand, onRowEdit, rowLabeledBy, dropdownPosition, dropdownDirection, actionsToggle, contentId, expandId, variant, rows, cells, bodyWrapper, rowWrapper, role, borders, onFavorite, canSortFavorites} = _a, props = __rest(_a, ["aria-label", "caption", "header", "onSort", "onSelect", "canSelectAll", "selectVariant", "sortBy", "children", "actions", "actionResolver", "areActionsDisabled", "onCollapse", "onExpand", "onRowEdit", "rowLabeledBy", "dropdownPosition", "dropdownDirection", "actionsToggle", "contentId", "expandId", "variant", "rows", "cells", "bodyWrapper", "rowWrapper", "role", "borders", "onFavorite", "canSortFavorites"]);
    if (!ariaLabel && !caption && !header && role !== "presentation") {
      console.error("Table: Specify at least one of: header, caption, aria-label");
    }
    const headerData = calculateColumns(cells, {
      sortBy: sortBy2,
      onSort,
      onSelect,
      canSelectAll: selectVariant === RowSelectVariant.radio ? false : canSelectAll,
      selectVariant,
      allRowsSelected: onSelect ? this.areAllRowsSelected(rows) : false,
      actions: actions2,
      actionResolver,
      areActionsDisabled,
      onCollapse,
      onRowEdit,
      onExpand,
      rowLabeledBy,
      expandId,
      contentId,
      dropdownPosition,
      dropdownDirection,
      actionsToggle,
      onFavorite,
      canSortFavorites,
      firstUserColumnIndex: [onCollapse, onSelect, onFavorite].filter((callback) => callback).length
    });
    const table2 = react.createElement(TableContext.Provider, {value: {
      headerData,
      headerRows: null,
      rows
    }}, header, react.createElement(Provider, Object.assign({}, props, {"aria-label": ariaLabel, renderers: {
      body: {
        wrapper: bodyWrapper || BodyWrapper,
        row: rowWrapper || (this.props.isTreeTable ? TreeRowWrapper : RowWrapper),
        cell: BodyCell
      },
      header: {
        cell: HeaderCell
      }
    }, columns: headerData, role, variant, borders}), caption && react.createElement("caption", null, caption), children2));
    if (onRowEdit) {
      return react.createElement("form", {className: css(inlineStyles.inlineEdit)}, table2);
    }
    return table2;
  }
};
Table.displayName = "Table";
Table.hasWarnBeta = false;
Table.defaultProps = {
  children: null,
  className: "",
  variant: null,
  borders: true,
  rowLabeledBy: "simple-node",
  expandId: "expandable-toggle",
  contentId: "expanded-content",
  dropdownPosition: DropdownPosition.right,
  dropdownDirection: DropdownDirection.down,
  header: void 0,
  caption: void 0,
  "aria-label": void 0,
  gridBreakPoint: TableGridBreakpoint.gridMd,
  role: "grid",
  canSelectAll: true,
  selectVariant: "checkbox",
  ouiaSafe: true,
  isStickyHeader: false,
  canSortFavorites: true,
  isTreeTable: false
};
var flagVisibility = (rows) => {
  const visibleRows = rows.filter((oneRow) => !oneRow.parent || oneRow.isExpanded);
  if (visibleRows.length > 0) {
    visibleRows[0].isFirstVisible = true;
    visibleRows[visibleRows.length - 1].isLastVisible = true;
  }
};
var ContextBody = class extends react.Component {
  constructor() {
    super(...arguments);
    this.onRow = (row, rowProps) => {
      const {onRowClick, onRow} = this.props;
      const extendedRowProps = Object.assign(Object.assign({}, rowProps), onRow ? onRow(row, rowProps) : {});
      return {
        row,
        rowProps: extendedRowProps,
        onMouseDown: (event) => {
          const computedData = {
            isInput: event.target.tagName !== "INPUT",
            isButton: event.target.tagName !== "BUTTON"
          };
          onRowClick(event, row, rowProps, computedData);
        }
      };
    };
    this.mapCells = (headerData, row, rowKey) => {
      const {firstUserColumnIndex} = headerData[0].extraParams;
      const isFullWidth = row && row.fullWidth;
      let additionalColsIndexShift = isFullWidth ? 0 : firstUserColumnIndex;
      return Object.assign({}, row && (row.cells || row).reduce((acc, cell, cellIndex) => {
        const isCellObject = cell === Object(cell);
        const isCellFunction = cell && typeof cell.title === "function";
        let formatters = [];
        if (isCellObject && cell.formatters) {
          formatters = cell.formatters;
        } else if (isFullWidth && cellIndex < firstUserColumnIndex) {
          formatters = headerData[firstUserColumnIndex].cell.formatters;
        }
        let mappedCellTitle = cell;
        if (isCellObject && isCellFunction) {
          mappedCellTitle = cell.title(cell.props.value, rowKey, cellIndex, cell.props);
        } else if (isCellObject) {
          mappedCellTitle = cell.title;
        }
        const mappedCell = {
          [headerData[cellIndex + additionalColsIndexShift].property]: {
            title: mappedCellTitle,
            formatters,
            props: Object.assign({isVisible: true}, isCellObject ? cell.props : null)
          }
        };
        if (isCellObject && cell.props && cell.props.colSpan) {
          additionalColsIndexShift += cell.props.colSpan - 1;
        }
        return Object.assign(Object.assign({}, acc), mappedCell);
      }, {secretTableRowKeyId: row.id !== void 0 ? row.id : rowKey}));
    };
  }
  render() {
    const _a = this.props, {className, headerData, rows, rowKey, children: children2, onRowClick} = _a, props = __rest(_a, ["className", "headerData", "rows", "rowKey", "children", "onRowClick"]);
    let mappedRows;
    if (headerData.length > 0) {
      mappedRows = rows.map((oneRow, oneRowKey) => Object.assign(Object.assign(Object.assign({}, oneRow), this.mapCells(headerData, oneRow, oneRowKey)), {isExpanded: isRowExpanded(oneRow, rows), isHeightAuto: oneRow.heightAuto || false, isFirst: oneRowKey === 0, isLast: oneRowKey === rows.length - 1, isFirstVisible: false, isLastVisible: false}));
      flagVisibility(mappedRows);
    }
    return react.createElement(react.Fragment, null, mappedRows && react.createElement(Body, Object.assign({}, props, {mappedRows, rows: mappedRows, onRow: this.onRow, rowKey, className})));
  }
};
var TableBody = (_a) => {
  var {
    className = "",
    children: children2 = null,
    rowKey = "secretTableRowKeyId",
    onRow = (...args) => ({}),
    onRowClick = (event, row, rowProps, computedData) => void 0
  } = _a, props = __rest(_a, ["className", "children", "rowKey", "onRow", "onRowClick"]);
  return react.createElement(TableContext.Consumer, null, (_a2) => {
    var {headerData = [], rows = []} = _a2, rest = __rest(_a2, ["headerData", "rows"]);
    return react.createElement(ContextBody, Object.assign({headerData, rows, onRow, className, rowKey, onRowClick}, props, rest), children2);
  });
};
var ContextHeader = (_a) => {
  var {className = "", headerRows = void 0} = _a, props = __rest(_a, ["className", "headerRows"]);
  return react.createElement(Header2, Object.assign({}, props, {headerRows, className}));
};
var TableHeader = (_a) => {
  var props = __rest(_a, []);
  return react.createElement(TableContext.Consumer, null, ({headerRows}) => react.createElement(ContextHeader, Object.assign({}, props, {headerRows})));
};
TableHeader.displayName = "TableHeader";

// build/components/table-toolbar/TableToolbar.js
var TableToolbar = ({
  toolbarItem,
  subToolbar,
  toolbarItemFooter,
  children: children2,
  searchTypeComponent,
  inputGroupName,
  inputGroupPlaceholder,
  inputGroupOnChange,
  inputGroupOnEnter
}) => {
  const {t: t4} = useTranslation();
  const [searchValue, setSearchValue] = useState("");
  const onSearch = () => {
    if (searchValue !== "") {
      setSearchValue(searchValue);
      inputGroupOnEnter && inputGroupOnEnter(searchValue);
    } else {
      setSearchValue("");
      inputGroupOnEnter && inputGroupOnEnter("");
    }
  };
  const handleKeyDown = (e3) => {
    if (e3.key === "Enter") {
      onSearch();
    }
  };
  const handleInputChange = (value, event) => {
    inputGroupOnChange && inputGroupOnChange(value, event);
    setSearchValue(value);
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Toolbar, null, /* @__PURE__ */ react.createElement(ToolbarContent, null, /* @__PURE__ */ react.createElement(Fragment, null, inputGroupName && /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(InputGroup, null, searchTypeComponent, inputGroupPlaceholder && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(TextInput, {
    name: inputGroupName,
    id: inputGroupName,
    type: "search",
    "aria-label": t4("search"),
    placeholder: inputGroupPlaceholder,
    onChange: handleInputChange,
    onKeyDown: handleKeyDown
  }), /* @__PURE__ */ react.createElement(Button, {
    variant: ButtonVariant.control,
    "aria-label": t4("search"),
    onClick: onSearch
  }, /* @__PURE__ */ react.createElement(SearchIcon, null)))))), toolbarItem)), subToolbar && /* @__PURE__ */ react.createElement(Toolbar, null, /* @__PURE__ */ react.createElement(ToolbarContent, null, subToolbar)), /* @__PURE__ */ react.createElement(Divider, null), children2, /* @__PURE__ */ react.createElement(Toolbar, null, toolbarItemFooter));
};

// build/components/table-toolbar/PaginatingTableToolbar.js
var PaginatingTableToolbar = ({
  count,
  first,
  max: max2,
  onNextClick,
  onPreviousClick,
  onPerPageSelect,
  searchTypeComponent,
  toolbarItem,
  subToolbar,
  children: children2,
  inputGroupName,
  inputGroupPlaceholder,
  inputGroupOnChange,
  inputGroupOnEnter
}) => {
  const page2 = Math.round(first / max2);
  const pagination2 = (variant = "top") => /* @__PURE__ */ react.createElement(Pagination, {
    isCompact: true,
    toggleTemplate: ({firstIndex, lastIndex}) => /* @__PURE__ */ react.createElement("b", null, firstIndex, " - ", lastIndex),
    itemCount: count + page2 * max2,
    page: page2 + 1,
    perPage: max2,
    onNextClick: (_23, p3) => onNextClick((p3 - 1) * max2),
    onPreviousClick: (_23, p3) => onPreviousClick((p3 - 1) * max2),
    onPerPageSelect: (_23, m3, f3) => onPerPageSelect(f3 - 1, m3),
    variant
  });
  return /* @__PURE__ */ react.createElement(TableToolbar, {
    searchTypeComponent,
    toolbarItem: /* @__PURE__ */ react.createElement(react.Fragment, null, toolbarItem, count !== 0 && /* @__PURE__ */ react.createElement(ToolbarItem, {
      variant: "pagination"
    }, pagination2())),
    subToolbar,
    toolbarItemFooter: count !== 0 ? /* @__PURE__ */ react.createElement(ToolbarItem, null, pagination2("bottom")) : /* @__PURE__ */ react.createElement(react.Fragment, null),
    inputGroupName,
    inputGroupPlaceholder,
    inputGroupOnChange,
    inputGroupOnEnter
  }, children2);
};

// build/components/list-empty-state/ListEmptyState.js
var ListEmptyState = ({
  message,
  instructions,
  onPrimaryAction,
  hasIcon = true,
  isSearchVariant,
  primaryActionText,
  secondaryActions,
  icon
}) => {
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(EmptyState, {
    "data-testid": "empty-state",
    variant: "large"
  }, hasIcon && isSearchVariant ? /* @__PURE__ */ react.createElement(EmptyStateIcon, {
    icon: SearchIcon
  }) : hasIcon && /* @__PURE__ */ react.createElement(EmptyStateIcon, {
    icon: icon ? icon : PlusCircleIcon
  }), /* @__PURE__ */ react.createElement(Title, {
    headingLevel: "h1",
    size: "lg"
  }, message), /* @__PURE__ */ react.createElement(EmptyStateBody, null, instructions), primaryActionText && /* @__PURE__ */ react.createElement(Button, {
    "data-testid": `${message.replace(/\W+/g, "-").toLowerCase()}-empty-action`,
    variant: "primary",
    onClick: onPrimaryAction
  }, primaryActionText), secondaryActions && /* @__PURE__ */ react.createElement(EmptyStateSecondaryActions, null, secondaryActions.map((action) => /* @__PURE__ */ react.createElement(Button, {
    key: action.text,
    variant: action.type || ButtonVariant.secondary,
    onClick: action.onClick
  }, action.text)))));
};

// build/components/table-toolbar/KeycloakDataTable.js
function DataTable({
  columns,
  rows,
  actions: actions2,
  actionResolver,
  ariaLabelKey,
  onSelect,
  onCollapse,
  canSelectAll,
  isNotCompact,
  isRadio: isRadio3,
  ...props
}) {
  const {t: t4} = useTranslation();
  return /* @__PURE__ */ react.createElement(Table, {
    ...props,
    variant: isNotCompact ? void 0 : TableVariant.compact,
    onSelect: onSelect ? (_23, isSelected, rowIndex) => onSelect(isSelected, rowIndex) : void 0,
    onCollapse: onCollapse ? (_23, rowIndex, isOpen) => onCollapse(isOpen, rowIndex) : void 0,
    selectVariant: isRadio3 ? "radio" : "checkbox",
    canSelectAll,
    cells: columns.map((column) => {
      return {...column, title: t4(column.displayKey || column.name)};
    }),
    rows,
    actions: actions2,
    actionResolver,
    "aria-label": t4(ariaLabelKey)
  }, /* @__PURE__ */ react.createElement(TableHeader, null), /* @__PURE__ */ react.createElement(TableBody, null));
}
function KeycloakDataTable({
  ariaLabelKey,
  searchPlaceholderKey,
  isPaginated = false,
  onSelect,
  canSelectAll = false,
  isNotCompact,
  isRadio: isRadio3,
  detailColumns,
  isRowDisabled,
  loader,
  columns,
  actions: actions2,
  actionResolver,
  searchTypeComponent,
  toolbarItem,
  subToolbar,
  emptyState: emptyState2,
  icon,
  isSearching = false,
  ...props
}) {
  const {t: t4} = useTranslation();
  const [selected, setSelected] = useState([]);
  const [rows, setRows] = useState();
  const [unPaginatedData, setUnPaginatedData] = useState();
  const [loading, setLoading] = useState(false);
  const [max2, setMax] = useState(10);
  const [first, setFirst] = useState(0);
  const [search, setSearch] = useState("");
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const convertToColumns = (data2) => {
    return data2.map((value, index3) => {
      const disabledRow = isRowDisabled ? isRowDisabled(value) : false;
      const row = [
        {
          data: value,
          disableSelection: disabledRow,
          disableActions: disabledRow,
          selected: !!selected.find((v3) => lodash.get(v3, "id") === lodash.get(value, "id")),
          isOpen: false,
          cells: columns.map((col) => {
            if (col.cellRenderer) {
              return {title: col.cellRenderer(value)};
            }
            return lodash.get(value, col.name);
          })
        }
      ];
      if (detailColumns && detailColumns[0] && detailColumns[0].enabled && detailColumns[0].enabled(value)) {
        row.push({
          parent: index3 * 2,
          cells: detailColumns.map((col) => {
            if (col.cellRenderer) {
              return {title: col.cellRenderer(value)};
            }
            return lodash.get(value, col.name);
          })
        });
      }
      return row;
    }).flat();
  };
  const getNodeText = (node) => {
    if (["string", "number"].includes(typeof node)) {
      return node.toString();
    }
    if (node instanceof Array) {
      return node.map(getNodeText).join("");
    }
    if (typeof node === "object" && node) {
      return getNodeText(isValidElement(node.title) ? node.title.props.children : node.title ? node.title : node.props?.children);
    }
    return "";
  };
  const filteredData = useMemo(() => search === "" || isPaginated ? void 0 : convertToColumns(unPaginatedData || []).filter((row) => row.cells.some((cell) => cell && getNodeText(cell).toLowerCase().includes(search.toLowerCase()))), [search]);
  useEffect(() => {
    if (canSelectAll) {
      const checkboxes = document.getElementsByClassName("pf-c-table__check").item(0);
      if (checkboxes) {
        const checkAllCheckbox = checkboxes.children.item(0);
        checkAllCheckbox.indeterminate = selected.length > 0 && selected.length < (filteredData || rows).length;
      }
    }
  }, [selected]);
  useFetch(async () => {
    setLoading(true);
    return unPaginatedData || await loader(first, max2 + 1, search);
  }, (data2) => {
    if (!isPaginated) {
      setUnPaginatedData(data2);
      data2 = data2.slice(first, first + max2 + 1);
    }
    const result = convertToColumns(data2);
    setRows(result);
    setLoading(false);
  }, [key, first, max2, search]);
  const convertAction = () => actions2 && lodash.cloneDeep(actions2).map((action, index3) => {
    delete action.onRowClick;
    action.onClick = async (_23, rowIndex) => {
      const result = await actions2[index3].onRowClick((filteredData || rows)[rowIndex].data);
      if (result) {
        if (!isPaginated) {
          setSearch("");
        }
        refresh();
      }
    };
    return action;
  });
  const Loading = () => /* @__PURE__ */ react.createElement("div", {
    className: "pf-u-text-align-center"
  }, /* @__PURE__ */ react.createElement(Spinner, null));
  const _onSelect = (isSelected, rowIndex) => {
    const data2 = filteredData || rows;
    if (rowIndex === -1) {
      setRows(data2.map((row) => {
        row.selected = isSelected;
        return row;
      }));
    } else {
      data2[rowIndex].selected = isSelected;
      setRows([...rows]);
    }
    const difference = lodash.differenceBy(selected, data2.map((row) => row.data), "id");
    const selectedRows = [
      ...difference,
      ...data2.filter((row) => row.selected).map((row) => row.data)
    ];
    setSelected(selectedRows);
    onSelect(selectedRows);
  };
  const data = filteredData || rows;
  const onCollapse = (isOpen, rowIndex) => {
    data[rowIndex].isOpen = isOpen;
    setRows([...data]);
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, (data && data.length > 0 || search !== "" || isSearching || loading) && /* @__PURE__ */ react.createElement(PaginatingTableToolbar, {
    count: data?.length || 0,
    first,
    max: max2,
    onNextClick: setFirst,
    onPreviousClick: setFirst,
    onPerPageSelect: (first2, max22) => {
      setFirst(first2);
      setMax(max22);
    },
    inputGroupName: searchPlaceholderKey ? `${ariaLabelKey}input` : void 0,
    inputGroupOnEnter: setSearch,
    inputGroupPlaceholder: t4(searchPlaceholderKey || ""),
    searchTypeComponent,
    toolbarItem,
    subToolbar
  }, !loading && data && data.length > 0 && /* @__PURE__ */ react.createElement(DataTable, {
    ...props,
    canSelectAll,
    onSelect: onSelect ? _onSelect : void 0,
    onCollapse: detailColumns ? onCollapse : void 0,
    actions: convertAction(),
    actionResolver,
    rows: data.slice(0, max2),
    columns,
    isNotCompact,
    isRadio: isRadio3,
    ariaLabelKey
  }), !loading && (!data || data.length === 0) && (search !== "" || !isSearching) && searchPlaceholderKey && /* @__PURE__ */ react.createElement(ListEmptyState, {
    hasIcon: true,
    icon,
    isSearchVariant: true,
    message: t4("noSearchResults"),
    instructions: t4("noSearchResultsInstructions")
  }), loading && /* @__PURE__ */ react.createElement(Loading, null)), /* @__PURE__ */ react.createElement(react.Fragment, null, !loading && (!data || data?.length === 0) && search === "" && emptyState2));
}

// build/components/confirm-dialog/ConfirmDialog.js
var useConfirmDialog = (props) => {
  const [show, setShow] = useState(false);
  function toggleDialog() {
    setShow((show2) => !show2);
  }
  const Dialog = () => /* @__PURE__ */ react.createElement(ConfirmDialogModal, {
    key: "confirmDialog",
    ...props,
    open: show,
    toggleDialog
  });
  return [toggleDialog, Dialog];
};
var ConfirmDialogModal = ({
  titleKey,
  messageKey,
  noCancelButton,
  cancelButtonLabel,
  continueButtonLabel,
  continueButtonVariant,
  onConfirm,
  onCancel,
  children: children2,
  open: open2 = true,
  variant = ModalVariant.small,
  toggleDialog,
  confirmButtonDisabled
}) => {
  const {t: t4} = useTranslation();
  return /* @__PURE__ */ react.createElement(Modal, {
    title: t4(titleKey),
    isOpen: open2,
    onClose: toggleDialog,
    variant,
    actions: [
      /* @__PURE__ */ react.createElement(Button, {
        id: "modal-confirm",
        "data-testid": "modalConfirm",
        key: "confirm",
        isDisabled: confirmButtonDisabled,
        variant: continueButtonVariant || ButtonVariant.primary,
        onClick: () => {
          onConfirm();
          toggleDialog();
        }
      }, t4(continueButtonLabel || "common:continue")),
      !noCancelButton && /* @__PURE__ */ react.createElement(Button, {
        id: "modal-cancel",
        key: "cancel",
        variant: ButtonVariant.link,
        onClick: () => {
          if (onCancel)
            onCancel();
          toggleDialog();
        }
      }, t4(cancelButtonLabel || "common:cancel"))
    ]
  }, !messageKey && children2, messageKey && t4(messageKey));
};

// build/components/keycloak-tabs/KeycloakTabs.js
var createUrl = (path, params) => {
  let url = path;
  for (const key in params) {
    const value = params[key];
    if (url.indexOf(key) !== -1) {
      url = url.replace(new RegExp(`:${key}\\??`), value || "");
    }
  }
  return url;
};
var KeycloakTabs = ({
  paramName = "tab",
  children: children2,
  ...rest
}) => {
  const match = useRouteMatch();
  const params = match.params;
  const history = useHistory();
  const form2 = useFormContext();
  const [key, setKey] = useState("");
  const firstTab = Children.toArray(children2)[0];
  const tab = params[paramName] || isValidElement(firstTab) && firstTab.props.eventKey || "";
  const pathIndex = match.path.indexOf(paramName) + paramName.length;
  const path = match.path.substr(0, pathIndex);
  const [toggleChangeTabDialog, ChangeTabConfirm] = useConfirmDialog({
    titleKey: "common:leaveDirtyTitle",
    messageKey: "common:leaveDirtyConfirm",
    continueButtonLabel: "common:leave",
    onConfirm: () => {
      form2.reset();
      history.push(createUrl(path, {...params, [paramName]: key}));
    }
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ChangeTabConfirm, null), /* @__PURE__ */ react.createElement(Tabs, {
    inset: {
      default: "insetNone",
      md: "insetSm",
      xl: "inset2xl",
      "2xl": "insetLg"
    },
    activeKey: tab,
    onSelect: (_23, key2) => {
      if (form2?.formState.isDirty) {
        setKey(key2);
        toggleChangeTabDialog();
      } else {
        history.push(createUrl(path, {...params, [paramName]: key2}));
      }
    },
    ...rest
  }, children2));
};

// build/authentication/form/NameDescription.js
var NameDescription = () => {
  const {t: t4} = useTranslation("authentication");
  const {register, errors} = useFormContext();
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:name"),
    fieldId: "kc-name",
    helperTextInvalid: t4("common:required"),
    validated: errors.alias ? ValidatedOptions.error : ValidatedOptions.default,
    isRequired: true,
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "authentication-help:name",
      forLabel: t4("common:name"),
      forID: "kc-name"
    })
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-name",
    name: "alias",
    "data-testid": "alias",
    ref: register({required: true}),
    validated: errors.alias ? ValidatedOptions.error : ValidatedOptions.default
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:description"),
    fieldId: "kc-description",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "authentication-help:description",
      forLabel: t4("common:description"),
      forID: "kc-description"
    }),
    validated: errors.description ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: errors.description?.message
  }, /* @__PURE__ */ react.createElement(TextArea, {
    ref: register({
      maxLength: {
        value: 255,
        message: t4("common:maxLength", {length: 255})
      }
    }),
    type: "text",
    id: "kc-description",
    name: "description",
    "data-testid": "description",
    validated: errors.description ? ValidatedOptions.error : ValidatedOptions.default
  })));
};

// build/authentication/DuplicateFlowModal.js
var DuplicateFlowModal = ({
  name,
  description,
  toggleDialog,
  onComplete
}) => {
  const {t: t4} = useTranslation("authentication");
  const form2 = useForm({
    shouldUnregister: false
  });
  const {setValue, trigger, getValues} = form2;
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  useEffect(() => {
    setValue("description", description);
    setValue("name", t4("copyOf", {name}));
  }, [name, description, setValue]);
  const save = async () => {
    await trigger();
    const form22 = getValues();
    try {
      await adminClient.authenticationManagement.copyFlow({
        flow: name,
        newName: form22.name
      });
      if (form22.description !== description) {
        const newFlow = (await adminClient.authenticationManagement.getFlows()).find((flow) => flow.alias === form22.name);
        newFlow.description = form22.description;
        await adminClient.authenticationManagement.updateFlow({flowId: newFlow.id}, newFlow);
      }
      addAlert(t4("copyFlowSuccess"), AlertVariant.success);
    } catch (error2) {
      addError("authentication:copyFlowError", error2);
    }
    onComplete();
  };
  return /* @__PURE__ */ react.createElement(Modal, {
    title: t4("duplicateFlow"),
    isOpen: true,
    onClose: toggleDialog,
    variant: ModalVariant.small,
    actions: [
      /* @__PURE__ */ react.createElement(Button, {
        id: "modal-confirm",
        key: "confirm",
        onClick: save,
        "data-testid": "confirm"
      }, t4("duplicate")),
      /* @__PURE__ */ react.createElement(Button, {
        "data-testid": "cancel",
        id: "modal-cancel",
        key: "cancel",
        variant: ButtonVariant.link,
        onClick: () => {
          toggleDialog();
        }
      }, t4("common:cancel"))
    ]
  }, /* @__PURE__ */ react.createElement(FormProvider, {
    ...form2
  }, /* @__PURE__ */ react.createElement(Form, {
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(NameDescription, null))));
};

// build/authentication/form/FlowType.js
var types = ["basic-flow", "client-flow"];
var FlowType = () => {
  const {t: t4} = useTranslation("authentication");
  const {control} = useFormContext();
  const [open2, setOpen] = useState(false);
  return /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("flowType"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "authentication-help:flowType",
      forLabel: t4("flowType"),
      forID: "flowType"
    }),
    fieldId: "flowType"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "providerId",
    defaultValue: types[0],
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "flowType",
      onToggle: () => setOpen(!open2),
      onSelect: (_23, value2) => {
        onChange(value2);
        setOpen(false);
      },
      selections: t4(`flow-type.${value}`),
      variant: SelectVariant.single,
      "aria-label": t4("flowType"),
      isOpen: open2
    }, types.map((type) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: type === value,
      key: type,
      value: t4(`flow-type.${type}`)
    })))
  }));
};

// build/authentication/form/CreateFlow.js
var CreateFlow = () => {
  const {t: t4} = useTranslation("authentication");
  const history = useHistory();
  const {realm: realm2} = useRealm();
  const form2 = useForm({
    defaultValues: {builtIn: false, topLevel: true}
  });
  const {handleSubmit, register} = form2;
  const adminClient = useAdminClient();
  const {addAlert} = useAlerts();
  const save = async (flow) => {
    try {
      await adminClient.authenticationManagement.createFlow(flow);
      addAlert(t4("flowCreatedSuccess"), AlertVariant.success);
    } catch (error2) {
      addAlert(t4("flowCreateError", {
        error: error2.response?.data?.errorMessage || error2
      }), AlertVariant.danger);
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: "authentication:createFlow",
    subKey: "authentication-help:createFlow"
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(FormProvider, {
    ...form2
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-authorization",
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement("input", {
    name: "builtIn",
    type: "hidden",
    ref: register
  }), /* @__PURE__ */ react.createElement("input", {
    name: "topLevel",
    type: "hidden",
    ref: register
  }), /* @__PURE__ */ react.createElement(NameDescription, null), /* @__PURE__ */ react.createElement(FlowType, null), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    "data-testid": "create",
    type: "submit"
  }, t4("common:create")), /* @__PURE__ */ react.createElement(Button, {
    "data-testid": "cancel",
    variant: "link",
    onClick: () => history.push(`/${realm2}/authentication`)
  }, t4("common:cancel")))))));
};

// build/authentication/routes/CreateFlow.js
var CreateFlowRoute = {
  path: "/:realm/authentication/create",
  component: CreateFlow,
  breadcrumb: (t4) => t4("authentication:createFlow"),
  access: "manage-authorization"
};
var toCreateFlow = (params) => ({
  pathname: generatePath(CreateFlowRoute.path, params)
});

// build/authentication/EmptyExecutionState.js
var sections = ["addExecution", "addSubFlow"];
var EmptyExecutionState = () => {
  const {t: t4} = useTranslation("authentication");
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ListEmptyState, {
    message: t4("emptyExecution"),
    instructions: t4("emptyExecutionInstructions")
  }), /* @__PURE__ */ react.createElement("div", {
    className: "keycloak__empty-execution-state__block"
  }, sections.map((section) => /* @__PURE__ */ react.createElement(Flex, {
    key: section,
    className: "keycloak__empty-execution-state__help"
  }, /* @__PURE__ */ react.createElement(FlexItem, {
    flex: {default: "flex_1"}
  }, /* @__PURE__ */ react.createElement(Title, {
    headingLevel: "h3",
    size: TitleSizes.md
  }, t4(`${section}Title`)), /* @__PURE__ */ react.createElement("p", null, t4(`authentication-help:${section}`))), /* @__PURE__ */ react.createElement(Flex, {
    alignSelf: {default: "alignSelfCenter"}
  }, /* @__PURE__ */ react.createElement(FlexItem, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "tertiary"
  }, t4(section))))))));
};

// build/authentication/components/FlowHeader.js
var FlowHeader = () => {
  const {t: t4} = useTranslation("authentication");
  return /* @__PURE__ */ react.createElement(DataListItem, {
    "aria-labelledby": "headerName",
    id: "header"
  }, /* @__PURE__ */ react.createElement(DataListItemRow, null, /* @__PURE__ */ react.createElement(DataListDragButton, {
    className: "keycloak__authentication__header-drag-button"
  }), /* @__PURE__ */ react.createElement(DataListItemCells, {
    className: "keycloak__authentication__header",
    dataListCells: [
      /* @__PURE__ */ react.createElement(DataListCell, {
        key: "step",
        id: "headerName"
      }, /* @__PURE__ */ react.createElement(react.Fragment, null, t4("steps"))),
      /* @__PURE__ */ react.createElement(DataListCell, {
        key: "requirement"
      }, /* @__PURE__ */ react.createElement(react.Fragment, null, t4("requirement")))
    ]
  })));
};

// build/authentication/components/FlowTitle.js
var FlowTitle = ({title: title3}) => {
  return /* @__PURE__ */ react.createElement(Card, {
    "data-testid": title3,
    className: "keycloak__authentication__title",
    isFlat: true
  }, /* @__PURE__ */ react.createElement(CardBody, null, title3));
};

// build/authentication/components/FlowRequirementDropdown.js
var FlowRequirementDropdown = ({
  flow,
  onChange
}) => {
  const {t: t4} = useTranslation("authentication");
  const [open2, setOpen] = useState(false);
  const options = flow.requirementChoices.map((option, index3) => /* @__PURE__ */ react.createElement(SelectOption, {
    key: index3,
    value: option
  }, t4(`requirements.${option}`)));
  return /* @__PURE__ */ react.createElement(react.Fragment, null, flow.requirementChoices && flow.requirementChoices.length > 1 && /* @__PURE__ */ react.createElement(Select, {
    className: "keycloak__authentication__requirement-dropdown",
    variant: SelectVariant.single,
    onToggle: () => setOpen(!open2),
    onSelect: (_event, value) => {
      flow.requirement = value.toString();
      onChange(flow);
      setOpen(false);
    },
    selections: [flow.requirement],
    isOpen: open2
  }, options), (!flow.requirementChoices || flow.requirementChoices.length <= 1) && /* @__PURE__ */ react.createElement(react.Fragment, null, t4(`requirements.${flow.requirement}`)));
};

// build/authentication/components/FlowRow.js
var FlowRow = ({
  execution,
  onRowClick,
  onRowChange
}) => {
  const {t: t4} = useTranslation("authentication");
  const hasSubList = !!execution.executionList?.length;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DataListItem, {
    className: "keycloak__authentication__flow-item",
    id: execution.id,
    isExpanded: !execution.isCollapsed
  }, /* @__PURE__ */ react.createElement(DataListItemRow, {
    className: "keycloak__authentication__flow-row",
    "aria-level": execution.level
  }, /* @__PURE__ */ react.createElement(DataListControl, null, /* @__PURE__ */ react.createElement(DataListDragButton, {
    "aria-labelledby": execution.displayName,
    "aria-describedby": t4("common-help:dragHelp")
  })), hasSubList && /* @__PURE__ */ react.createElement(DataListToggle, {
    onClick: () => onRowClick(execution),
    isExpanded: !execution.isCollapsed,
    id: `toggle1-${execution.id}`,
    "aria-controls": `expand-${execution.id}`
  }), /* @__PURE__ */ react.createElement(DataListItemCells, {
    dataListCells: [
      /* @__PURE__ */ react.createElement(DataListCell, {
        key: `${execution.id}-name`
      }, !hasSubList && /* @__PURE__ */ react.createElement(FlowTitle, {
        key: execution.id,
        title: execution.displayName
      }), hasSubList && /* @__PURE__ */ react.createElement(react.Fragment, null, execution.displayName, " ", /* @__PURE__ */ react.createElement("br", null), " ", /* @__PURE__ */ react.createElement(Text, {
        component: TextVariants.small
      }, execution.description))),
      /* @__PURE__ */ react.createElement(DataListCell, {
        key: `${execution.id}-requirement`
      }, /* @__PURE__ */ react.createElement(FlowRequirementDropdown, {
        flow: execution,
        onChange: onRowChange
      }))
    ]
  }))), !execution.isCollapsed && hasSubList && /* @__PURE__ */ react.createElement(react.Fragment, null, execution.executionList.map((execution2) => /* @__PURE__ */ react.createElement(FlowRow, {
    key: execution2.id,
    execution: execution2,
    onRowClick,
    onRowChange
  }))));
};

// build/authentication/execution-model.js
var IndexChange = class {
  constructor(oldIndex, newIndex) {
    this.oldIndex = oldIndex;
    this.newIndex = newIndex;
  }
};
var LevelChange = class extends IndexChange {
  constructor(oldIndex, newIndex, parent) {
    super(oldIndex, newIndex);
    this.parent = parent;
  }
};
var ExecutionList = class {
  constructor(list3) {
    this.list = list3;
    this.expandableList = this.transformToExpandableList(0, 0, {
      executionList: [],
      isCollapsed: false
    }).executionList;
  }
  transformToExpandableList(level2, currIndex, execution) {
    for (let index3 = currIndex; index3 < this.list.length; index3++) {
      const ex = this.list[index3];
      const nextRowLevel = this.list[index3 + 1]?.level || 0;
      if (ex.level === level2 && nextRowLevel <= level2) {
        execution.executionList.push(ex);
      } else if (ex.level === level2 && nextRowLevel > level2) {
        const expandable2 = this.transformToExpandableList(nextRowLevel, index3 + 1, {
          ...ex,
          executionList: [],
          isCollapsed: false
        });
        execution.executionList.push(expandable2);
      }
    }
    return execution;
  }
  order(list3) {
    let result = [];
    for (const row of list3 || this.expandableList) {
      result.push(row);
      if (row.executionList && !row.isCollapsed) {
        result = result.concat(this.order(row.executionList));
      }
    }
    return result;
  }
  findExecution(id3, list3) {
    let found = (list3 || this.expandableList).find((ex) => ex.id === id3);
    if (!found) {
      for (const ex of list3 || this.expandableList) {
        if (ex.executionList) {
          found = this.findExecution(id3, ex.executionList);
          if (found) {
            return found;
          }
        }
      }
    }
    return found;
  }
  getParentNodes(level2) {
    for (let index3 = 0; index3 < this.list.length; index3++) {
      const ex = this.list[index3];
      if (index3 + 1 < this.list.length && this.list[index3 + 1].level > ex.level && ex.level + 1 === level2) {
        return ex;
      }
    }
  }
  getChange(changed, order3) {
    const currentOrder = this.order();
    const newLocIndex = order3.findIndex((id3) => id3 === changed.id);
    const oldLocation = currentOrder[currentOrder.findIndex((ex) => ex.id === changed.id)];
    const newLocation = currentOrder[newLocIndex];
    if (newLocation.level !== oldLocation.level) {
      if (newLocation.level > 0) {
        const parent = this.getParentNodes(newLocation.level);
        return new LevelChange(parent?.executionList?.length || 0, newLocation.index, parent);
      }
      return new LevelChange(this.expandableList.length, newLocation.index);
    }
    return new IndexChange(oldLocation.index, newLocation.index);
  }
  clone() {
    const newList = new ExecutionList([]);
    newList.list = this.list;
    newList.expandableList = this.expandableList;
    return newList;
  }
};

// build/_snowpack/pkg/react-flow-renderer.js
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutPropertiesLoose2(source2, excluded) {
  if (source2 == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source2);
  var key, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++) {
    key = sourceKeys[i3];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source2[key];
  }
  return target;
}
function _objectWithoutProperties3(source2, excluded) {
  if (source2 == null)
    return {};
  var target = _objectWithoutPropertiesLoose2(source2, excluded);
  var key, i3;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source2);
    for (i3 = 0; i3 < sourceSymbolKeys.length; i3++) {
      key = sourceSymbolKeys[i3];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source2, key))
        continue;
      target[key] = source2[key];
    }
  }
  return target;
}
function cc2(names) {
  if (typeof names === "string" || typeof names === "number")
    return "" + names;
  let out = "";
  if (Array.isArray(names)) {
    for (let i3 = 0, tmp; i3 < names.length; i3++) {
      if ((tmp = cc2(names[i3])) !== "") {
        out += (out && " ") + tmp;
      }
    }
  } else {
    for (let k3 in names) {
      if (names[k3])
        out += (out && " ") + k3;
    }
  }
  return out;
}
function formatProdErrorMessage(code2) {
  return "Minified Redux error #" + code2 + "; visit https://redux.js.org/Errors?code=" + code2 + " for the full message or use the non-minified dev environment for full errors. ";
}
var $$observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var randomString = function randomString2() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
function isPlainObject3(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  var proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(formatProdErrorMessage(0));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(formatProdErrorMessage(1));
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  if (typeof reducer !== "function") {
    throw new Error(formatProdErrorMessage(2));
  }
  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(3));
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(formatProdErrorMessage(4));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(5));
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage(6));
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index3 = nextListeners.indexOf(listener);
      nextListeners.splice(index3, 1);
      currentListeners = null;
    };
  }
  function dispatch2(action) {
    if (!isPlainObject3(action)) {
      throw new Error(formatProdErrorMessage(7));
    }
    if (typeof action.type === "undefined") {
      throw new Error(formatProdErrorMessage(8));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(9));
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    var listeners = currentListeners = nextListeners;
    for (var i3 = 0; i3 < listeners.length; i3++) {
      var listener = listeners[i3];
      listener();
    }
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(formatProdErrorMessage(10));
    }
    currentReducer = nextReducer;
    dispatch2({
      type: ActionTypes.REPLACE
    });
  }
  function observable() {
    var _ref;
    var outerSubscribe = subscribe;
    return _ref = {
      subscribe: function subscribe2(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(formatProdErrorMessage(11));
        }
        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }
        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      }
    }, _ref[$$observable] = function() {
      return this;
    }, _ref;
  }
  dispatch2({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch2,
    subscribe,
    getState,
    replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
function bindActionCreator(actionCreator, dispatch2) {
  return function() {
    return dispatch2(actionCreator.apply(this, arguments));
  };
}
function bindActionCreators(actionCreators, dispatch2) {
  if (typeof actionCreators === "function") {
    return bindActionCreator(actionCreators, dispatch2);
  }
  if (typeof actionCreators !== "object" || actionCreators === null) {
    throw new Error(formatProdErrorMessage(16));
  }
  var boundActionCreators = {};
  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch2);
    }
  }
  return boundActionCreators;
}
var propTypes2 = {exports: {}};
var reactIs$12 = {exports: {}};
var reactIs_production_min2 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b2 = typeof Symbol === "function" && Symbol.for;
var c3 = b2 ? Symbol.for("react.element") : 60103;
var d2 = b2 ? Symbol.for("react.portal") : 60106;
var e2 = b2 ? Symbol.for("react.fragment") : 60107;
var f2 = b2 ? Symbol.for("react.strict_mode") : 60108;
var g2 = b2 ? Symbol.for("react.profiler") : 60114;
var h2 = b2 ? Symbol.for("react.provider") : 60109;
var k2 = b2 ? Symbol.for("react.context") : 60110;
var l2 = b2 ? Symbol.for("react.async_mode") : 60111;
var m2 = b2 ? Symbol.for("react.concurrent_mode") : 60111;
var n3 = b2 ? Symbol.for("react.forward_ref") : 60112;
var p2 = b2 ? Symbol.for("react.suspense") : 60113;
var q2 = b2 ? Symbol.for("react.suspense_list") : 60120;
var r3 = b2 ? Symbol.for("react.memo") : 60115;
var t3 = b2 ? Symbol.for("react.lazy") : 60116;
var v2 = b2 ? Symbol.for("react.block") : 60121;
var w2 = b2 ? Symbol.for("react.fundamental") : 60117;
var x2 = b2 ? Symbol.for("react.responder") : 60118;
var y3 = b2 ? Symbol.for("react.scope") : 60119;
function z2(a2) {
  if (typeof a2 === "object" && a2 !== null) {
    var u = a2.$$typeof;
    switch (u) {
      case c3:
        switch (a2 = a2.type, a2) {
          case l2:
          case m2:
          case e2:
          case g2:
          case f2:
          case p2:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k2:
              case n3:
              case t3:
              case r3:
              case h2:
                return a2;
              default:
                return u;
            }
        }
      case d2:
        return u;
    }
  }
}
function A2(a2) {
  return z2(a2) === m2;
}
reactIs_production_min2.AsyncMode = l2;
reactIs_production_min2.ConcurrentMode = m2;
reactIs_production_min2.ContextConsumer = k2;
reactIs_production_min2.ContextProvider = h2;
reactIs_production_min2.Element = c3;
reactIs_production_min2.ForwardRef = n3;
reactIs_production_min2.Fragment = e2;
reactIs_production_min2.Lazy = t3;
reactIs_production_min2.Memo = r3;
reactIs_production_min2.Portal = d2;
reactIs_production_min2.Profiler = g2;
reactIs_production_min2.StrictMode = f2;
reactIs_production_min2.Suspense = p2;
reactIs_production_min2.isAsyncMode = function(a2) {
  return A2(a2) || z2(a2) === l2;
};
reactIs_production_min2.isConcurrentMode = A2;
reactIs_production_min2.isContextConsumer = function(a2) {
  return z2(a2) === k2;
};
reactIs_production_min2.isContextProvider = function(a2) {
  return z2(a2) === h2;
};
reactIs_production_min2.isElement = function(a2) {
  return typeof a2 === "object" && a2 !== null && a2.$$typeof === c3;
};
reactIs_production_min2.isForwardRef = function(a2) {
  return z2(a2) === n3;
};
reactIs_production_min2.isFragment = function(a2) {
  return z2(a2) === e2;
};
reactIs_production_min2.isLazy = function(a2) {
  return z2(a2) === t3;
};
reactIs_production_min2.isMemo = function(a2) {
  return z2(a2) === r3;
};
reactIs_production_min2.isPortal = function(a2) {
  return z2(a2) === d2;
};
reactIs_production_min2.isProfiler = function(a2) {
  return z2(a2) === g2;
};
reactIs_production_min2.isStrictMode = function(a2) {
  return z2(a2) === f2;
};
reactIs_production_min2.isSuspense = function(a2) {
  return z2(a2) === p2;
};
reactIs_production_min2.isValidElementType = function(a2) {
  return typeof a2 === "string" || typeof a2 === "function" || a2 === e2 || a2 === m2 || a2 === g2 || a2 === f2 || a2 === p2 || a2 === q2 || typeof a2 === "object" && a2 !== null && (a2.$$typeof === t3 || a2.$$typeof === r3 || a2.$$typeof === h2 || a2.$$typeof === k2 || a2.$$typeof === n3 || a2.$$typeof === w2 || a2.$$typeof === x2 || a2.$$typeof === y3 || a2.$$typeof === v2);
};
reactIs_production_min2.typeOf = z2;
{
  reactIs$12.exports = reactIs_production_min2;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols2 = Object.getOwnPropertySymbols;
var hasOwnProperty3 = Object.prototype.hasOwnProperty;
var propIsEnumerable2 = Object.prototype.propertyIsEnumerable;
function toObject2(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative2() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i3 = 0; i3 < 10; i3++) {
      test2["_" + String.fromCharCode(i3)] = i3;
    }
    var order22 = Object.getOwnPropertyNames(test2).map(function(n4) {
      return test2[n4];
    });
    if (order22.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign2 = shouldUseNative2() ? Object.assign : function(target, source2) {
  var from;
  var to = toObject2(target);
  var symbols;
  for (var s2 = 1; s2 < arguments.length; s2++) {
    from = Object(arguments[s2]);
    for (var key in from) {
      if (hasOwnProperty3.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols2) {
      symbols = getOwnPropertySymbols2(from);
      for (var i3 = 0; i3 < symbols.length; i3++) {
        if (propIsEnumerable2.call(from, symbols[i3])) {
          to[symbols[i3]] = from[symbols[i3]];
        }
      }
    }
  }
  return to;
};
var ReactPropTypesSecret$3 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_12 = ReactPropTypesSecret$3;
var has2 = Function.call.bind(Object.prototype.hasOwnProperty);
var ReactPropTypesSecret2 = ReactPropTypesSecret_12;
function emptyFunction2() {
}
function emptyFunctionWithReset2() {
}
emptyFunctionWithReset2.resetWarningCache = emptyFunction2;
var factoryWithThrowingShims2 = function() {
  function shim(props, propName, componentName, location2, propFullName, secret) {
    if (secret === ReactPropTypesSecret2) {
      return;
    }
    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset2,
    resetWarningCache: emptyFunction2
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes2.exports = factoryWithThrowingShims2();
}
var ReactReduxContext = /* @__PURE__ */ react.createContext(null);
function defaultNoopBatch(callback) {
  callback();
}
var batch = defaultNoopBatch;
var setBatch = function setBatch2(newBatch) {
  return batch = newBatch;
};
var getBatch = function getBatch2() {
  return batch;
};
var nullListeners = {
  notify: function notify() {
  }
};
function createListenerCollection() {
  var batch2 = getBatch();
  var first = null;
  var last2 = null;
  return {
    clear: function clear() {
      first = null;
      last2 = null;
    },
    notify: function notify2() {
      batch2(function() {
        var listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get: function get5() {
      var listeners = [];
      var listener = first;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },
    subscribe: function subscribe(callback) {
      var isSubscribed = true;
      var listener = last2 = {
        callback,
        next: null,
        prev: last2
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null)
          return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last2 = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}
var Subscription = /* @__PURE__ */ function() {
  function Subscription2(store2, parentSub) {
    this.store = store2;
    this.parentSub = parentSub;
    this.unsubscribe = null;
    this.listeners = nullListeners;
    this.handleChangeWrapper = this.handleChangeWrapper.bind(this);
  }
  var _proto = Subscription2.prototype;
  _proto.addNestedSub = function addNestedSub(listener) {
    this.trySubscribe();
    return this.listeners.subscribe(listener);
  };
  _proto.notifyNestedSubs = function notifyNestedSubs() {
    this.listeners.notify();
  };
  _proto.handleChangeWrapper = function handleChangeWrapper() {
    if (this.onStateChange) {
      this.onStateChange();
    }
  };
  _proto.isSubscribed = function isSubscribed() {
    return Boolean(this.unsubscribe);
  };
  _proto.trySubscribe = function trySubscribe() {
    if (!this.unsubscribe) {
      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.handleChangeWrapper) : this.store.subscribe(this.handleChangeWrapper);
      this.listeners = createListenerCollection();
    }
  };
  _proto.tryUnsubscribe = function tryUnsubscribe() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
      this.listeners.clear();
      this.listeners = nullListeners;
    }
  };
  return Subscription2;
}();
var useIsomorphicLayoutEffect2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? react.useLayoutEffect : react.useEffect;
function Provider$1(_ref) {
  var store2 = _ref.store, context2 = _ref.context, children2 = _ref.children;
  var contextValue = react.useMemo(function() {
    var subscription = new Subscription(store2);
    subscription.onStateChange = subscription.notifyNestedSubs;
    return {
      store: store2,
      subscription
    };
  }, [store2]);
  var previousState = react.useMemo(function() {
    return store2.getState();
  }, [store2]);
  useIsomorphicLayoutEffect2(function() {
    var subscription = contextValue.subscription;
    subscription.trySubscribe();
    if (previousState !== store2.getState()) {
      subscription.notifyNestedSubs();
    }
    return function() {
      subscription.tryUnsubscribe();
      subscription.onStateChange = null;
    };
  }, [contextValue, previousState]);
  var Context = context2 || ReactReduxContext;
  return /* @__PURE__ */ react.createElement(Context.Provider, {
    value: contextValue
  }, children2);
}
var reactIs2 = reactIs$12.exports;
var FORWARD_REF_STATICS2 = {
  $$typeof: true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS2 = {
  $$typeof: true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS2 = {};
TYPE_STATICS2[reactIs2.ForwardRef] = FORWARD_REF_STATICS2;
TYPE_STATICS2[reactIs2.Memo] = MEMO_STATICS2;
function useReduxContext() {
  var contextValue = react.useContext(ReactReduxContext);
  return contextValue;
}
function createStoreHook(context2) {
  if (context2 === void 0) {
    context2 = ReactReduxContext;
  }
  var useReduxContext$1 = context2 === ReactReduxContext ? useReduxContext : function() {
    return react.useContext(context2);
  };
  return function useStore3() {
    var _useReduxContext = useReduxContext$1(), store2 = _useReduxContext.store;
    return store2;
  };
}
var useStore$1 = /* @__PURE__ */ createStoreHook();
function createDispatchHook(context2) {
  if (context2 === void 0) {
    context2 = ReactReduxContext;
  }
  var useStore3 = context2 === ReactReduxContext ? useStore$1 : createStoreHook(context2);
  return function useDispatch() {
    var store2 = useStore3();
    return store2.dispatch;
  };
}
var useDispatch$1 = /* @__PURE__ */ createDispatchHook();
var refEquality = function refEquality2(a2, b3) {
  return a2 === b3;
};
function useSelectorWithStoreAndSubscription(selector2, equalityFn, store2, contextSub) {
  var _useReducer = react.useReducer(function(s2) {
    return s2 + 1;
  }, 0), forceRender = _useReducer[1];
  var subscription = react.useMemo(function() {
    return new Subscription(store2, contextSub);
  }, [store2, contextSub]);
  var latestSubscriptionCallbackError = react.useRef();
  var latestSelector = react.useRef();
  var latestStoreState = react.useRef();
  var latestSelectedState = react.useRef();
  var storeState = store2.getState();
  var selectedState;
  try {
    if (selector2 !== latestSelector.current || storeState !== latestStoreState.current || latestSubscriptionCallbackError.current) {
      var newSelectedState = selector2(storeState);
      if (latestSelectedState.current === void 0 || !equalityFn(newSelectedState, latestSelectedState.current)) {
        selectedState = newSelectedState;
      } else {
        selectedState = latestSelectedState.current;
      }
    } else {
      selectedState = latestSelectedState.current;
    }
  } catch (err) {
    if (latestSubscriptionCallbackError.current) {
      err.message += "\nThe error may be correlated with this previous error:\n" + latestSubscriptionCallbackError.current.stack + "\n\n";
    }
    throw err;
  }
  useIsomorphicLayoutEffect2(function() {
    latestSelector.current = selector2;
    latestStoreState.current = storeState;
    latestSelectedState.current = selectedState;
    latestSubscriptionCallbackError.current = void 0;
  });
  useIsomorphicLayoutEffect2(function() {
    function checkForUpdates() {
      try {
        var newStoreState = store2.getState();
        var _newSelectedState = latestSelector.current(newStoreState);
        if (equalityFn(_newSelectedState, latestSelectedState.current)) {
          return;
        }
        latestSelectedState.current = _newSelectedState;
        latestStoreState.current = newStoreState;
      } catch (err) {
        latestSubscriptionCallbackError.current = err;
      }
      forceRender();
    }
    subscription.onStateChange = checkForUpdates;
    subscription.trySubscribe();
    checkForUpdates();
    return function() {
      return subscription.tryUnsubscribe();
    };
  }, [store2, subscription]);
  return selectedState;
}
function createSelectorHook(context2) {
  if (context2 === void 0) {
    context2 = ReactReduxContext;
  }
  var useReduxContext$1 = context2 === ReactReduxContext ? useReduxContext : function() {
    return react.useContext(context2);
  };
  return function useSelector2(selector2, equalityFn) {
    if (equalityFn === void 0) {
      equalityFn = refEquality;
    }
    var _useReduxContext = useReduxContext$1(), store2 = _useReduxContext.store, contextSub = _useReduxContext.subscription;
    var selectedState = useSelectorWithStoreAndSubscription(selector2, equalityFn, store2, contextSub);
    react.useDebugValue(selectedState);
    return selectedState;
  };
}
var useSelector = /* @__PURE__ */ createSelectorHook();
setBatch(reactDom.unstable_batchedUpdates);
function createAction(type, payload) {
  return {
    type,
    payload
  };
}
var SET_ON_CONNECT = "SET_ON_CONNECT";
var SET_ON_CONNECT_START = "SET_ON_CONNECT_START";
var SET_ON_CONNECT_STOP = "SET_ON_CONNECT_STOP";
var SET_ON_CONNECT_END = "SET_ON_CONNECT_END";
var SET_ELEMENTS = "SET_ELEMENTS";
var UPDATE_NODE_DIMENSIONS = "UPDATE_NODE_DIMENSIONS";
var UPDATE_NODE_POS = "UPDATE_NODE_POS";
var UPDATE_NODE_POS_DIFF = "UPDATE_NODE_POS_DIFF";
var SET_USER_SELECTION = "SET_USER_SELECTION";
var UPDATE_USER_SELECTION = "UPDATE_USER_SELECTION";
var UNSET_USER_SELECTION = "UNSET_USER_SELECTION";
var SET_SELECTION = "SET_SELECTION";
var UNSET_NODES_SELECTION = "UNSET_NODES_SELECTION";
var SET_SELECTED_ELEMENTS = "SET_SELECTED_ELEMENTS";
var RESET_SELECTED_ELEMENTS = "RESET_SELECTED_ELEMENTS";
var ADD_SELECTED_ELEMENTS = "ADD_SELECTED_ELEMENTS";
var UPDATE_TRANSFORM = "UPDATE_TRANSFORM";
var UPDATE_SIZE = "UPDATE_SIZE";
var INIT_D3ZOOM = "INIT_D3ZOOM";
var SET_MINZOOM = "SET_MINZOOM";
var SET_MAXZOOM = "SET_MAXZOOM";
var SET_TRANSLATEEXTENT = "SET_TRANSLATEEXTENT";
var SET_CONNECTION_POSITION = "SET_CONNECTION_POSITION";
var SET_CONNECTION_NODEID = "SET_CONNECTION_NODEID";
var SET_SNAPTOGRID = "SET_SNAPTOGRID";
var SET_SNAPGRID = "SET_SNAPGRID";
var SET_INTERACTIVE = "SET_INTERACTIVE";
var SET_NODES_DRAGGABLE = "SET_NODES_DRAGGABLE";
var SET_NODES_CONNECTABLE = "SET_NODES_CONNECTABLE";
var SET_ELEMENTS_SELECTABLE = "SET_ELEMENTS_SELECTABLE";
var SET_MULTI_SELECTION_ACTIVE = "SET_MULTI_SELECTION_ACTIVE";
var SET_CONNECTION_MODE = "SET_CONNECTION_MODE";
var SET_NODE_EXTENT = "SET_NODE_EXTENT";
var setOnConnect = function setOnConnect2(onConnect) {
  return createAction(SET_ON_CONNECT, {
    onConnect
  });
};
var setOnConnectStart = function setOnConnectStart2(onConnectStart) {
  return createAction(SET_ON_CONNECT_START, {
    onConnectStart
  });
};
var setOnConnectStop = function setOnConnectStop2(onConnectStop) {
  return createAction(SET_ON_CONNECT_STOP, {
    onConnectStop
  });
};
var setOnConnectEnd = function setOnConnectEnd2(onConnectEnd) {
  return createAction(SET_ON_CONNECT_END, {
    onConnectEnd
  });
};
var setElements = function setElements2(elements) {
  return createAction(SET_ELEMENTS, elements);
};
var updateNodeDimensions = function updateNodeDimensions2(updates) {
  return createAction(UPDATE_NODE_DIMENSIONS, updates);
};
var updateNodePos = function updateNodePos2(payload) {
  return createAction(UPDATE_NODE_POS, payload);
};
var updateNodePosDiff = function updateNodePosDiff2(payload) {
  return createAction(UPDATE_NODE_POS_DIFF, payload);
};
var setUserSelection = function setUserSelection2(mousePos) {
  return createAction(SET_USER_SELECTION, mousePos);
};
var updateUserSelection = function updateUserSelection2(mousePos) {
  return createAction(UPDATE_USER_SELECTION, mousePos);
};
var unsetUserSelection = function unsetUserSelection2() {
  return createAction(UNSET_USER_SELECTION);
};
var setSelection = function setSelection2(selectionActive) {
  return createAction(SET_SELECTION, {
    selectionActive
  });
};
var unsetNodesSelection = function unsetNodesSelection2() {
  return createAction(UNSET_NODES_SELECTION, {
    nodesSelectionActive: false
  });
};
var resetSelectedElements = function resetSelectedElements2() {
  return createAction(RESET_SELECTED_ELEMENTS, {
    selectedElements: null
  });
};
var setSelectedElements = function setSelectedElements2(elements) {
  return createAction(SET_SELECTED_ELEMENTS, elements);
};
var addSelectedElements = function addSelectedElements2(elements) {
  return createAction(ADD_SELECTED_ELEMENTS, elements);
};
var updateTransform = function updateTransform2(transform3) {
  return createAction(UPDATE_TRANSFORM, {
    transform: transform3
  });
};
var updateSize = function updateSize2(size2) {
  return createAction(UPDATE_SIZE, {
    width: size2.width || 500,
    height: size2.height || 500
  });
};
var initD3Zoom = function initD3Zoom2(payload) {
  return createAction(INIT_D3ZOOM, payload);
};
var setMinZoom = function setMinZoom2(minZoom) {
  return createAction(SET_MINZOOM, minZoom);
};
var setMaxZoom = function setMaxZoom2(maxZoom) {
  return createAction(SET_MAXZOOM, maxZoom);
};
var setTranslateExtent = function setTranslateExtent2(translateExtent) {
  return createAction(SET_TRANSLATEEXTENT, translateExtent);
};
var setConnectionPosition = function setConnectionPosition2(connectionPosition) {
  return createAction(SET_CONNECTION_POSITION, {
    connectionPosition
  });
};
var setConnectionNodeId = function setConnectionNodeId2(payload) {
  return createAction(SET_CONNECTION_NODEID, payload);
};
var setSnapToGrid = function setSnapToGrid2(snapToGrid2) {
  return createAction(SET_SNAPTOGRID, {
    snapToGrid: snapToGrid2
  });
};
var setSnapGrid = function setSnapGrid2(snapGrid) {
  return createAction(SET_SNAPGRID, {
    snapGrid
  });
};
var setInteractive = function setInteractive2(isInteractive) {
  return createAction(SET_INTERACTIVE, {
    nodesDraggable: isInteractive,
    nodesConnectable: isInteractive,
    elementsSelectable: isInteractive
  });
};
var setNodesDraggable = function setNodesDraggable2(nodesDraggable) {
  return createAction(SET_NODES_DRAGGABLE, {
    nodesDraggable
  });
};
var setNodesConnectable = function setNodesConnectable2(nodesConnectable) {
  return createAction(SET_NODES_CONNECTABLE, {
    nodesConnectable
  });
};
var setElementsSelectable = function setElementsSelectable2(elementsSelectable) {
  return createAction(SET_ELEMENTS_SELECTABLE, {
    elementsSelectable
  });
};
var setMultiSelectionActive = function setMultiSelectionActive2(multiSelectionActive) {
  return createAction(SET_MULTI_SELECTION_ACTIVE, {
    multiSelectionActive
  });
};
var setConnectionMode = function setConnectionMode2(connectionMode) {
  return createAction(SET_CONNECTION_MODE, {
    connectionMode
  });
};
var setNodeExtent = function setNodeExtent2(nodeExtent) {
  return createAction(SET_NODE_EXTENT, nodeExtent);
};
var actions = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  setOnConnect,
  setOnConnectStart,
  setOnConnectStop,
  setOnConnectEnd,
  setElements,
  updateNodeDimensions,
  updateNodePos,
  updateNodePosDiff,
  setUserSelection,
  updateUserSelection,
  unsetUserSelection,
  setSelection,
  unsetNodesSelection,
  resetSelectedElements,
  setSelectedElements,
  addSelectedElements,
  updateTransform,
  updateSize,
  initD3Zoom,
  setMinZoom,
  setMaxZoom,
  setTranslateExtent,
  setConnectionPosition,
  setConnectionNodeId,
  setSnapToGrid,
  setSnapGrid,
  setInteractive,
  setNodesDraggable,
  setNodesConnectable,
  setElementsSelectable,
  setMultiSelectionActive,
  setConnectionMode,
  setNodeExtent
});
var useTypedSelector = useSelector;
function useStoreActions(actionSelector) {
  var dispatch2 = useDispatch$1();
  var currAction = actionSelector(actions);
  var action = react.useMemo(function() {
    return typeof currAction === "function" ? bindActionCreators(currAction, dispatch2) : bindActionCreators(currAction, dispatch2);
  }, [dispatch2, currAction]);
  return action;
}
var useStoreState = useTypedSelector;
var useStore = function useStore2() {
  var store2 = useStore$1();
  return store2;
};
function _arrayLikeToArray$1(arr, len2) {
  if (len2 == null || len2 > arr.length)
    len2 = arr.length;
  for (var i3 = 0, arr2 = new Array(len2); i3 < len2; i3++) {
    arr2[i3] = arr[i3];
  }
  return arr2;
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$1(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n4 = Object.prototype.toString.call(o).slice(8, -1);
  if (n4 === "Object" && o.constructor)
    n4 = o.constructor.name;
  if (n4 === "Map" || n4 === "Set")
    return Array.from(o);
  if (n4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4))
    return _arrayLikeToArray$1(o, minLen);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray2(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit$1(arr, i3) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i3 && _arr.length === i3)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray$1(arr, i3) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i3) || _unsupportedIterableToArray$1(arr, i3) || _nonIterableRest$1();
}
var isInputDOMNode = function isInputDOMNode2(e3) {
  var target = e3 === null || e3 === void 0 ? void 0 : e3.target;
  return ["INPUT", "SELECT", "TEXTAREA", "BUTTON"].includes(target === null || target === void 0 ? void 0 : target.nodeName) || (target === null || target === void 0 ? void 0 : target.hasAttribute("contenteditable"));
};
var getDimensions = function getDimensions2(node) {
  return {
    width: node.offsetWidth,
    height: node.offsetHeight
  };
};
var clamp2 = function clamp3(val) {
  var min2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var max2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  return Math.min(Math.max(val, min2), max2);
};
var clampPosition = function clampPosition2(position2, extent) {
  return {
    x: clamp2(position2.x, extent[0][0], extent[1][0]),
    y: clamp2(position2.y, extent[0][1], extent[1][1])
  };
};
var getHostForElement = function getHostForElement2(element) {
  var _element$getRootNode, _window;
  return ((_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element)) || ((_window = window) === null || _window === void 0 ? void 0 : _window.document);
};
var useKeyPress = function(keyCode) {
  var _useState = react.useState(false), _useState2 = _slicedToArray$1(_useState, 2), keyPressed = _useState2[0], setKeyPressed = _useState2[1];
  react.useEffect(function() {
    if (typeof keyCode !== "undefined") {
      var downHandler = function downHandler2(event) {
        if (!isInputDOMNode(event) && (event.key === keyCode || event.keyCode === keyCode)) {
          event.preventDefault();
          setKeyPressed(true);
        }
      };
      var upHandler = function upHandler2(event) {
        if (!isInputDOMNode(event) && (event.key === keyCode || event.keyCode === keyCode)) {
          setKeyPressed(false);
        }
      };
      var resetHandler = function resetHandler2() {
        return setKeyPressed(false);
      };
      window.addEventListener("keydown", downHandler);
      window.addEventListener("keyup", upHandler);
      window.addEventListener("blur", resetHandler);
      return function() {
        window.removeEventListener("keydown", downHandler);
        window.removeEventListener("keyup", upHandler);
        window.removeEventListener("blur", resetHandler);
      };
    }
  }, [keyCode, setKeyPressed]);
  return keyPressed;
};
function ownKeys$d(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$d(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys$d(Object(source2), true).forEach(function(key) {
        _defineProperty$2(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys$d(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
var isEdge2 = function isEdge3(element) {
  return "id" in element && "source" in element && "target" in element;
};
var isNode = function isNode2(element) {
  return "id" in element && !("source" in element) && !("target" in element);
};
var removeElements = function removeElements2(elementsToRemove, elements) {
  var nodeIdsToRemove = elementsToRemove.map(function(n4) {
    return n4.id;
  });
  return elements.filter(function(element) {
    var edgeElement = element;
    return !(nodeIdsToRemove.includes(element.id) || nodeIdsToRemove.includes(edgeElement.target) || nodeIdsToRemove.includes(edgeElement.source));
  });
};
var pointToRendererPoint = function pointToRendererPoint2(_ref2, _ref3, snapToGrid2, _ref4) {
  var x3 = _ref2.x, y4 = _ref2.y;
  var _ref5 = _slicedToArray$1(_ref3, 3), tx = _ref5[0], ty = _ref5[1], tScale = _ref5[2];
  var _ref6 = _slicedToArray$1(_ref4, 2), snapX = _ref6[0], snapY = _ref6[1];
  var position2 = {
    x: (x3 - tx) / tScale,
    y: (y4 - ty) / tScale
  };
  if (snapToGrid2) {
    return {
      x: snapX * Math.round(position2.x / snapX),
      y: snapY * Math.round(position2.y / snapY)
    };
  }
  return position2;
};
var onLoadProject = function onLoadProject2(currentStore) {
  return function(position2) {
    var _currentStore$getStat = currentStore.getState(), transform3 = _currentStore$getStat.transform, snapToGrid2 = _currentStore$getStat.snapToGrid, snapGrid = _currentStore$getStat.snapGrid;
    return pointToRendererPoint(position2, transform3, snapToGrid2, snapGrid);
  };
};
var parseNode = function parseNode2(node, nodeExtent) {
  return _objectSpread$d(_objectSpread$d({}, node), {}, {
    id: node.id.toString(),
    type: node.type || "default",
    __rf: {
      position: clampPosition(node.position, nodeExtent),
      width: null,
      height: null,
      handleBounds: {},
      isDragging: false
    }
  });
};
var parseEdge = function parseEdge2(edge) {
  return _objectSpread$d(_objectSpread$d({}, edge), {}, {
    source: edge.source.toString(),
    target: edge.target.toString(),
    sourceHandle: edge.sourceHandle ? edge.sourceHandle.toString() : null,
    targetHandle: edge.targetHandle ? edge.targetHandle.toString() : null,
    id: edge.id.toString(),
    type: edge.type || "default"
  });
};
var getBoundsOfBoxes = function getBoundsOfBoxes2(box1, box2) {
  return {
    x: Math.min(box1.x, box2.x),
    y: Math.min(box1.y, box2.y),
    x2: Math.max(box1.x2, box2.x2),
    y2: Math.max(box1.y2, box2.y2)
  };
};
var rectToBox = function rectToBox2(_ref7) {
  var x3 = _ref7.x, y4 = _ref7.y, width2 = _ref7.width, height = _ref7.height;
  return {
    x: x3,
    y: y4,
    x2: x3 + width2,
    y2: y4 + height
  };
};
var boxToRect = function boxToRect2(_ref8) {
  var x3 = _ref8.x, y4 = _ref8.y, x22 = _ref8.x2, y22 = _ref8.y2;
  return {
    x: x3,
    y: y4,
    width: x22 - x3,
    height: y22 - y4
  };
};
var getBoundsofRects = function getBoundsofRects2(rect1, rect2) {
  return boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));
};
var getRectOfNodes = function getRectOfNodes2(nodes) {
  var box = nodes.reduce(function(currBox, _ref9) {
    var _ref9$__rf = _ref9.__rf;
    _ref9$__rf = _ref9$__rf === void 0 ? {} : _ref9$__rf;
    var position2 = _ref9$__rf.position, width2 = _ref9$__rf.width, height = _ref9$__rf.height;
    return getBoundsOfBoxes(currBox, rectToBox(_objectSpread$d(_objectSpread$d({}, position2), {}, {
      width: width2,
      height
    })));
  }, {
    x: Infinity,
    y: Infinity,
    x2: -Infinity,
    y2: -Infinity
  });
  return boxToRect(box);
};
var getNodesInside = function getNodesInside2(nodes, rect) {
  var _ref13 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [0, 0, 1], _ref14 = _slicedToArray$1(_ref13, 3), tx = _ref14[0], ty = _ref14[1], tScale = _ref14[2];
  var partially = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var excludeNonSelectableNodes = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var rBox = rectToBox({
    x: (rect.x - tx) / tScale,
    y: (rect.y - ty) / tScale,
    width: rect.width / tScale,
    height: rect.height / tScale
  });
  return nodes.filter(function(_ref15) {
    var _ref15$selectable = _ref15.selectable, selectable2 = _ref15$selectable === void 0 ? true : _ref15$selectable, _ref15$__rf = _ref15.__rf, position2 = _ref15$__rf.position, width2 = _ref15$__rf.width, height = _ref15$__rf.height, isDragging = _ref15$__rf.isDragging;
    if (excludeNonSelectableNodes && !selectable2) {
      return false;
    }
    var nBox = rectToBox(_objectSpread$d(_objectSpread$d({}, position2), {}, {
      width: width2,
      height
    }));
    var xOverlap = Math.max(0, Math.min(rBox.x2, nBox.x2) - Math.max(rBox.x, nBox.x));
    var yOverlap = Math.max(0, Math.min(rBox.y2, nBox.y2) - Math.max(rBox.y, nBox.y));
    var overlappingArea = Math.ceil(xOverlap * yOverlap);
    if (width2 === null || height === null || isDragging) {
      return true;
    }
    if (partially) {
      return overlappingArea > 0;
    }
    var area = width2 * height;
    return overlappingArea >= area;
  });
};
var getConnectedEdges = function getConnectedEdges2(nodes, edges) {
  var nodeIds = nodes.map(function(node) {
    return node.id;
  });
  return edges.filter(function(edge) {
    return nodeIds.includes(edge.source) || nodeIds.includes(edge.target);
  });
};
var parseElements = function parseElements2(nodes, edges) {
  return [].concat(_toConsumableArray2(nodes.map(function(node) {
    var n4 = _objectSpread$d({}, node);
    n4.position = n4.__rf.position;
    delete n4.__rf;
    return n4;
  })), _toConsumableArray2(edges.map(function(e3) {
    return _objectSpread$d({}, e3);
  })));
};
var onLoadGetElements = function onLoadGetElements2(currentStore) {
  return function() {
    var _currentStore$getStat2 = currentStore.getState(), _currentStore$getStat3 = _currentStore$getStat2.nodes, nodes = _currentStore$getStat3 === void 0 ? [] : _currentStore$getStat3, _currentStore$getStat4 = _currentStore$getStat2.edges, edges = _currentStore$getStat4 === void 0 ? [] : _currentStore$getStat4;
    return parseElements(nodes, edges);
  };
};
var onLoadToObject = function onLoadToObject2(currentStore) {
  return function() {
    var _currentStore$getStat5 = currentStore.getState(), _currentStore$getStat6 = _currentStore$getStat5.nodes, nodes = _currentStore$getStat6 === void 0 ? [] : _currentStore$getStat6, _currentStore$getStat7 = _currentStore$getStat5.edges, edges = _currentStore$getStat7 === void 0 ? [] : _currentStore$getStat7, transform3 = _currentStore$getStat5.transform;
    return {
      elements: parseElements(nodes, edges),
      position: [transform3[0], transform3[1]],
      zoom: transform3[2]
    };
  };
};
var getTransformForBounds = function getTransformForBounds2(bounds, width2, height, minZoom, maxZoom) {
  var padding = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0.1;
  var xZoom = width2 / (bounds.width * (1 + padding));
  var yZoom = height / (bounds.height * (1 + padding));
  var zoom2 = Math.min(xZoom, yZoom);
  var clampedZoom = clamp2(zoom2, minZoom, maxZoom);
  var boundsCenterX = bounds.x + bounds.width / 2;
  var boundsCenterY = bounds.y + bounds.height / 2;
  var x3 = width2 / 2 - boundsCenterX * clampedZoom;
  var y4 = height / 2 - boundsCenterY * clampedZoom;
  return [x3, y4, clampedZoom];
};
var useGlobalKeyHandler = function(_ref) {
  var deleteKeyCode = _ref.deleteKeyCode, multiSelectionKeyCode = _ref.multiSelectionKeyCode, onElementsRemove = _ref.onElementsRemove;
  var store2 = useStore();
  var unsetNodesSelection3 = useStoreActions(function(actions2) {
    return actions2.unsetNodesSelection;
  });
  var setMultiSelectionActive3 = useStoreActions(function(actions2) {
    return actions2.setMultiSelectionActive;
  });
  var resetSelectedElements3 = useStoreActions(function(actions2) {
    return actions2.resetSelectedElements;
  });
  var deleteKeyPressed = useKeyPress(deleteKeyCode);
  var multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode);
  react.useEffect(function() {
    var _store$getState = store2.getState(), edges = _store$getState.edges, selectedElements = _store$getState.selectedElements;
    if (onElementsRemove && deleteKeyPressed && selectedElements) {
      var selectedNodes = selectedElements.filter(isNode);
      var connectedEdges = getConnectedEdges(selectedNodes, edges);
      var elementsToRemove = [].concat(_toConsumableArray2(selectedElements), _toConsumableArray2(connectedEdges)).reduce(function(res, item) {
        return res.set(item.id, item);
      }, new Map());
      onElementsRemove(Array.from(elementsToRemove.values()));
      unsetNodesSelection3();
      resetSelectedElements3();
    }
  }, [deleteKeyPressed]);
  react.useEffect(function() {
    setMultiSelectionActive3(multiSelectionKeyPressed);
  }, [multiSelectionKeyPressed]);
};
var noop4 = {value: () => {
}};
function dispatch() {
  for (var i3 = 0, n4 = arguments.length, _23 = {}, t4; i3 < n4; ++i3) {
    if (!(t4 = arguments[i3] + "") || t4 in _23 || /[\s.]/.test(t4))
      throw new Error("illegal type: " + t4);
    _23[t4] = [];
  }
  return new Dispatch(_23);
}
function Dispatch(_23) {
  this._ = _23;
}
function parseTypenames$1(typenames, types2) {
  return typenames.trim().split(/^|\s+/).map(function(t4) {
    var name = "", i3 = t4.indexOf(".");
    if (i3 >= 0)
      name = t4.slice(i3 + 1), t4 = t4.slice(0, i3);
    if (t4 && !types2.hasOwnProperty(t4))
      throw new Error("unknown type: " + t4);
    return {type: t4, name};
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _23 = this._, T2 = parseTypenames$1(typename + "", _23), t4, i3 = -1, n4 = T2.length;
    if (arguments.length < 2) {
      while (++i3 < n4)
        if ((t4 = (typename = T2[i3]).type) && (t4 = get$1(_23[t4], typename.name)))
          return t4;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i3 < n4) {
      if (t4 = (typename = T2[i3]).type)
        _23[t4] = set$1(_23[t4], typename.name, callback);
      else if (callback == null)
        for (t4 in _23)
          _23[t4] = set$1(_23[t4], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy2 = {}, _23 = this._;
    for (var t4 in _23)
      copy2[t4] = _23[t4].slice();
    return new Dispatch(copy2);
  },
  call: function(type, that) {
    if ((n4 = arguments.length - 2) > 0)
      for (var args = new Array(n4), i3 = 0, n4, t4; i3 < n4; ++i3)
        args[i3] = arguments[i3 + 2];
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (t4 = this._[type], i3 = 0, n4 = t4.length; i3 < n4; ++i3)
      t4[i3].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (var t4 = this._[type], i3 = 0, n4 = t4.length; i3 < n4; ++i3)
      t4[i3].value.apply(that, args);
  }
};
function get$1(type, name) {
  for (var i3 = 0, n4 = type.length, c4; i3 < n4; ++i3) {
    if ((c4 = type[i3]).name === name) {
      return c4.value;
    }
  }
}
function set$1(type, name, callback) {
  for (var i3 = 0, n4 = type.length; i3 < n4; ++i3) {
    if (type[i3].name === name) {
      type[i3] = noop4, type = type.slice(0, i3).concat(type.slice(i3 + 1));
      break;
    }
  }
  if (callback != null)
    type.push({name, value: callback});
  return type;
}
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace(name) {
  var prefix2 = name += "", i3 = prefix2.indexOf(":");
  if (i3 >= 0 && (prefix2 = name.slice(0, i3)) !== "xmlns")
    name = name.slice(i3 + 1);
  return namespaces.hasOwnProperty(prefix2) ? {space: namespaces[prefix2], local: name} : name;
}
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name) {
  var fullname = namespace(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
function none() {
}
function selector(selector2) {
  return selector2 == null ? none : function() {
    return this.querySelector(selector2);
  };
}
function selection_select(select3) {
  if (typeof select3 !== "function")
    select3 = selector(select3);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {
    for (var group = groups2[j], n4 = group.length, subgroup = subgroups[j] = new Array(n4), node, subnode, i3 = 0; i3 < n4; ++i3) {
      if ((node = group[i3]) && (subnode = select3.call(node, node.__data__, i3, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i3] = subnode;
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function array(x3) {
  return x3 == null ? [] : Array.isArray(x3) ? x3 : Array.from(x3);
}
function empty() {
  return [];
}
function selectorAll(selector2) {
  return selector2 == null ? empty : function() {
    return this.querySelectorAll(selector2);
  };
}
function arrayAll(select3) {
  return function() {
    return array(select3.apply(this, arguments));
  };
}
function selection_selectAll(select3) {
  if (typeof select3 === "function")
    select3 = arrayAll(select3);
  else
    select3 = selectorAll(select3);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j = 0; j < m3; ++j) {
    for (var group = groups2[j], n4 = group.length, node, i3 = 0; i3 < n4; ++i3) {
      if (node = group[i3]) {
        subgroups.push(select3.call(node, node.__data__, i3, group));
        parents.push(node);
      }
    }
  }
  return new Selection$1(subgroups, parents);
}
function matcher(selector2) {
  return function() {
    return this.matches(selector2);
  };
}
function childMatcher(selector2) {
  return function(node) {
    return node.matches(selector2);
  };
}
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selection_selectChild(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selection_selectChildren(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}
function selection_filter(match) {
  if (typeof match !== "function")
    match = matcher(match);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {
    for (var group = groups2[j], n4 = group.length, subgroup = subgroups[j] = [], node, i3 = 0; i3 < n4; ++i3) {
      if ((node = group[i3]) && match.call(node, node.__data__, i3, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function sparse(update) {
  return new Array(update.length);
}
function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector2) {
    return this._parent.querySelector(selector2);
  },
  querySelectorAll: function(selector2) {
    return this._parent.querySelectorAll(selector2);
  }
};
function constant$2(x3) {
  return function() {
    return x3;
  };
}
function bindIndex(parent, group, enter, update, exit, data) {
  var i3 = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i3 < dataLength; ++i3) {
    if (node = group[i3]) {
      node.__data__ = data[i3];
      update[i3] = node;
    } else {
      enter[i3] = new EnterNode(parent, data[i3]);
    }
  }
  for (; i3 < groupLength; ++i3) {
    if (node = group[i3]) {
      exit[i3] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i3, node, nodeByKeyValue = new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i3 = 0; i3 < groupLength; ++i3) {
    if (node = group[i3]) {
      keyValues[i3] = keyValue = key.call(node, node.__data__, i3, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i3] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i3 = 0; i3 < dataLength; ++i3) {
    keyValue = key.call(parent, data[i3], i3, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i3] = node;
      node.__data__ = data[i3];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i3] = new EnterNode(parent, data[i3]);
    }
  }
  for (i3 = 0; i3 < groupLength; ++i3) {
    if ((node = group[i3]) && nodeByKeyValue.get(keyValues[i3]) === node) {
      exit[i3] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function selection_data(value, key) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind3 = key ? bindKey : bindIndex, parents = this._parents, groups2 = this._groups;
  if (typeof value !== "function")
    value = constant$2(value);
  for (var m3 = groups2.length, update = new Array(m3), enter = new Array(m3), exit = new Array(m3), j = 0; j < m3; ++j) {
    var parent = parents[j], group = groups2[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind3(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection$1(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}
function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update)
      update = update.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}
function selection_merge(context2) {
  var selection2 = context2.selection ? context2.selection() : context2;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m3; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n4 = group0.length, merge3 = merges[j] = new Array(n4), node, i3 = 0; i3 < n4; ++i3) {
      if (node = group0[i3] || group1[i3]) {
        merge3[i3] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection$1(merges, this._parents);
}
function selection_order() {
  for (var groups2 = this._groups, j = -1, m3 = groups2.length; ++j < m3; ) {
    for (var group = groups2[j], i3 = group.length - 1, next = group[i3], node; --i3 >= 0; ) {
      if (node = group[i3]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}
function selection_sort(compare) {
  if (!compare)
    compare = ascending;
  function compareNode(a2, b3) {
    return a2 && b3 ? compare(a2.__data__, b3.__data__) : !a2 - !b3;
  }
  for (var groups2 = this._groups, m3 = groups2.length, sortgroups = new Array(m3), j = 0; j < m3; ++j) {
    for (var group = groups2[j], n4 = group.length, sortgroup = sortgroups[j] = new Array(n4), node, i3 = 0; i3 < n4; ++i3) {
      if (node = group[i3]) {
        sortgroup[i3] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection$1(sortgroups, this._parents).order();
}
function ascending(a2, b3) {
  return a2 < b3 ? -1 : a2 > b3 ? 1 : a2 >= b3 ? 0 : NaN;
}
function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
function selection_nodes() {
  return Array.from(this);
}
function selection_node() {
  for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {
    for (var group = groups2[j], i3 = 0, n4 = group.length; i3 < n4; ++i3) {
      var node = group[i3];
      if (node)
        return node;
    }
  }
  return null;
}
function selection_size() {
  let size2 = 0;
  for (const node of this)
    ++size2;
  return size2;
}
function selection_empty() {
  return !this.node();
}
function selection_each(callback) {
  for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {
    for (var group = groups2[j], i3 = 0, n4 = group.length, node; i3 < n4; ++i3) {
      if (node = group[i3])
        callback.call(node, node.__data__, i3, group);
    }
  }
  return this;
}
function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$1(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS$1(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction$1(name, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v3);
  };
}
function attrFunctionNS$1(fullname, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v3);
  };
}
function selection_attr(name, value) {
  var fullname = namespace(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
}
function defaultView(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}
function styleRemove$1(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant$1(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction$1(name, value, priority) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v3, priority);
  };
}
function selection_style(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value === "function" ? styleFunction$1 : styleConstant$1)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null)
      delete this[name];
    else
      this[name] = v3;
  };
}
function selection_property(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i3 = this._names.indexOf(name);
    if (i3 < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i3 = this._names.indexOf(name);
    if (i3 >= 0) {
      this._names.splice(i3, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list3 = classList(node), i3 = -1, n4 = names.length;
  while (++i3 < n4)
    list3.add(names[i3]);
}
function classedRemove(node, names) {
  var list3 = classList(node), i3 = -1, n4 = names.length;
  while (++i3 < n4)
    list3.remove(names[i3]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function selection_classed(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list3 = classList(this.node()), i3 = -1, n4 = names.length;
    while (++i3 < n4)
      if (!list3.contains(names[i3]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}
function textRemove() {
  this.textContent = "";
}
function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction$1(value) {
  return function() {
    var v3 = value.apply(this, arguments);
    this.textContent = v3 == null ? "" : v3;
  };
}
function selection_text(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v3 = value.apply(this, arguments);
    this.innerHTML = v3 == null ? "" : v3;
  };
}
function selection_html(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise);
}
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}
function selection_append(name) {
  var create3 = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create3.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(name, before) {
  var create3 = typeof name === "function" ? name : creator(name), select3 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create3.apply(this, arguments), select3.apply(this, arguments) || null);
  });
}
function remove2() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function selection_remove() {
  return this.each(remove2);
}
function selection_cloneShallow() {
  var clone2 = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_cloneDeep() {
  var clone2 = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t4) {
    var name = "", i3 = t4.indexOf(".");
    if (i3 >= 0)
      name = t4.slice(i3 + 1), t4 = t4.slice(0, i3);
    return {type: t4, name};
  });
}
function onRemove(typename) {
  return function() {
    var on2 = this.__on;
    if (!on2)
      return;
    for (var j = 0, i3 = -1, m3 = on2.length, o; j < m3; ++j) {
      if (o = on2[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on2[++i3] = o;
      }
    }
    if (++i3)
      on2.length = i3;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on2 = this.__on, o, listener = contextListener(value);
    if (on2)
      for (var j = 0, m3 = on2.length; j < m3; ++j) {
        if ((o = on2[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value, listener, options};
    if (!on2)
      this.__on = [o];
    else
      on2.push(o);
  };
}
function selection_on(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i3, n4 = typenames.length, t4;
  if (arguments.length < 2) {
    var on2 = this.node().__on;
    if (on2)
      for (var j = 0, m3 = on2.length, o; j < m3; ++j) {
        for (i3 = 0, o = on2[j]; i3 < n4; ++i3) {
          if ((t4 = typenames[i3]).type === o.type && t4.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on2 = value ? onAdd : onRemove;
  for (i3 = 0; i3 < n4; ++i3)
    this.each(on2(typenames[i3], value, options));
  return this;
}
function dispatchEvent(node, type, params) {
  var window2 = defaultView(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}
function selection_dispatch(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}
function* selection_iterator() {
  for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {
    for (var group = groups2[j], i3 = 0, n4 = group.length, node; i3 < n4; ++i3) {
      if (node = group[i3])
        yield node;
    }
  }
}
var root2 = [null];
function Selection$1(groups2, parents) {
  this._groups = groups2;
  this._parents = parents;
}
function selection() {
  return new Selection$1([[document.documentElement]], root2);
}
function selection_selection() {
  return this;
}
Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};
function select2(selector2) {
  return typeof selector2 === "string" ? new Selection$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1([[selector2]], root2);
}
function sourceEvent(event) {
  let sourceEvent2;
  while (sourceEvent2 = event.sourceEvent)
    event = sourceEvent2;
  return event;
}
function pointer(event, node) {
  event = sourceEvent(event);
  if (node === void 0)
    node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}
var nonpassivecapture = {capture: true, passive: false};
function noevent$1(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function dragDisable(view) {
  var root3 = view.document.documentElement, selection2 = select2(view).on("dragstart.drag", noevent$1, nonpassivecapture);
  if ("onselectstart" in root3) {
    selection2.on("selectstart.drag", noevent$1, nonpassivecapture);
  } else {
    root3.__noselect = root3.style.MozUserSelect;
    root3.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root3 = view.document.documentElement, selection2 = select2(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent$1, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root3) {
    selection2.on("selectstart.drag", null);
  } else {
    root3.style.MozUserSelect = root3.__noselect;
    delete root3.__noselect;
  }
}
function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend2(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m3, l3;
  format = (format + "").trim().toLowerCase();
  return (m3 = reHex.exec(format)) ? (l3 = m3[1].length, m3 = parseInt(m3[1], 16), l3 === 6 ? rgbn(m3) : l3 === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l3 === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l3 === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n4) {
  return new Rgb(n4 >> 16 & 255, n4 >> 8 & 255, n4 & 255, 1);
}
function rgba(r4, g3, b3, a2) {
  if (a2 <= 0)
    r4 = g3 = b3 = NaN;
  return new Rgb(r4, g3, b3, a2);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r4, g3, b3, opacity) {
  return arguments.length === 1 ? rgbConvert(r4) : new Rgb(r4, g3, b3, opacity == null ? 1 : opacity);
}
function Rgb(r4, g3, b3, opacity) {
  this.r = +r4;
  this.g = +g3;
  this.b = +b3;
  this.opacity = +opacity;
}
define(Rgb, rgb, extend2(Color, {
  brighter: function(k3) {
    k3 = k3 == null ? brighter : Math.pow(brighter, k3);
    return new Rgb(this.r * k3, this.g * k3, this.b * k3, this.opacity);
  },
  darker: function(k3) {
    k3 = k3 == null ? darker : Math.pow(darker, k3);
    return new Rgb(this.r * k3, this.g * k3, this.b * k3, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a2 = this.opacity;
  a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
  return (a2 === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a2 === 1 ? ")" : ", " + a2 + ")");
}
function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h3, s2, l3, a2) {
  if (a2 <= 0)
    h3 = s2 = l3 = NaN;
  else if (l3 <= 0 || l3 >= 1)
    h3 = s2 = NaN;
  else if (s2 <= 0)
    h3 = NaN;
  return new Hsl(h3, s2, l3, a2);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r4 = o.r / 255, g3 = o.g / 255, b3 = o.b / 255, min2 = Math.min(r4, g3, b3), max2 = Math.max(r4, g3, b3), h3 = NaN, s2 = max2 - min2, l3 = (max2 + min2) / 2;
  if (s2) {
    if (r4 === max2)
      h3 = (g3 - b3) / s2 + (g3 < b3) * 6;
    else if (g3 === max2)
      h3 = (b3 - r4) / s2 + 2;
    else
      h3 = (r4 - g3) / s2 + 4;
    s2 /= l3 < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h3 *= 60;
  } else {
    s2 = l3 > 0 && l3 < 1 ? 0 : h3;
  }
  return new Hsl(h3, s2, l3, o.opacity);
}
function hsl(h3, s2, l3, opacity) {
  return arguments.length === 1 ? hslConvert(h3) : new Hsl(h3, s2, l3, opacity == null ? 1 : opacity);
}
function Hsl(h3, s2, l3, opacity) {
  this.h = +h3;
  this.s = +s2;
  this.l = +l3;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend2(Color, {
  brighter: function(k3) {
    k3 = k3 == null ? brighter : Math.pow(brighter, k3);
    return new Hsl(this.h, this.s, this.l * k3, this.opacity);
  },
  darker: function(k3) {
    k3 = k3 == null ? darker : Math.pow(darker, k3);
    return new Hsl(this.h, this.s, this.l * k3, this.opacity);
  },
  rgb: function() {
    var h3 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h3) || isNaN(this.s) ? 0 : this.s, l3 = this.l, m22 = l3 + (l3 < 0.5 ? l3 : 1 - l3) * s2, m1 = 2 * l3 - m22;
    return new Rgb(hsl2rgb(h3 >= 240 ? h3 - 240 : h3 + 120, m1, m22), hsl2rgb(h3, m1, m22), hsl2rgb(h3 < 120 ? h3 + 240 : h3 - 120, m1, m22), this.opacity);
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a2 = this.opacity;
    a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
    return (a2 === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a2 === 1 ? ")" : ", " + a2 + ")");
  }
}));
function hsl2rgb(h3, m1, m22) {
  return (h3 < 60 ? m1 + (m22 - m1) * h3 / 60 : h3 < 180 ? m22 : h3 < 240 ? m1 + (m22 - m1) * (240 - h3) / 60 : m1) * 255;
}
var constant$1 = (x3) => () => x3;
function linear(a2, d3) {
  return function(t4) {
    return a2 + t4 * d3;
  };
}
function exponential(a2, b3, y4) {
  return a2 = Math.pow(a2, y4), b3 = Math.pow(b3, y4) - a2, y4 = 1 / y4, function(t4) {
    return Math.pow(a2 + t4 * b3, y4);
  };
}
function gamma(y4) {
  return (y4 = +y4) === 1 ? nogamma : function(a2, b3) {
    return b3 - a2 ? exponential(a2, b3, y4) : constant$1(isNaN(a2) ? b3 : a2);
  };
}
function nogamma(a2, b3) {
  var d3 = b3 - a2;
  return d3 ? linear(a2, d3) : constant$1(isNaN(a2) ? b3 : a2);
}
var interpolateRgb = function rgbGamma(y4) {
  var color2 = gamma(y4);
  function rgb$1(start3, end2) {
    var r4 = color2((start3 = rgb(start3)).r, (end2 = rgb(end2)).r), g3 = color2(start3.g, end2.g), b3 = color2(start3.b, end2.b), opacity = nogamma(start3.opacity, end2.opacity);
    return function(t4) {
      start3.r = r4(t4);
      start3.g = g3(t4);
      start3.b = b3(t4);
      start3.opacity = opacity(t4);
      return start3 + "";
    };
  }
  rgb$1.gamma = rgbGamma;
  return rgb$1;
}(1);
function interpolateNumber(a2, b3) {
  return a2 = +a2, b3 = +b3, function(t4) {
    return a2 * (1 - t4) + b3 * t4;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero(b3) {
  return function() {
    return b3;
  };
}
function one(b3) {
  return function(t4) {
    return b3(t4) + "";
  };
}
function interpolateString(a2, b3) {
  var bi2 = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i3 = -1, s2 = [], q3 = [];
  a2 = a2 + "", b3 = b3 + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b3))) {
    if ((bs = bm.index) > bi2) {
      bs = b3.slice(bi2, bs);
      if (s2[i3])
        s2[i3] += bs;
      else
        s2[++i3] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i3])
        s2[i3] += bm;
      else
        s2[++i3] = bm;
    } else {
      s2[++i3] = null;
      q3.push({i: i3, x: interpolateNumber(am, bm)});
    }
    bi2 = reB.lastIndex;
  }
  if (bi2 < b3.length) {
    bs = b3.slice(bi2);
    if (s2[i3])
      s2[i3] += bs;
    else
      s2[++i3] = bs;
  }
  return s2.length < 2 ? q3[0] ? one(q3[0].x) : zero(b3) : (b3 = q3.length, function(t4) {
    for (var i4 = 0, o; i4 < b3; ++i4)
      s2[(o = q3[i4]).i] = o.x(t4);
    return s2.join("");
  });
}
var degrees = 180 / Math.PI;
var identity$1 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose(a2, b3, c4, d3, e3, f3) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a2 * a2 + b3 * b3))
    a2 /= scaleX, b3 /= scaleX;
  if (skewX = a2 * c4 + b3 * d3)
    c4 -= a2 * skewX, d3 -= b3 * skewX;
  if (scaleY = Math.sqrt(c4 * c4 + d3 * d3))
    c4 /= scaleY, d3 /= scaleY, skewX /= scaleY;
  if (a2 * d3 < b3 * c4)
    a2 = -a2, b3 = -b3, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e3,
    translateY: f3,
    rotate: Math.atan2(b3, a2) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}
var svgNode;
function parseCss(value) {
  const m3 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m3.isIdentity ? identity$1 : decompose(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);
}
function parseSvg(value) {
  if (value == null)
    return identity$1;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity$1;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate(xa2, ya2, xb2, yb2, s2, q3) {
    if (xa2 !== xb2 || ya2 !== yb2) {
      var i3 = s2.push("translate(", null, pxComma, null, pxParen);
      q3.push({i: i3 - 4, x: interpolateNumber(xa2, xb2)}, {i: i3 - 2, x: interpolateNumber(ya2, yb2)});
    } else if (xb2 || yb2) {
      s2.push("translate(" + xb2 + pxComma + yb2 + pxParen);
    }
  }
  function rotate(a2, b3, s2, q3) {
    if (a2 !== b3) {
      if (a2 - b3 > 180)
        b3 += 360;
      else if (b3 - a2 > 180)
        a2 += 360;
      q3.push({i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: interpolateNumber(a2, b3)});
    } else if (b3) {
      s2.push(pop(s2) + "rotate(" + b3 + degParen);
    }
  }
  function skewX(a2, b3, s2, q3) {
    if (a2 !== b3) {
      q3.push({i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: interpolateNumber(a2, b3)});
    } else if (b3) {
      s2.push(pop(s2) + "skewX(" + b3 + degParen);
    }
  }
  function scale(xa2, ya2, xb2, yb2, s2, q3) {
    if (xa2 !== xb2 || ya2 !== yb2) {
      var i3 = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q3.push({i: i3 - 4, x: interpolateNumber(xa2, xb2)}, {i: i3 - 2, x: interpolateNumber(ya2, yb2)});
    } else if (xb2 !== 1 || yb2 !== 1) {
      s2.push(pop(s2) + "scale(" + xb2 + "," + yb2 + ")");
    }
  }
  return function(a2, b3) {
    var s2 = [], q3 = [];
    a2 = parse2(a2), b3 = parse2(b3);
    translate(a2.translateX, a2.translateY, b3.translateX, b3.translateY, s2, q3);
    rotate(a2.rotate, b3.rotate, s2, q3);
    skewX(a2.skewX, b3.skewX, s2, q3);
    scale(a2.scaleX, a2.scaleY, b3.scaleX, b3.scaleY, s2, q3);
    a2 = b3 = null;
    return function(t4) {
      var i3 = -1, n4 = q3.length, o;
      while (++i3 < n4)
        s2[(o = q3[i3]).i] = o.x(t4);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
var epsilon2 = 1e-12;
function cosh(x3) {
  return ((x3 = Math.exp(x3)) + 1 / x3) / 2;
}
function sinh(x3) {
  return ((x3 = Math.exp(x3)) - 1 / x3) / 2;
}
function tanh(x3) {
  return ((x3 = Math.exp(2 * x3)) - 1) / (x3 + 1);
}
var interpolateZoom = function zoomRho(rho, rho2, rho4) {
  function zoom2(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d22 = dx * dx + dy * dy, i3, S2;
    if (d22 < epsilon2) {
      S2 = Math.log(w1 / w0) / rho;
      i3 = function(t4) {
        return [
          ux0 + t4 * dx,
          uy0 + t4 * dy,
          w0 * Math.exp(rho * t4 * S2)
        ];
      };
    } else {
      var d1 = Math.sqrt(d22), b0 = (w1 * w1 - w0 * w0 + rho4 * d22) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d22) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S2 = (r1 - r0) / rho;
      i3 = function(t4) {
        var s2 = t4 * S2, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s2 + r0)
        ];
      };
    }
    i3.duration = S2 * 1e3 * rho / Math.SQRT2;
    return i3;
  }
  zoom2.rho = function(_23) {
    var _1 = Math.max(1e-3, +_23), _24 = _1 * _1, _42 = _24 * _24;
    return zoomRho(_1, _24, _42);
  };
  return zoom2;
}(Math.SQRT2, 2, 4);
var frame = 0;
var timeout$1 = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f3) {
  setTimeout(f3, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay3, time2) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now() : +time2) + (delay3 == null ? 0 : +delay3);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time2;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay3, time2) {
  var t4 = new Timer();
  t4.restart(callback, delay3, time2);
  return t4;
}
function timerFlush() {
  now();
  ++frame;
  var t4 = taskHead, e3;
  while (t4) {
    if ((e3 = clockNow - t4._time) >= 0)
      t4._call.call(void 0, e3);
    t4 = t4._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now3 = clock.now(), delay3 = now3 - clockLast;
  if (delay3 > pokeDelay)
    clockSkew -= delay3, clockLast = now3;
}
function nap() {
  var t0, t1 = taskHead, t22, time2 = Infinity;
  while (t1) {
    if (t1._call) {
      if (time2 > t1._time)
        time2 = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t22 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t22 : taskHead = t22;
    }
  }
  taskTail = t0;
  sleep(time2);
}
function sleep(time2) {
  if (frame)
    return;
  if (timeout$1)
    timeout$1 = clearTimeout(timeout$1);
  var delay3 = time2 - clockNow;
  if (delay3 > 24) {
    if (time2 < Infinity)
      timeout$1 = setTimeout(wake, time2 - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
function timeout(callback, delay3, time2) {
  var t4 = new Timer();
  delay3 = delay3 == null ? 0 : +delay3;
  t4.restart((elapsed) => {
    t4.stop();
    callback(elapsed + delay3);
  }, delay3, time2);
  return t4;
}
var emptyOn = dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule(node, name, id3, index3, group, timing) {
  var schedules = node.__transition;
  if (!schedules)
    node.__transition = {};
  else if (id3 in schedules)
    return;
  create2(node, id3, {
    name,
    index: index3,
    group,
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init2(node, id3) {
  var schedule2 = get3(node, id3);
  if (schedule2.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule2;
}
function set2(node, id3) {
  var schedule2 = get3(node, id3);
  if (schedule2.state > STARTED)
    throw new Error("too late; already running");
  return schedule2;
}
function get3(node, id3) {
  var schedule2 = node.__transition;
  if (!schedule2 || !(schedule2 = schedule2[id3]))
    throw new Error("transition not found");
  return schedule2;
}
function create2(node, id3, self2) {
  var schedules = node.__transition, tween;
  schedules[id3] = self2;
  self2.timer = timer(schedule2, 0, self2.time);
  function schedule2(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start3, self2.delay, self2.time);
    if (self2.delay <= elapsed)
      start3(elapsed - self2.delay);
  }
  function start3(elapsed) {
    var i3, j, n4, o;
    if (self2.state !== SCHEDULED)
      return stop();
    for (i3 in schedules) {
      o = schedules[i3];
      if (o.name !== self2.name)
        continue;
      if (o.state === STARTED)
        return timeout(start3);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i3];
      } else if (+i3 < id3) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i3];
      }
    }
    timeout(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick, self2.delay, self2.time);
        tick(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node, node.__data__, self2.index, self2.group);
    if (self2.state !== STARTING)
      return;
    self2.state = STARTED;
    tween = new Array(n4 = self2.tween.length);
    for (i3 = 0, j = -1; i3 < n4; ++i3) {
      if (o = self2.tween[i3].value.call(node, node.__data__, self2.index, self2.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t4 = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i3 = -1, n4 = tween.length;
    while (++i3 < n4) {
      tween[i3].call(node, t4);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node, node.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id3];
    for (var i3 in schedules)
      return;
    delete node.__transition;
  }
}
function interrupt(node, name) {
  var schedules = node.__transition, schedule2, active, empty2 = true, i3;
  if (!schedules)
    return;
  name = name == null ? null : name + "";
  for (i3 in schedules) {
    if ((schedule2 = schedules[i3]).name !== name) {
      empty2 = false;
      continue;
    }
    active = schedule2.state > STARTING && schedule2.state < ENDING;
    schedule2.state = ENDED;
    schedule2.timer.stop();
    schedule2.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule2.index, schedule2.group);
    delete schedules[i3];
  }
  if (empty2)
    delete node.__transition;
}
function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}
function tweenRemove(id3, name) {
  var tween0, tween1;
  return function() {
    var schedule2 = set2(this, id3), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i3 = 0, n4 = tween1.length; i3 < n4; ++i3) {
        if (tween1[i3].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i3, 1);
          break;
        }
      }
    }
    schedule2.tween = tween1;
  };
}
function tweenFunction(id3, name, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule2 = set2(this, id3), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t4 = {name, value}, i3 = 0, n4 = tween1.length; i3 < n4; ++i3) {
        if (tween1[i3].name === name) {
          tween1[i3] = t4;
          break;
        }
      }
      if (i3 === n4)
        tween1.push(t4);
    }
    schedule2.tween = tween1;
  };
}
function transition_tween(name, value) {
  var id3 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get3(this.node(), id3).tween;
    for (var i3 = 0, n4 = tween.length, t4; i3 < n4; ++i3) {
      if ((t4 = tween[i3]).name === name) {
        return t4.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id3, name, value));
}
function tweenValue(transition, name, value) {
  var id3 = transition._id;
  transition.each(function() {
    var schedule2 = set2(this, id3);
    (schedule2.value || (schedule2.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get3(node, id3).value[name];
  };
}
function interpolate(a2, b3) {
  var c4;
  return (typeof b3 === "number" ? interpolateNumber : b3 instanceof color ? interpolateRgb : (c4 = color(b3)) ? (b3 = c4, interpolateRgb) : interpolateString)(a2, b3);
}
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrConstantNS(fullname, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrFunction(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function attrFunctionNS(fullname, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function transition_attr(name, value) {
  var fullname = namespace(name), i3 = fullname === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i3, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i3, value));
}
function attrInterpolate(name, i3) {
  return function(t4) {
    this.setAttribute(name, i3.call(this, t4));
  };
}
function attrInterpolateNS(fullname, i3) {
  return function(t4) {
    this.setAttributeNS(fullname.space, fullname.local, i3.call(this, t4));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i3 = value.apply(this, arguments);
    if (i3 !== i0)
      t0 = (i0 = i3) && attrInterpolateNS(fullname, i3);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i3 = value.apply(this, arguments);
    if (i3 !== i0)
      t0 = (i0 = i3) && attrInterpolate(name, i3);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}
function delayFunction(id3, value) {
  return function() {
    init2(this, id3).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id3, value) {
  return value = +value, function() {
    init2(this, id3).delay = value;
  };
}
function transition_delay(value) {
  var id3 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id3, value)) : get3(this.node(), id3).delay;
}
function durationFunction(id3, value) {
  return function() {
    set2(this, id3).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id3, value) {
  return value = +value, function() {
    set2(this, id3).duration = value;
  };
}
function transition_duration(value) {
  var id3 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id3, value)) : get3(this.node(), id3).duration;
}
function easeConstant(id3, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set2(this, id3).ease = value;
  };
}
function transition_ease(value) {
  var id3 = this._id;
  return arguments.length ? this.each(easeConstant(id3, value)) : get3(this.node(), id3).ease;
}
function easeVarying(id3, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (typeof v3 !== "function")
      throw new Error();
    set2(this, id3).ease = v3;
  };
}
function transition_easeVarying(value) {
  if (typeof value !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value));
}
function transition_filter(match) {
  if (typeof match !== "function")
    match = matcher(match);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {
    for (var group = groups2[j], n4 = group.length, subgroup = subgroups[j] = [], node, i3 = 0; i3 < n4; ++i3) {
      if ((node = group[i3]) && match.call(node, node.__data__, i3, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}
function transition_merge(transition) {
  if (transition._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m3; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n4 = group0.length, merge3 = merges[j] = new Array(n4), node, i3 = 0; i3 < n4; ++i3) {
      if (node = group0[i3] || group1[i3]) {
        merge3[i3] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}
function start2(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t4) {
    var i3 = t4.indexOf(".");
    if (i3 >= 0)
      t4 = t4.slice(0, i3);
    return !t4 || t4 === "start";
  });
}
function onFunction(id3, name, listener) {
  var on0, on1, sit = start2(name) ? init2 : set2;
  return function() {
    var schedule2 = sit(this, id3), on2 = schedule2.on;
    if (on2 !== on0)
      (on1 = (on0 = on2).copy()).on(name, listener);
    schedule2.on = on1;
  };
}
function transition_on(name, listener) {
  var id3 = this._id;
  return arguments.length < 2 ? get3(this.node(), id3).on.on(name) : this.each(onFunction(id3, name, listener));
}
function removeFunction(id3) {
  return function() {
    var parent = this.parentNode;
    for (var i3 in this.__transition)
      if (+i3 !== id3)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}
function transition_select(select3) {
  var name = this._name, id3 = this._id;
  if (typeof select3 !== "function")
    select3 = selector(select3);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {
    for (var group = groups2[j], n4 = group.length, subgroup = subgroups[j] = new Array(n4), node, subnode, i3 = 0; i3 < n4; ++i3) {
      if ((node = group[i3]) && (subnode = select3.call(node, node.__data__, i3, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i3] = subnode;
        schedule(subgroup[i3], name, id3, i3, subgroup, get3(node, id3));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id3);
}
function transition_selectAll(select3) {
  var name = this._name, id3 = this._id;
  if (typeof select3 !== "function")
    select3 = selectorAll(select3);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j = 0; j < m3; ++j) {
    for (var group = groups2[j], n4 = group.length, node, i3 = 0; i3 < n4; ++i3) {
      if (node = group[i3]) {
        for (var children2 = select3.call(node, node.__data__, i3, group), child, inherit2 = get3(node, id3), k3 = 0, l3 = children2.length; k3 < l3; ++k3) {
          if (child = children2[k3]) {
            schedule(child, name, id3, k3, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id3);
}
var Selection = selection.prototype.constructor;
function transition_selection() {
  return new Selection(this._groups, this._parents);
}
function styleNull(name, interpolate2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
  };
}
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function styleFunction(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function styleMaybeRemove(id3, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove3;
  return function() {
    var schedule2 = set2(this, id3), on2 = schedule2.on, listener = schedule2.value[key] == null ? remove3 || (remove3 = styleRemove(name)) : void 0;
    if (on2 !== on0 || listener0 !== listener)
      (on1 = (on0 = on2).copy()).on(event, listener0 = listener);
    schedule2.on = on1;
  };
}
function transition_style(name, value, priority) {
  var i3 = (name += "") === "transform" ? interpolateTransformCss : interpolate;
  return value == null ? this.styleTween(name, styleNull(name, i3)).on("end.style." + name, styleRemove(name)) : typeof value === "function" ? this.styleTween(name, styleFunction(name, i3, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i3, value), priority).on("end.style." + name, null);
}
function styleInterpolate(name, i3, priority) {
  return function(t4) {
    this.style.setProperty(name, i3.call(this, t4), priority);
  };
}
function styleTween(name, value, priority) {
  var t4, i0;
  function tween() {
    var i3 = value.apply(this, arguments);
    if (i3 !== i0)
      t4 = (i0 = i3) && styleInterpolate(name, i3, priority);
    return t4;
  }
  tween._value = value;
  return tween;
}
function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function transition_text(value) {
  return this.tween("text", typeof value === "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
}
function textInterpolate(i3) {
  return function(t4) {
    this.textContent = i3.call(this, t4);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i3 = value.apply(this, arguments);
    if (i3 !== i0)
      t0 = (i0 = i3) && textInterpolate(i3);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween(value));
}
function transition_transition() {
  var name = this._name, id0 = this._id, id1 = newId2();
  for (var groups2 = this._groups, m3 = groups2.length, j = 0; j < m3; ++j) {
    for (var group = groups2[j], n4 = group.length, node, i3 = 0; i3 < n4; ++i3) {
      if (node = group[i3]) {
        var inherit2 = get3(node, id0);
        schedule(node, name, id1, i3, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups2, this._parents, name, id1);
}
function transition_end() {
  var on0, on1, that = this, id3 = that._id, size2 = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject}, end2 = {value: function() {
      if (--size2 === 0)
        resolve();
    }};
    that.each(function() {
      var schedule2 = set2(this, id3), on2 = schedule2.on;
      if (on2 !== on0) {
        on1 = (on0 = on2).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end2);
      }
      schedule2.on = on1;
    });
    if (size2 === 0)
      resolve();
  });
}
var id2 = 0;
function Transition(groups2, parents, name, id3) {
  this._groups = groups2;
  this._parents = parents;
  this._name = name;
  this._id = id3;
}
function newId2() {
  return ++id2;
}
var selection_prototype = selection.prototype;
Transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  easeVarying: transition_easeVarying,
  end: transition_end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};
function cubicInOut(t4) {
  return ((t4 *= 2) <= 1 ? t4 * t4 * t4 : (t4 -= 2) * t4 * t4 + 2) / 2;
}
var defaultTiming = {
  time: null,
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id3) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id3])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id3} not found`);
    }
  }
  return timing;
}
function selection_transition(name) {
  var id3, timing;
  if (name instanceof Transition) {
    id3 = name._id, name = name._name;
  } else {
    id3 = newId2(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups2 = this._groups, m3 = groups2.length, j = 0; j < m3; ++j) {
    for (var group = groups2[j], n4 = group.length, node, i3 = 0; i3 < n4; ++i3) {
      if (node = group[i3]) {
        schedule(node, name, id3, i3, group, timing || inherit(node, id3));
      }
    }
  }
  return new Transition(groups2, this._parents, name, id3);
}
selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;
var constant2 = (x3) => () => x3;
function ZoomEvent(type, {
  sourceEvent: sourceEvent2,
  target,
  transform: transform3,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent2, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    transform: {value: transform3, enumerable: true, configurable: true},
    _: {value: dispatch2}
  });
}
function Transform(k3, x3, y4) {
  this.k = k3;
  this.x = x3;
  this.y = y4;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k3) {
    return k3 === 1 ? this : new Transform(this.k * k3, this.x, this.y);
  },
  translate: function(x3, y4) {
    return x3 === 0 & y4 === 0 ? this : new Transform(this.k, this.x + this.k * x3, this.y + this.k * y4);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x3) {
    return x3 * this.k + this.x;
  },
  applyY: function(y4) {
    return y4 * this.k + this.y;
  },
  invert: function(location2) {
    return [(location2[0] - this.x) / this.k, (location2[1] - this.y) / this.k];
  },
  invertX: function(x3) {
    return (x3 - this.x) / this.k;
  },
  invertY: function(y4) {
    return (y4 - this.y) / this.k;
  },
  rescaleX: function(x3) {
    return x3.copy().domain(x3.range().map(this.invertX, this).map(x3.invert, x3));
  },
  rescaleY: function(y4) {
    return y4.copy().domain(y4.range().map(this.invertY, this).map(y4.invert, y4));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity2 = new Transform(1, 0, 0);
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent() {
  var e3 = this;
  if (e3 instanceof SVGElement) {
    e3 = e3.ownerSVGElement || e3;
    if (e3.hasAttribute("viewBox")) {
      e3 = e3.viewBox.baseVal;
      return [[e3.x, e3.y], [e3.x + e3.width, e3.y + e3.height]];
    }
    return [[0, 0], [e3.width.baseVal.value, e3.height.baseVal.value]];
  }
  return [[0, 0], [e3.clientWidth, e3.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity2;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform3, extent, translateExtent) {
  var dx0 = transform3.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform3.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform3.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform3.invertY(extent[1][1]) - translateExtent[1][1];
  return transform3.translate(dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1), dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1));
}
function zoom() {
  var filter3 = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate2 = interpolateZoom, listeners = dispatch("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom2(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, {passive: false}).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom2.transform = function(collection, transform3, point, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule2(collection, transform3, point, event);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform3 === "function" ? transform3.apply(this, arguments) : transform3).end();
      });
    }
  };
  zoom2.scaleBy = function(selection2, k3, p3, event) {
    zoom2.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k3 === "function" ? k3.apply(this, arguments) : k3;
      return k0 * k1;
    }, p3, event);
  };
  zoom2.scaleTo = function(selection2, k3, p3, event) {
    zoom2.transform(selection2, function() {
      var e3 = extent.apply(this, arguments), t0 = this.__zoom, p0 = p3 == null ? centroid(e3) : typeof p3 === "function" ? p3.apply(this, arguments) : p3, p1 = t0.invert(p0), k1 = typeof k3 === "function" ? k3.apply(this, arguments) : k3;
      return constrain(translate(scale(t0, k1), p0, p1), e3, translateExtent);
    }, p3, event);
  };
  zoom2.translateBy = function(selection2, x3, y4, event) {
    zoom2.transform(selection2, function() {
      return constrain(this.__zoom.translate(typeof x3 === "function" ? x3.apply(this, arguments) : x3, typeof y4 === "function" ? y4.apply(this, arguments) : y4), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom2.translateTo = function(selection2, x3, y4, p3, event) {
    zoom2.transform(selection2, function() {
      var e3 = extent.apply(this, arguments), t4 = this.__zoom, p0 = p3 == null ? centroid(e3) : typeof p3 === "function" ? p3.apply(this, arguments) : p3;
      return constrain(identity2.translate(p0[0], p0[1]).scale(t4.k).translate(typeof x3 === "function" ? -x3.apply(this, arguments) : -x3, typeof y4 === "function" ? -y4.apply(this, arguments) : -y4), e3, translateExtent);
    }, p3, event);
  };
  function scale(transform3, k3) {
    k3 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k3));
    return k3 === transform3.k ? transform3 : new Transform(k3, transform3.x, transform3.y);
  }
  function translate(transform3, p0, p1) {
    var x3 = p0[0] - p1[0] * transform3.k, y4 = p0[1] - p1[1] * transform3.k;
    return x3 === transform3.x && y4 === transform3.y ? transform3 : new Transform(transform3.k, x3, y4);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule2(transition, transform3, point, event) {
    transition.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g3 = gesture(that, args).event(event), e3 = extent.apply(that, args), p3 = point == null ? centroid(e3) : typeof point === "function" ? point.apply(that, args) : point, w3 = Math.max(e3[1][0] - e3[0][0], e3[1][1] - e3[0][1]), a2 = that.__zoom, b3 = typeof transform3 === "function" ? transform3.apply(that, args) : transform3, i3 = interpolate2(a2.invert(p3).concat(w3 / a2.k), b3.invert(p3).concat(w3 / b3.k));
      return function(t4) {
        if (t4 === 1)
          t4 = b3;
        else {
          var l3 = i3(t4), k3 = w3 / l3[2];
          t4 = new Transform(k3, p3[0] - l3[0] * k3, p3[1] - l3[1] * k3);
        }
        g3.zoom(null, t4);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      if (event)
        this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform3) {
      if (this.mouse && key !== "mouse")
        this.mouse[1] = transform3.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch")
        this.touch0[1] = transform3.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch")
        this.touch1[1] = transform3.invert(this.touch1[0]);
      this.that.__zoom = transform3;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d3 = select2(this.that).datum();
      listeners.call(type, this.that, new ZoomEvent(type, {
        sourceEvent: this.sourceEvent,
        target: zoom2,
        type,
        transform: this.that.__zoom,
        dispatch: listeners
      }), d3);
    }
  };
  function wheeled(event, ...args) {
    if (!filter3.apply(this, arguments))
      return;
    var g3 = gesture(this, args).event(event), t4 = this.__zoom, k3 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t4.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p3 = pointer(event);
    if (g3.wheel) {
      if (g3.mouse[0][0] !== p3[0] || g3.mouse[0][1] !== p3[1]) {
        g3.mouse[1] = t4.invert(g3.mouse[0] = p3);
      }
      clearTimeout(g3.wheel);
    } else if (t4.k === k3)
      return;
    else {
      g3.mouse = [p3, t4.invert(p3)];
      interrupt(this);
      g3.start();
    }
    noevent(event);
    g3.wheel = setTimeout(wheelidled, wheelDelay);
    g3.zoom("mouse", constrain(translate(scale(t4, k3), g3.mouse[0], g3.mouse[1]), g3.extent, translateExtent));
    function wheelidled() {
      g3.wheel = null;
      g3.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter3.apply(this, arguments))
      return;
    var currentTarget = event.currentTarget, g3 = gesture(this, args, true).event(event), v3 = select2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p3 = pointer(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
    dragDisable(event.view);
    nopropagation(event);
    g3.mouse = [p3, this.__zoom.invert(p3)];
    interrupt(this);
    g3.start();
    function mousemoved(event2) {
      noevent(event2);
      if (!g3.moved) {
        var dx = event2.clientX - x0, dy = event2.clientY - y0;
        g3.moved = dx * dx + dy * dy > clickDistance2;
      }
      g3.event(event2).zoom("mouse", constrain(translate(g3.that.__zoom, g3.mouse[0] = pointer(event2, currentTarget), g3.mouse[1]), g3.extent, translateExtent));
    }
    function mouseupped(event2) {
      v3.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event2.view, g3.moved);
      noevent(event2);
      g3.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (!filter3.apply(this, arguments))
      return;
    var t0 = this.__zoom, p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
    noevent(event);
    if (duration > 0)
      select2(this).transition().duration(duration).call(schedule2, t1, p0, event);
    else
      select2(this).call(zoom2.transform, t1, p0, event);
  }
  function touchstarted(event, ...args) {
    if (!filter3.apply(this, arguments))
      return;
    var touches = event.touches, n4 = touches.length, g3 = gesture(this, args, event.changedTouches.length === n4).event(event), started, i3, t4, p3;
    nopropagation(event);
    for (i3 = 0; i3 < n4; ++i3) {
      t4 = touches[i3], p3 = pointer(t4, this);
      p3 = [p3, this.__zoom.invert(p3), t4.identifier];
      if (!g3.touch0)
        g3.touch0 = p3, started = true, g3.taps = 1 + !!touchstarting;
      else if (!g3.touch1 && g3.touch0[2] !== p3[2])
        g3.touch1 = p3, g3.taps = 0;
    }
    if (touchstarting)
      touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g3.taps < 2)
        touchfirst = p3[0], touchstarting = setTimeout(function() {
          touchstarting = null;
        }, touchDelay);
      interrupt(this);
      g3.start();
    }
  }
  function touchmoved(event, ...args) {
    if (!this.__zooming)
      return;
    var g3 = gesture(this, args).event(event), touches = event.changedTouches, n4 = touches.length, i3, t4, p3, l3;
    noevent(event);
    for (i3 = 0; i3 < n4; ++i3) {
      t4 = touches[i3], p3 = pointer(t4, this);
      if (g3.touch0 && g3.touch0[2] === t4.identifier)
        g3.touch0[0] = p3;
      else if (g3.touch1 && g3.touch1[2] === t4.identifier)
        g3.touch1[0] = p3;
    }
    t4 = g3.that.__zoom;
    if (g3.touch1) {
      var p0 = g3.touch0[0], l0 = g3.touch0[1], p1 = g3.touch1[0], l1 = g3.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t4 = scale(t4, Math.sqrt(dp / dl));
      p3 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l3 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g3.touch0)
      p3 = g3.touch0[0], l3 = g3.touch0[1];
    else
      return;
    g3.zoom("touch", constrain(translate(t4, p3, l3), g3.extent, translateExtent));
  }
  function touchended(event, ...args) {
    if (!this.__zooming)
      return;
    var g3 = gesture(this, args).event(event), touches = event.changedTouches, n4 = touches.length, i3, t4;
    nopropagation(event);
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i3 = 0; i3 < n4; ++i3) {
      t4 = touches[i3];
      if (g3.touch0 && g3.touch0[2] === t4.identifier)
        delete g3.touch0;
      else if (g3.touch1 && g3.touch1[2] === t4.identifier)
        delete g3.touch1;
    }
    if (g3.touch1 && !g3.touch0)
      g3.touch0 = g3.touch1, delete g3.touch1;
    if (g3.touch0)
      g3.touch0[1] = this.__zoom.invert(g3.touch0[0]);
    else {
      g3.end();
      if (g3.taps === 2) {
        t4 = pointer(t4, this);
        if (Math.hypot(touchfirst[0] - t4[0], touchfirst[1] - t4[1]) < tapDistance) {
          var p3 = select2(this).on("dblclick.zoom");
          if (p3)
            p3.apply(this, arguments);
        }
      }
    }
  }
  zoom2.wheelDelta = function(_23) {
    return arguments.length ? (wheelDelta = typeof _23 === "function" ? _23 : constant2(+_23), zoom2) : wheelDelta;
  };
  zoom2.filter = function(_23) {
    return arguments.length ? (filter3 = typeof _23 === "function" ? _23 : constant2(!!_23), zoom2) : filter3;
  };
  zoom2.touchable = function(_23) {
    return arguments.length ? (touchable = typeof _23 === "function" ? _23 : constant2(!!_23), zoom2) : touchable;
  };
  zoom2.extent = function(_23) {
    return arguments.length ? (extent = typeof _23 === "function" ? _23 : constant2([[+_23[0][0], +_23[0][1]], [+_23[1][0], +_23[1][1]]]), zoom2) : extent;
  };
  zoom2.scaleExtent = function(_23) {
    return arguments.length ? (scaleExtent[0] = +_23[0], scaleExtent[1] = +_23[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom2.translateExtent = function(_23) {
    return arguments.length ? (translateExtent[0][0] = +_23[0][0], translateExtent[1][0] = +_23[1][0], translateExtent[0][1] = +_23[0][1], translateExtent[1][1] = +_23[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom2.constrain = function(_23) {
    return arguments.length ? (constrain = _23, zoom2) : constrain;
  };
  zoom2.duration = function(_23) {
    return arguments.length ? (duration = +_23, zoom2) : duration;
  };
  zoom2.interpolate = function(_23) {
    return arguments.length ? (interpolate2 = _23, zoom2) : interpolate2;
  };
  zoom2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom2 : value;
  };
  zoom2.clickDistance = function(_23) {
    return arguments.length ? (clickDistance2 = (_23 = +_23) * _23, zoom2) : Math.sqrt(clickDistance2);
  };
  zoom2.tapDistance = function(_23) {
    return arguments.length ? (tapDistance = +_23, zoom2) : tapDistance;
  };
  return zoom2;
}
var useResizeHandler = function(rendererNode) {
  var updateSize3 = useStoreActions(function(actions2) {
    return actions2.updateSize;
  });
  react.useEffect(function() {
    var resizeObserver;
    var updateDimensions = function updateDimensions2() {
      if (!rendererNode.current) {
        return;
      }
      var size2 = getDimensions(rendererNode.current);
      if (size2.height === 0 || size2.width === 0) {
        console.warn("The React Flow parent container needs a width and a height to render the graph.");
      }
      updateSize3(size2);
    };
    updateDimensions();
    window.onresize = updateDimensions;
    if (rendererNode.current) {
      resizeObserver = new ResizeObserver(function() {
        return updateDimensions();
      });
      resizeObserver.observe(rendererNode.current);
    }
    return function() {
      window.onresize = null;
      if (resizeObserver && rendererNode.current) {
        resizeObserver.unobserve(rendererNode.current);
      }
    };
  }, []);
};
var Position;
(function(Position2) {
  Position2["Left"] = "left";
  Position2["Top"] = "top";
  Position2["Right"] = "right";
  Position2["Bottom"] = "bottom";
})(Position || (Position = {}));
var ArrowHeadType;
(function(ArrowHeadType2) {
  ArrowHeadType2["Arrow"] = "arrow";
  ArrowHeadType2["ArrowClosed"] = "arrowclosed";
})(ArrowHeadType || (ArrowHeadType = {}));
var BackgroundVariant;
(function(BackgroundVariant2) {
  BackgroundVariant2["Lines"] = "lines";
  BackgroundVariant2["Dots"] = "dots";
})(BackgroundVariant || (BackgroundVariant = {}));
var ConnectionMode;
(function(ConnectionMode2) {
  ConnectionMode2["Strict"] = "strict";
  ConnectionMode2["Loose"] = "loose";
})(ConnectionMode || (ConnectionMode = {}));
var ConnectionLineType;
(function(ConnectionLineType2) {
  ConnectionLineType2["Bezier"] = "default";
  ConnectionLineType2["Straight"] = "straight";
  ConnectionLineType2["Step"] = "step";
  ConnectionLineType2["SmoothStep"] = "smoothstep";
})(ConnectionLineType || (ConnectionLineType = {}));
var PanOnScrollMode;
(function(PanOnScrollMode2) {
  PanOnScrollMode2["Free"] = "free";
  PanOnScrollMode2["Vertical"] = "vertical";
  PanOnScrollMode2["Horizontal"] = "horizontal";
})(PanOnScrollMode || (PanOnScrollMode = {}));
var viewChanged = function viewChanged2(prevTransform, eventTransform) {
  return prevTransform.x !== eventTransform.x || prevTransform.y !== eventTransform.y || prevTransform.zoom !== eventTransform.k;
};
var eventToFlowTransform = function eventToFlowTransform2(eventTransform) {
  return {
    x: eventTransform.x,
    y: eventTransform.y,
    zoom: eventTransform.k
  };
};
var hasNoWheelClass = function hasNoWheelClass2(event) {
  return event.target.closest(".nowheel");
};
var ZoomPane = function ZoomPane2(_ref) {
  var onMove = _ref.onMove, onMoveStart = _ref.onMoveStart, onMoveEnd = _ref.onMoveEnd, _ref$zoomOnScroll = _ref.zoomOnScroll, zoomOnScroll = _ref$zoomOnScroll === void 0 ? true : _ref$zoomOnScroll, _ref$zoomOnPinch = _ref.zoomOnPinch, zoomOnPinch = _ref$zoomOnPinch === void 0 ? true : _ref$zoomOnPinch, _ref$panOnScroll = _ref.panOnScroll, panOnScroll = _ref$panOnScroll === void 0 ? false : _ref$panOnScroll, _ref$panOnScrollSpeed = _ref.panOnScrollSpeed, panOnScrollSpeed = _ref$panOnScrollSpeed === void 0 ? 0.5 : _ref$panOnScrollSpeed, _ref$panOnScrollMode = _ref.panOnScrollMode, panOnScrollMode = _ref$panOnScrollMode === void 0 ? PanOnScrollMode.Free : _ref$panOnScrollMode, _ref$zoomOnDoubleClic = _ref.zoomOnDoubleClick, zoomOnDoubleClick = _ref$zoomOnDoubleClic === void 0 ? true : _ref$zoomOnDoubleClic, selectionKeyPressed = _ref.selectionKeyPressed, elementsSelectable = _ref.elementsSelectable, _ref$paneMoveable = _ref.paneMoveable, paneMoveable = _ref$paneMoveable === void 0 ? true : _ref$paneMoveable, _ref$defaultPosition = _ref.defaultPosition, defaultPosition = _ref$defaultPosition === void 0 ? [0, 0] : _ref$defaultPosition, _ref$defaultZoom = _ref.defaultZoom, defaultZoom = _ref$defaultZoom === void 0 ? 1 : _ref$defaultZoom, translateExtent = _ref.translateExtent, zoomActivationKeyCode = _ref.zoomActivationKeyCode, _ref$preventScrolling = _ref.preventScrolling, preventScrolling = _ref$preventScrolling === void 0 ? true : _ref$preventScrolling, children2 = _ref.children;
  var zoomPane = react.useRef(null);
  var prevTransform = react.useRef({
    x: 0,
    y: 0,
    zoom: 0
  });
  var store2 = useStore();
  var d3Zoom = useStoreState(function(s2) {
    return s2.d3Zoom;
  });
  var d3Selection = useStoreState(function(s2) {
    return s2.d3Selection;
  });
  var d3ZoomHandler = useStoreState(function(s2) {
    return s2.d3ZoomHandler;
  });
  var initD3Zoom3 = useStoreActions(function(actions2) {
    return actions2.initD3Zoom;
  });
  var updateTransform3 = useStoreActions(function(actions2) {
    return actions2.updateTransform;
  });
  var zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode);
  useResizeHandler(zoomPane);
  react.useEffect(function() {
    if (zoomPane.current) {
      var state = store2.getState();
      var currentTranslateExtent = typeof translateExtent !== "undefined" ? translateExtent : state.translateExtent;
      var d3ZoomInstance = zoom().scaleExtent([state.minZoom, state.maxZoom]).translateExtent(currentTranslateExtent);
      var selection2 = select2(zoomPane.current).call(d3ZoomInstance);
      var clampedX = clamp2(defaultPosition[0], currentTranslateExtent[0][0], currentTranslateExtent[1][0]);
      var clampedY = clamp2(defaultPosition[1], currentTranslateExtent[0][1], currentTranslateExtent[1][1]);
      var clampedZoom = clamp2(defaultZoom, state.minZoom, state.maxZoom);
      var updatedTransform = identity2.translate(clampedX, clampedY).scale(clampedZoom);
      d3ZoomInstance.transform(selection2, updatedTransform);
      initD3Zoom3({
        d3Zoom: d3ZoomInstance,
        d3Selection: selection2,
        d3ZoomHandler: selection2.on("wheel.zoom"),
        transform: [clampedX, clampedY, clampedZoom]
      });
    }
  }, []);
  react.useEffect(function() {
    if (d3Selection && d3Zoom) {
      if (panOnScroll && !zoomActivationKeyPressed) {
        d3Selection.on("wheel", function(event) {
          if (hasNoWheelClass(event)) {
            return false;
          }
          event.preventDefault();
          event.stopImmediatePropagation();
          var currentZoom = d3Selection.property("__zoom").k || 1;
          if (event.ctrlKey && zoomOnPinch) {
            var point = pointer(event);
            var pinchDelta = -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * 10;
            var _zoom = currentZoom * Math.pow(2, pinchDelta);
            d3Zoom.scaleTo(d3Selection, _zoom, point);
            return;
          }
          var deltaNormalize = event.deltaMode === 1 ? 20 : 1;
          var deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;
          var deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;
          d3Zoom.translateBy(d3Selection, -(deltaX / currentZoom) * panOnScrollSpeed, -(deltaY / currentZoom) * panOnScrollSpeed);
        }).on("wheel.zoom", null);
      } else if (typeof d3ZoomHandler !== "undefined") {
        d3Selection.on("wheel", function(event) {
          if (!preventScrolling || hasNoWheelClass(event)) {
            return null;
          }
          event.preventDefault();
        }).on("wheel.zoom", d3ZoomHandler);
      }
    }
  }, [panOnScroll, panOnScrollMode, d3Selection, d3Zoom, d3ZoomHandler, zoomActivationKeyPressed, zoomOnPinch, preventScrolling]);
  react.useEffect(function() {
    if (d3Zoom) {
      if (selectionKeyPressed) {
        d3Zoom.on("zoom", null);
      } else {
        d3Zoom.on("zoom", function(event) {
          updateTransform3([event.transform.x, event.transform.y, event.transform.k]);
          if (onMove) {
            var flowTransform = eventToFlowTransform(event.transform);
            onMove(flowTransform);
          }
        });
      }
    }
  }, [selectionKeyPressed, d3Zoom, updateTransform3, onMove]);
  react.useEffect(function() {
    if (d3Zoom) {
      if (onMoveStart) {
        d3Zoom.on("start", function(event) {
          if (viewChanged(prevTransform.current, event.transform)) {
            var flowTransform = eventToFlowTransform(event.transform);
            prevTransform.current = flowTransform;
            onMoveStart(flowTransform);
          }
        });
      } else {
        d3Zoom.on("start", null);
      }
    }
  }, [d3Zoom, onMoveStart]);
  react.useEffect(function() {
    if (d3Zoom) {
      if (onMoveEnd) {
        d3Zoom.on("end", function(event) {
          if (viewChanged(prevTransform.current, event.transform)) {
            var flowTransform = eventToFlowTransform(event.transform);
            prevTransform.current = flowTransform;
            onMoveEnd(flowTransform);
          }
        });
      } else {
        d3Zoom.on("end", null);
      }
    }
  }, [d3Zoom, onMoveEnd]);
  react.useEffect(function() {
    if (d3Zoom) {
      d3Zoom.filter(function(event) {
        var zoomScroll = zoomActivationKeyPressed || zoomOnScroll;
        var pinchZoom = zoomOnPinch && event.ctrlKey;
        if (!paneMoveable && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {
          return false;
        }
        if (selectionKeyPressed) {
          return false;
        }
        if (!zoomOnDoubleClick && event.type === "dblclick") {
          return false;
        }
        if (hasNoWheelClass(event) && event.type === "wheel") {
          return false;
        }
        if ((event.target.closest(".react-flow__node") || event.target.closest(".react-flow__edge")) && event.type !== "wheel") {
          return false;
        }
        if (event.target.closest(".react-flow__nodesselection") && event.type !== "wheel") {
          return false;
        }
        if (!zoomOnPinch && event.ctrlKey && event.type === "wheel") {
          return false;
        }
        if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === "wheel") {
          return false;
        }
        if (!paneMoveable && (event.type === "mousedown" || event.type === "touchstart")) {
          return false;
        }
        return (!event.ctrlKey || event.type === "wheel") && !event.button;
      });
    }
  }, [d3Zoom, zoomOnScroll, zoomOnPinch, panOnScroll, zoomOnDoubleClick, paneMoveable, selectionKeyPressed, elementsSelectable, zoomActivationKeyPressed]);
  return /* @__PURE__ */ react.createElement("div", {
    className: "react-flow__renderer react-flow__zoompane",
    ref: zoomPane
  }, children2);
};
function getMousePosition(event) {
  var reactFlowNode = event.target.closest(".react-flow");
  if (!reactFlowNode) {
    return;
  }
  var containerBounds = reactFlowNode.getBoundingClientRect();
  return {
    x: event.clientX - containerBounds.left,
    y: event.clientY - containerBounds.top
  };
}
var SelectionRect = function SelectionRect2() {
  var userSelectionRect = useStoreState(function(state) {
    return state.userSelectionRect;
  });
  if (!userSelectionRect.draw) {
    return null;
  }
  return /* @__PURE__ */ react.createElement("div", {
    className: "react-flow__selection",
    style: {
      width: userSelectionRect.width,
      height: userSelectionRect.height,
      transform: "translate(".concat(userSelectionRect.x, "px, ").concat(userSelectionRect.y, "px)")
    }
  });
};
var UserSelection = /* @__PURE__ */ react.memo(function(_ref) {
  var selectionKeyPressed = _ref.selectionKeyPressed;
  var selectionActive = useStoreState(function(state) {
    return state.selectionActive;
  });
  var elementsSelectable = useStoreState(function(state) {
    return state.elementsSelectable;
  });
  var setUserSelection3 = useStoreActions(function(actions2) {
    return actions2.setUserSelection;
  });
  var updateUserSelection3 = useStoreActions(function(actions2) {
    return actions2.updateUserSelection;
  });
  var unsetUserSelection3 = useStoreActions(function(actions2) {
    return actions2.unsetUserSelection;
  });
  var unsetNodesSelection3 = useStoreActions(function(actions2) {
    return actions2.unsetNodesSelection;
  });
  var renderUserSelectionPane = selectionActive || selectionKeyPressed;
  if (!elementsSelectable || !renderUserSelectionPane) {
    return null;
  }
  var onMouseDown3 = function onMouseDown4(event) {
    var mousePos = getMousePosition(event);
    if (!mousePos) {
      return;
    }
    setUserSelection3(mousePos);
  };
  var onMouseMove = function onMouseMove2(event) {
    if (!selectionKeyPressed || !selectionActive) {
      return;
    }
    var mousePos = getMousePosition(event);
    if (!mousePos) {
      return;
    }
    updateUserSelection3(mousePos);
  };
  var onMouseUp = function onMouseUp2() {
    return unsetUserSelection3();
  };
  var onMouseLeave = function onMouseLeave2() {
    unsetUserSelection3();
    unsetNodesSelection3();
  };
  return /* @__PURE__ */ react.createElement("div", {
    className: "react-flow__selectionpane",
    onMouseDown: onMouseDown3,
    onMouseMove,
    onMouseUp,
    onMouseLeave
  }, /* @__PURE__ */ react.createElement(SelectionRect, null));
});
var cjs = {exports: {}};
var Draggable$1 = {};
var classnames = {exports: {}};
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
(function(module2) {
  (function() {
    var hasOwn = {}.hasOwnProperty;
    function classNames2() {
      var classes = [];
      for (var i3 = 0; i3 < arguments.length; i3++) {
        var arg = arguments[i3];
        if (!arg)
          continue;
        var argType = typeof arg;
        if (argType === "string" || argType === "number") {
          classes.push(arg);
        } else if (Array.isArray(arg)) {
          if (arg.length) {
            var inner = classNames2.apply(null, arg);
            if (inner) {
              classes.push(inner);
            }
          }
        } else if (argType === "object") {
          if (arg.toString === Object.prototype.toString) {
            for (var key in arg) {
              if (hasOwn.call(arg, key) && arg[key]) {
                classes.push(key);
              }
            }
          } else {
            classes.push(arg.toString());
          }
        }
      }
      return classes.join(" ");
    }
    if (module2.exports) {
      classNames2.default = classNames2;
      module2.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames);
var domFns = {};
var shims = {};
Object.defineProperty(shims, "__esModule", {
  value: true
});
shims.findInArray = findInArray;
shims.isFunction = isFunction4;
shims.isNum = isNum;
shims.int = int;
shims.dontSetMe = dontSetMe;
function findInArray(array2, callback) {
  for (var i3 = 0, length = array2.length; i3 < length; i3++) {
    if (callback.apply(callback, [array2[i3], i3, array2]))
      return array2[i3];
  }
}
function isFunction4(func) {
  return typeof func === "function" || Object.prototype.toString.call(func) === "[object Function]";
}
function isNum(num) {
  return typeof num === "number" && !isNaN(num);
}
function int(a2) {
  return parseInt(a2, 10);
}
function dontSetMe(props, propName, componentName) {
  if (props[propName]) {
    return new Error("Invalid prop ".concat(propName, " passed to ").concat(componentName, " - do not set this, set it on the child."));
  }
}
var getPrefix$1 = {};
Object.defineProperty(getPrefix$1, "__esModule", {
  value: true
});
getPrefix$1.getPrefix = getPrefix;
getPrefix$1.browserPrefixToKey = browserPrefixToKey;
getPrefix$1.browserPrefixToStyle = browserPrefixToStyle;
getPrefix$1.default = void 0;
var prefixes = ["Moz", "Webkit", "O", "ms"];
function getPrefix() {
  var prop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
  if (typeof window === "undefined" || typeof window.document === "undefined")
    return "";
  var style = window.document.documentElement.style;
  if (prop in style)
    return "";
  for (var i3 = 0; i3 < prefixes.length; i3++) {
    if (browserPrefixToKey(prop, prefixes[i3]) in style)
      return prefixes[i3];
  }
  return "";
}
function browserPrefixToKey(prop, prefix2) {
  return prefix2 ? "".concat(prefix2).concat(kebabToTitleCase(prop)) : prop;
}
function browserPrefixToStyle(prop, prefix2) {
  return prefix2 ? "-".concat(prefix2.toLowerCase(), "-").concat(prop) : prop;
}
function kebabToTitleCase(str) {
  var out = "";
  var shouldCapitalize = true;
  for (var i3 = 0; i3 < str.length; i3++) {
    if (shouldCapitalize) {
      out += str[i3].toUpperCase();
      shouldCapitalize = false;
    } else if (str[i3] === "-") {
      shouldCapitalize = true;
    } else {
      out += str[i3];
    }
  }
  return out;
}
var _default2 = getPrefix();
getPrefix$1.default = _default2;
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof4(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function _typeof4(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
Object.defineProperty(domFns, "__esModule", {
  value: true
});
domFns.matchesSelector = matchesSelector;
domFns.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
domFns.addEvent = addEvent;
domFns.removeEvent = removeEvent;
domFns.outerHeight = outerHeight;
domFns.outerWidth = outerWidth;
domFns.innerHeight = innerHeight;
domFns.innerWidth = innerWidth;
domFns.offsetXYFromParent = offsetXYFromParent;
domFns.createCSSTransform = createCSSTransform;
domFns.createSVGTransform = createSVGTransform;
domFns.getTranslation = getTranslation;
domFns.getTouch = getTouch;
domFns.getTouchIdentifier = getTouchIdentifier;
domFns.addUserSelectStyles = addUserSelectStyles;
domFns.removeUserSelectStyles = removeUserSelectStyles;
domFns.addClassName = addClassName;
domFns.removeClassName = removeClassName;
var _shims$2 = shims;
var _getPrefix = _interopRequireWildcard$1(getPrefix$1);
function _getRequireWildcardCache$1() {
  if (typeof WeakMap !== "function")
    return null;
  var cache3 = new WeakMap();
  _getRequireWildcardCache$1 = function _getRequireWildcardCache2() {
    return cache3;
  };
  return cache3;
}
function _interopRequireWildcard$1(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || _typeof$1(obj) !== "object" && typeof obj !== "function") {
    return {default: obj};
  }
  var cache3 = _getRequireWildcardCache$1();
  if (cache3 && cache3.has(obj)) {
    return cache3.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache3) {
    cache3.set(obj, newObj);
  }
  return newObj;
}
function ownKeys$c(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$c(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys$c(Object(source2), true).forEach(function(key) {
        _defineProperty$1(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys$c(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
var matchesSelectorFunc = "";
function matchesSelector(el, selector2) {
  if (!matchesSelectorFunc) {
    matchesSelectorFunc = (0, _shims$2.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(method) {
      return (0, _shims$2.isFunction)(el[method]);
    });
  }
  if (!(0, _shims$2.isFunction)(el[matchesSelectorFunc]))
    return false;
  return el[matchesSelectorFunc](selector2);
}
function matchesSelectorAndParentsTo(el, selector2, baseNode) {
  var node = el;
  do {
    if (matchesSelector(node, selector2))
      return true;
    if (node === baseNode)
      return false;
    node = node.parentNode;
  } while (node);
  return false;
}
function addEvent(el, event, handler, inputOptions) {
  if (!el)
    return;
  var options = _objectSpread$c({
    capture: true
  }, inputOptions);
  if (el.addEventListener) {
    el.addEventListener(event, handler, options);
  } else if (el.attachEvent) {
    el.attachEvent("on" + event, handler);
  } else {
    el["on" + event] = handler;
  }
}
function removeEvent(el, event, handler, inputOptions) {
  if (!el)
    return;
  var options = _objectSpread$c({
    capture: true
  }, inputOptions);
  if (el.removeEventListener) {
    el.removeEventListener(event, handler, options);
  } else if (el.detachEvent) {
    el.detachEvent("on" + event, handler);
  } else {
    el["on" + event] = null;
  }
}
function outerHeight(node) {
  var height = node.clientHeight;
  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
  height += (0, _shims$2.int)(computedStyle.borderTopWidth);
  height += (0, _shims$2.int)(computedStyle.borderBottomWidth);
  return height;
}
function outerWidth(node) {
  var width2 = node.clientWidth;
  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
  width2 += (0, _shims$2.int)(computedStyle.borderLeftWidth);
  width2 += (0, _shims$2.int)(computedStyle.borderRightWidth);
  return width2;
}
function innerHeight(node) {
  var height = node.clientHeight;
  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
  height -= (0, _shims$2.int)(computedStyle.paddingTop);
  height -= (0, _shims$2.int)(computedStyle.paddingBottom);
  return height;
}
function innerWidth(node) {
  var width2 = node.clientWidth;
  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
  width2 -= (0, _shims$2.int)(computedStyle.paddingLeft);
  width2 -= (0, _shims$2.int)(computedStyle.paddingRight);
  return width2;
}
function offsetXYFromParent(evt, offsetParent2, scale) {
  var isBody = offsetParent2 === offsetParent2.ownerDocument.body;
  var offsetParentRect = isBody ? {
    left: 0,
    top: 0
  } : offsetParent2.getBoundingClientRect();
  var x3 = (evt.clientX + offsetParent2.scrollLeft - offsetParentRect.left) / scale;
  var y4 = (evt.clientY + offsetParent2.scrollTop - offsetParentRect.top) / scale;
  return {
    x: x3,
    y: y4
  };
}
function createCSSTransform(controlPos, positionOffset) {
  var translation = getTranslation(controlPos, positionOffset, "px");
  return _defineProperty$1({}, (0, _getPrefix.browserPrefixToKey)("transform", _getPrefix.default), translation);
}
function createSVGTransform(controlPos, positionOffset) {
  var translation = getTranslation(controlPos, positionOffset, "");
  return translation;
}
function getTranslation(_ref2, positionOffset, unitSuffix) {
  var x3 = _ref2.x, y4 = _ref2.y;
  var translation = "translate(".concat(x3).concat(unitSuffix, ",").concat(y4).concat(unitSuffix, ")");
  if (positionOffset) {
    var defaultX = "".concat(typeof positionOffset.x === "string" ? positionOffset.x : positionOffset.x + unitSuffix);
    var defaultY = "".concat(typeof positionOffset.y === "string" ? positionOffset.y : positionOffset.y + unitSuffix);
    translation = "translate(".concat(defaultX, ", ").concat(defaultY, ")") + translation;
  }
  return translation;
}
function getTouch(e3, identifier) {
  return e3.targetTouches && (0, _shims$2.findInArray)(e3.targetTouches, function(t4) {
    return identifier === t4.identifier;
  }) || e3.changedTouches && (0, _shims$2.findInArray)(e3.changedTouches, function(t4) {
    return identifier === t4.identifier;
  });
}
function getTouchIdentifier(e3) {
  if (e3.targetTouches && e3.targetTouches[0])
    return e3.targetTouches[0].identifier;
  if (e3.changedTouches && e3.changedTouches[0])
    return e3.changedTouches[0].identifier;
}
function addUserSelectStyles(doc) {
  if (!doc)
    return;
  var styleEl = doc.getElementById("react-draggable-style-el");
  if (!styleEl) {
    styleEl = doc.createElement("style");
    styleEl.type = "text/css";
    styleEl.id = "react-draggable-style-el";
    styleEl.innerHTML = ".react-draggable-transparent-selection *::-moz-selection {all: inherit;}\n";
    styleEl.innerHTML += ".react-draggable-transparent-selection *::selection {all: inherit;}\n";
    doc.getElementsByTagName("head")[0].appendChild(styleEl);
  }
  if (doc.body)
    addClassName(doc.body, "react-draggable-transparent-selection");
}
function removeUserSelectStyles(doc) {
  if (!doc)
    return;
  try {
    if (doc.body)
      removeClassName(doc.body, "react-draggable-transparent-selection");
    if (doc.selection) {
      doc.selection.empty();
    } else {
      var selection2 = (doc.defaultView || window).getSelection();
      if (selection2 && selection2.type !== "Caret") {
        selection2.removeAllRanges();
      }
    }
  } catch (e3) {
  }
}
function addClassName(el, className) {
  if (el.classList) {
    el.classList.add(className);
  } else {
    if (!el.className.match(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)")))) {
      el.className += " ".concat(className);
    }
  }
}
function removeClassName(el, className) {
  if (el.classList) {
    el.classList.remove(className);
  } else {
    el.className = el.className.replace(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)"), "g"), "");
  }
}
var positionFns = {};
Object.defineProperty(positionFns, "__esModule", {
  value: true
});
positionFns.getBoundPosition = getBoundPosition;
positionFns.snapToGrid = snapToGrid;
positionFns.canDragX = canDragX;
positionFns.canDragY = canDragY;
positionFns.getControlPosition = getControlPosition;
positionFns.createCoreData = createCoreData;
positionFns.createDraggableData = createDraggableData;
var _shims$1 = shims;
var _domFns$1 = domFns;
function getBoundPosition(draggable2, x3, y4) {
  if (!draggable2.props.bounds)
    return [x3, y4];
  var bounds = draggable2.props.bounds;
  bounds = typeof bounds === "string" ? bounds : cloneBounds(bounds);
  var node = findDOMNode2(draggable2);
  if (typeof bounds === "string") {
    var ownerDocument = node.ownerDocument;
    var ownerWindow = ownerDocument.defaultView;
    var boundNode;
    if (bounds === "parent") {
      boundNode = node.parentNode;
    } else {
      boundNode = ownerDocument.querySelector(bounds);
    }
    if (!(boundNode instanceof ownerWindow.HTMLElement)) {
      throw new Error('Bounds selector "' + bounds + '" could not find an element.');
    }
    var nodeStyle = ownerWindow.getComputedStyle(node);
    var boundNodeStyle = ownerWindow.getComputedStyle(boundNode);
    bounds = {
      left: -node.offsetLeft + (0, _shims$1.int)(boundNodeStyle.paddingLeft) + (0, _shims$1.int)(nodeStyle.marginLeft),
      top: -node.offsetTop + (0, _shims$1.int)(boundNodeStyle.paddingTop) + (0, _shims$1.int)(nodeStyle.marginTop),
      right: (0, _domFns$1.innerWidth)(boundNode) - (0, _domFns$1.outerWidth)(node) - node.offsetLeft + (0, _shims$1.int)(boundNodeStyle.paddingRight) - (0, _shims$1.int)(nodeStyle.marginRight),
      bottom: (0, _domFns$1.innerHeight)(boundNode) - (0, _domFns$1.outerHeight)(node) - node.offsetTop + (0, _shims$1.int)(boundNodeStyle.paddingBottom) - (0, _shims$1.int)(nodeStyle.marginBottom)
    };
  }
  if ((0, _shims$1.isNum)(bounds.right))
    x3 = Math.min(x3, bounds.right);
  if ((0, _shims$1.isNum)(bounds.bottom))
    y4 = Math.min(y4, bounds.bottom);
  if ((0, _shims$1.isNum)(bounds.left))
    x3 = Math.max(x3, bounds.left);
  if ((0, _shims$1.isNum)(bounds.top))
    y4 = Math.max(y4, bounds.top);
  return [x3, y4];
}
function snapToGrid(grid2, pendingX, pendingY) {
  var x3 = Math.round(pendingX / grid2[0]) * grid2[0];
  var y4 = Math.round(pendingY / grid2[1]) * grid2[1];
  return [x3, y4];
}
function canDragX(draggable2) {
  return draggable2.props.axis === "both" || draggable2.props.axis === "x";
}
function canDragY(draggable2) {
  return draggable2.props.axis === "both" || draggable2.props.axis === "y";
}
function getControlPosition(e3, touchIdentifier, draggableCore) {
  var touchObj = typeof touchIdentifier === "number" ? (0, _domFns$1.getTouch)(e3, touchIdentifier) : null;
  if (typeof touchIdentifier === "number" && !touchObj)
    return null;
  var node = findDOMNode2(draggableCore);
  var offsetParent2 = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
  return (0, _domFns$1.offsetXYFromParent)(touchObj || e3, offsetParent2, draggableCore.props.scale);
}
function createCoreData(draggable2, x3, y4) {
  var state = draggable2.state;
  var isStart = !(0, _shims$1.isNum)(state.lastX);
  var node = findDOMNode2(draggable2);
  if (isStart) {
    return {
      node,
      deltaX: 0,
      deltaY: 0,
      lastX: x3,
      lastY: y4,
      x: x3,
      y: y4
    };
  } else {
    return {
      node,
      deltaX: x3 - state.lastX,
      deltaY: y4 - state.lastY,
      lastX: state.lastX,
      lastY: state.lastY,
      x: x3,
      y: y4
    };
  }
}
function createDraggableData(draggable2, coreData) {
  var scale = draggable2.props.scale;
  return {
    node: coreData.node,
    x: draggable2.state.x + coreData.deltaX / scale,
    y: draggable2.state.y + coreData.deltaY / scale,
    deltaX: coreData.deltaX / scale,
    deltaY: coreData.deltaY / scale,
    lastX: draggable2.state.x,
    lastY: draggable2.state.y
  };
}
function cloneBounds(bounds) {
  return {
    left: bounds.left,
    top: bounds.top,
    right: bounds.right,
    bottom: bounds.bottom
  };
}
function findDOMNode2(draggable2) {
  var node = draggable2.findDOMNode();
  if (!node) {
    throw new Error("<DraggableCore>: Unmounted during event!");
  }
  return node;
}
var DraggableCore$2 = {};
var log$1 = {};
Object.defineProperty(log$1, "__esModule", {
  value: true
});
log$1.default = log2;
function log2() {
}
Object.defineProperty(DraggableCore$2, "__esModule", {
  value: true
});
DraggableCore$2.default = void 0;
var React = _interopRequireWildcard(react);
var _propTypes = _interopRequireDefault(propTypes2.exports);
var _reactDom = _interopRequireDefault(reactDom);
var _domFns = domFns;
var _positionFns = positionFns;
var _shims = shims;
var _log = _interopRequireDefault(log$1);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}
function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function")
    return null;
  var cache3 = new WeakMap();
  _getRequireWildcardCache = function _getRequireWildcardCache2() {
    return cache3;
  };
  return cache3;
}
function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") {
    return {default: obj};
  }
  var cache3 = _getRequireWildcardCache();
  if (cache3 && cache3.has(obj)) {
    return cache3.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache3) {
    cache3.set(obj, newObj);
  }
  return newObj;
}
function _typeof3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof3 = function _typeof4(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof3 = function _typeof4(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof3(obj);
}
function _slicedToArray2(arr, i3) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i3) || _unsupportedIterableToArray(arr, i3) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n4 = Object.prototype.toString.call(o).slice(8, -1);
  if (n4 === "Object" && o.constructor)
    n4 = o.constructor.name;
  if (n4 === "Map" || n4 === "Set")
    return Array.from(o);
  if (n4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len2) {
  if (len2 == null || len2 > arr.length)
    len2 = arr.length;
  for (var i3 = 0, arr2 = new Array(len2); i3 < len2; i3++) {
    arr2[i3] = arr[i3];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i3) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i3 && _arr.length === i3)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties2(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  return Constructor;
}
function _inherits3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf2(subClass, superClass);
}
function _setPrototypeOf2(o, p3) {
  _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p4) {
    o2.__proto__ = p4;
    return o2;
  };
  return _setPrototypeOf2(o, p3);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn3(this, result);
  };
}
function _possibleConstructorReturn3(self2, call) {
  if (call && (_typeof3(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized2(self2);
}
function _assertThisInitialized2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf2(o) {
  _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf2(o);
}
function _defineProperty6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
var eventsFor = {
  touch: {
    start: "touchstart",
    move: "touchmove",
    stop: "touchend"
  },
  mouse: {
    start: "mousedown",
    move: "mousemove",
    stop: "mouseup"
  }
};
var dragEventFor = eventsFor.mouse;
var DraggableCore$1 = /* @__PURE__ */ function(_React$Component) {
  _inherits3(DraggableCore2, _React$Component);
  var _super = _createSuper(DraggableCore2);
  function DraggableCore2() {
    var _this;
    _classCallCheck4(this, DraggableCore2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty6(_assertThisInitialized2(_this), "state", {
      dragging: false,
      lastX: NaN,
      lastY: NaN,
      touchIdentifier: null
    });
    _defineProperty6(_assertThisInitialized2(_this), "mounted", false);
    _defineProperty6(_assertThisInitialized2(_this), "handleDragStart", function(e3) {
      _this.props.onMouseDown(e3);
      if (!_this.props.allowAnyClick && typeof e3.button === "number" && e3.button !== 0)
        return false;
      var thisNode = _this.findDOMNode();
      if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {
        throw new Error("<DraggableCore> not mounted on DragStart!");
      }
      var ownerDocument = thisNode.ownerDocument;
      if (_this.props.disabled || !(e3.target instanceof ownerDocument.defaultView.Node) || _this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e3.target, _this.props.handle, thisNode) || _this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e3.target, _this.props.cancel, thisNode)) {
        return;
      }
      if (e3.type === "touchstart")
        e3.preventDefault();
      var touchIdentifier = (0, _domFns.getTouchIdentifier)(e3);
      _this.setState({
        touchIdentifier
      });
      var position2 = (0, _positionFns.getControlPosition)(e3, touchIdentifier, _assertThisInitialized2(_this));
      if (position2 == null)
        return;
      var x3 = position2.x, y4 = position2.y;
      var coreEvent = (0, _positionFns.createCoreData)(_assertThisInitialized2(_this), x3, y4);
      (0, _log.default)("DraggableCore: handleDragStart: %j", coreEvent);
      (0, _log.default)("calling", _this.props.onStart);
      var shouldUpdate = _this.props.onStart(e3, coreEvent);
      if (shouldUpdate === false || _this.mounted === false)
        return;
      if (_this.props.enableUserSelectHack)
        (0, _domFns.addUserSelectStyles)(ownerDocument);
      _this.setState({
        dragging: true,
        lastX: x3,
        lastY: y4
      });
      (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, _this.handleDrag);
      (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, _this.handleDragStop);
    });
    _defineProperty6(_assertThisInitialized2(_this), "handleDrag", function(e3) {
      var position2 = (0, _positionFns.getControlPosition)(e3, _this.state.touchIdentifier, _assertThisInitialized2(_this));
      if (position2 == null)
        return;
      var x3 = position2.x, y4 = position2.y;
      if (Array.isArray(_this.props.grid)) {
        var deltaX = x3 - _this.state.lastX, deltaY = y4 - _this.state.lastY;
        var _snapToGrid = (0, _positionFns.snapToGrid)(_this.props.grid, deltaX, deltaY);
        var _snapToGrid2 = _slicedToArray2(_snapToGrid, 2);
        deltaX = _snapToGrid2[0];
        deltaY = _snapToGrid2[1];
        if (!deltaX && !deltaY)
          return;
        x3 = _this.state.lastX + deltaX, y4 = _this.state.lastY + deltaY;
      }
      var coreEvent = (0, _positionFns.createCoreData)(_assertThisInitialized2(_this), x3, y4);
      (0, _log.default)("DraggableCore: handleDrag: %j", coreEvent);
      var shouldUpdate = _this.props.onDrag(e3, coreEvent);
      if (shouldUpdate === false || _this.mounted === false) {
        try {
          _this.handleDragStop(new MouseEvent("mouseup"));
        } catch (err) {
          var event = document.createEvent("MouseEvents");
          event.initMouseEvent("mouseup", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
          _this.handleDragStop(event);
        }
        return;
      }
      _this.setState({
        lastX: x3,
        lastY: y4
      });
    });
    _defineProperty6(_assertThisInitialized2(_this), "handleDragStop", function(e3) {
      if (!_this.state.dragging)
        return;
      var position2 = (0, _positionFns.getControlPosition)(e3, _this.state.touchIdentifier, _assertThisInitialized2(_this));
      if (position2 == null)
        return;
      var x3 = position2.x, y4 = position2.y;
      var coreEvent = (0, _positionFns.createCoreData)(_assertThisInitialized2(_this), x3, y4);
      var shouldContinue = _this.props.onStop(e3, coreEvent);
      if (shouldContinue === false || _this.mounted === false)
        return false;
      var thisNode = _this.findDOMNode();
      if (thisNode) {
        if (_this.props.enableUserSelectHack)
          (0, _domFns.removeUserSelectStyles)(thisNode.ownerDocument);
      }
      (0, _log.default)("DraggableCore: handleDragStop: %j", coreEvent);
      _this.setState({
        dragging: false,
        lastX: NaN,
        lastY: NaN
      });
      if (thisNode) {
        (0, _log.default)("DraggableCore: Removing handlers");
        (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, _this.handleDrag);
        (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, _this.handleDragStop);
      }
    });
    _defineProperty6(_assertThisInitialized2(_this), "onMouseDown", function(e3) {
      dragEventFor = eventsFor.mouse;
      return _this.handleDragStart(e3);
    });
    _defineProperty6(_assertThisInitialized2(_this), "onMouseUp", function(e3) {
      dragEventFor = eventsFor.mouse;
      return _this.handleDragStop(e3);
    });
    _defineProperty6(_assertThisInitialized2(_this), "onTouchStart", function(e3) {
      dragEventFor = eventsFor.touch;
      return _this.handleDragStart(e3);
    });
    _defineProperty6(_assertThisInitialized2(_this), "onTouchEnd", function(e3) {
      dragEventFor = eventsFor.touch;
      return _this.handleDragStop(e3);
    });
    return _this;
  }
  _createClass4(DraggableCore2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.mounted = true;
      var thisNode = this.findDOMNode();
      if (thisNode) {
        (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
          passive: false
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.mounted = false;
      var thisNode = this.findDOMNode();
      if (thisNode) {
        var ownerDocument = thisNode.ownerDocument;
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
        (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
          passive: false
        });
        if (this.props.enableUserSelectHack)
          (0, _domFns.removeUserSelectStyles)(ownerDocument);
      }
    }
  }, {
    key: "findDOMNode",
    value: function findDOMNode3() {
      return this.props.nodeRef ? this.props.nodeRef.current : _reactDom.default.findDOMNode(this);
    }
  }, {
    key: "render",
    value: function render4() {
      return React.cloneElement(React.Children.only(this.props.children), {
        onMouseDown: this.onMouseDown,
        onMouseUp: this.onMouseUp,
        onTouchEnd: this.onTouchEnd
      });
    }
  }]);
  return DraggableCore2;
}(React.Component);
DraggableCore$2.default = DraggableCore$1;
_defineProperty6(DraggableCore$1, "displayName", "DraggableCore");
_defineProperty6(DraggableCore$1, "propTypes", {
  allowAnyClick: _propTypes.default.bool,
  disabled: _propTypes.default.bool,
  enableUserSelectHack: _propTypes.default.bool,
  offsetParent: function offsetParent(props, propName) {
    if (props[propName] && props[propName].nodeType !== 1) {
      throw new Error("Draggable's offsetParent must be a DOM Node.");
    }
  },
  grid: _propTypes.default.arrayOf(_propTypes.default.number),
  handle: _propTypes.default.string,
  cancel: _propTypes.default.string,
  nodeRef: _propTypes.default.object,
  onStart: _propTypes.default.func,
  onDrag: _propTypes.default.func,
  onStop: _propTypes.default.func,
  onMouseDown: _propTypes.default.func,
  scale: _propTypes.default.number,
  className: _shims.dontSetMe,
  style: _shims.dontSetMe,
  transform: _shims.dontSetMe
});
_defineProperty6(DraggableCore$1, "defaultProps", {
  allowAnyClick: false,
  cancel: null,
  disabled: false,
  enableUserSelectHack: true,
  offsetParent: null,
  handle: null,
  grid: null,
  transform: null,
  onStart: function onStart() {
  },
  onDrag: function onDrag() {
  },
  onStop: function onStop() {
  },
  onMouseDown: function onMouseDown() {
  },
  scale: 1
});
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  Object.defineProperty(exports2, "DraggableCore", {
    enumerable: true,
    get: function get5() {
      return _DraggableCore.default;
    }
  });
  exports2.default = void 0;
  var React2 = _interopRequireWildcard2(react);
  var _propTypes2 = _interopRequireDefault2(propTypes2.exports);
  var _reactDom2 = _interopRequireDefault2(reactDom);
  var _classnames = _interopRequireDefault2(classnames.exports);
  var _domFns2 = domFns;
  var _positionFns2 = positionFns;
  var _shims2 = shims;
  var _DraggableCore = _interopRequireDefault2(DraggableCore$2);
  var _log2 = _interopRequireDefault2(log$1);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _getRequireWildcardCache2() {
    if (typeof WeakMap !== "function")
      return null;
    var cache3 = new WeakMap();
    _getRequireWildcardCache2 = function _getRequireWildcardCache3() {
      return cache3;
    };
    return cache3;
  }
  function _interopRequireWildcard2(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || _typeof4(obj) !== "object" && typeof obj !== "function") {
      return {default: obj};
    }
    var cache3 = _getRequireWildcardCache2();
    if (cache3 && cache3.has(obj)) {
      return cache3.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache3) {
      cache3.set(obj, newObj);
    }
    return newObj;
  }
  function _typeof4(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof4 = function _typeof5(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof4 = function _typeof5(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof4(obj);
  }
  function _extends4() {
    _extends4 = Object.assign || function(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source2 = arguments[i3];
        for (var key in source2) {
          if (Object.prototype.hasOwnProperty.call(source2, key)) {
            target[key] = source2[key];
          }
        }
      }
      return target;
    };
    return _extends4.apply(this, arguments);
  }
  function _objectWithoutProperties4(source2, excluded) {
    if (source2 == null)
      return {};
    var target = _objectWithoutPropertiesLoose3(source2, excluded);
    var key, i3;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source2);
      for (i3 = 0; i3 < sourceSymbolKeys.length; i3++) {
        key = sourceSymbolKeys[i3];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source2, key))
          continue;
        target[key] = source2[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose3(source2, excluded) {
    if (source2 == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source2);
    var key, i3;
    for (i3 = 0; i3 < sourceKeys.length; i3++) {
      key = sourceKeys[i3];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source2[key];
    }
    return target;
  }
  function _slicedToArray3(arr, i3) {
    return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i3) || _unsupportedIterableToArray2(arr, i3) || _nonIterableRest2();
  }
  function _nonIterableRest2() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n4 = Object.prototype.toString.call(o).slice(8, -1);
    if (n4 === "Object" && o.constructor)
      n4 = o.constructor.name;
    if (n4 === "Map" || n4 === "Set")
      return Array.from(o);
    if (n4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i3 = 0, arr2 = new Array(len2); i3 < len2; i3++) {
      arr2[i3] = arr[i3];
    }
    return arr2;
  }
  function _iterableToArrayLimit2(arr, i3) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i3 && _arr.length === i3)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles2(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function ownKeys4(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread5(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source2 = arguments[i3] != null ? arguments[i3] : {};
      if (i3 % 2) {
        ownKeys4(Object(source2), true).forEach(function(key) {
          _defineProperty7(target, key, source2[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
      } else {
        ownKeys4(Object(source2)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
        });
      }
    }
    return target;
  }
  function _classCallCheck5(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties3(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass5(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties3(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties3(Constructor, staticProps);
    return Constructor;
  }
  function _inherits4(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
    if (superClass)
      _setPrototypeOf3(subClass, superClass);
  }
  function _setPrototypeOf3(o, p3) {
    _setPrototypeOf3 = Object.setPrototypeOf || function _setPrototypeOf4(o2, p4) {
      o2.__proto__ = p4;
      return o2;
    };
    return _setPrototypeOf3(o, p3);
  }
  function _createSuper2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct2();
    return function() {
      var Super = _getPrototypeOf3(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf3(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn4(this, result);
    };
  }
  function _possibleConstructorReturn4(self2, call) {
    if (call && (_typeof4(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized3(self2);
  }
  function _assertThisInitialized3(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct2() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e3) {
      return false;
    }
  }
  function _getPrototypeOf3(o) {
    _getPrototypeOf3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf4(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf3(o);
  }
  function _defineProperty7(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var Draggable2 = /* @__PURE__ */ function(_React$Component) {
    _inherits4(Draggable3, _React$Component);
    var _super = _createSuper2(Draggable3);
    _createClass5(Draggable3, null, [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, _ref2) {
        var position2 = _ref.position;
        var prevPropsPosition = _ref2.prevPropsPosition;
        if (position2 && (!prevPropsPosition || position2.x !== prevPropsPosition.x || position2.y !== prevPropsPosition.y)) {
          (0, _log2.default)("Draggable: getDerivedStateFromProps %j", {
            position: position2,
            prevPropsPosition
          });
          return {
            x: position2.x,
            y: position2.y,
            prevPropsPosition: _objectSpread5({}, position2)
          };
        }
        return null;
      }
    }]);
    function Draggable3(props) {
      var _this;
      _classCallCheck5(this, Draggable3);
      _this = _super.call(this, props);
      _defineProperty7(_assertThisInitialized3(_this), "onDragStart", function(e3, coreData) {
        (0, _log2.default)("Draggable: onDragStart: %j", coreData);
        var shouldStart = _this.props.onStart(e3, (0, _positionFns2.createDraggableData)(_assertThisInitialized3(_this), coreData));
        if (shouldStart === false)
          return false;
        _this.setState({
          dragging: true,
          dragged: true
        });
      });
      _defineProperty7(_assertThisInitialized3(_this), "onDrag", function(e3, coreData) {
        if (!_this.state.dragging)
          return false;
        (0, _log2.default)("Draggable: onDrag: %j", coreData);
        var uiData = (0, _positionFns2.createDraggableData)(_assertThisInitialized3(_this), coreData);
        var newState = {
          x: uiData.x,
          y: uiData.y
        };
        if (_this.props.bounds) {
          var x3 = newState.x, y4 = newState.y;
          newState.x += _this.state.slackX;
          newState.y += _this.state.slackY;
          var _getBoundPosition = (0, _positionFns2.getBoundPosition)(_assertThisInitialized3(_this), newState.x, newState.y), _getBoundPosition2 = _slicedToArray3(_getBoundPosition, 2), newStateX = _getBoundPosition2[0], newStateY = _getBoundPosition2[1];
          newState.x = newStateX;
          newState.y = newStateY;
          newState.slackX = _this.state.slackX + (x3 - newState.x);
          newState.slackY = _this.state.slackY + (y4 - newState.y);
          uiData.x = newState.x;
          uiData.y = newState.y;
          uiData.deltaX = newState.x - _this.state.x;
          uiData.deltaY = newState.y - _this.state.y;
        }
        var shouldUpdate = _this.props.onDrag(e3, uiData);
        if (shouldUpdate === false)
          return false;
        _this.setState(newState);
      });
      _defineProperty7(_assertThisInitialized3(_this), "onDragStop", function(e3, coreData) {
        if (!_this.state.dragging)
          return false;
        var shouldContinue = _this.props.onStop(e3, (0, _positionFns2.createDraggableData)(_assertThisInitialized3(_this), coreData));
        if (shouldContinue === false)
          return false;
        (0, _log2.default)("Draggable: onDragStop: %j", coreData);
        var newState = {
          dragging: false,
          slackX: 0,
          slackY: 0
        };
        var controlled = Boolean(_this.props.position);
        if (controlled) {
          var _this$props$position = _this.props.position, x3 = _this$props$position.x, y4 = _this$props$position.y;
          newState.x = x3;
          newState.y = y4;
        }
        _this.setState(newState);
      });
      _this.state = {
        dragging: false,
        dragged: false,
        x: props.position ? props.position.x : props.defaultPosition.x,
        y: props.position ? props.position.y : props.defaultPosition.y,
        prevPropsPosition: _objectSpread5({}, props.position),
        slackX: 0,
        slackY: 0,
        isElementSVG: false
      };
      if (props.position && !(props.onDrag || props.onStop)) {
        console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
      }
      return _this;
    }
    _createClass5(Draggable3, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        if (typeof window.SVGElement !== "undefined" && this.findDOMNode() instanceof window.SVGElement) {
          this.setState({
            isElementSVG: true
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.setState({
          dragging: false
        });
      }
    }, {
      key: "findDOMNode",
      value: function findDOMNode3() {
        return this.props.nodeRef ? this.props.nodeRef.current : _reactDom2.default.findDOMNode(this);
      }
    }, {
      key: "render",
      value: function render4() {
        var _classNames;
        var _this$props = this.props;
        _this$props.axis;
        _this$props.bounds;
        var children2 = _this$props.children, defaultPosition = _this$props.defaultPosition, defaultClassName = _this$props.defaultClassName, defaultClassNameDragging = _this$props.defaultClassNameDragging, defaultClassNameDragged = _this$props.defaultClassNameDragged, position2 = _this$props.position, positionOffset = _this$props.positionOffset;
        _this$props.scale;
        var draggableCoreProps = _objectWithoutProperties4(_this$props, ["axis", "bounds", "children", "defaultPosition", "defaultClassName", "defaultClassNameDragging", "defaultClassNameDragged", "position", "positionOffset", "scale"]);
        var style = {};
        var svgTransform = null;
        var controlled = Boolean(position2);
        var draggable2 = !controlled || this.state.dragging;
        var validPosition = position2 || defaultPosition;
        var transformOpts = {
          x: (0, _positionFns2.canDragX)(this) && draggable2 ? this.state.x : validPosition.x,
          y: (0, _positionFns2.canDragY)(this) && draggable2 ? this.state.y : validPosition.y
        };
        if (this.state.isElementSVG) {
          svgTransform = (0, _domFns2.createSVGTransform)(transformOpts, positionOffset);
        } else {
          style = (0, _domFns2.createCSSTransform)(transformOpts, positionOffset);
        }
        var className = (0, _classnames.default)(children2.props.className || "", defaultClassName, (_classNames = {}, _defineProperty7(_classNames, defaultClassNameDragging, this.state.dragging), _defineProperty7(_classNames, defaultClassNameDragged, this.state.dragged), _classNames));
        return /* @__PURE__ */ React2.createElement(_DraggableCore.default, _extends4({}, draggableCoreProps, {
          onStart: this.onDragStart,
          onDrag: this.onDrag,
          onStop: this.onDragStop
        }), React2.cloneElement(React2.Children.only(children2), {
          className,
          style: _objectSpread5(_objectSpread5({}, children2.props.style), style),
          transform: svgTransform
        }));
      }
    }]);
    return Draggable3;
  }(React2.Component);
  exports2.default = Draggable2;
  _defineProperty7(Draggable2, "displayName", "Draggable");
  _defineProperty7(Draggable2, "propTypes", _objectSpread5(_objectSpread5({}, _DraggableCore.default.propTypes), {}, {
    axis: _propTypes2.default.oneOf(["both", "x", "y", "none"]),
    bounds: _propTypes2.default.oneOfType([_propTypes2.default.shape({
      left: _propTypes2.default.number,
      right: _propTypes2.default.number,
      top: _propTypes2.default.number,
      bottom: _propTypes2.default.number
    }), _propTypes2.default.string, _propTypes2.default.oneOf([false])]),
    defaultClassName: _propTypes2.default.string,
    defaultClassNameDragging: _propTypes2.default.string,
    defaultClassNameDragged: _propTypes2.default.string,
    defaultPosition: _propTypes2.default.shape({
      x: _propTypes2.default.number,
      y: _propTypes2.default.number
    }),
    positionOffset: _propTypes2.default.shape({
      x: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
      y: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string])
    }),
    position: _propTypes2.default.shape({
      x: _propTypes2.default.number,
      y: _propTypes2.default.number
    }),
    className: _shims2.dontSetMe,
    style: _shims2.dontSetMe,
    transform: _shims2.dontSetMe
  }));
  _defineProperty7(Draggable2, "defaultProps", _objectSpread5(_objectSpread5({}, _DraggableCore.default.defaultProps), {}, {
    axis: "both",
    bounds: false,
    defaultClassName: "react-draggable",
    defaultClassNameDragging: "react-draggable-dragging",
    defaultClassNameDragged: "react-draggable-dragged",
    defaultPosition: {
      x: 0,
      y: 0
    },
    position: null,
    scale: 1
  }));
})(Draggable$1);
var _require = Draggable$1;
var Draggable = _require.default;
var DraggableCore = _require.DraggableCore;
cjs.exports = Draggable;
cjs.exports.default = Draggable;
var DraggableCore_1 = cjs.exports.DraggableCore = DraggableCore;
var ReactDraggable = cjs.exports;
function ownKeys$b(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$b(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys$b(Object(source2), true).forEach(function(key) {
        _defineProperty$2(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys$b(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
var NodesSelection = function(_ref) {
  var onSelectionDragStart = _ref.onSelectionDragStart, onSelectionDrag = _ref.onSelectionDrag, onSelectionDragStop = _ref.onSelectionDragStop, onSelectionContextMenu = _ref.onSelectionContextMenu;
  var _useStoreState = useStoreState(function(state) {
    return state.transform;
  }), _useStoreState2 = _slicedToArray$1(_useStoreState, 3), tX = _useStoreState2[0], tY = _useStoreState2[1], tScale = _useStoreState2[2];
  var selectedNodesBbox = useStoreState(function(state) {
    return state.selectedNodesBbox;
  });
  var selectionActive = useStoreState(function(state) {
    return state.selectionActive;
  });
  var selectedElements = useStoreState(function(state) {
    return state.selectedElements;
  });
  var snapToGrid2 = useStoreState(function(state) {
    return state.snapToGrid;
  });
  var snapGrid = useStoreState(function(state) {
    return state.snapGrid;
  });
  var nodes = useStoreState(function(state) {
    return state.nodes;
  });
  var updateNodePosDiff3 = useStoreActions(function(actions2) {
    return actions2.updateNodePosDiff;
  });
  var nodeRef = react.useRef(null);
  var grid2 = react.useMemo(function() {
    return snapToGrid2 ? snapGrid : [1, 1];
  }, [snapToGrid2, snapGrid]);
  var selectedNodes = react.useMemo(function() {
    return selectedElements ? selectedElements.filter(isNode).map(function(selectedNode) {
      var matchingNode = nodes.find(function(node) {
        return node.id === selectedNode.id;
      });
      return _objectSpread$b(_objectSpread$b({}, matchingNode), {}, {
        position: matchingNode === null || matchingNode === void 0 ? void 0 : matchingNode.__rf.position
      });
    }) : [];
  }, [selectedElements, nodes]);
  var style = react.useMemo(function() {
    return {
      transform: "translate(".concat(tX, "px,").concat(tY, "px) scale(").concat(tScale, ")")
    };
  }, [tX, tY, tScale]);
  var innerStyle = react.useMemo(function() {
    return {
      width: selectedNodesBbox.width,
      height: selectedNodesBbox.height,
      top: selectedNodesBbox.y,
      left: selectedNodesBbox.x
    };
  }, [selectedNodesBbox]);
  var _onStart = react.useCallback(function(event) {
    onSelectionDragStart === null || onSelectionDragStart === void 0 ? void 0 : onSelectionDragStart(event, selectedNodes);
  }, [onSelectionDragStart, selectedNodes]);
  var _onDrag = react.useCallback(function(event, data) {
    if (onSelectionDrag) {
      onSelectionDrag(event, selectedNodes);
    }
    updateNodePosDiff3({
      diff: {
        x: data.deltaX,
        y: data.deltaY
      },
      isDragging: true
    });
  }, [onSelectionDrag, selectedNodes, updateNodePosDiff3]);
  var _onStop = react.useCallback(function(event) {
    updateNodePosDiff3({
      isDragging: false
    });
    onSelectionDragStop === null || onSelectionDragStop === void 0 ? void 0 : onSelectionDragStop(event, selectedNodes);
  }, [selectedNodes, onSelectionDragStop]);
  var onContextMenu = react.useCallback(function(event) {
    var selectedNodes2 = selectedElements ? selectedElements.filter(isNode).map(function(selectedNode) {
      return nodes.find(function(node) {
        return node.id === selectedNode.id;
      });
    }) : [];
    onSelectionContextMenu === null || onSelectionContextMenu === void 0 ? void 0 : onSelectionContextMenu(event, selectedNodes2);
  }, [onSelectionContextMenu]);
  if (!selectedElements || selectionActive) {
    return null;
  }
  return /* @__PURE__ */ react.createElement("div", {
    className: "react-flow__nodesselection",
    style
  }, /* @__PURE__ */ react.createElement(ReactDraggable, {
    scale: tScale,
    grid: grid2,
    onStart: function onStart2(event) {
      return _onStart(event);
    },
    onDrag: function onDrag2(event, data) {
      return _onDrag(event, data);
    },
    onStop: function onStop2(event) {
      return _onStop(event);
    },
    nodeRef,
    enableUserSelectHack: false
  }, /* @__PURE__ */ react.createElement("div", {
    ref: nodeRef,
    className: "react-flow__nodesselection-rect",
    onContextMenu,
    style: innerStyle
  })));
};
var FlowRenderer = function FlowRenderer2(_ref) {
  var children2 = _ref.children, onPaneClick = _ref.onPaneClick, onPaneContextMenu = _ref.onPaneContextMenu, onPaneScroll = _ref.onPaneScroll, onElementsRemove = _ref.onElementsRemove, deleteKeyCode = _ref.deleteKeyCode, onMove = _ref.onMove, onMoveStart = _ref.onMoveStart, onMoveEnd = _ref.onMoveEnd, selectionKeyCode = _ref.selectionKeyCode, multiSelectionKeyCode = _ref.multiSelectionKeyCode, zoomActivationKeyCode = _ref.zoomActivationKeyCode, elementsSelectable = _ref.elementsSelectable, zoomOnScroll = _ref.zoomOnScroll, zoomOnPinch = _ref.zoomOnPinch, panOnScroll = _ref.panOnScroll, panOnScrollSpeed = _ref.panOnScrollSpeed, panOnScrollMode = _ref.panOnScrollMode, zoomOnDoubleClick = _ref.zoomOnDoubleClick, paneMoveable = _ref.paneMoveable, defaultPosition = _ref.defaultPosition, defaultZoom = _ref.defaultZoom, translateExtent = _ref.translateExtent, preventScrolling = _ref.preventScrolling, onSelectionDragStart = _ref.onSelectionDragStart, onSelectionDrag = _ref.onSelectionDrag, onSelectionDragStop = _ref.onSelectionDragStop, onSelectionContextMenu = _ref.onSelectionContextMenu;
  var unsetNodesSelection3 = useStoreActions(function(actions2) {
    return actions2.unsetNodesSelection;
  });
  var resetSelectedElements3 = useStoreActions(function(actions2) {
    return actions2.resetSelectedElements;
  });
  var nodesSelectionActive = useStoreState(function(state) {
    return state.nodesSelectionActive;
  });
  var selectionKeyPressed = useKeyPress(selectionKeyCode);
  useGlobalKeyHandler({
    onElementsRemove,
    deleteKeyCode,
    multiSelectionKeyCode
  });
  var onClick = react.useCallback(function(event) {
    onPaneClick === null || onPaneClick === void 0 ? void 0 : onPaneClick(event);
    unsetNodesSelection3();
    resetSelectedElements3();
  }, [onPaneClick]);
  var onContextMenu = react.useCallback(function(event) {
    onPaneContextMenu === null || onPaneContextMenu === void 0 ? void 0 : onPaneContextMenu(event);
  }, [onPaneContextMenu]);
  var onWheel = react.useCallback(function(event) {
    onPaneScroll === null || onPaneScroll === void 0 ? void 0 : onPaneScroll(event);
  }, [onPaneScroll]);
  return /* @__PURE__ */ react.createElement(ZoomPane, {
    onMove,
    onMoveStart,
    onMoveEnd,
    selectionKeyPressed,
    elementsSelectable,
    zoomOnScroll,
    zoomOnPinch,
    panOnScroll,
    panOnScrollSpeed,
    panOnScrollMode,
    zoomOnDoubleClick,
    paneMoveable,
    defaultPosition,
    defaultZoom,
    translateExtent,
    zoomActivationKeyCode,
    preventScrolling
  }, children2, /* @__PURE__ */ react.createElement(UserSelection, {
    selectionKeyPressed
  }), nodesSelectionActive && /* @__PURE__ */ react.createElement(NodesSelection, {
    onSelectionDragStart,
    onSelectionDrag,
    onSelectionDragStop,
    onSelectionContextMenu
  }), /* @__PURE__ */ react.createElement("div", {
    className: "react-flow__pane",
    onClick,
    onContextMenu,
    onWheel
  }));
};
FlowRenderer.displayName = "FlowRenderer";
var FlowRenderer$1 = /* @__PURE__ */ react.memo(FlowRenderer);
var NodeRenderer = function NodeRenderer2(props) {
  var transform3 = useStoreState(function(state) {
    return state.transform;
  });
  var selectedElements = useStoreState(function(state) {
    return state.selectedElements;
  });
  var nodesDraggable = useStoreState(function(state) {
    return state.nodesDraggable;
  });
  var nodesConnectable = useStoreState(function(state) {
    return state.nodesConnectable;
  });
  var elementsSelectable = useStoreState(function(state) {
    return state.elementsSelectable;
  });
  var width2 = useStoreState(function(state) {
    return state.width;
  });
  var height = useStoreState(function(state) {
    return state.height;
  });
  var nodes = useStoreState(function(state) {
    return state.nodes;
  });
  var updateNodeDimensions3 = useStoreActions(function(actions2) {
    return actions2.updateNodeDimensions;
  });
  var visibleNodes = props.onlyRenderVisibleElements ? getNodesInside(nodes, {
    x: 0,
    y: 0,
    width: width2,
    height
  }, transform3, true) : nodes;
  var transformStyle = react.useMemo(function() {
    return {
      transform: "translate(".concat(transform3[0], "px,").concat(transform3[1], "px) scale(").concat(transform3[2], ")")
    };
  }, [transform3[0], transform3[1], transform3[2]]);
  var resizeObserver = react.useMemo(function() {
    if (typeof ResizeObserver === "undefined") {
      return null;
    }
    return new ResizeObserver(function(entries) {
      var updates = entries.map(function(entry) {
        return {
          id: entry.target.getAttribute("data-id"),
          nodeElement: entry.target
        };
      });
      updateNodeDimensions3(updates);
    });
  }, []);
  return /* @__PURE__ */ react.createElement("div", {
    className: "react-flow__nodes",
    style: transformStyle
  }, visibleNodes.map(function(node) {
    var nodeType = node.type || "default";
    var NodeComponent = props.nodeTypes[nodeType] || props.nodeTypes["default"];
    if (!props.nodeTypes[nodeType]) {
      console.warn('Node type "'.concat(nodeType, '" not found. Using fallback type "default".'));
    }
    var isDraggable = !!(node.draggable || nodesDraggable && typeof node.draggable === "undefined");
    var isSelectable = !!(node.selectable || elementsSelectable && typeof node.selectable === "undefined");
    var isConnectable = !!(node.connectable || nodesConnectable && typeof node.connectable === "undefined");
    return /* @__PURE__ */ react.createElement(NodeComponent, {
      key: node.id,
      id: node.id,
      className: node.className,
      style: node.style,
      type: nodeType,
      data: node.data,
      sourcePosition: node.sourcePosition,
      targetPosition: node.targetPosition,
      isHidden: node.isHidden,
      xPos: node.__rf.position.x,
      yPos: node.__rf.position.y,
      isDragging: node.__rf.isDragging,
      isInitialized: node.__rf.width !== null && node.__rf.height !== null,
      snapGrid: props.snapGrid,
      snapToGrid: props.snapToGrid,
      selectNodesOnDrag: props.selectNodesOnDrag,
      onClick: props.onElementClick,
      onMouseEnter: props.onNodeMouseEnter,
      onMouseMove: props.onNodeMouseMove,
      onMouseLeave: props.onNodeMouseLeave,
      onContextMenu: props.onNodeContextMenu,
      onNodeDoubleClick: props.onNodeDoubleClick,
      onNodeDragStart: props.onNodeDragStart,
      onNodeDrag: props.onNodeDrag,
      onNodeDragStop: props.onNodeDragStop,
      scale: transform3[2],
      selected: (selectedElements === null || selectedElements === void 0 ? void 0 : selectedElements.some(function(_ref) {
        var id3 = _ref.id;
        return id3 === node.id;
      })) || false,
      isDraggable,
      isSelectable,
      isConnectable,
      resizeObserver
    });
  }));
};
NodeRenderer.displayName = "NodeRenderer";
var NodeRenderer$1 = /* @__PURE__ */ react.memo(NodeRenderer);
var _excluded$3 = ["x", "y", "label", "labelStyle", "labelShowBg", "labelBgStyle", "labelBgPadding", "labelBgBorderRadius", "children", "className"];
function ownKeys$a(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$a(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys$a(Object(source2), true).forEach(function(key) {
        _defineProperty$2(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys$a(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
var EdgeText = function EdgeText2(_ref) {
  var x3 = _ref.x, y4 = _ref.y, label2 = _ref.label, _ref$labelStyle = _ref.labelStyle, labelStyle = _ref$labelStyle === void 0 ? {} : _ref$labelStyle, _ref$labelShowBg = _ref.labelShowBg, labelShowBg = _ref$labelShowBg === void 0 ? true : _ref$labelShowBg, _ref$labelBgStyle = _ref.labelBgStyle, labelBgStyle = _ref$labelBgStyle === void 0 ? {} : _ref$labelBgStyle, _ref$labelBgPadding = _ref.labelBgPadding, labelBgPadding = _ref$labelBgPadding === void 0 ? [2, 4] : _ref$labelBgPadding, _ref$labelBgBorderRad = _ref.labelBgBorderRadius, labelBgBorderRadius = _ref$labelBgBorderRad === void 0 ? 2 : _ref$labelBgBorderRad, children2 = _ref.children, className = _ref.className, rest = _objectWithoutProperties3(_ref, _excluded$3);
  var edgeRef = react.useRef(null);
  var _useState = react.useState({
    x: 0,
    y: 0,
    width: 0,
    height: 0
  }), _useState2 = _slicedToArray$1(_useState, 2), edgeTextBbox = _useState2[0], setEdgeTextBbox = _useState2[1];
  var edgeTextClasses = cc2(["react-flow__edge-textwrapper", className]);
  react.useEffect(function() {
    if (edgeRef.current) {
      var textBbox = edgeRef.current.getBBox();
      setEdgeTextBbox({
        x: textBbox.x,
        y: textBbox.y,
        width: textBbox.width,
        height: textBbox.height
      });
    }
  }, [label2]);
  if (typeof label2 === "undefined" || !label2) {
    return null;
  }
  return /* @__PURE__ */ react.createElement("g", _objectSpread$a({
    transform: "translate(".concat(x3 - edgeTextBbox.width / 2, " ").concat(y4 - edgeTextBbox.height / 2, ")"),
    className: edgeTextClasses
  }, rest), labelShowBg && /* @__PURE__ */ react.createElement("rect", {
    width: edgeTextBbox.width + 2 * labelBgPadding[0],
    x: -labelBgPadding[0],
    y: -labelBgPadding[1],
    height: edgeTextBbox.height + 2 * labelBgPadding[1],
    className: "react-flow__edge-textbg",
    style: labelBgStyle,
    rx: labelBgBorderRadius,
    ry: labelBgBorderRadius
  }), /* @__PURE__ */ react.createElement("text", {
    className: "react-flow__edge-text",
    y: edgeTextBbox.height / 2,
    dy: "0.3em",
    ref: edgeRef,
    style: labelStyle
  }, label2), children2);
};
var EdgeText$1 = /* @__PURE__ */ react.memo(EdgeText);
var getMarkerEnd = function getMarkerEnd2(arrowHeadType, markerEndId) {
  if (typeof markerEndId !== "undefined" && markerEndId) {
    return "url(#".concat(markerEndId, ")");
  }
  return typeof arrowHeadType !== "undefined" ? "url(#react-flow__".concat(arrowHeadType, ")") : "none";
};
var LeftOrRight = [Position.Left, Position.Right];
var getCenter = function getCenter2(_ref) {
  var sourceX = _ref.sourceX, sourceY = _ref.sourceY, targetX = _ref.targetX, targetY = _ref.targetY, _ref$sourcePosition = _ref.sourcePosition, sourcePosition = _ref$sourcePosition === void 0 ? Position.Bottom : _ref$sourcePosition, _ref$targetPosition = _ref.targetPosition, targetPosition = _ref$targetPosition === void 0 ? Position.Top : _ref$targetPosition;
  var sourceIsLeftOrRight = LeftOrRight.includes(sourcePosition);
  var targetIsLeftOrRight = LeftOrRight.includes(targetPosition);
  var mixedEdge = sourceIsLeftOrRight && !targetIsLeftOrRight || targetIsLeftOrRight && !sourceIsLeftOrRight;
  if (mixedEdge) {
    var _xOffset = sourceIsLeftOrRight ? Math.abs(targetX - sourceX) : 0;
    var _centerX = sourceX > targetX ? sourceX - _xOffset : sourceX + _xOffset;
    var _yOffset = sourceIsLeftOrRight ? 0 : Math.abs(targetY - sourceY);
    var _centerY = sourceY < targetY ? sourceY + _yOffset : sourceY - _yOffset;
    return [_centerX, _centerY, _xOffset, _yOffset];
  }
  var xOffset = Math.abs(targetX - sourceX) / 2;
  var centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;
  var yOffset = Math.abs(targetY - sourceY) / 2;
  var centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;
  return [centerX, centerY, xOffset, yOffset];
};
function getBezierPath(_ref) {
  var sourceX = _ref.sourceX, sourceY = _ref.sourceY, _ref$sourcePosition = _ref.sourcePosition, sourcePosition = _ref$sourcePosition === void 0 ? Position.Bottom : _ref$sourcePosition, targetX = _ref.targetX, targetY = _ref.targetY, _ref$targetPosition = _ref.targetPosition, targetPosition = _ref$targetPosition === void 0 ? Position.Top : _ref$targetPosition, centerX = _ref.centerX, centerY = _ref.centerY;
  var _getCenter = getCenter({
    sourceX,
    sourceY,
    targetX,
    targetY
  }), _getCenter2 = _slicedToArray$1(_getCenter, 2), _centerX = _getCenter2[0], _centerY = _getCenter2[1];
  var leftAndRight = [Position.Left, Position.Right];
  var cX = typeof centerX !== "undefined" ? centerX : _centerX;
  var cY = typeof centerY !== "undefined" ? centerY : _centerY;
  var path = "M".concat(sourceX, ",").concat(sourceY, " C").concat(sourceX, ",").concat(cY, " ").concat(targetX, ",").concat(cY, " ").concat(targetX, ",").concat(targetY);
  if (leftAndRight.includes(sourcePosition) && leftAndRight.includes(targetPosition)) {
    path = "M".concat(sourceX, ",").concat(sourceY, " C").concat(cX, ",").concat(sourceY, " ").concat(cX, ",").concat(targetY, " ").concat(targetX, ",").concat(targetY);
  } else if (leftAndRight.includes(targetPosition)) {
    path = "M".concat(sourceX, ",").concat(sourceY, " C").concat(sourceX, ",").concat(targetY, " ").concat(sourceX, ",").concat(targetY, " ").concat(targetX, ",").concat(targetY);
  } else if (leftAndRight.includes(sourcePosition)) {
    path = "M".concat(sourceX, ",").concat(sourceY, " C").concat(targetX, ",").concat(sourceY, " ").concat(targetX, ",").concat(sourceY, " ").concat(targetX, ",").concat(targetY);
  }
  return path;
}
var BezierEdge = /* @__PURE__ */ react.memo(function(_ref2) {
  var sourceX = _ref2.sourceX, sourceY = _ref2.sourceY, targetX = _ref2.targetX, targetY = _ref2.targetY, _ref2$sourcePosition = _ref2.sourcePosition, sourcePosition = _ref2$sourcePosition === void 0 ? Position.Bottom : _ref2$sourcePosition, _ref2$targetPosition = _ref2.targetPosition, targetPosition = _ref2$targetPosition === void 0 ? Position.Top : _ref2$targetPosition, label2 = _ref2.label, labelStyle = _ref2.labelStyle, labelShowBg = _ref2.labelShowBg, labelBgStyle = _ref2.labelBgStyle, labelBgPadding = _ref2.labelBgPadding, labelBgBorderRadius = _ref2.labelBgBorderRadius, style = _ref2.style, arrowHeadType = _ref2.arrowHeadType, markerEndId = _ref2.markerEndId;
  var _getCenter3 = getCenter({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourcePosition,
    targetPosition
  }), _getCenter4 = _slicedToArray$1(_getCenter3, 2), centerX = _getCenter4[0], centerY = _getCenter4[1];
  var path = getBezierPath({
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition
  });
  var text = label2 ? /* @__PURE__ */ react.createElement(EdgeText$1, {
    x: centerX,
    y: centerY,
    label: label2,
    labelStyle,
    labelShowBg,
    labelBgStyle,
    labelBgPadding,
    labelBgBorderRadius
  }) : null;
  var markerEnd = getMarkerEnd(arrowHeadType, markerEndId);
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement("path", {
    style,
    d: path,
    className: "react-flow__edge-path",
    markerEnd
  }), text);
});
var bottomLeftCorner = function bottomLeftCorner2(x3, y4, size2) {
  return "L ".concat(x3, ",").concat(y4 - size2, "Q ").concat(x3, ",").concat(y4, " ").concat(x3 + size2, ",").concat(y4);
};
var leftBottomCorner = function leftBottomCorner2(x3, y4, size2) {
  return "L ".concat(x3 + size2, ",").concat(y4, "Q ").concat(x3, ",").concat(y4, " ").concat(x3, ",").concat(y4 - size2);
};
var bottomRightCorner = function bottomRightCorner2(x3, y4, size2) {
  return "L ".concat(x3, ",").concat(y4 - size2, "Q ").concat(x3, ",").concat(y4, " ").concat(x3 - size2, ",").concat(y4);
};
var rightBottomCorner = function rightBottomCorner2(x3, y4, size2) {
  return "L ".concat(x3 - size2, ",").concat(y4, "Q ").concat(x3, ",").concat(y4, " ").concat(x3, ",").concat(y4 - size2);
};
var leftTopCorner = function leftTopCorner2(x3, y4, size2) {
  return "L ".concat(x3 + size2, ",").concat(y4, "Q ").concat(x3, ",").concat(y4, " ").concat(x3, ",").concat(y4 + size2);
};
var topLeftCorner = function topLeftCorner2(x3, y4, size2) {
  return "L ".concat(x3, ",").concat(y4 + size2, "Q ").concat(x3, ",").concat(y4, " ").concat(x3 + size2, ",").concat(y4);
};
var topRightCorner = function topRightCorner2(x3, y4, size2) {
  return "L ".concat(x3, ",").concat(y4 + size2, "Q ").concat(x3, ",").concat(y4, " ").concat(x3 - size2, ",").concat(y4);
};
var rightTopCorner = function rightTopCorner2(x3, y4, size2) {
  return "L ".concat(x3 - size2, ",").concat(y4, "Q ").concat(x3, ",").concat(y4, " ").concat(x3, ",").concat(y4 + size2);
};
function getSmoothStepPath(_ref) {
  var sourceX = _ref.sourceX, sourceY = _ref.sourceY, _ref$sourcePosition = _ref.sourcePosition, sourcePosition = _ref$sourcePosition === void 0 ? Position.Bottom : _ref$sourcePosition, targetX = _ref.targetX, targetY = _ref.targetY, _ref$targetPosition = _ref.targetPosition, targetPosition = _ref$targetPosition === void 0 ? Position.Top : _ref$targetPosition, _ref$borderRadius = _ref.borderRadius, borderRadius = _ref$borderRadius === void 0 ? 5 : _ref$borderRadius, centerX = _ref.centerX, centerY = _ref.centerY;
  var _getCenter = getCenter({
    sourceX,
    sourceY,
    targetX,
    targetY
  }), _getCenter2 = _slicedToArray$1(_getCenter, 4), _centerX = _getCenter2[0], _centerY = _getCenter2[1], offsetX = _getCenter2[2], offsetY = _getCenter2[3];
  var cornerWidth = Math.min(borderRadius, Math.abs(targetX - sourceX));
  var cornerHeight = Math.min(borderRadius, Math.abs(targetY - sourceY));
  var cornerSize = Math.min(cornerWidth, cornerHeight, offsetX, offsetY);
  var leftAndRight = [Position.Left, Position.Right];
  var cX = typeof centerX !== "undefined" ? centerX : _centerX;
  var cY = typeof centerY !== "undefined" ? centerY : _centerY;
  var firstCornerPath = null;
  var secondCornerPath = null;
  if (sourceX <= targetX) {
    firstCornerPath = sourceY <= targetY ? bottomLeftCorner(sourceX, cY, cornerSize) : topLeftCorner(sourceX, cY, cornerSize);
    secondCornerPath = sourceY <= targetY ? rightTopCorner(targetX, cY, cornerSize) : rightBottomCorner(targetX, cY, cornerSize);
  } else {
    firstCornerPath = sourceY < targetY ? bottomRightCorner(sourceX, cY, cornerSize) : topRightCorner(sourceX, cY, cornerSize);
    secondCornerPath = sourceY < targetY ? leftTopCorner(targetX, cY, cornerSize) : leftBottomCorner(targetX, cY, cornerSize);
  }
  if (leftAndRight.includes(sourcePosition) && leftAndRight.includes(targetPosition)) {
    if (sourceX <= targetX) {
      firstCornerPath = sourceY <= targetY ? rightTopCorner(cX, sourceY, cornerSize) : rightBottomCorner(cX, sourceY, cornerSize);
      secondCornerPath = sourceY <= targetY ? bottomLeftCorner(cX, targetY, cornerSize) : topLeftCorner(cX, targetY, cornerSize);
    } else if (sourcePosition === Position.Right && targetPosition === Position.Left) {
      firstCornerPath = sourceY <= targetY ? leftTopCorner(cX, sourceY, cornerSize) : leftBottomCorner(cX, sourceY, cornerSize);
      secondCornerPath = sourceY <= targetY ? bottomRightCorner(cX, targetY, cornerSize) : topRightCorner(cX, targetY, cornerSize);
    }
  } else if (leftAndRight.includes(sourcePosition) && !leftAndRight.includes(targetPosition)) {
    if (sourceX <= targetX) {
      firstCornerPath = sourceY <= targetY ? rightTopCorner(targetX, sourceY, cornerSize) : rightBottomCorner(targetX, sourceY, cornerSize);
    } else {
      firstCornerPath = sourceY <= targetY ? leftTopCorner(targetX, sourceY, cornerSize) : leftBottomCorner(targetX, sourceY, cornerSize);
    }
    secondCornerPath = "";
  } else if (!leftAndRight.includes(sourcePosition) && leftAndRight.includes(targetPosition)) {
    if (sourceX <= targetX) {
      firstCornerPath = sourceY <= targetY ? bottomLeftCorner(sourceX, targetY, cornerSize) : topLeftCorner(sourceX, targetY, cornerSize);
    } else {
      firstCornerPath = sourceY <= targetY ? bottomRightCorner(sourceX, targetY, cornerSize) : topRightCorner(sourceX, targetY, cornerSize);
    }
    secondCornerPath = "";
  }
  return "M ".concat(sourceX, ",").concat(sourceY).concat(firstCornerPath).concat(secondCornerPath, "L ").concat(targetX, ",").concat(targetY);
}
var SmoothStepEdge = /* @__PURE__ */ react.memo(function(_ref2) {
  var sourceX = _ref2.sourceX, sourceY = _ref2.sourceY, targetX = _ref2.targetX, targetY = _ref2.targetY, label2 = _ref2.label, labelStyle = _ref2.labelStyle, labelShowBg = _ref2.labelShowBg, labelBgStyle = _ref2.labelBgStyle, labelBgPadding = _ref2.labelBgPadding, labelBgBorderRadius = _ref2.labelBgBorderRadius, style = _ref2.style, _ref2$sourcePosition = _ref2.sourcePosition, sourcePosition = _ref2$sourcePosition === void 0 ? Position.Bottom : _ref2$sourcePosition, _ref2$targetPosition = _ref2.targetPosition, targetPosition = _ref2$targetPosition === void 0 ? Position.Top : _ref2$targetPosition, arrowHeadType = _ref2.arrowHeadType, markerEndId = _ref2.markerEndId, _ref2$borderRadius = _ref2.borderRadius, borderRadius = _ref2$borderRadius === void 0 ? 5 : _ref2$borderRadius;
  var _getCenter3 = getCenter({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourcePosition,
    targetPosition
  }), _getCenter4 = _slicedToArray$1(_getCenter3, 2), centerX = _getCenter4[0], centerY = _getCenter4[1];
  var path = getSmoothStepPath({
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
    borderRadius
  });
  var markerEnd = getMarkerEnd(arrowHeadType, markerEndId);
  var text = label2 ? /* @__PURE__ */ react.createElement(EdgeText$1, {
    x: centerX,
    y: centerY,
    label: label2,
    labelStyle,
    labelShowBg,
    labelBgStyle,
    labelBgPadding,
    labelBgBorderRadius
  }) : null;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement("path", {
    style,
    className: "react-flow__edge-path",
    d: path,
    markerEnd
  }), text);
});
var ConnectionLine = function(_ref) {
  var connectionNodeId = _ref.connectionNodeId, connectionHandleId = _ref.connectionHandleId, connectionHandleType = _ref.connectionHandleType, connectionLineStyle = _ref.connectionLineStyle, connectionPositionX = _ref.connectionPositionX, connectionPositionY = _ref.connectionPositionY, _ref$connectionLineTy = _ref.connectionLineType, connectionLineType = _ref$connectionLineTy === void 0 ? ConnectionLineType.Bezier : _ref$connectionLineTy, _ref$nodes = _ref.nodes, nodes = _ref$nodes === void 0 ? [] : _ref$nodes, transform3 = _ref.transform, isConnectable = _ref.isConnectable, CustomConnectionLineComponent = _ref.CustomConnectionLineComponent;
  var _useState = react.useState(null), _useState2 = _slicedToArray$1(_useState, 2), sourceNode = _useState2[0], setSourceNode = _useState2[1];
  var nodeId = connectionNodeId;
  var handleId = connectionHandleId;
  react.useEffect(function() {
    var nextSourceNode = nodes.find(function(n4) {
      return n4.id === nodeId;
    }) || null;
    setSourceNode(nextSourceNode);
  }, []);
  if (!sourceNode || !isConnectable) {
    return null;
  }
  var sourceHandle = handleId ? sourceNode.__rf.handleBounds[connectionHandleType].find(function(d3) {
    return d3.id === handleId;
  }) : sourceNode.__rf.handleBounds[connectionHandleType][0];
  var sourceHandleX = sourceHandle ? sourceHandle.x + sourceHandle.width / 2 : sourceNode.__rf.width / 2;
  var sourceHandleY = sourceHandle ? sourceHandle.y + sourceHandle.height / 2 : sourceNode.__rf.height;
  var sourceX = sourceNode.__rf.position.x + sourceHandleX;
  var sourceY = sourceNode.__rf.position.y + sourceHandleY;
  var targetX = (connectionPositionX - transform3[0]) / transform3[2];
  var targetY = (connectionPositionY - transform3[1]) / transform3[2];
  var isRightOrLeft = (sourceHandle === null || sourceHandle === void 0 ? void 0 : sourceHandle.position) === Position.Left || (sourceHandle === null || sourceHandle === void 0 ? void 0 : sourceHandle.position) === Position.Right;
  var targetPosition = isRightOrLeft ? Position.Left : Position.Top;
  if (CustomConnectionLineComponent) {
    return /* @__PURE__ */ react.createElement("g", {
      className: "react-flow__connection"
    }, /* @__PURE__ */ react.createElement(CustomConnectionLineComponent, {
      sourceX,
      sourceY,
      sourcePosition: sourceHandle === null || sourceHandle === void 0 ? void 0 : sourceHandle.position,
      targetX,
      targetY,
      targetPosition,
      connectionLineType,
      connectionLineStyle,
      sourceNode,
      sourceHandle
    }));
  }
  var dAttr = "";
  if (connectionLineType === ConnectionLineType.Bezier) {
    dAttr = getBezierPath({
      sourceX,
      sourceY,
      sourcePosition: sourceHandle === null || sourceHandle === void 0 ? void 0 : sourceHandle.position,
      targetX,
      targetY,
      targetPosition
    });
  } else if (connectionLineType === ConnectionLineType.Step) {
    dAttr = getSmoothStepPath({
      sourceX,
      sourceY,
      sourcePosition: sourceHandle === null || sourceHandle === void 0 ? void 0 : sourceHandle.position,
      targetX,
      targetY,
      targetPosition,
      borderRadius: 0
    });
  } else if (connectionLineType === ConnectionLineType.SmoothStep) {
    dAttr = getSmoothStepPath({
      sourceX,
      sourceY,
      sourcePosition: sourceHandle === null || sourceHandle === void 0 ? void 0 : sourceHandle.position,
      targetX,
      targetY,
      targetPosition
    });
  } else {
    dAttr = "M".concat(sourceX, ",").concat(sourceY, " ").concat(targetX, ",").concat(targetY);
  }
  return /* @__PURE__ */ react.createElement("g", {
    className: "react-flow__connection"
  }, /* @__PURE__ */ react.createElement("path", {
    d: dAttr,
    className: "react-flow__connection-path",
    style: connectionLineStyle
  }));
};
var Marker = function Marker2(_ref) {
  var id3 = _ref.id, children2 = _ref.children;
  return /* @__PURE__ */ react.createElement("marker", {
    className: "react-flow__arrowhead",
    id: id3,
    markerWidth: "12.5",
    markerHeight: "12.5",
    viewBox: "-10 -10 20 20",
    orient: "auto",
    refX: "0",
    refY: "0"
  }, children2);
};
var MarkerDefinitions = function MarkerDefinitions2(_ref2) {
  var color2 = _ref2.color;
  return /* @__PURE__ */ react.createElement("defs", null, /* @__PURE__ */ react.createElement(Marker, {
    id: "react-flow__arrowclosed"
  }, /* @__PURE__ */ react.createElement("polyline", {
    stroke: color2,
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: "1",
    fill: color2,
    points: "-5,-4 0,0 -5,4 -5,-4"
  })), /* @__PURE__ */ react.createElement(Marker, {
    id: "react-flow__arrow"
  }, /* @__PURE__ */ react.createElement("polyline", {
    stroke: color2,
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: "1.5",
    fill: "none",
    points: "-5,-4 0,0 -5,4"
  })));
};
MarkerDefinitions.displayName = "MarkerDefinitions";
function ownKeys$9(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$9(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys$9(Object(source2), true).forEach(function(key) {
        _defineProperty$2(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys$9(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
var StepEdge = /* @__PURE__ */ react.memo(function(props) {
  return /* @__PURE__ */ react.createElement(SmoothStepEdge, _objectSpread$9(_objectSpread$9({}, props), {}, {
    borderRadius: 0
  }));
});
var StraightEdge = /* @__PURE__ */ react.memo(function(_ref) {
  var sourceX = _ref.sourceX, sourceY = _ref.sourceY, targetX = _ref.targetX, targetY = _ref.targetY, label2 = _ref.label, labelStyle = _ref.labelStyle, labelShowBg = _ref.labelShowBg, labelBgStyle = _ref.labelBgStyle, labelBgPadding = _ref.labelBgPadding, labelBgBorderRadius = _ref.labelBgBorderRadius, style = _ref.style, arrowHeadType = _ref.arrowHeadType, markerEndId = _ref.markerEndId;
  var yOffset = Math.abs(targetY - sourceY) / 2;
  var centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;
  var xOffset = Math.abs(targetX - sourceX) / 2;
  var centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;
  var markerEnd = getMarkerEnd(arrowHeadType, markerEndId);
  var text = label2 ? /* @__PURE__ */ react.createElement(EdgeText$1, {
    x: centerX,
    y: centerY,
    label: label2,
    labelStyle,
    labelShowBg,
    labelBgStyle,
    labelBgPadding,
    labelBgBorderRadius
  }) : null;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement("path", {
    style,
    className: "react-flow__edge-path",
    d: "M ".concat(sourceX, ",").concat(sourceY, "L ").concat(targetX, ",").concat(targetY),
    markerEnd
  }), text);
});
function checkElementBelowIsValid(event, connectionMode, isTarget, nodeId, handleId, isValidConnection, doc) {
  var elementBelow = doc.elementFromPoint(event.clientX, event.clientY);
  var elementBelowIsTarget = (elementBelow === null || elementBelow === void 0 ? void 0 : elementBelow.classList.contains("target")) || false;
  var elementBelowIsSource = (elementBelow === null || elementBelow === void 0 ? void 0 : elementBelow.classList.contains("source")) || false;
  var result = {
    elementBelow,
    isValid: false,
    connection: {
      source: null,
      target: null,
      sourceHandle: null,
      targetHandle: null
    },
    isHoveringHandle: false
  };
  if (elementBelow && (elementBelowIsTarget || elementBelowIsSource)) {
    result.isHoveringHandle = true;
    var isValid = connectionMode === ConnectionMode.Strict ? isTarget && elementBelowIsSource || !isTarget && elementBelowIsTarget : true;
    if (isValid) {
      var elementBelowNodeId = elementBelow.getAttribute("data-nodeid");
      var elementBelowHandleId = elementBelow.getAttribute("data-handleid");
      var connection = isTarget ? {
        source: elementBelowNodeId,
        sourceHandle: elementBelowHandleId,
        target: nodeId,
        targetHandle: handleId
      } : {
        source: nodeId,
        sourceHandle: handleId,
        target: elementBelowNodeId,
        targetHandle: elementBelowHandleId
      };
      result.connection = connection;
      result.isValid = isValidConnection(connection);
    }
  }
  return result;
}
function resetRecentHandle(hoveredHandle) {
  hoveredHandle === null || hoveredHandle === void 0 ? void 0 : hoveredHandle.classList.remove("react-flow__handle-valid");
  hoveredHandle === null || hoveredHandle === void 0 ? void 0 : hoveredHandle.classList.remove("react-flow__handle-connecting");
}
function onMouseDown2(event, handleId, nodeId, setConnectionNodeId3, setPosition, onConnect, isTarget, isValidConnection, connectionMode, elementEdgeUpdaterType, onEdgeUpdateEnd, onConnectStart, onConnectStop, onConnectEnd) {
  var reactFlowNode = event.target.closest(".react-flow");
  var doc = getHostForElement(event.target);
  if (!doc) {
    return;
  }
  var elementBelow = doc.elementFromPoint(event.clientX, event.clientY);
  var elementBelowIsTarget = elementBelow === null || elementBelow === void 0 ? void 0 : elementBelow.classList.contains("target");
  var elementBelowIsSource = elementBelow === null || elementBelow === void 0 ? void 0 : elementBelow.classList.contains("source");
  if (!reactFlowNode || !elementBelowIsTarget && !elementBelowIsSource && !elementEdgeUpdaterType) {
    return;
  }
  var handleType = elementEdgeUpdaterType ? elementEdgeUpdaterType : elementBelowIsTarget ? "target" : "source";
  var containerBounds = reactFlowNode.getBoundingClientRect();
  var recentHoveredHandle;
  setPosition({
    x: event.clientX - containerBounds.left,
    y: event.clientY - containerBounds.top
  });
  setConnectionNodeId3({
    connectionNodeId: nodeId,
    connectionHandleId: handleId,
    connectionHandleType: handleType
  });
  onConnectStart === null || onConnectStart === void 0 ? void 0 : onConnectStart(event, {
    nodeId,
    handleId,
    handleType
  });
  function onMouseMove(event2) {
    setPosition({
      x: event2.clientX - containerBounds.left,
      y: event2.clientY - containerBounds.top
    });
    var _checkElementBelowIsV = checkElementBelowIsValid(event2, connectionMode, isTarget, nodeId, handleId, isValidConnection, doc), connection = _checkElementBelowIsV.connection, elementBelow2 = _checkElementBelowIsV.elementBelow, isValid = _checkElementBelowIsV.isValid, isHoveringHandle = _checkElementBelowIsV.isHoveringHandle;
    if (!isHoveringHandle) {
      return resetRecentHandle(recentHoveredHandle);
    }
    var isOwnHandle = connection.source === connection.target;
    if (!isOwnHandle && elementBelow2) {
      recentHoveredHandle = elementBelow2;
      elementBelow2.classList.add("react-flow__handle-connecting");
      elementBelow2.classList.toggle("react-flow__handle-valid", isValid);
    }
  }
  function onMouseUp(event2) {
    var _checkElementBelowIsV2 = checkElementBelowIsValid(event2, connectionMode, isTarget, nodeId, handleId, isValidConnection, doc), connection = _checkElementBelowIsV2.connection, isValid = _checkElementBelowIsV2.isValid;
    onConnectStop === null || onConnectStop === void 0 ? void 0 : onConnectStop(event2);
    if (isValid) {
      onConnect === null || onConnect === void 0 ? void 0 : onConnect(connection);
    }
    onConnectEnd === null || onConnectEnd === void 0 ? void 0 : onConnectEnd(event2);
    if (elementEdgeUpdaterType && onEdgeUpdateEnd) {
      onEdgeUpdateEnd(event2);
    }
    resetRecentHandle(recentHoveredHandle);
    setConnectionNodeId3({
      connectionNodeId: null,
      connectionHandleId: null,
      connectionHandleType: null
    });
    doc.removeEventListener("mousemove", onMouseMove);
    doc.removeEventListener("mouseup", onMouseUp);
  }
  doc.addEventListener("mousemove", onMouseMove);
  doc.addEventListener("mouseup", onMouseUp);
}
var shiftX = function shiftX2(x3, shift, position2) {
  if (position2 === Position.Left)
    return x3 - shift;
  if (position2 === Position.Right)
    return x3 + shift;
  return x3;
};
var shiftY = function shiftY2(y4, shift, position2) {
  if (position2 === Position.Top)
    return y4 - shift;
  if (position2 === Position.Bottom)
    return y4 + shift;
  return y4;
};
var EdgeAnchor = function EdgeAnchor2(_ref) {
  var className = _ref.className, position2 = _ref.position, centerX = _ref.centerX, centerY = _ref.centerY, _ref$radius = _ref.radius, radius = _ref$radius === void 0 ? 10 : _ref$radius;
  return /* @__PURE__ */ react.createElement("circle", {
    className: cc2(["react-flow__edgeupdater", className]),
    cx: shiftX(centerX, radius, position2),
    cy: shiftY(centerY, radius, position2),
    r: radius,
    stroke: "transparent",
    fill: "transparent"
  });
};
var wrapEdge = function(EdgeComponent) {
  var EdgeWrapper = function EdgeWrapper2(_ref) {
    var id3 = _ref.id, className = _ref.className, type = _ref.type, data = _ref.data, onClick = _ref.onClick, onEdgeDoubleClick = _ref.onEdgeDoubleClick, selected = _ref.selected, animated = _ref.animated, label2 = _ref.label, labelStyle = _ref.labelStyle, labelShowBg = _ref.labelShowBg, labelBgStyle = _ref.labelBgStyle, labelBgPadding = _ref.labelBgPadding, labelBgBorderRadius = _ref.labelBgBorderRadius, style = _ref.style, arrowHeadType = _ref.arrowHeadType, source2 = _ref.source, target = _ref.target, sourceX = _ref.sourceX, sourceY = _ref.sourceY, targetX = _ref.targetX, targetY = _ref.targetY, sourcePosition = _ref.sourcePosition, targetPosition = _ref.targetPosition, elementsSelectable = _ref.elementsSelectable, markerEndId = _ref.markerEndId, isHidden3 = _ref.isHidden, sourceHandleId = _ref.sourceHandleId, targetHandleId = _ref.targetHandleId, handleEdgeUpdate = _ref.handleEdgeUpdate, onConnectEdge = _ref.onConnectEdge, onContextMenu = _ref.onContextMenu, onMouseEnter = _ref.onMouseEnter, onMouseMove = _ref.onMouseMove, onMouseLeave = _ref.onMouseLeave, edgeUpdaterRadius = _ref.edgeUpdaterRadius, onEdgeUpdateStart = _ref.onEdgeUpdateStart, onEdgeUpdateEnd = _ref.onEdgeUpdateEnd;
    var addSelectedElements3 = useStoreActions(function(actions2) {
      return actions2.addSelectedElements;
    });
    var setConnectionNodeId3 = useStoreActions(function(actions2) {
      return actions2.setConnectionNodeId;
    });
    var unsetNodesSelection3 = useStoreActions(function(actions2) {
      return actions2.unsetNodesSelection;
    });
    var setPosition = useStoreActions(function(actions2) {
      return actions2.setConnectionPosition;
    });
    var connectionMode = useStoreState(function(state) {
      return state.connectionMode;
    });
    var _useState = react.useState(false), _useState2 = _slicedToArray$1(_useState, 2), updating = _useState2[0], setUpdating = _useState2[1];
    var inactive = !elementsSelectable && !onClick;
    var edgeClasses = cc2(["react-flow__edge", "react-flow__edge-".concat(type), className, {
      selected,
      animated,
      inactive,
      updating
    }]);
    var edgeElement = react.useMemo(function() {
      var el = {
        id: id3,
        source: source2,
        target,
        type
      };
      if (sourceHandleId) {
        el.sourceHandle = sourceHandleId;
      }
      if (targetHandleId) {
        el.targetHandle = targetHandleId;
      }
      if (typeof data !== "undefined") {
        el.data = data;
      }
      return el;
    }, [id3, source2, target, type, sourceHandleId, targetHandleId, data]);
    var onEdgeClick = react.useCallback(function(event) {
      if (elementsSelectable) {
        unsetNodesSelection3();
        addSelectedElements3(edgeElement);
      }
      onClick === null || onClick === void 0 ? void 0 : onClick(event, edgeElement);
    }, [elementsSelectable, edgeElement, onClick]);
    var onEdgeDoubleClickHandler = react.useCallback(function(event) {
      onEdgeDoubleClick === null || onEdgeDoubleClick === void 0 ? void 0 : onEdgeDoubleClick(event, edgeElement);
    }, [edgeElement, onEdgeDoubleClick]);
    var onEdgeContextMenu = react.useCallback(function(event) {
      onContextMenu === null || onContextMenu === void 0 ? void 0 : onContextMenu(event, edgeElement);
    }, [edgeElement, onContextMenu]);
    var onEdgeMouseEnter = react.useCallback(function(event) {
      onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter(event, edgeElement);
    }, [edgeElement, onContextMenu]);
    var onEdgeMouseMove = react.useCallback(function(event) {
      onMouseMove === null || onMouseMove === void 0 ? void 0 : onMouseMove(event, edgeElement);
    }, [edgeElement, onContextMenu]);
    var onEdgeMouseLeave = react.useCallback(function(event) {
      onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave(event, edgeElement);
    }, [edgeElement, onContextMenu]);
    var handleEdgeUpdater = react.useCallback(function(event, isSourceHandle) {
      var nodeId = isSourceHandle ? target : source2;
      var handleId = isSourceHandle ? targetHandleId : sourceHandleId;
      var isValidConnection = function isValidConnection2() {
        return true;
      };
      var isTarget = isSourceHandle;
      onEdgeUpdateStart === null || onEdgeUpdateStart === void 0 ? void 0 : onEdgeUpdateStart(event, edgeElement);
      var _onEdgeUpdate = onEdgeUpdateEnd ? function(evt) {
        return onEdgeUpdateEnd(evt, edgeElement);
      } : void 0;
      onMouseDown2(event, handleId, nodeId, setConnectionNodeId3, setPosition, onConnectEdge, isTarget, isValidConnection, connectionMode, isSourceHandle ? "target" : "source", _onEdgeUpdate);
    }, [id3, source2, target, type, sourceHandleId, targetHandleId, setConnectionNodeId3, setPosition, edgeElement]);
    var onEdgeUpdaterSourceMouseDown = react.useCallback(function(event) {
      handleEdgeUpdater(event, true);
    }, [id3, source2, sourceHandleId, handleEdgeUpdater]);
    var onEdgeUpdaterTargetMouseDown = react.useCallback(function(event) {
      handleEdgeUpdater(event, false);
    }, [id3, target, targetHandleId, handleEdgeUpdater]);
    var onEdgeUpdaterMouseEnter = react.useCallback(function() {
      return setUpdating(true);
    }, [setUpdating]);
    var onEdgeUpdaterMouseOut = react.useCallback(function() {
      return setUpdating(false);
    }, [setUpdating]);
    if (isHidden3) {
      return null;
    }
    return /* @__PURE__ */ react.createElement("g", {
      className: edgeClasses,
      onClick: onEdgeClick,
      onDoubleClick: onEdgeDoubleClickHandler,
      onContextMenu: onEdgeContextMenu,
      onMouseEnter: onEdgeMouseEnter,
      onMouseMove: onEdgeMouseMove,
      onMouseLeave: onEdgeMouseLeave
    }, /* @__PURE__ */ react.createElement(EdgeComponent, {
      id: id3,
      source: source2,
      target,
      selected,
      animated,
      label: label2,
      labelStyle,
      labelShowBg,
      labelBgStyle,
      labelBgPadding,
      labelBgBorderRadius,
      data,
      style,
      arrowHeadType,
      sourceX,
      sourceY,
      targetX,
      targetY,
      sourcePosition,
      targetPosition,
      markerEndId,
      sourceHandleId,
      targetHandleId
    }), handleEdgeUpdate && /* @__PURE__ */ react.createElement("g", {
      onMouseDown: onEdgeUpdaterSourceMouseDown,
      onMouseEnter: onEdgeUpdaterMouseEnter,
      onMouseOut: onEdgeUpdaterMouseOut
    }, /* @__PURE__ */ react.createElement(EdgeAnchor, {
      position: sourcePosition,
      centerX: sourceX,
      centerY: sourceY,
      radius: edgeUpdaterRadius
    })), handleEdgeUpdate && /* @__PURE__ */ react.createElement("g", {
      onMouseDown: onEdgeUpdaterTargetMouseDown,
      onMouseEnter: onEdgeUpdaterMouseEnter,
      onMouseOut: onEdgeUpdaterMouseOut
    }, /* @__PURE__ */ react.createElement(EdgeAnchor, {
      position: targetPosition,
      centerX: targetX,
      centerY: targetY,
      radius: edgeUpdaterRadius
    })));
  };
  EdgeWrapper.displayName = "EdgeWrapper";
  return /* @__PURE__ */ react.memo(EdgeWrapper);
};
function ownKeys$8(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$8(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys$8(Object(source2), true).forEach(function(key) {
        _defineProperty$2(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys$8(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
function createEdgeTypes(edgeTypes) {
  var standardTypes = {
    default: wrapEdge(edgeTypes["default"] || BezierEdge),
    straight: wrapEdge(edgeTypes.bezier || StraightEdge),
    step: wrapEdge(edgeTypes.step || StepEdge),
    smoothstep: wrapEdge(edgeTypes.step || SmoothStepEdge)
  };
  var wrappedTypes = {};
  var specialTypes = Object.keys(edgeTypes).filter(function(k3) {
    return !["default", "bezier"].includes(k3);
  }).reduce(function(res, key) {
    res[key] = wrapEdge(edgeTypes[key] || BezierEdge);
    return res;
  }, wrappedTypes);
  return _objectSpread$8(_objectSpread$8({}, standardTypes), specialTypes);
}
function getHandlePosition(position2, node) {
  var handle2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  var x3 = ((handle2 === null || handle2 === void 0 ? void 0 : handle2.x) || 0) + node.__rf.position.x;
  var y4 = ((handle2 === null || handle2 === void 0 ? void 0 : handle2.y) || 0) + node.__rf.position.y;
  var width2 = (handle2 === null || handle2 === void 0 ? void 0 : handle2.width) || node.__rf.width;
  var height = (handle2 === null || handle2 === void 0 ? void 0 : handle2.height) || node.__rf.height;
  switch (position2) {
    case Position.Top:
      return {
        x: x3 + width2 / 2,
        y: y4
      };
    case Position.Right:
      return {
        x: x3 + width2,
        y: y4 + height / 2
      };
    case Position.Bottom:
      return {
        x: x3 + width2 / 2,
        y: y4 + height
      };
    case Position.Left:
      return {
        x: x3,
        y: y4 + height / 2
      };
  }
}
function getHandle(bounds, handleId) {
  if (!bounds) {
    return null;
  }
  var handle2 = null;
  if (bounds.length === 1 || !handleId) {
    handle2 = bounds[0];
  } else if (handleId) {
    handle2 = bounds.find(function(d3) {
      return d3.id === handleId;
    });
  }
  return typeof handle2 === "undefined" ? null : handle2;
}
var getEdgePositions = function getEdgePositions2(sourceNode, sourceHandle, sourcePosition, targetNode, targetHandle, targetPosition) {
  var sourceHandlePos = getHandlePosition(sourcePosition, sourceNode, sourceHandle);
  var targetHandlePos = getHandlePosition(targetPosition, targetNode, targetHandle);
  return {
    sourceX: sourceHandlePos.x,
    sourceY: sourceHandlePos.y,
    targetX: targetHandlePos.x,
    targetY: targetHandlePos.y
  };
};
function isEdgeVisible(_ref) {
  var sourcePos = _ref.sourcePos, targetPos = _ref.targetPos, width2 = _ref.width, height = _ref.height, transform3 = _ref.transform;
  var edgeBox = {
    x: Math.min(sourcePos.x, targetPos.x),
    y: Math.min(sourcePos.y, targetPos.y),
    x2: Math.max(sourcePos.x, targetPos.x),
    y2: Math.max(sourcePos.y, targetPos.y)
  };
  if (edgeBox.x === edgeBox.x2) {
    edgeBox.x2 += 1;
  }
  if (edgeBox.y === edgeBox.y2) {
    edgeBox.y2 += 1;
  }
  var viewBox = rectToBox({
    x: (0 - transform3[0]) / transform3[2],
    y: (0 - transform3[1]) / transform3[2],
    width: width2 / transform3[2],
    height: height / transform3[2]
  });
  var xOverlap = Math.max(0, Math.min(viewBox.x2, edgeBox.x2) - Math.max(viewBox.x, edgeBox.x));
  var yOverlap = Math.max(0, Math.min(viewBox.y2, edgeBox.y2) - Math.max(viewBox.y, edgeBox.y));
  var overlappingArea = Math.ceil(xOverlap * yOverlap);
  return overlappingArea > 0;
}
var getSourceTargetNodes = function getSourceTargetNodes2(edge, nodes) {
  return nodes.reduce(function(res, node) {
    if (node.id === edge.source) {
      res.sourceNode = node;
    }
    if (node.id === edge.target) {
      res.targetNode = node;
    }
    return res;
  }, {
    sourceNode: null,
    targetNode: null
  });
};
var Edge = function Edge2(_ref) {
  var edge = _ref.edge, props = _ref.props, nodes = _ref.nodes, selectedElements = _ref.selectedElements, elementsSelectable = _ref.elementsSelectable, transform3 = _ref.transform, width2 = _ref.width, height = _ref.height, onlyRenderVisibleElements = _ref.onlyRenderVisibleElements, connectionMode = _ref.connectionMode;
  var sourceHandleId = edge.sourceHandle || null;
  var targetHandleId = edge.targetHandle || null;
  var _getSourceTargetNodes = getSourceTargetNodes(edge, nodes), sourceNode = _getSourceTargetNodes.sourceNode, targetNode = _getSourceTargetNodes.targetNode;
  var onConnectEdge = react.useCallback(function(connection) {
    var _props$onEdgeUpdate;
    (_props$onEdgeUpdate = props.onEdgeUpdate) === null || _props$onEdgeUpdate === void 0 ? void 0 : _props$onEdgeUpdate.call(props, edge, connection);
  }, [edge]);
  if (!sourceNode) {
    console.warn("couldn't create edge for source id: ".concat(edge.source, "; edge id: ").concat(edge.id));
    return null;
  }
  if (!targetNode) {
    console.warn("couldn't create edge for target id: ".concat(edge.target, "; edge id: ").concat(edge.id));
    return null;
  }
  if (!sourceNode.__rf.width || !targetNode.__rf.width) {
    return null;
  }
  var edgeType = edge.type || "default";
  var EdgeComponent = props.edgeTypes[edgeType] || props.edgeTypes["default"];
  var targetNodeBounds = targetNode.__rf.handleBounds;
  var targetNodeHandles = connectionMode === ConnectionMode.Strict ? targetNodeBounds.target : targetNodeBounds.target || targetNodeBounds.source;
  var sourceHandle = getHandle(sourceNode.__rf.handleBounds.source, sourceHandleId);
  var targetHandle = getHandle(targetNodeHandles, targetHandleId);
  var sourcePosition = sourceHandle ? sourceHandle.position : Position.Bottom;
  var targetPosition = targetHandle ? targetHandle.position : Position.Top;
  if (!sourceHandle) {
    console.warn("couldn't create edge for source handle id: ".concat(sourceHandleId, "; edge id: ").concat(edge.id));
    return null;
  }
  if (!targetHandle) {
    console.warn("couldn't create edge for target handle id: ".concat(targetHandleId, "; edge id: ").concat(edge.id));
    return null;
  }
  var _getEdgePositions = getEdgePositions(sourceNode, sourceHandle, sourcePosition, targetNode, targetHandle, targetPosition), sourceX = _getEdgePositions.sourceX, sourceY = _getEdgePositions.sourceY, targetX = _getEdgePositions.targetX, targetY = _getEdgePositions.targetY;
  var isVisible = onlyRenderVisibleElements ? isEdgeVisible({
    sourcePos: {
      x: sourceX,
      y: sourceY
    },
    targetPos: {
      x: targetX,
      y: targetY
    },
    width: width2,
    height,
    transform: transform3
  }) : true;
  if (!isVisible) {
    return null;
  }
  var isSelected = (selectedElements === null || selectedElements === void 0 ? void 0 : selectedElements.some(function(elm) {
    return isEdge2(elm) && elm.id === edge.id;
  })) || false;
  return /* @__PURE__ */ react.createElement(EdgeComponent, {
    key: edge.id,
    id: edge.id,
    className: edge.className,
    type: edge.type,
    data: edge.data,
    onClick: props.onElementClick,
    selected: isSelected,
    animated: edge.animated,
    label: edge.label,
    labelStyle: edge.labelStyle,
    labelShowBg: edge.labelShowBg,
    labelBgStyle: edge.labelBgStyle,
    labelBgPadding: edge.labelBgPadding,
    labelBgBorderRadius: edge.labelBgBorderRadius,
    style: edge.style,
    arrowHeadType: edge.arrowHeadType,
    source: edge.source,
    target: edge.target,
    sourceHandleId,
    targetHandleId,
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourcePosition,
    targetPosition,
    elementsSelectable,
    markerEndId: props.markerEndId,
    isHidden: edge.isHidden,
    onConnectEdge,
    handleEdgeUpdate: typeof props.onEdgeUpdate !== "undefined",
    onContextMenu: props.onEdgeContextMenu,
    onMouseEnter: props.onEdgeMouseEnter,
    onMouseMove: props.onEdgeMouseMove,
    onMouseLeave: props.onEdgeMouseLeave,
    edgeUpdaterRadius: props.edgeUpdaterRadius,
    onEdgeDoubleClick: props.onEdgeDoubleClick,
    onEdgeUpdateStart: props.onEdgeUpdateStart,
    onEdgeUpdateEnd: props.onEdgeUpdateEnd
  });
};
var EdgeRenderer = function EdgeRenderer2(props) {
  var transform3 = useStoreState(function(state) {
    return state.transform;
  });
  var nodes = useStoreState(function(state) {
    return state.nodes;
  });
  var edges = useStoreState(function(state) {
    return state.edges;
  });
  var connectionNodeId = useStoreState(function(state) {
    return state.connectionNodeId;
  });
  var connectionHandleId = useStoreState(function(state) {
    return state.connectionHandleId;
  });
  var connectionHandleType = useStoreState(function(state) {
    return state.connectionHandleType;
  });
  var connectionPosition = useStoreState(function(state) {
    return state.connectionPosition;
  });
  var selectedElements = useStoreState(function(state) {
    return state.selectedElements;
  });
  var nodesConnectable = useStoreState(function(state) {
    return state.nodesConnectable;
  });
  var elementsSelectable = useStoreState(function(state) {
    return state.elementsSelectable;
  });
  var width2 = useStoreState(function(state) {
    return state.width;
  });
  var height = useStoreState(function(state) {
    return state.height;
  });
  if (!width2) {
    return null;
  }
  var connectionLineType = props.connectionLineType, arrowHeadColor = props.arrowHeadColor, connectionLineStyle = props.connectionLineStyle, connectionLineComponent = props.connectionLineComponent, onlyRenderVisibleElements = props.onlyRenderVisibleElements;
  var transformStyle = "translate(".concat(transform3[0], ",").concat(transform3[1], ") scale(").concat(transform3[2], ")");
  var renderConnectionLine = connectionNodeId && connectionHandleType;
  return /* @__PURE__ */ react.createElement("svg", {
    width: width2,
    height,
    className: "react-flow__edges"
  }, /* @__PURE__ */ react.createElement(MarkerDefinitions, {
    color: arrowHeadColor
  }), /* @__PURE__ */ react.createElement("g", {
    transform: transformStyle
  }, edges.map(function(edge) {
    return /* @__PURE__ */ react.createElement(Edge, {
      key: edge.id,
      edge,
      props,
      nodes,
      selectedElements,
      elementsSelectable,
      transform: transform3,
      width: width2,
      height,
      onlyRenderVisibleElements
    });
  }), renderConnectionLine && /* @__PURE__ */ react.createElement(ConnectionLine, {
    nodes,
    connectionNodeId,
    connectionHandleId,
    connectionHandleType,
    connectionPositionX: connectionPosition.x,
    connectionPositionY: connectionPosition.y,
    transform: transform3,
    connectionLineStyle,
    connectionLineType,
    isConnectable: nodesConnectable,
    CustomConnectionLineComponent: connectionLineComponent
  })));
};
EdgeRenderer.displayName = "EdgeRenderer";
var EdgeRenderer$1 = /* @__PURE__ */ react.memo(EdgeRenderer);
var DEFAULT_PADDING = 0.1;
var initialZoomPanHelper = {
  zoomIn: function zoomIn() {
  },
  zoomOut: function zoomOut() {
  },
  zoomTo: function zoomTo(_23) {
  },
  transform: function transform(_23) {
  },
  fitView: function fitView() {
  },
  setCenter: function setCenter(_23, __) {
  },
  fitBounds: function fitBounds(_23) {
  },
  project: function project(position2) {
    return position2;
  },
  initialized: false
};
var useZoomPanHelper = function useZoomPanHelper2() {
  var store2 = useStore();
  var d3Zoom = useStoreState(function(s2) {
    return s2.d3Zoom;
  });
  var d3Selection = useStoreState(function(s2) {
    return s2.d3Selection;
  });
  var zoomPanHelperFunctions = react.useMemo(function() {
    if (d3Selection && d3Zoom) {
      return {
        zoomIn: function zoomIn2() {
          return d3Zoom.scaleBy(d3Selection, 1.2);
        },
        zoomOut: function zoomOut2() {
          return d3Zoom.scaleBy(d3Selection, 1 / 1.2);
        },
        zoomTo: function zoomTo2(zoomLevel) {
          return d3Zoom.scaleTo(d3Selection, zoomLevel);
        },
        transform: function transform3(_transform) {
          var nextTransform = identity2.translate(_transform.x, _transform.y).scale(_transform.zoom);
          d3Zoom.transform(d3Selection, nextTransform);
        },
        fitView: function fitView2() {
          var _options$minZoom, _options$maxZoom, _options$padding;
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
            padding: DEFAULT_PADDING,
            includeHiddenNodes: false
          };
          var _store$getState = store2.getState(), nodes = _store$getState.nodes, width2 = _store$getState.width, height = _store$getState.height, minZoom = _store$getState.minZoom, maxZoom = _store$getState.maxZoom;
          if (!nodes.length) {
            return;
          }
          var bounds = getRectOfNodes(options.includeHiddenNodes ? nodes : nodes.filter(function(node) {
            return !node.isHidden;
          }));
          var _getTransformForBound = getTransformForBounds(bounds, width2, height, (_options$minZoom = options.minZoom) !== null && _options$minZoom !== void 0 ? _options$minZoom : minZoom, (_options$maxZoom = options.maxZoom) !== null && _options$maxZoom !== void 0 ? _options$maxZoom : maxZoom, (_options$padding = options.padding) !== null && _options$padding !== void 0 ? _options$padding : DEFAULT_PADDING), _getTransformForBound2 = _slicedToArray$1(_getTransformForBound, 3), x3 = _getTransformForBound2[0], y4 = _getTransformForBound2[1], zoom2 = _getTransformForBound2[2];
          var transform3 = identity2.translate(x3, y4).scale(zoom2);
          d3Zoom.transform(d3Selection, transform3);
        },
        setCenter: function setCenter2(x3, y4, zoom2) {
          var _store$getState2 = store2.getState(), width2 = _store$getState2.width, height = _store$getState2.height, maxZoom = _store$getState2.maxZoom;
          var nextZoom = typeof zoom2 !== "undefined" ? zoom2 : maxZoom;
          var centerX = width2 / 2 - x3 * nextZoom;
          var centerY = height / 2 - y4 * nextZoom;
          var transform3 = identity2.translate(centerX, centerY).scale(nextZoom);
          d3Zoom.transform(d3Selection, transform3);
        },
        fitBounds: function fitBounds2(bounds) {
          var padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_PADDING;
          var _store$getState3 = store2.getState(), width2 = _store$getState3.width, height = _store$getState3.height, minZoom = _store$getState3.minZoom, maxZoom = _store$getState3.maxZoom;
          var _getTransformForBound3 = getTransformForBounds(bounds, width2, height, minZoom, maxZoom, padding), _getTransformForBound4 = _slicedToArray$1(_getTransformForBound3, 3), x3 = _getTransformForBound4[0], y4 = _getTransformForBound4[1], zoom2 = _getTransformForBound4[2];
          var transform3 = identity2.translate(x3, y4).scale(zoom2);
          d3Zoom.transform(d3Selection, transform3);
        },
        project: function project2(position2) {
          var _store$getState4 = store2.getState(), transform3 = _store$getState4.transform, snapToGrid2 = _store$getState4.snapToGrid, snapGrid = _store$getState4.snapGrid;
          return pointToRendererPoint(position2, transform3, snapToGrid2, snapGrid);
        },
        initialized: true
      };
    }
    return initialZoomPanHelper;
  }, [d3Zoom, d3Selection]);
  return zoomPanHelperFunctions;
};
var GraphView = function GraphView2(_ref) {
  var nodeTypes = _ref.nodeTypes, edgeTypes = _ref.edgeTypes, onMove = _ref.onMove, onMoveStart = _ref.onMoveStart, onMoveEnd = _ref.onMoveEnd, onLoad = _ref.onLoad, onElementClick = _ref.onElementClick, onNodeDoubleClick = _ref.onNodeDoubleClick, onEdgeDoubleClick = _ref.onEdgeDoubleClick, onNodeMouseEnter = _ref.onNodeMouseEnter, onNodeMouseMove = _ref.onNodeMouseMove, onNodeMouseLeave = _ref.onNodeMouseLeave, onNodeContextMenu = _ref.onNodeContextMenu, onNodeDragStart = _ref.onNodeDragStart, onNodeDrag = _ref.onNodeDrag, onNodeDragStop = _ref.onNodeDragStop, onSelectionDragStart = _ref.onSelectionDragStart, onSelectionDrag = _ref.onSelectionDrag, onSelectionDragStop = _ref.onSelectionDragStop, onSelectionContextMenu = _ref.onSelectionContextMenu, connectionMode = _ref.connectionMode, connectionLineType = _ref.connectionLineType, connectionLineStyle = _ref.connectionLineStyle, connectionLineComponent = _ref.connectionLineComponent, selectionKeyCode = _ref.selectionKeyCode, multiSelectionKeyCode = _ref.multiSelectionKeyCode, zoomActivationKeyCode = _ref.zoomActivationKeyCode, onElementsRemove = _ref.onElementsRemove, deleteKeyCode = _ref.deleteKeyCode, onConnect = _ref.onConnect, onConnectStart = _ref.onConnectStart, onConnectStop = _ref.onConnectStop, onConnectEnd = _ref.onConnectEnd, snapToGrid2 = _ref.snapToGrid, snapGrid = _ref.snapGrid, onlyRenderVisibleElements = _ref.onlyRenderVisibleElements, nodesDraggable = _ref.nodesDraggable, nodesConnectable = _ref.nodesConnectable, elementsSelectable = _ref.elementsSelectable, selectNodesOnDrag = _ref.selectNodesOnDrag, minZoom = _ref.minZoom, maxZoom = _ref.maxZoom, defaultZoom = _ref.defaultZoom, defaultPosition = _ref.defaultPosition, translateExtent = _ref.translateExtent, preventScrolling = _ref.preventScrolling, nodeExtent = _ref.nodeExtent, arrowHeadColor = _ref.arrowHeadColor, markerEndId = _ref.markerEndId, zoomOnScroll = _ref.zoomOnScroll, zoomOnPinch = _ref.zoomOnPinch, panOnScroll = _ref.panOnScroll, panOnScrollSpeed = _ref.panOnScrollSpeed, panOnScrollMode = _ref.panOnScrollMode, zoomOnDoubleClick = _ref.zoomOnDoubleClick, paneMoveable = _ref.paneMoveable, onPaneClick = _ref.onPaneClick, onPaneScroll = _ref.onPaneScroll, onPaneContextMenu = _ref.onPaneContextMenu, onEdgeUpdate = _ref.onEdgeUpdate, onEdgeContextMenu = _ref.onEdgeContextMenu, onEdgeMouseEnter = _ref.onEdgeMouseEnter, onEdgeMouseMove = _ref.onEdgeMouseMove, onEdgeMouseLeave = _ref.onEdgeMouseLeave, edgeUpdaterRadius = _ref.edgeUpdaterRadius, onEdgeUpdateStart = _ref.onEdgeUpdateStart, onEdgeUpdateEnd = _ref.onEdgeUpdateEnd;
  var isInitialized = react.useRef(false);
  var setOnConnect3 = useStoreActions(function(actions2) {
    return actions2.setOnConnect;
  });
  var setOnConnectStart3 = useStoreActions(function(actions2) {
    return actions2.setOnConnectStart;
  });
  var setOnConnectStop3 = useStoreActions(function(actions2) {
    return actions2.setOnConnectStop;
  });
  var setOnConnectEnd3 = useStoreActions(function(actions2) {
    return actions2.setOnConnectEnd;
  });
  var setSnapGrid3 = useStoreActions(function(actions2) {
    return actions2.setSnapGrid;
  });
  var setSnapToGrid3 = useStoreActions(function(actions2) {
    return actions2.setSnapToGrid;
  });
  var setNodesDraggable3 = useStoreActions(function(actions2) {
    return actions2.setNodesDraggable;
  });
  var setNodesConnectable3 = useStoreActions(function(actions2) {
    return actions2.setNodesConnectable;
  });
  var setElementsSelectable3 = useStoreActions(function(actions2) {
    return actions2.setElementsSelectable;
  });
  var setMinZoom3 = useStoreActions(function(actions2) {
    return actions2.setMinZoom;
  });
  var setMaxZoom3 = useStoreActions(function(actions2) {
    return actions2.setMaxZoom;
  });
  var setTranslateExtent3 = useStoreActions(function(actions2) {
    return actions2.setTranslateExtent;
  });
  var setNodeExtent3 = useStoreActions(function(actions2) {
    return actions2.setNodeExtent;
  });
  var setConnectionMode3 = useStoreActions(function(actions2) {
    return actions2.setConnectionMode;
  });
  var currentStore = useStore();
  var _useZoomPanHelper = useZoomPanHelper(), zoomIn2 = _useZoomPanHelper.zoomIn, zoomOut2 = _useZoomPanHelper.zoomOut, zoomTo2 = _useZoomPanHelper.zoomTo, transform3 = _useZoomPanHelper.transform, _fitView = _useZoomPanHelper.fitView, initialized = _useZoomPanHelper.initialized;
  react.useEffect(function() {
    if (!isInitialized.current && initialized) {
      if (onLoad) {
        onLoad({
          fitView: function fitView2() {
            var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
              padding: 0.1
            };
            return _fitView(params);
          },
          zoomIn: zoomIn2,
          zoomOut: zoomOut2,
          zoomTo: zoomTo2,
          setTransform: transform3,
          project: onLoadProject(currentStore),
          getElements: onLoadGetElements(currentStore),
          toObject: onLoadToObject(currentStore)
        });
      }
      isInitialized.current = true;
    }
  }, [onLoad, zoomIn2, zoomOut2, zoomTo2, transform3, _fitView, initialized]);
  react.useEffect(function() {
    if (onConnect) {
      setOnConnect3(onConnect);
    }
  }, [onConnect]);
  react.useEffect(function() {
    if (onConnectStart) {
      setOnConnectStart3(onConnectStart);
    }
  }, [onConnectStart]);
  react.useEffect(function() {
    if (onConnectStop) {
      setOnConnectStop3(onConnectStop);
    }
  }, [onConnectStop]);
  react.useEffect(function() {
    if (onConnectEnd) {
      setOnConnectEnd3(onConnectEnd);
    }
  }, [onConnectEnd]);
  react.useEffect(function() {
    if (typeof snapToGrid2 !== "undefined") {
      setSnapToGrid3(snapToGrid2);
    }
  }, [snapToGrid2]);
  react.useEffect(function() {
    if (typeof snapGrid !== "undefined") {
      setSnapGrid3(snapGrid);
    }
  }, [snapGrid]);
  react.useEffect(function() {
    if (typeof nodesDraggable !== "undefined") {
      setNodesDraggable3(nodesDraggable);
    }
  }, [nodesDraggable]);
  react.useEffect(function() {
    if (typeof nodesConnectable !== "undefined") {
      setNodesConnectable3(nodesConnectable);
    }
  }, [nodesConnectable]);
  react.useEffect(function() {
    if (typeof elementsSelectable !== "undefined") {
      setElementsSelectable3(elementsSelectable);
    }
  }, [elementsSelectable]);
  react.useEffect(function() {
    if (typeof minZoom !== "undefined") {
      setMinZoom3(minZoom);
    }
  }, [minZoom]);
  react.useEffect(function() {
    if (typeof maxZoom !== "undefined") {
      setMaxZoom3(maxZoom);
    }
  }, [maxZoom]);
  react.useEffect(function() {
    if (typeof translateExtent !== "undefined") {
      setTranslateExtent3(translateExtent);
    }
  }, [translateExtent]);
  react.useEffect(function() {
    if (typeof nodeExtent !== "undefined") {
      setNodeExtent3(nodeExtent);
    }
  }, [nodeExtent]);
  react.useEffect(function() {
    if (typeof connectionMode !== "undefined") {
      setConnectionMode3(connectionMode);
    }
  }, [connectionMode]);
  return /* @__PURE__ */ react.createElement(FlowRenderer$1, {
    onPaneClick,
    onPaneContextMenu,
    onPaneScroll,
    onElementsRemove,
    deleteKeyCode,
    selectionKeyCode,
    multiSelectionKeyCode,
    zoomActivationKeyCode,
    elementsSelectable,
    onMove,
    onMoveStart,
    onMoveEnd,
    zoomOnScroll,
    zoomOnPinch,
    zoomOnDoubleClick,
    panOnScroll,
    panOnScrollSpeed,
    panOnScrollMode,
    paneMoveable,
    defaultPosition,
    defaultZoom,
    translateExtent,
    onSelectionDragStart,
    onSelectionDrag,
    onSelectionDragStop,
    onSelectionContextMenu,
    preventScrolling
  }, /* @__PURE__ */ react.createElement(NodeRenderer$1, {
    nodeTypes,
    onElementClick,
    onNodeDoubleClick,
    onNodeMouseEnter,
    onNodeMouseMove,
    onNodeMouseLeave,
    onNodeContextMenu,
    onNodeDragStop,
    onNodeDrag,
    onNodeDragStart,
    selectNodesOnDrag,
    snapToGrid: snapToGrid2,
    snapGrid,
    onlyRenderVisibleElements
  }), /* @__PURE__ */ react.createElement(EdgeRenderer$1, {
    edgeTypes,
    onElementClick,
    onEdgeDoubleClick,
    connectionLineType,
    connectionLineStyle,
    connectionLineComponent,
    connectionMode,
    arrowHeadColor,
    markerEndId,
    onEdgeUpdate,
    onlyRenderVisibleElements,
    onEdgeContextMenu,
    onEdgeMouseEnter,
    onEdgeMouseMove,
    onEdgeMouseLeave,
    onEdgeUpdateStart,
    onEdgeUpdateEnd,
    edgeUpdaterRadius
  }));
};
GraphView.displayName = "GraphView";
var GraphView$1 = /* @__PURE__ */ react.memo(GraphView);
var ElementUpdater = function ElementUpdater2(_ref) {
  var elements = _ref.elements;
  var setElements3 = useStoreActions(function(actions2) {
    return actions2.setElements;
  });
  react.useEffect(function() {
    setElements3(elements);
  }, [elements]);
  return null;
};
var NodeIdContext = /* @__PURE__ */ react.createContext(null);
var Provider2 = NodeIdContext.Provider;
NodeIdContext.Consumer;
var _excluded$2 = ["type", "position", "isValidConnection", "isConnectable", "id", "onConnect", "children", "className"];
function ownKeys$7(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$7(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys$7(Object(source2), true).forEach(function(key) {
        _defineProperty$2(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys$7(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
var alwaysValid = function alwaysValid2() {
  return true;
};
var Handle = function Handle2(_ref) {
  var _ref$type = _ref.type, type = _ref$type === void 0 ? "source" : _ref$type, _ref$position = _ref.position, position2 = _ref$position === void 0 ? Position.Top : _ref$position, _ref$isValidConnectio = _ref.isValidConnection, isValidConnection = _ref$isValidConnectio === void 0 ? alwaysValid : _ref$isValidConnectio, _ref$isConnectable = _ref.isConnectable, isConnectable = _ref$isConnectable === void 0 ? true : _ref$isConnectable, id3 = _ref.id, onConnect = _ref.onConnect, children2 = _ref.children, className = _ref.className, rest = _objectWithoutProperties3(_ref, _excluded$2);
  var nodeId = react.useContext(NodeIdContext);
  var setPosition = useStoreActions(function(actions2) {
    return actions2.setConnectionPosition;
  });
  var setConnectionNodeId3 = useStoreActions(function(actions2) {
    return actions2.setConnectionNodeId;
  });
  var onConnectAction = useStoreState(function(state) {
    return state.onConnect;
  });
  var onConnectStart = useStoreState(function(state) {
    return state.onConnectStart;
  });
  var onConnectStop = useStoreState(function(state) {
    return state.onConnectStop;
  });
  var onConnectEnd = useStoreState(function(state) {
    return state.onConnectEnd;
  });
  var connectionMode = useStoreState(function(state) {
    return state.connectionMode;
  });
  var handleId = id3 || null;
  var isTarget = type === "target";
  var onConnectExtended = react.useCallback(function(params) {
    onConnectAction === null || onConnectAction === void 0 ? void 0 : onConnectAction(params);
    onConnect === null || onConnect === void 0 ? void 0 : onConnect(params);
  }, [onConnectAction, onConnect]);
  var onMouseDownHandler = react.useCallback(function(event) {
    onMouseDown2(event, handleId, nodeId, setConnectionNodeId3, setPosition, onConnectExtended, isTarget, isValidConnection, connectionMode, void 0, void 0, onConnectStart, onConnectStop, onConnectEnd);
  }, [handleId, nodeId, setConnectionNodeId3, setPosition, onConnectExtended, isTarget, isValidConnection, connectionMode, onConnectStart, onConnectStop, onConnectEnd]);
  var handleClasses = cc2(["react-flow__handle", "react-flow__handle-".concat(position2), "nodrag", className, {
    source: !isTarget,
    target: isTarget,
    connectable: isConnectable
  }]);
  return /* @__PURE__ */ react.createElement("div", _objectSpread$7({
    "data-handleid": handleId,
    "data-nodeid": nodeId,
    "data-handlepos": position2,
    className: handleClasses,
    onMouseDown: onMouseDownHandler
  }, rest), children2);
};
Handle.displayName = "Handle";
var Handle$1 = /* @__PURE__ */ react.memo(Handle);
var DefaultNode = function DefaultNode2(_ref) {
  var data = _ref.data, isConnectable = _ref.isConnectable, _ref$targetPosition = _ref.targetPosition, targetPosition = _ref$targetPosition === void 0 ? Position.Top : _ref$targetPosition, _ref$sourcePosition = _ref.sourcePosition, sourcePosition = _ref$sourcePosition === void 0 ? Position.Bottom : _ref$sourcePosition;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Handle$1, {
    type: "target",
    position: targetPosition,
    isConnectable
  }), data.label, /* @__PURE__ */ react.createElement(Handle$1, {
    type: "source",
    position: sourcePosition,
    isConnectable
  }));
};
DefaultNode.displayName = "DefaultNode";
var DefaultNode$1 = /* @__PURE__ */ react.memo(DefaultNode);
var InputNode = function InputNode2(_ref) {
  var data = _ref.data, isConnectable = _ref.isConnectable, _ref$sourcePosition = _ref.sourcePosition, sourcePosition = _ref$sourcePosition === void 0 ? Position.Bottom : _ref$sourcePosition;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, data.label, /* @__PURE__ */ react.createElement(Handle$1, {
    type: "source",
    position: sourcePosition,
    isConnectable
  }));
};
InputNode.displayName = "InputNode";
var InputNode$1 = /* @__PURE__ */ react.memo(InputNode);
var OutputNode = function OutputNode2(_ref) {
  var data = _ref.data, isConnectable = _ref.isConnectable, _ref$targetPosition = _ref.targetPosition, targetPosition = _ref$targetPosition === void 0 ? Position.Top : _ref$targetPosition;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Handle$1, {
    type: "target",
    position: targetPosition,
    isConnectable
  }), data.label);
};
OutputNode.displayName = "OutputNode";
var OutputNode$1 = /* @__PURE__ */ react.memo(OutputNode);
function ownKeys$6(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$6(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys$6(Object(source2), true).forEach(function(key) {
        _defineProperty$2(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys$6(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
var wrapNode = function(NodeComponent) {
  var NodeWrapper = function NodeWrapper2(_ref) {
    var id3 = _ref.id, type = _ref.type, data = _ref.data, scale = _ref.scale, xPos = _ref.xPos, yPos = _ref.yPos, selected = _ref.selected, onClick = _ref.onClick, onMouseEnter = _ref.onMouseEnter, onMouseMove = _ref.onMouseMove, onMouseLeave = _ref.onMouseLeave, onContextMenu = _ref.onContextMenu, onNodeDoubleClick = _ref.onNodeDoubleClick, onNodeDragStart = _ref.onNodeDragStart, onNodeDrag = _ref.onNodeDrag, onNodeDragStop = _ref.onNodeDragStop, style = _ref.style, className = _ref.className, isDraggable = _ref.isDraggable, isSelectable = _ref.isSelectable, isConnectable = _ref.isConnectable, selectNodesOnDrag = _ref.selectNodesOnDrag, sourcePosition = _ref.sourcePosition, targetPosition = _ref.targetPosition, isHidden3 = _ref.isHidden, isInitialized = _ref.isInitialized, snapToGrid2 = _ref.snapToGrid, snapGrid = _ref.snapGrid, isDragging = _ref.isDragging, resizeObserver = _ref.resizeObserver;
    var updateNodeDimensions3 = useStoreActions(function(actions2) {
      return actions2.updateNodeDimensions;
    });
    var addSelectedElements3 = useStoreActions(function(actions2) {
      return actions2.addSelectedElements;
    });
    var updateNodePosDiff3 = useStoreActions(function(actions2) {
      return actions2.updateNodePosDiff;
    });
    var unsetNodesSelection3 = useStoreActions(function(actions2) {
      return actions2.unsetNodesSelection;
    });
    var nodeElement = react.useRef(null);
    var node = react.useMemo(function() {
      return {
        id: id3,
        type,
        position: {
          x: xPos,
          y: yPos
        },
        data
      };
    }, [id3, type, xPos, yPos, data]);
    var grid2 = react.useMemo(function() {
      return snapToGrid2 ? snapGrid : [1, 1];
    }, [snapToGrid2, snapGrid]);
    var nodeStyle = react.useMemo(function() {
      return _objectSpread$6({
        zIndex: selected ? 10 : 3,
        transform: "translate(".concat(xPos, "px,").concat(yPos, "px)"),
        pointerEvents: isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave ? "all" : "none",
        opacity: isInitialized ? 1 : 0
      }, style);
    }, [selected, xPos, yPos, isSelectable, isDraggable, onClick, isInitialized, style, onMouseEnter, onMouseMove, onMouseLeave]);
    var onMouseEnterHandler = react.useMemo(function() {
      if (!onMouseEnter || isDragging) {
        return;
      }
      return function(event) {
        return onMouseEnter(event, node);
      };
    }, [onMouseEnter, isDragging, node]);
    var onMouseMoveHandler = react.useMemo(function() {
      if (!onMouseMove || isDragging) {
        return;
      }
      return function(event) {
        return onMouseMove(event, node);
      };
    }, [onMouseMove, isDragging, node]);
    var onMouseLeaveHandler = react.useMemo(function() {
      if (!onMouseLeave || isDragging) {
        return;
      }
      return function(event) {
        return onMouseLeave(event, node);
      };
    }, [onMouseLeave, isDragging, node]);
    var onContextMenuHandler = react.useMemo(function() {
      if (!onContextMenu) {
        return;
      }
      return function(event) {
        return onContextMenu(event, node);
      };
    }, [onContextMenu, node]);
    var onSelectNodeHandler = react.useCallback(function(event) {
      if (!isDraggable) {
        if (isSelectable) {
          unsetNodesSelection3();
          if (!selected) {
            addSelectedElements3(node);
          }
        }
        onClick === null || onClick === void 0 ? void 0 : onClick(event, node);
      }
    }, [isSelectable, selected, isDraggable, onClick, node]);
    var onDragStart = react.useCallback(function(event) {
      onNodeDragStart === null || onNodeDragStart === void 0 ? void 0 : onNodeDragStart(event, node);
      if (selectNodesOnDrag && isSelectable) {
        unsetNodesSelection3();
        if (!selected) {
          addSelectedElements3(node);
        }
      } else if (!selectNodesOnDrag && !selected && isSelectable) {
        unsetNodesSelection3();
        addSelectedElements3([]);
      }
    }, [node, selected, selectNodesOnDrag, isSelectable, onNodeDragStart]);
    var onDrag2 = react.useCallback(function(event, draggableData) {
      if (onNodeDrag) {
        node.position.x += draggableData.deltaX;
        node.position.y += draggableData.deltaY;
        onNodeDrag(event, node);
      }
      updateNodePosDiff3({
        id: id3,
        diff: {
          x: draggableData.deltaX,
          y: draggableData.deltaY
        },
        isDragging: true
      });
    }, [id3, node, onNodeDrag]);
    var onDragStop = react.useCallback(function(event) {
      if (!isDragging) {
        if (isSelectable && !selectNodesOnDrag && !selected) {
          addSelectedElements3(node);
        }
        onClick === null || onClick === void 0 ? void 0 : onClick(event, node);
        return;
      }
      updateNodePosDiff3({
        id: node.id,
        isDragging: false
      });
      onNodeDragStop === null || onNodeDragStop === void 0 ? void 0 : onNodeDragStop(event, node);
    }, [node, isSelectable, selectNodesOnDrag, onClick, onNodeDragStop, isDragging, selected]);
    var onNodeDoubleClickHandler = react.useCallback(function(event) {
      onNodeDoubleClick === null || onNodeDoubleClick === void 0 ? void 0 : onNodeDoubleClick(event, node);
    }, [node, onNodeDoubleClick]);
    react.useLayoutEffect(function() {
      if (nodeElement.current && !isHidden3) {
        updateNodeDimensions3([{
          id: id3,
          nodeElement: nodeElement.current,
          forceUpdate: true
        }]);
      }
    }, [id3, isHidden3, sourcePosition, targetPosition]);
    react.useEffect(function() {
      if (nodeElement.current) {
        var currNode = nodeElement.current;
        resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.observe(currNode);
        return function() {
          return resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.unobserve(currNode);
        };
      }
    }, []);
    if (isHidden3) {
      return null;
    }
    var nodeClasses = cc2(["react-flow__node", "react-flow__node-".concat(type), className, {
      selected,
      selectable: isSelectable
    }]);
    return /* @__PURE__ */ react.createElement(DraggableCore_1, {
      onStart: onDragStart,
      onDrag: onDrag2,
      onStop: onDragStop,
      scale,
      disabled: !isDraggable,
      cancel: ".nodrag",
      nodeRef: nodeElement,
      grid: grid2,
      enableUserSelectHack: false
    }, /* @__PURE__ */ react.createElement("div", {
      className: nodeClasses,
      ref: nodeElement,
      style: nodeStyle,
      onMouseEnter: onMouseEnterHandler,
      onMouseMove: onMouseMoveHandler,
      onMouseLeave: onMouseLeaveHandler,
      onContextMenu: onContextMenuHandler,
      onClick: onSelectNodeHandler,
      onDoubleClick: onNodeDoubleClickHandler,
      "data-id": id3
    }, /* @__PURE__ */ react.createElement(Provider2, {
      value: id3
    }, /* @__PURE__ */ react.createElement(NodeComponent, {
      id: id3,
      data,
      type,
      xPos,
      yPos,
      selected,
      isConnectable,
      sourcePosition,
      targetPosition,
      isDragging
    }))));
  };
  NodeWrapper.displayName = "NodeWrapper";
  return /* @__PURE__ */ react.memo(NodeWrapper);
};
function ownKeys$5(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$5(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys$5(Object(source2), true).forEach(function(key) {
        _defineProperty$2(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys$5(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
function createNodeTypes(nodeTypes) {
  var standardTypes = {
    input: wrapNode(nodeTypes.input || InputNode$1),
    default: wrapNode(nodeTypes["default"] || DefaultNode$1),
    output: wrapNode(nodeTypes.output || OutputNode$1)
  };
  var wrappedTypes = {};
  var specialTypes = Object.keys(nodeTypes).filter(function(k3) {
    return !["input", "default", "output"].includes(k3);
  }).reduce(function(res, key) {
    res[key] = wrapNode(nodeTypes[key] || DefaultNode$1);
    return res;
  }, wrappedTypes);
  return _objectSpread$5(_objectSpread$5({}, standardTypes), specialTypes);
}
var SelectionListener = function(_ref) {
  var onSelectionChange = _ref.onSelectionChange;
  var selectedElements = useStoreState(function(s2) {
    return s2.selectedElements;
  });
  react.useEffect(function() {
    onSelectionChange(selectedElements);
  }, [selectedElements]);
  return null;
};
var fastDeepEqual = function equal(a2, b3) {
  if (a2 === b3)
    return true;
  if (a2 && b3 && typeof a2 == "object" && typeof b3 == "object") {
    if (a2.constructor !== b3.constructor)
      return false;
    var length, i3, keys2;
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length != b3.length)
        return false;
      for (i3 = length; i3-- !== 0; )
        if (!equal(a2[i3], b3[i3]))
          return false;
      return true;
    }
    if (a2.constructor === RegExp)
      return a2.source === b3.source && a2.flags === b3.flags;
    if (a2.valueOf !== Object.prototype.valueOf)
      return a2.valueOf() === b3.valueOf();
    if (a2.toString !== Object.prototype.toString)
      return a2.toString() === b3.toString();
    keys2 = Object.keys(a2);
    length = keys2.length;
    if (length !== Object.keys(b3).length)
      return false;
    for (i3 = length; i3-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b3, keys2[i3]))
        return false;
    for (i3 = length; i3-- !== 0; ) {
      var key = keys2[i3];
      if (!equal(a2[key], b3[key]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b3 !== b3;
};
function ownKeys$4(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$4(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys$4(Object(source2), true).forEach(function(key) {
        _defineProperty$2(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys$4(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
var getHandleBounds = function getHandleBounds2(nodeElement, scale) {
  var bounds = nodeElement.getBoundingClientRect();
  return {
    source: getHandleBoundsByHandleType(".source", nodeElement, bounds, scale),
    target: getHandleBoundsByHandleType(".target", nodeElement, bounds, scale)
  };
};
var getHandleBoundsByHandleType = function getHandleBoundsByHandleType2(selector2, nodeElement, parentBounds, k3) {
  var handles = nodeElement.querySelectorAll(selector2);
  if (!handles || !handles.length) {
    return null;
  }
  var handlesArray = Array.from(handles);
  return handlesArray.map(function(handle2) {
    var bounds = handle2.getBoundingClientRect();
    var dimensions = getDimensions(handle2);
    var handleId = handle2.getAttribute("data-handleid");
    var handlePosition = handle2.getAttribute("data-handlepos");
    return _objectSpread$4({
      id: handleId,
      position: handlePosition,
      x: (bounds.left - parentBounds.left) / k3,
      y: (bounds.top - parentBounds.top) / k3
    }, dimensions);
  });
};
function ownKeys$3(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$3(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys$3(Object(source2), true).forEach(function(key) {
        _defineProperty$2(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys$3(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
function reactFlowReducer() {
  var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : initialState2;
  var action = arguments.length > 1 ? arguments[1] : void 0;
  switch (action.type) {
    case SET_ELEMENTS: {
      var propElements = action.payload;
      var nextElements = {
        nextNodes: [],
        nextEdges: []
      };
      var _propElements$reduce = propElements.reduce(function(res, propElement) {
        if (isNode(propElement)) {
          var storeNode = state.nodes.find(function(node) {
            return node.id === propElement.id;
          });
          if (storeNode) {
            var updatedNode = _objectSpread$3(_objectSpread$3({}, storeNode), propElement);
            if (storeNode.position.x !== propElement.position.x || storeNode.position.y !== propElement.position.y) {
              updatedNode.__rf.position = propElement.position;
            }
            if (typeof propElement.type !== "undefined" && propElement.type !== storeNode.type) {
              updatedNode.__rf.width = null;
            }
            res.nextNodes.push(updatedNode);
          } else {
            res.nextNodes.push(parseNode(propElement, state.nodeExtent));
          }
        } else if (isEdge2(propElement)) {
          var storeEdge = state.edges.find(function(se2) {
            return se2.id === propElement.id;
          });
          if (storeEdge) {
            res.nextEdges.push(_objectSpread$3(_objectSpread$3({}, storeEdge), propElement));
          } else {
            res.nextEdges.push(parseEdge(propElement));
          }
        }
        return res;
      }, nextElements), nextNodes = _propElements$reduce.nextNodes, nextEdges = _propElements$reduce.nextEdges;
      return _objectSpread$3(_objectSpread$3({}, state), {}, {
        nodes: nextNodes,
        edges: nextEdges
      });
    }
    case UPDATE_NODE_DIMENSIONS: {
      var updatedNodes = state.nodes.map(function(node) {
        var update = action.payload.find(function(u) {
          return u.id === node.id;
        });
        if (update) {
          var dimensions = getDimensions(update.nodeElement);
          var doUpdate = dimensions.width && dimensions.height && (node.__rf.width !== dimensions.width || node.__rf.height !== dimensions.height || update.forceUpdate);
          if (doUpdate) {
            var handleBounds = getHandleBounds(update.nodeElement, state.transform[2]);
            return _objectSpread$3(_objectSpread$3({}, node), {}, {
              __rf: _objectSpread$3(_objectSpread$3(_objectSpread$3({}, node.__rf), dimensions), {}, {
                handleBounds
              })
            });
          }
        }
        return node;
      });
      return _objectSpread$3(_objectSpread$3({}, state), {}, {
        nodes: updatedNodes
      });
    }
    case UPDATE_NODE_POS: {
      var _action$payload = action.payload, id3 = _action$payload.id, pos = _action$payload.pos;
      var position2 = pos;
      if (state.snapToGrid) {
        var _state$snapGrid = _slicedToArray$1(state.snapGrid, 2), gridSizeX = _state$snapGrid[0], gridSizeY = _state$snapGrid[1];
        position2 = {
          x: gridSizeX * Math.round(pos.x / gridSizeX),
          y: gridSizeY * Math.round(pos.y / gridSizeY)
        };
      }
      var _nextNodes = state.nodes.map(function(node) {
        if (node.id === id3) {
          return _objectSpread$3(_objectSpread$3({}, node), {}, {
            __rf: _objectSpread$3(_objectSpread$3({}, node.__rf), {}, {
              position: position2
            })
          });
        }
        return node;
      });
      return _objectSpread$3(_objectSpread$3({}, state), {}, {
        nodes: _nextNodes
      });
    }
    case UPDATE_NODE_POS_DIFF: {
      var _action$payload2 = action.payload, _id = _action$payload2.id, diff = _action$payload2.diff, isDragging = _action$payload2.isDragging;
      var _nextNodes2 = state.nodes.map(function(node) {
        var _state$selectedElemen;
        if (_id === node.id || (_state$selectedElemen = state.selectedElements) !== null && _state$selectedElemen !== void 0 && _state$selectedElemen.find(function(sNode) {
          return sNode.id === node.id;
        })) {
          var updatedNode = _objectSpread$3(_objectSpread$3({}, node), {}, {
            __rf: _objectSpread$3(_objectSpread$3({}, node.__rf), {}, {
              isDragging
            })
          });
          if (diff) {
            updatedNode.__rf.position = {
              x: node.__rf.position.x + diff.x,
              y: node.__rf.position.y + diff.y
            };
          }
          return updatedNode;
        }
        return node;
      });
      return _objectSpread$3(_objectSpread$3({}, state), {}, {
        nodes: _nextNodes2
      });
    }
    case SET_USER_SELECTION: {
      var mousePos = action.payload;
      return _objectSpread$3(_objectSpread$3({}, state), {}, {
        selectionActive: true,
        userSelectionRect: {
          width: 0,
          height: 0,
          startX: mousePos.x,
          startY: mousePos.y,
          x: mousePos.x,
          y: mousePos.y,
          draw: true
        }
      });
    }
    case UPDATE_USER_SELECTION: {
      var _state$userSelectionR, _state$userSelectionR2;
      var _mousePos = action.payload;
      var startX = (_state$userSelectionR = state.userSelectionRect.startX) !== null && _state$userSelectionR !== void 0 ? _state$userSelectionR : 0;
      var startY = (_state$userSelectionR2 = state.userSelectionRect.startY) !== null && _state$userSelectionR2 !== void 0 ? _state$userSelectionR2 : 0;
      var nextUserSelectRect = _objectSpread$3(_objectSpread$3({}, state.userSelectionRect), {}, {
        x: _mousePos.x < startX ? _mousePos.x : state.userSelectionRect.x,
        y: _mousePos.y < startY ? _mousePos.y : state.userSelectionRect.y,
        width: Math.abs(_mousePos.x - startX),
        height: Math.abs(_mousePos.y - startY)
      });
      var selectedNodes = getNodesInside(state.nodes, nextUserSelectRect, state.transform, false, true);
      var selectedEdges = getConnectedEdges(selectedNodes, state.edges);
      var nextSelectedElements = [].concat(_toConsumableArray2(selectedNodes), _toConsumableArray2(selectedEdges));
      var selectedElementsChanged = !fastDeepEqual(nextSelectedElements, state.selectedElements);
      var selectedElementsUpdate = selectedElementsChanged ? {
        selectedElements: nextSelectedElements.length > 0 ? nextSelectedElements : null
      } : {};
      return _objectSpread$3(_objectSpread$3(_objectSpread$3({}, state), selectedElementsUpdate), {}, {
        userSelectionRect: nextUserSelectRect
      });
    }
    case UNSET_USER_SELECTION: {
      var _state$selectedElemen2;
      var _selectedNodes = (_state$selectedElemen2 = state.selectedElements) === null || _state$selectedElemen2 === void 0 ? void 0 : _state$selectedElemen2.filter(function(node) {
        return isNode(node) && node.__rf;
      });
      var stateUpdate = _objectSpread$3(_objectSpread$3({}, state), {}, {
        selectionActive: false,
        userSelectionRect: _objectSpread$3(_objectSpread$3({}, state.userSelectionRect), {}, {
          draw: false
        })
      });
      if (!_selectedNodes || _selectedNodes.length === 0) {
        stateUpdate.selectedElements = null;
        stateUpdate.nodesSelectionActive = false;
      } else {
        var selectedNodesBbox = getRectOfNodes(_selectedNodes);
        stateUpdate.selectedNodesBbox = selectedNodesBbox;
        stateUpdate.nodesSelectionActive = true;
      }
      return stateUpdate;
    }
    case SET_SELECTED_ELEMENTS: {
      var elements = action.payload;
      var selectedElementsArr = Array.isArray(elements) ? elements : [elements];
      var selectedElementsUpdated = !fastDeepEqual(selectedElementsArr, state.selectedElements);
      var selectedElements = selectedElementsUpdated ? selectedElementsArr : state.selectedElements;
      return _objectSpread$3(_objectSpread$3({}, state), {}, {
        selectedElements
      });
    }
    case ADD_SELECTED_ELEMENTS: {
      var multiSelectionActive = state.multiSelectionActive, _selectedElements = state.selectedElements;
      var _elements = action.payload;
      var _selectedElementsArr = Array.isArray(_elements) ? _elements : [_elements];
      var _nextElements = _selectedElementsArr;
      if (multiSelectionActive) {
        _nextElements = _selectedElements ? [].concat(_toConsumableArray2(_selectedElements), _toConsumableArray2(_selectedElementsArr)) : _selectedElementsArr;
      }
      var _selectedElementsUpdated = !fastDeepEqual(_nextElements, state.selectedElements);
      var _nextSelectedElements = _selectedElementsUpdated ? _nextElements : state.selectedElements;
      return _objectSpread$3(_objectSpread$3({}, state), {}, {
        selectedElements: _nextSelectedElements
      });
    }
    case INIT_D3ZOOM: {
      var _action$payload3 = action.payload, d3Zoom = _action$payload3.d3Zoom, d3Selection = _action$payload3.d3Selection, d3ZoomHandler = _action$payload3.d3ZoomHandler, transform3 = _action$payload3.transform;
      return _objectSpread$3(_objectSpread$3({}, state), {}, {
        d3Zoom,
        d3Selection,
        d3ZoomHandler,
        transform: transform3
      });
    }
    case SET_MINZOOM: {
      var _state$d3Zoom;
      var minZoom = action.payload;
      (_state$d3Zoom = state.d3Zoom) === null || _state$d3Zoom === void 0 ? void 0 : _state$d3Zoom.scaleExtent([minZoom, state.maxZoom]);
      return _objectSpread$3(_objectSpread$3({}, state), {}, {
        minZoom
      });
    }
    case SET_MAXZOOM: {
      var _state$d3Zoom2;
      var maxZoom = action.payload;
      (_state$d3Zoom2 = state.d3Zoom) === null || _state$d3Zoom2 === void 0 ? void 0 : _state$d3Zoom2.scaleExtent([state.minZoom, maxZoom]);
      return _objectSpread$3(_objectSpread$3({}, state), {}, {
        maxZoom
      });
    }
    case SET_TRANSLATEEXTENT: {
      var _state$d3Zoom3;
      var translateExtent = action.payload;
      (_state$d3Zoom3 = state.d3Zoom) === null || _state$d3Zoom3 === void 0 ? void 0 : _state$d3Zoom3.translateExtent(translateExtent);
      return _objectSpread$3(_objectSpread$3({}, state), {}, {
        translateExtent
      });
    }
    case SET_NODE_EXTENT: {
      var nodeExtent = action.payload;
      return _objectSpread$3(_objectSpread$3({}, state), {}, {
        nodeExtent,
        nodes: state.nodes.map(function(node) {
          return _objectSpread$3(_objectSpread$3({}, node), {}, {
            __rf: _objectSpread$3(_objectSpread$3({}, node.__rf), {}, {
              position: clampPosition(node.__rf.position, nodeExtent)
            })
          });
        })
      });
    }
    case SET_ON_CONNECT:
    case SET_ON_CONNECT_START:
    case SET_ON_CONNECT_STOP:
    case SET_ON_CONNECT_END:
    case RESET_SELECTED_ELEMENTS:
    case UNSET_NODES_SELECTION:
    case UPDATE_TRANSFORM:
    case UPDATE_SIZE:
    case SET_CONNECTION_POSITION:
    case SET_CONNECTION_NODEID:
    case SET_SNAPTOGRID:
    case SET_SNAPGRID:
    case SET_INTERACTIVE:
    case SET_NODES_DRAGGABLE:
    case SET_NODES_CONNECTABLE:
    case SET_ELEMENTS_SELECTABLE:
    case SET_MULTI_SELECTION_ACTIVE:
    case SET_CONNECTION_MODE:
      return _objectSpread$3(_objectSpread$3({}, state), action.payload);
    default:
      return state;
  }
}
function configureStore(preloadedState) {
  var store2 = createStore(reactFlowReducer, preloadedState);
  return store2;
}
var initialState2 = {
  width: 0,
  height: 0,
  transform: [0, 0, 1],
  nodes: [],
  edges: [],
  selectedElements: null,
  selectedNodesBbox: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  d3Zoom: null,
  d3Selection: null,
  d3ZoomHandler: void 0,
  minZoom: 0.5,
  maxZoom: 2,
  translateExtent: [[Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY], [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]],
  nodeExtent: [[Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY], [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]],
  nodesSelectionActive: false,
  selectionActive: false,
  userSelectionRect: {
    startX: 0,
    startY: 0,
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    draw: false
  },
  connectionNodeId: null,
  connectionHandleId: null,
  connectionHandleType: "source",
  connectionPosition: {
    x: 0,
    y: 0
  },
  connectionMode: ConnectionMode.Strict,
  snapGrid: [15, 15],
  snapToGrid: false,
  nodesDraggable: true,
  nodesConnectable: true,
  elementsSelectable: true,
  multiSelectionActive: false,
  reactFlowVersion: "9.6.6"
};
var store = configureStore(initialState2);
var Wrapper = function Wrapper2(_ref) {
  var children2 = _ref.children;
  var contextValue = react.useContext(ReactReduxContext);
  var isWrappedWithReactFlowProvider = react.useMemo(function() {
    var _contextValue$store, _contextValue$store$g;
    return contextValue === null || contextValue === void 0 ? void 0 : (_contextValue$store = contextValue.store) === null || _contextValue$store === void 0 ? void 0 : (_contextValue$store$g = _contextValue$store.getState()) === null || _contextValue$store$g === void 0 ? void 0 : _contextValue$store$g.reactFlowVersion;
  }, [contextValue]);
  if (isWrappedWithReactFlowProvider) {
    return /* @__PURE__ */ react.createElement(react.Fragment, null, children2);
  }
  return /* @__PURE__ */ react.createElement(Provider$1, {
    store
  }, children2);
};
Wrapper.displayName = "ReactFlowWrapper";
function styleInject(css2, ref) {
  if (ref === void 0)
    ref = {};
  var insertAt = ref.insertAt;
  if (!css2 || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css2;
  } else {
    style.appendChild(document.createTextNode(css2));
  }
}
var css_248z$1 = ".react-flow{width:100%;height:100%;position:relative;overflow:hidden}.react-flow__pane,.react-flow__renderer,.react-flow__selectionpane{width:100%;height:100%;position:absolute;top:0;left:0}.react-flow__pane{z-index:1}.react-flow__renderer{z-index:4}.react-flow__selectionpane{z-index:5}.react-flow__edges,.react-flow__selection{position:absolute;top:0;left:0}.react-flow__edges{pointer-events:none;z-index:2}.react-flow__edge{pointer-events:visibleStroke;}.react-flow__edge.inactive{pointer-events:none}@-webkit-keyframes dashdraw{0%{stroke-dashoffset:10}}@keyframes dashdraw{0%{stroke-dashoffset:10}}.react-flow__edge-path{fill:none}.react-flow__edge-textwrapper{pointer-events:all}.react-flow__edge-text{pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.react-flow__connection{pointer-events:none;}.react-flow__connection .animated{stroke-dasharray:5;-webkit-animation:dashdraw .5s linear infinite;animation:dashdraw .5s linear infinite}.react-flow__connection-path{fill:none}.react-flow__nodes{width:100%;height:100%;pointer-events:none;z-index:3}.react-flow__node,.react-flow__nodes{position:absolute;transform-origin:0 0}.react-flow__node{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:all}.react-flow__nodesselection{z-index:3;position:absolute;width:100%;height:100%;top:0;left:0;transform-origin:left top;pointer-events:none;}.react-flow__nodesselection-rect{position:absolute;pointer-events:all;cursor:-webkit-grab;cursor:grab}.react-flow__handle{pointer-events:none;}.react-flow__handle.connectable{pointer-events:all}.react-flow__handle-bottom{top:auto;left:50%;bottom:-4px;transform:translate(-50%)}.react-flow__handle-top{left:50%;top:-4px;transform:translate(-50%)}.react-flow__handle-left{top:50%;left:-4px;transform:translateY(-50%)}.react-flow__handle-right{right:-4px;top:50%;transform:translateY(-50%)}.react-flow__edgeupdater{cursor:move;pointer-events:all}.react-flow__background{position:absolute;top:0;left:0;width:100%;height:100%}.react-flow__controls{position:absolute;z-index:5;bottom:10px;left:10px;}.react-flow__controls-button{width:24px;height:24px;border:none;}.react-flow__controls-button svg{width:100%}.react-flow__minimap{position:absolute;z-index:5;bottom:10px;right:10px}";
styleInject(css_248z$1);
var css_248z = ".react-flow__selection{background:rgba(0,89,220,.08);border:1px dotted rgba(0,89,220,.8)}.react-flow__edge.selected .react-flow__edge-path{stroke:#555}.react-flow__edge.animated path{stroke-dasharray:5;-webkit-animation:dashdraw .5s linear infinite;animation:dashdraw .5s linear infinite}.react-flow__edge.updating .react-flow__edge-path{stroke:#777}.react-flow__edge-path{stroke:#b1b1b7;stroke-width:1}.react-flow__edge-text{font-size:10px}.react-flow__edge-textbg{fill:#fff}.react-flow__connection-path{stroke:#b1b1b7;stroke-width:1}.react-flow__node{cursor:-webkit-grab;cursor:grab}.react-flow__node-default,.react-flow__node-input,.react-flow__node-output{padding:10px;border-radius:3px;width:150px;font-size:12px;color:#222;text-align:center;border-width:1px;border-style:solid}.react-flow__node-default.selectable:hover,.react-flow__node-input.selectable:hover,.react-flow__node-output.selectable:hover{box-shadow:0 1px 4px 1px rgba(0,0,0,.08)}.react-flow__node-input{background:#fff;border-color:#0041d0;}.react-flow__node-input.selected,.react-flow__node-input.selected:hover{box-shadow:0 0 0 .5px #0041d0}.react-flow__node-input .react-flow__handle{background:#0041d0}.react-flow__node-default{background:#fff;border-color:#1a192b;}.react-flow__node-default.selected,.react-flow__node-default.selected:hover{box-shadow:0 0 0 .5px #1a192b}.react-flow__node-default .react-flow__handle{background:#1a192b}.react-flow__node-output{background:#fff;border-color:#ff0072;}.react-flow__node-output.selected,.react-flow__node-output.selected:hover{box-shadow:0 0 0 .5px #ff0072}.react-flow__node-output .react-flow__handle{background:#ff0072}.react-flow__nodesselection-rect{background:rgba(0,89,220,.08);border:1px dotted rgba(0,89,220,.8)}.react-flow__handle{position:absolute;width:6px;height:6px;background:#555;border:1px solid #fff;border-radius:100%;}.react-flow__handle.connectable{cursor:crosshair}.react-flow__minimap{background-color:#fff}.react-flow__controls{box-shadow:0 0 2px 1px rgba(0,0,0,.08);}.react-flow__controls-button{background:#fefefe;border-bottom:1px solid #eee;box-sizing:content-box;display:flex;justify-content:center;align-items:center;width:16px;height:16px;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;padding:5px;}.react-flow__controls-button svg{max-width:12px;max-height:12px}.react-flow__controls-button:hover{background:#f4f4f4}";
styleInject(css_248z);
var _excluded$1 = ["elements", "className", "nodeTypes", "edgeTypes", "onElementClick", "onLoad", "onMove", "onMoveStart", "onMoveEnd", "onElementsRemove", "onConnect", "onConnectStart", "onConnectStop", "onConnectEnd", "onNodeMouseEnter", "onNodeMouseMove", "onNodeMouseLeave", "onNodeContextMenu", "onNodeDoubleClick", "onNodeDragStart", "onNodeDrag", "onNodeDragStop", "onSelectionChange", "onSelectionDragStart", "onSelectionDrag", "onSelectionDragStop", "onSelectionContextMenu", "connectionMode", "connectionLineType", "connectionLineStyle", "connectionLineComponent", "deleteKeyCode", "selectionKeyCode", "multiSelectionKeyCode", "zoomActivationKeyCode", "snapToGrid", "snapGrid", "onlyRenderVisibleElements", "selectNodesOnDrag", "nodesDraggable", "nodesConnectable", "elementsSelectable", "minZoom", "maxZoom", "defaultZoom", "defaultPosition", "translateExtent", "preventScrolling", "nodeExtent", "arrowHeadColor", "markerEndId", "zoomOnScroll", "zoomOnPinch", "panOnScroll", "panOnScrollSpeed", "panOnScrollMode", "zoomOnDoubleClick", "paneMoveable", "onPaneClick", "onPaneScroll", "onPaneContextMenu", "children", "onEdgeUpdate", "onEdgeContextMenu", "onEdgeDoubleClick", "onEdgeMouseEnter", "onEdgeMouseMove", "onEdgeMouseLeave", "onEdgeUpdateStart", "onEdgeUpdateEnd", "edgeUpdaterRadius", "nodeTypesId", "edgeTypesId"];
function ownKeys$22(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$22(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys$22(Object(source2), true).forEach(function(key) {
        _defineProperty$2(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys$22(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
var defaultNodeTypes = {
  input: InputNode$1,
  default: DefaultNode$1,
  output: OutputNode$1
};
var defaultEdgeTypes = {
  default: BezierEdge,
  straight: StraightEdge,
  step: StepEdge,
  smoothstep: SmoothStepEdge
};
var ReactFlow = /* @__PURE__ */ react.forwardRef(function(_ref, ref) {
  var _ref$elements = _ref.elements, elements = _ref$elements === void 0 ? [] : _ref$elements, className = _ref.className, _ref$nodeTypes = _ref.nodeTypes, nodeTypes = _ref$nodeTypes === void 0 ? defaultNodeTypes : _ref$nodeTypes, _ref$edgeTypes = _ref.edgeTypes, edgeTypes = _ref$edgeTypes === void 0 ? defaultEdgeTypes : _ref$edgeTypes, onElementClick = _ref.onElementClick, onLoad = _ref.onLoad, onMove = _ref.onMove, onMoveStart = _ref.onMoveStart, onMoveEnd = _ref.onMoveEnd, onElementsRemove = _ref.onElementsRemove, onConnect = _ref.onConnect, onConnectStart = _ref.onConnectStart, onConnectStop = _ref.onConnectStop, onConnectEnd = _ref.onConnectEnd, onNodeMouseEnter = _ref.onNodeMouseEnter, onNodeMouseMove = _ref.onNodeMouseMove, onNodeMouseLeave = _ref.onNodeMouseLeave, onNodeContextMenu = _ref.onNodeContextMenu, onNodeDoubleClick = _ref.onNodeDoubleClick, onNodeDragStart = _ref.onNodeDragStart, onNodeDrag = _ref.onNodeDrag, onNodeDragStop = _ref.onNodeDragStop, onSelectionChange = _ref.onSelectionChange, onSelectionDragStart = _ref.onSelectionDragStart, onSelectionDrag = _ref.onSelectionDrag, onSelectionDragStop = _ref.onSelectionDragStop, onSelectionContextMenu = _ref.onSelectionContextMenu, _ref$connectionMode = _ref.connectionMode, connectionMode = _ref$connectionMode === void 0 ? ConnectionMode.Strict : _ref$connectionMode, _ref$connectionLineTy = _ref.connectionLineType, connectionLineType = _ref$connectionLineTy === void 0 ? ConnectionLineType.Bezier : _ref$connectionLineTy, connectionLineStyle = _ref.connectionLineStyle, connectionLineComponent = _ref.connectionLineComponent, _ref$deleteKeyCode = _ref.deleteKeyCode, deleteKeyCode = _ref$deleteKeyCode === void 0 ? "Backspace" : _ref$deleteKeyCode, _ref$selectionKeyCode = _ref.selectionKeyCode, selectionKeyCode = _ref$selectionKeyCode === void 0 ? "Shift" : _ref$selectionKeyCode, _ref$multiSelectionKe = _ref.multiSelectionKeyCode, multiSelectionKeyCode = _ref$multiSelectionKe === void 0 ? "Meta" : _ref$multiSelectionKe, _ref$zoomActivationKe = _ref.zoomActivationKeyCode, zoomActivationKeyCode = _ref$zoomActivationKe === void 0 ? "Meta" : _ref$zoomActivationKe, _ref$snapToGrid = _ref.snapToGrid, snapToGrid2 = _ref$snapToGrid === void 0 ? false : _ref$snapToGrid, _ref$snapGrid = _ref.snapGrid, snapGrid = _ref$snapGrid === void 0 ? [15, 15] : _ref$snapGrid, _ref$onlyRenderVisibl = _ref.onlyRenderVisibleElements, onlyRenderVisibleElements = _ref$onlyRenderVisibl === void 0 ? false : _ref$onlyRenderVisibl, _ref$selectNodesOnDra = _ref.selectNodesOnDrag, selectNodesOnDrag = _ref$selectNodesOnDra === void 0 ? true : _ref$selectNodesOnDra, nodesDraggable = _ref.nodesDraggable, nodesConnectable = _ref.nodesConnectable, elementsSelectable = _ref.elementsSelectable, minZoom = _ref.minZoom, maxZoom = _ref.maxZoom, _ref$defaultZoom = _ref.defaultZoom, defaultZoom = _ref$defaultZoom === void 0 ? 1 : _ref$defaultZoom, _ref$defaultPosition = _ref.defaultPosition, defaultPosition = _ref$defaultPosition === void 0 ? [0, 0] : _ref$defaultPosition, translateExtent = _ref.translateExtent, _ref$preventScrolling = _ref.preventScrolling, preventScrolling = _ref$preventScrolling === void 0 ? true : _ref$preventScrolling, nodeExtent = _ref.nodeExtent, _ref$arrowHeadColor = _ref.arrowHeadColor, arrowHeadColor = _ref$arrowHeadColor === void 0 ? "#b1b1b7" : _ref$arrowHeadColor, markerEndId = _ref.markerEndId, _ref$zoomOnScroll = _ref.zoomOnScroll, zoomOnScroll = _ref$zoomOnScroll === void 0 ? true : _ref$zoomOnScroll, _ref$zoomOnPinch = _ref.zoomOnPinch, zoomOnPinch = _ref$zoomOnPinch === void 0 ? true : _ref$zoomOnPinch, _ref$panOnScroll = _ref.panOnScroll, panOnScroll = _ref$panOnScroll === void 0 ? false : _ref$panOnScroll, _ref$panOnScrollSpeed = _ref.panOnScrollSpeed, panOnScrollSpeed = _ref$panOnScrollSpeed === void 0 ? 0.5 : _ref$panOnScrollSpeed, _ref$panOnScrollMode = _ref.panOnScrollMode, panOnScrollMode = _ref$panOnScrollMode === void 0 ? PanOnScrollMode.Free : _ref$panOnScrollMode, _ref$zoomOnDoubleClic = _ref.zoomOnDoubleClick, zoomOnDoubleClick = _ref$zoomOnDoubleClic === void 0 ? true : _ref$zoomOnDoubleClic, _ref$paneMoveable = _ref.paneMoveable, paneMoveable = _ref$paneMoveable === void 0 ? true : _ref$paneMoveable, onPaneClick = _ref.onPaneClick, onPaneScroll = _ref.onPaneScroll, onPaneContextMenu = _ref.onPaneContextMenu, children2 = _ref.children, onEdgeUpdate = _ref.onEdgeUpdate, onEdgeContextMenu = _ref.onEdgeContextMenu, onEdgeDoubleClick = _ref.onEdgeDoubleClick, onEdgeMouseEnter = _ref.onEdgeMouseEnter, onEdgeMouseMove = _ref.onEdgeMouseMove, onEdgeMouseLeave = _ref.onEdgeMouseLeave, onEdgeUpdateStart = _ref.onEdgeUpdateStart, onEdgeUpdateEnd = _ref.onEdgeUpdateEnd, _ref$edgeUpdaterRadiu = _ref.edgeUpdaterRadius, edgeUpdaterRadius = _ref$edgeUpdaterRadiu === void 0 ? 10 : _ref$edgeUpdaterRadiu, _ref$nodeTypesId = _ref.nodeTypesId, nodeTypesId = _ref$nodeTypesId === void 0 ? "1" : _ref$nodeTypesId, _ref$edgeTypesId = _ref.edgeTypesId, edgeTypesId = _ref$edgeTypesId === void 0 ? "1" : _ref$edgeTypesId, rest = _objectWithoutProperties3(_ref, _excluded$1);
  var nodeTypesParsed = react.useMemo(function() {
    return createNodeTypes(nodeTypes);
  }, [nodeTypesId]);
  var edgeTypesParsed = react.useMemo(function() {
    return createEdgeTypes(edgeTypes);
  }, [edgeTypesId]);
  var reactFlowClasses = cc2(["react-flow", className]);
  return /* @__PURE__ */ react.createElement("div", _objectSpread$22(_objectSpread$22({}, rest), {}, {
    ref,
    className: reactFlowClasses
  }), /* @__PURE__ */ react.createElement(Wrapper, null, /* @__PURE__ */ react.createElement(GraphView$1, {
    onLoad,
    onMove,
    onMoveStart,
    onMoveEnd,
    onElementClick,
    onNodeMouseEnter,
    onNodeMouseMove,
    onNodeMouseLeave,
    onNodeContextMenu,
    onNodeDoubleClick,
    onNodeDragStart,
    onNodeDrag,
    onNodeDragStop,
    nodeTypes: nodeTypesParsed,
    edgeTypes: edgeTypesParsed,
    connectionMode,
    connectionLineType,
    connectionLineStyle,
    connectionLineComponent,
    selectionKeyCode,
    onElementsRemove,
    deleteKeyCode,
    multiSelectionKeyCode,
    zoomActivationKeyCode,
    onConnect,
    onConnectStart,
    onConnectStop,
    onConnectEnd,
    snapToGrid: snapToGrid2,
    snapGrid,
    onlyRenderVisibleElements,
    nodesDraggable,
    nodesConnectable,
    elementsSelectable,
    selectNodesOnDrag,
    minZoom,
    maxZoom,
    defaultZoom,
    defaultPosition,
    translateExtent,
    preventScrolling,
    nodeExtent,
    arrowHeadColor,
    markerEndId,
    zoomOnScroll,
    zoomOnPinch,
    zoomOnDoubleClick,
    panOnScroll,
    panOnScrollSpeed,
    panOnScrollMode,
    paneMoveable,
    onPaneClick,
    onPaneScroll,
    onPaneContextMenu,
    onSelectionDragStart,
    onSelectionDrag,
    onSelectionDragStop,
    onSelectionContextMenu,
    onEdgeUpdate,
    onEdgeContextMenu,
    onEdgeDoubleClick,
    onEdgeMouseEnter,
    onEdgeMouseMove,
    onEdgeMouseLeave,
    onEdgeUpdateStart,
    onEdgeUpdateEnd,
    edgeUpdaterRadius
  }), /* @__PURE__ */ react.createElement(ElementUpdater, {
    elements
  }), onSelectionChange && /* @__PURE__ */ react.createElement(SelectionListener, {
    onSelectionChange
  }), children2));
});
ReactFlow.displayName = "ReactFlow";
var MiniMapNode = function MiniMapNode2(_ref) {
  var x3 = _ref.x, y4 = _ref.y, width2 = _ref.width, height = _ref.height, style = _ref.style, color2 = _ref.color, strokeColor = _ref.strokeColor, strokeWidth = _ref.strokeWidth, className = _ref.className, borderRadius = _ref.borderRadius, shapeRendering = _ref.shapeRendering;
  var _ref2 = style || {}, background = _ref2.background, backgroundColor = _ref2.backgroundColor;
  var fill = color2 || background || backgroundColor;
  return /* @__PURE__ */ react.createElement("rect", {
    className: cc2(["react-flow__minimap-node", className]),
    x: x3,
    y: y4,
    rx: borderRadius,
    ry: borderRadius,
    width: width2,
    height,
    fill,
    stroke: strokeColor,
    strokeWidth,
    shapeRendering
  });
};
MiniMapNode.displayName = "MiniMapNode";
var MiniMapNode$1 = /* @__PURE__ */ react.memo(MiniMapNode);
var defaultWidth = 200;
var defaultHeight = 150;
var MiniMap = function MiniMap2(_ref) {
  var style = _ref.style, className = _ref.className, _ref$nodeStrokeColor = _ref.nodeStrokeColor, nodeStrokeColor = _ref$nodeStrokeColor === void 0 ? "#555" : _ref$nodeStrokeColor, _ref$nodeColor = _ref.nodeColor, nodeColor = _ref$nodeColor === void 0 ? "#fff" : _ref$nodeColor, _ref$nodeClassName = _ref.nodeClassName, nodeClassName = _ref$nodeClassName === void 0 ? "" : _ref$nodeClassName, _ref$nodeBorderRadius = _ref.nodeBorderRadius, nodeBorderRadius = _ref$nodeBorderRadius === void 0 ? 5 : _ref$nodeBorderRadius, _ref$nodeStrokeWidth = _ref.nodeStrokeWidth, nodeStrokeWidth = _ref$nodeStrokeWidth === void 0 ? 2 : _ref$nodeStrokeWidth, _ref$maskColor = _ref.maskColor, maskColor = _ref$maskColor === void 0 ? "rgb(240, 242, 243, 0.7)" : _ref$maskColor;
  var containerWidth = useStoreState(function(s2) {
    return s2.width;
  });
  var containerHeight = useStoreState(function(s2) {
    return s2.height;
  });
  var _useStoreState = useStoreState(function(s2) {
    return s2.transform;
  }), _useStoreState2 = _slicedToArray$1(_useStoreState, 3), tX = _useStoreState2[0], tY = _useStoreState2[1], tScale = _useStoreState2[2];
  var nodes = useStoreState(function(s2) {
    return s2.nodes;
  });
  var mapClasses = cc2(["react-flow__minimap", className]);
  var elementWidth = (style === null || style === void 0 ? void 0 : style.width) || defaultWidth;
  var elementHeight = (style === null || style === void 0 ? void 0 : style.height) || defaultHeight;
  var nodeColorFunc = nodeColor instanceof Function ? nodeColor : function() {
    return nodeColor;
  };
  var nodeStrokeColorFunc = nodeStrokeColor instanceof Function ? nodeStrokeColor : function() {
    return nodeStrokeColor;
  };
  var nodeClassNameFunc = nodeClassName instanceof Function ? nodeClassName : function() {
    return nodeClassName;
  };
  var hasNodes = nodes && nodes.length;
  var bb2 = getRectOfNodes(nodes);
  var viewBB = {
    x: -tX / tScale,
    y: -tY / tScale,
    width: containerWidth / tScale,
    height: containerHeight / tScale
  };
  var boundingRect = hasNodes ? getBoundsofRects(bb2, viewBB) : viewBB;
  var scaledWidth = boundingRect.width / elementWidth;
  var scaledHeight = boundingRect.height / elementHeight;
  var viewScale = Math.max(scaledWidth, scaledHeight);
  var viewWidth = viewScale * elementWidth;
  var viewHeight = viewScale * elementHeight;
  var offset2 = 5 * viewScale;
  var x3 = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset2;
  var y4 = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset2;
  var width2 = viewWidth + offset2 * 2;
  var height = viewHeight + offset2 * 2;
  var shapeRendering = typeof window === "undefined" || !!window.chrome ? "crispEdges" : "geometricPrecision";
  return /* @__PURE__ */ react.createElement("svg", {
    width: elementWidth,
    height: elementHeight,
    viewBox: "".concat(x3, " ").concat(y4, " ").concat(width2, " ").concat(height),
    style,
    className: mapClasses
  }, nodes.filter(function(node) {
    return !node.isHidden;
  }).map(function(node) {
    return /* @__PURE__ */ react.createElement(MiniMapNode$1, {
      key: node.id,
      x: node.__rf.position.x,
      y: node.__rf.position.y,
      width: node.__rf.width,
      height: node.__rf.height,
      style: node.style,
      className: nodeClassNameFunc(node),
      color: nodeColorFunc(node),
      borderRadius: nodeBorderRadius,
      strokeColor: nodeStrokeColorFunc(node),
      strokeWidth: nodeStrokeWidth,
      shapeRendering
    });
  }), /* @__PURE__ */ react.createElement("path", {
    className: "react-flow__minimap-mask",
    d: "M".concat(x3 - offset2, ",").concat(y4 - offset2, "h").concat(width2 + offset2 * 2, "v").concat(height + offset2 * 2, "h").concat(-width2 - offset2 * 2, "z\n        M").concat(viewBB.x, ",").concat(viewBB.y, "h").concat(viewBB.width, "v").concat(viewBB.height, "h").concat(-viewBB.width, "z"),
    fill: maskColor,
    fillRule: "evenodd"
  }));
};
MiniMap.displayName = "MiniMap";
var index$2 = /* @__PURE__ */ react.memo(MiniMap);
var _path$4;
function _extends$4() {
  _extends$4 = Object.assign || function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source2 = arguments[i3];
      for (var key in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key)) {
          target[key] = source2[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
function SvgPlus(props) {
  return /* @__PURE__ */ react.createElement("svg", _extends$4({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32"
  }, props), _path$4 || (_path$4 = /* @__PURE__ */ react.createElement("path", {
    d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z"
  })));
}
var _path$3;
function _extends$3() {
  _extends$3 = Object.assign || function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source2 = arguments[i3];
      for (var key in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key)) {
          target[key] = source2[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
function SvgMinus(props) {
  return /* @__PURE__ */ react.createElement("svg", _extends$3({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 5"
  }, props), _path$3 || (_path$3 = /* @__PURE__ */ react.createElement("path", {
    d: "M0 0h32v4.2H0z"
  })));
}
var _path$2;
function _extends$2() {
  _extends$2 = Object.assign || function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source2 = arguments[i3];
      for (var key in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key)) {
          target[key] = source2[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function SvgFitview(props) {
  return /* @__PURE__ */ react.createElement("svg", _extends$2({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 30"
  }, props), _path$2 || (_path$2 = /* @__PURE__ */ react.createElement("path", {
    d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94a.919.919 0 01-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z"
  })));
}
var _path$1;
function _extends$1() {
  _extends$1 = Object.assign || function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source2 = arguments[i3];
      for (var key in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key)) {
          target[key] = source2[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function SvgLock(props) {
  return /* @__PURE__ */ react.createElement("svg", _extends$1({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 25 32"
  }, props), _path$1 || (_path$1 = /* @__PURE__ */ react.createElement("path", {
    d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z"
  })));
}
var _path;
function _extends3() {
  _extends3 = Object.assign || function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source2 = arguments[i3];
      for (var key in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key)) {
          target[key] = source2[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
function SvgUnlock(props) {
  return /* @__PURE__ */ react.createElement("svg", _extends3({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 25 32"
  }, props), _path || (_path = /* @__PURE__ */ react.createElement("path", {
    d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z"
  })));
}
var _excluded3 = ["children", "className"];
function ownKeys$12(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$12(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys$12(Object(source2), true).forEach(function(key) {
        _defineProperty$2(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys$12(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
var ControlButton = function ControlButton2(_ref) {
  var children2 = _ref.children, className = _ref.className, rest = _objectWithoutProperties3(_ref, _excluded3);
  return /* @__PURE__ */ react.createElement("button", _objectSpread$12({
    className: cc2(["react-flow__controls-button", className])
  }, rest), children2);
};
var Controls = function Controls2(_ref2) {
  var style = _ref2.style, _ref2$showZoom = _ref2.showZoom, showZoom = _ref2$showZoom === void 0 ? true : _ref2$showZoom, _ref2$showFitView = _ref2.showFitView, showFitView = _ref2$showFitView === void 0 ? true : _ref2$showFitView, _ref2$showInteractive = _ref2.showInteractive, showInteractive = _ref2$showInteractive === void 0 ? true : _ref2$showInteractive, fitViewParams = _ref2.fitViewParams, onZoomIn = _ref2.onZoomIn, onZoomOut = _ref2.onZoomOut, onFitView = _ref2.onFitView, onInteractiveChange = _ref2.onInteractiveChange, className = _ref2.className, children2 = _ref2.children;
  var _useState = react.useState(false), _useState2 = _slicedToArray$1(_useState, 2), isVisible = _useState2[0], setIsVisible = _useState2[1];
  var setInteractive3 = useStoreActions(function(actions2) {
    return actions2.setInteractive;
  });
  var _useZoomPanHelper = useZoomPanHelper(), zoomIn2 = _useZoomPanHelper.zoomIn, zoomOut2 = _useZoomPanHelper.zoomOut, fitView2 = _useZoomPanHelper.fitView;
  var isInteractive = useStoreState(function(s2) {
    return s2.nodesDraggable && s2.nodesConnectable && s2.elementsSelectable;
  });
  var mapClasses = cc2(["react-flow__controls", className]);
  var onZoomInHandler = react.useCallback(function() {
    zoomIn2 === null || zoomIn2 === void 0 ? void 0 : zoomIn2();
    onZoomIn === null || onZoomIn === void 0 ? void 0 : onZoomIn();
  }, [zoomIn2, onZoomIn]);
  var onZoomOutHandler = react.useCallback(function() {
    zoomOut2 === null || zoomOut2 === void 0 ? void 0 : zoomOut2();
    onZoomOut === null || onZoomOut === void 0 ? void 0 : onZoomOut();
  }, [zoomOut2, onZoomOut]);
  var onFitViewHandler = react.useCallback(function() {
    fitView2 === null || fitView2 === void 0 ? void 0 : fitView2(fitViewParams);
    onFitView === null || onFitView === void 0 ? void 0 : onFitView();
  }, [fitView2, fitViewParams, onFitView]);
  var onInteractiveChangeHandler = react.useCallback(function() {
    setInteractive3 === null || setInteractive3 === void 0 ? void 0 : setInteractive3(!isInteractive);
    onInteractiveChange === null || onInteractiveChange === void 0 ? void 0 : onInteractiveChange(!isInteractive);
  }, [isInteractive, setInteractive3, onInteractiveChange]);
  react.useEffect(function() {
    setIsVisible(true);
  }, []);
  if (!isVisible) {
    return null;
  }
  return /* @__PURE__ */ react.createElement("div", {
    className: mapClasses,
    style
  }, showZoom && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ControlButton, {
    onClick: onZoomInHandler,
    className: "react-flow__controls-zoomin"
  }, /* @__PURE__ */ react.createElement(SvgPlus, null)), /* @__PURE__ */ react.createElement(ControlButton, {
    onClick: onZoomOutHandler,
    className: "react-flow__controls-zoomout"
  }, /* @__PURE__ */ react.createElement(SvgMinus, null))), showFitView && /* @__PURE__ */ react.createElement(ControlButton, {
    className: "react-flow__controls-fitview",
    onClick: onFitViewHandler
  }, /* @__PURE__ */ react.createElement(SvgFitview, null)), showInteractive && /* @__PURE__ */ react.createElement(ControlButton, {
    className: "react-flow__controls-interactive",
    onClick: onInteractiveChangeHandler
  }, isInteractive ? /* @__PURE__ */ react.createElement(SvgUnlock, null) : /* @__PURE__ */ react.createElement(SvgLock, null)), children2);
};
Controls.displayName = "Controls";
var index$1 = /* @__PURE__ */ react.memo(Controls);
var createGridLinesPath = function createGridLinesPath2(size2, strokeWidth, stroke) {
  return /* @__PURE__ */ react.createElement("path", {
    stroke,
    strokeWidth,
    d: "M".concat(size2 / 2, " 0 V").concat(size2, " M0 ").concat(size2 / 2, " H").concat(size2)
  });
};
var createGridDotsPath = function createGridDotsPath2(size2, fill) {
  return /* @__PURE__ */ react.createElement("circle", {
    cx: size2,
    cy: size2,
    r: size2,
    fill
  });
};
var _defaultColors;
function ownKeys3(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread4(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys3(Object(source2), true).forEach(function(key) {
        _defineProperty$2(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys3(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
var defaultColors = (_defaultColors = {}, _defineProperty$2(_defaultColors, BackgroundVariant.Dots, "#81818a"), _defineProperty$2(_defaultColors, BackgroundVariant.Lines, "#eee"), _defaultColors);
var Background = function Background2(_ref) {
  var _ref$variant = _ref.variant, variant = _ref$variant === void 0 ? BackgroundVariant.Dots : _ref$variant, _ref$gap = _ref.gap, gap = _ref$gap === void 0 ? 15 : _ref$gap, _ref$size = _ref.size, size2 = _ref$size === void 0 ? 0.4 : _ref$size, color2 = _ref.color, style = _ref.style, className = _ref.className;
  var _useStoreState = useStoreState(function(s2) {
    return s2.transform;
  }), _useStoreState2 = _slicedToArray$1(_useStoreState, 3), x3 = _useStoreState2[0], y4 = _useStoreState2[1], scale = _useStoreState2[2];
  var patternId = react.useMemo(function() {
    return "pattern-".concat(Math.floor(Math.random() * 1e5));
  }, []);
  var bgClasses = cc2(["react-flow__background", className]);
  var scaledGap = gap * scale;
  var xOffset = x3 % scaledGap;
  var yOffset = y4 % scaledGap;
  var isLines = variant === BackgroundVariant.Lines;
  var bgColor = color2 ? color2 : defaultColors[variant];
  var path = isLines ? createGridLinesPath(scaledGap, size2, bgColor) : createGridDotsPath(size2 * scale, bgColor);
  return /* @__PURE__ */ react.createElement("svg", {
    className: bgClasses,
    style: _objectSpread4(_objectSpread4({}, style), {}, {
      width: "100%",
      height: "100%"
    })
  }, /* @__PURE__ */ react.createElement("pattern", {
    id: patternId,
    x: xOffset,
    y: yOffset,
    width: scaledGap,
    height: scaledGap,
    patternUnits: "userSpaceOnUse"
  }, path), /* @__PURE__ */ react.createElement("rect", {
    x: "0",
    y: "0",
    width: "100%",
    height: "100%",
    fill: "url(#".concat(patternId, ")")
  }));
};
Background.displayName = "Background";
var index2 = /* @__PURE__ */ react.memo(Background);
var react_flow_renderer_default = ReactFlow;

// build/authentication/components/diagram/SubFlowNode.js
var SubFlowNode = memo(function TheNode({
  data: {label: label2},
  prefix: prefix2,
  selected
}) {
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Handle$1, {
    position: Position.Right,
    type: "source"
  }), /* @__PURE__ */ react.createElement("div", {
    className: `react-flow__node-default keycloak__authentication__subflow_node ${selected ? "selected" : ""}`
  }, /* @__PURE__ */ react.createElement("div", null, prefix2, " ", label2)), /* @__PURE__ */ react.createElement(Handle$1, {
    position: Position.Left,
    type: "target"
  }));
});
var StartSubFlowNode = ({...props}) => /* @__PURE__ */ react.createElement(SubFlowNode, {
  ...props,
  prefix: "Start"
});
var EndSubFlowNode = ({...props}) => /* @__PURE__ */ react.createElement(SubFlowNode, {
  ...props,
  prefix: "End"
});

// build/authentication/components/diagram/ConditionalNode.js
var ConditionalNode = memo(function TheNode2({
  data,
  selected
}) {
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Handle$1, {
    position: Position.Right,
    type: "source"
  }), /* @__PURE__ */ react.createElement("div", {
    className: `react-flow__node-default keycloak__authentication__conditional_node ${selected ? "selected" : ""}`
  }, /* @__PURE__ */ react.createElement("div", null, data.label)), /* @__PURE__ */ react.createElement(Handle$1, {
    position: Position.Left,
    type: "target"
  }));
});

// build/authentication/components/diagram/ButtonEdge.js
var foreignObjectSize = 33;
var ButtonEdge = ({
  id: id3,
  sourceX,
  sourceY,
  targetX,
  targetY,
  sourcePosition,
  targetPosition,
  style = {},
  arrowHeadType,
  markerEndId,
  selected,
  data: {onEdgeClick}
}) => {
  const edgePath = getBezierPath({
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition
  });
  const markerEnd = getMarkerEnd(arrowHeadType, markerEndId);
  const [edgeCenterX, edgeCenterY] = getCenter({
    sourceX,
    sourceY,
    targetX,
    targetY
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement("path", {
    id: id3,
    style,
    className: "react-flow__edge-path",
    d: edgePath,
    markerEnd
  }), selected && /* @__PURE__ */ react.createElement("foreignObject", {
    width: foreignObjectSize,
    height: foreignObjectSize,
    x: edgeCenterX - foreignObjectSize / 2,
    y: edgeCenterY - foreignObjectSize / 2,
    className: "edgebutton-foreignobject",
    requiredExtensions: "http://www.w3.org/1999/xhtml"
  }, /* @__PURE__ */ react.createElement("button", {
    className: "edgebutton",
    onClick: (event) => onEdgeClick(event, id3)
  }, /* @__PURE__ */ react.createElement(PlusIcon, null))));
};

// build/_snowpack/pkg/dagre.js
function arrayEach(array2, iteratee) {
  var index3 = -1, length = array2 == null ? 0 : array2.length;
  while (++index3 < length) {
    if (iteratee(array2[index3], index3, array2) === false) {
      break;
    }
  }
  return array2;
}
var _arrayEach = arrayEach;
function baseAssign(object, source2) {
  return object && _copyObject(source2, keys_1(source2), object);
}
var _baseAssign = baseAssign;
function baseAssignIn(object, source2) {
  return object && _copyObject(source2, keysIn_1(source2), object);
}
var _baseAssignIn = baseAssignIn;
function copySymbols(source2, object) {
  return _copyObject(source2, _getSymbols(source2), object);
}
var _copySymbols = copySymbols;
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols2 ? stubArray_1 : function(object) {
  var result = [];
  while (object) {
    _arrayPush(result, _getSymbols(object));
    object = _getPrototype(object);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn;
function copySymbolsIn(source2, object) {
  return _copyObject(source2, _getSymbolsIn(source2), object);
}
var _copySymbolsIn = copySymbolsIn;
function getAllKeysIn(object) {
  return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn;
var objectProto2 = Object.prototype;
var hasOwnProperty4 = objectProto2.hasOwnProperty;
function initCloneArray(array2) {
  var length = array2.length, result = new array2.constructor(length);
  if (length && typeof array2[0] == "string" && hasOwnProperty4.call(array2, "index")) {
    result.index = array2.index;
    result.input = array2.input;
  }
  return result;
}
var _initCloneArray = initCloneArray;
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView;
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp;
var symbolProto2 = _Symbol ? _Symbol.prototype : void 0;
var symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf2 ? Object(symbolValueOf2.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol;
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var mapTag2 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag2 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag2 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag2:
      return _cloneArrayBuffer(object);
    case boolTag2:
    case dateTag2:
      return new Ctor(+object);
    case dataViewTag2:
      return _cloneDataView(object, isDeep);
    case float32Tag2:
    case float64Tag2:
    case int8Tag2:
    case int16Tag2:
    case int32Tag2:
    case uint8Tag2:
    case uint8ClampedTag2:
    case uint16Tag2:
    case uint32Tag2:
      return _cloneTypedArray(object, isDeep);
    case mapTag2:
      return new Ctor();
    case numberTag2:
    case stringTag2:
      return new Ctor(object);
    case regexpTag2:
      return _cloneRegExp(object);
    case setTag2:
      return new Ctor();
    case symbolTag2:
      return _cloneSymbol(object);
  }
}
var _initCloneByTag = initCloneByTag;
var mapTag$12 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike_1(value) && _getTag(value) == mapTag$12;
}
var _baseIsMap = baseIsMap;
var nodeIsMap = _nodeUtil && _nodeUtil.isMap;
var isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;
var isMap_1 = isMap;
var setTag$12 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike_1(value) && _getTag(value) == setTag$12;
}
var _baseIsSet = baseIsSet;
var nodeIsSet = _nodeUtil && _nodeUtil.isSet;
var isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;
var isSet_1 = isSet;
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var argsTag2 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var boolTag$12 = "[object Boolean]";
var dateTag$12 = "[object Date]";
var errorTag2 = "[object Error]";
var funcTag2 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var mapTag$22 = "[object Map]";
var numberTag$12 = "[object Number]";
var objectTag2 = "[object Object]";
var regexpTag$12 = "[object RegExp]";
var setTag$22 = "[object Set]";
var stringTag$12 = "[object String]";
var symbolTag$1 = "[object Symbol]";
var weakMapTag2 = "[object WeakMap]";
var arrayBufferTag$12 = "[object ArrayBuffer]";
var dataViewTag$12 = "[object DataView]";
var float32Tag$1 = "[object Float32Array]";
var float64Tag$1 = "[object Float64Array]";
var int8Tag$1 = "[object Int8Array]";
var int16Tag$1 = "[object Int16Array]";
var int32Tag$1 = "[object Int32Array]";
var uint8Tag$1 = "[object Uint8Array]";
var uint8ClampedTag$1 = "[object Uint8ClampedArray]";
var uint16Tag$1 = "[object Uint16Array]";
var uint32Tag$1 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag2] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag$12] = cloneableTags[dataViewTag$12] = cloneableTags[boolTag$12] = cloneableTags[dateTag$12] = cloneableTags[float32Tag$1] = cloneableTags[float64Tag$1] = cloneableTags[int8Tag$1] = cloneableTags[int16Tag$1] = cloneableTags[int32Tag$1] = cloneableTags[mapTag$22] = cloneableTags[numberTag$12] = cloneableTags[objectTag2] = cloneableTags[regexpTag$12] = cloneableTags[setTag$22] = cloneableTags[stringTag$12] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag$1] = cloneableTags[uint8ClampedTag$1] = cloneableTags[uint16Tag$1] = cloneableTags[uint32Tag$1] = true;
cloneableTags[errorTag2] = cloneableTags[funcTag2] = cloneableTags[weakMapTag2] = false;
function baseClone(value, bitmask, customizer, key, object, stack2) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
  if (customizer) {
    result = object ? customizer(value, key, object, stack2) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject_1(value)) {
    return value;
  }
  var isArr = isArray_1(value);
  if (isArr) {
    result = _initCloneArray(value);
    if (!isDeep) {
      return _copyArray(value, result);
    }
  } else {
    var tag = _getTag(value), isFunc = tag == funcTag2 || tag == genTag2;
    if (isBuffer_1(value)) {
      return _cloneBuffer(value, isDeep);
    }
    if (tag == objectTag2 || tag == argsTag2 || isFunc && !object) {
      result = isFlat || isFunc ? {} : _initCloneObject(value);
      if (!isDeep) {
        return isFlat ? _copySymbolsIn(value, _baseAssignIn(result, value)) : _copySymbols(value, _baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = _initCloneByTag(value, tag, isDeep);
    }
  }
  stack2 || (stack2 = new _Stack());
  var stacked = stack2.get(value);
  if (stacked) {
    return stacked;
  }
  stack2.set(value, result);
  if (isSet_1(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
    });
  } else if (isMap_1(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
    });
  }
  var keysFunc = isFull ? isFlat ? _getAllKeysIn : _getAllKeys : isFlat ? keysIn_1 : keys_1;
  var props = isArr ? void 0 : keysFunc(value);
  _arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    _assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
  });
  return result;
}
var _baseClone = baseClone;
var CLONE_SYMBOLS_FLAG$1 = 4;
function clone(value) {
  return _baseClone(value, CLONE_SYMBOLS_FLAG$1);
}
var clone_1 = clone;
function baseForOwn(object, iteratee) {
  return object && _baseFor(object, iteratee, keys_1);
}
var _baseForOwn = baseForOwn;
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_1(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index3 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index3-- : ++index3 < length) {
      if (iteratee(iterable[index3], index3, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var _createBaseEach = createBaseEach;
var baseEach = _createBaseEach(_baseForOwn);
var _baseEach = baseEach;
function castFunction(value) {
  return typeof value == "function" ? value : identity_1;
}
var _castFunction = castFunction;
function forEach3(collection, iteratee) {
  var func = isArray_1(collection) ? _arrayEach : _baseEach;
  return func(collection, _castFunction(iteratee));
}
var forEach_1 = forEach3;
var each = forEach_1;
function baseFilter(collection, predicate) {
  var result = [];
  _baseEach(collection, function(value, index3, collection2) {
    if (predicate(value, index3, collection2)) {
      result.push(value);
    }
  });
  return result;
}
var _baseFilter = baseFilter;
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
function baseIsMatch(object, source2, matchData, customizer) {
  var index3 = matchData.length, length = index3, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index3--) {
    var data = matchData[index3];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index3 < length) {
    data = matchData[index3];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack2 = new _Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source2, stack2);
      }
      if (!(result === void 0 ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG2 | COMPARE_UNORDERED_FLAG2, customizer, stack2) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch;
function isStrictComparable(value) {
  return value === value && !isObject_1(value);
}
var _isStrictComparable = isStrictComparable;
function getMatchData(object) {
  var result = keys_1(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, _isStrictComparable(value)];
  }
  return result;
}
var _getMatchData = getMatchData;
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var _matchesStrictComparable = matchesStrictComparable;
function baseMatches(source2) {
  var matchData = _getMatchData(source2);
  if (matchData.length == 1 && matchData[0][2]) {
    return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source2 || _baseIsMatch(object, source2, matchData);
  };
}
var _baseMatches = baseMatches;
var symbolTag$2 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_1(value) && _baseGetTag(value) == symbolTag$2;
}
var isSymbol_1 = isSymbol;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey2(value, object) {
  if (isArray_1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_1(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var _isKey = isKey2;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache3 = memoized.cache;
    if (cache3.has(key)) {
      return cache3.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache3.set(key, result) || cache3;
    return result;
  };
  memoized.cache = new (memoize.Cache || _MapCache)();
  return memoized;
}
memoize.Cache = _MapCache;
var memoize_1 = memoize;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_1(func, function(key) {
    if (cache3.size === MAX_MEMOIZE_SIZE) {
      cache3.clear();
    }
    return key;
  });
  var cache3 = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath2 = _memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var _stringToPath = stringToPath2;
function arrayMap(array2, iteratee) {
  var index3 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
  while (++index3 < length) {
    result[index3] = iteratee(array2[index3], index3, array2);
  }
  return result;
}
var _arrayMap = arrayMap;
var INFINITY = 1 / 0;
var symbolProto$1 = _Symbol ? _Symbol.prototype : void 0;
var symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_1(value)) {
    return _arrayMap(value, baseToString) + "";
  }
  if (isSymbol_1(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var _baseToString = baseToString;
function toString3(value) {
  return value == null ? "" : _baseToString(value);
}
var toString_1 = toString3;
function castPath(value, object) {
  if (isArray_1(value)) {
    return value;
  }
  return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
}
var _castPath = castPath;
var INFINITY$1 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_1(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var _toKey = toKey;
function baseGet2(object, path) {
  path = _castPath(path, object);
  var index3 = 0, length = path.length;
  while (object != null && index3 < length) {
    object = object[_toKey(path[index3++])];
  }
  return index3 && index3 == length ? object : void 0;
}
var _baseGet = baseGet2;
function get4(object, path, defaultValue) {
  var result = object == null ? void 0 : _baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get4;
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
var _baseHasIn = baseHasIn;
function hasPath(object, path, hasFunc) {
  path = _castPath(path, object);
  var index3 = -1, length = path.length, result = false;
  while (++index3 < length) {
    var key = _toKey(path[index3]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index3 != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength_1(length) && _isIndex(key, length) && (isArray_1(object) || isArguments_1(object));
}
var _hasPath = hasPath;
function hasIn(object, path) {
  return object != null && _hasPath(object, path, _baseHasIn);
}
var hasIn_1 = hasIn;
var COMPARE_PARTIAL_FLAG$12 = 1;
var COMPARE_UNORDERED_FLAG$12 = 2;
function baseMatchesProperty(path, srcValue) {
  if (_isKey(path) && _isStrictComparable(srcValue)) {
    return _matchesStrictComparable(_toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get_1(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn_1(object, path) : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$12 | COMPARE_UNORDERED_FLAG$12);
  };
}
var _baseMatchesProperty = baseMatchesProperty;
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var _baseProperty = baseProperty;
function basePropertyDeep(path) {
  return function(object) {
    return _baseGet(object, path);
  };
}
var _basePropertyDeep = basePropertyDeep;
function property(path) {
  return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
}
var property_1 = property;
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_1;
  }
  if (typeof value == "object") {
    return isArray_1(value) ? _baseMatchesProperty(value[0], value[1]) : _baseMatches(value);
  }
  return property_1(value);
}
var _baseIteratee = baseIteratee;
function filter2(collection, predicate) {
  var func = isArray_1(collection) ? _arrayFilter : _baseFilter;
  return func(collection, _baseIteratee(predicate));
}
var filter_1 = filter2;
var objectProto$12 = Object.prototype;
var hasOwnProperty$12 = objectProto$12.hasOwnProperty;
function baseHas(object, key) {
  return object != null && hasOwnProperty$12.call(object, key);
}
var _baseHas = baseHas;
function has3(object, path) {
  return object != null && _hasPath(object, path, _baseHas);
}
var has_1 = has3;
var mapTag$3 = "[object Map]";
var setTag$3 = "[object Set]";
var objectProto$22 = Object.prototype;
var hasOwnProperty$22 = objectProto$22.hasOwnProperty;
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike_1(value) && (isArray_1(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer_1(value) || isTypedArray_1(value) || isArguments_1(value))) {
    return !value.length;
  }
  var tag = _getTag(value);
  if (tag == mapTag$3 || tag == setTag$3) {
    return !value.size;
  }
  if (_isPrototype(value)) {
    return !_baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty$22.call(value, key)) {
      return false;
    }
  }
  return true;
}
var isEmpty_1 = isEmpty;
function isUndefined3(value) {
  return value === void 0;
}
var isUndefined_1 = isUndefined3;
function baseMap(collection, iteratee) {
  var index3 = -1, result = isArrayLike_1(collection) ? Array(collection.length) : [];
  _baseEach(collection, function(value, key, collection2) {
    result[++index3] = iteratee(value, key, collection2);
  });
  return result;
}
var _baseMap = baseMap;
function map2(collection, iteratee) {
  var func = isArray_1(collection) ? _arrayMap : _baseMap;
  return func(collection, _baseIteratee(iteratee));
}
var map_1 = map2;
function arrayReduce(array2, iteratee, accumulator, initAccum) {
  var index3 = -1, length = array2 == null ? 0 : array2.length;
  if (initAccum && length) {
    accumulator = array2[++index3];
  }
  while (++index3 < length) {
    accumulator = iteratee(accumulator, array2[index3], index3, array2);
  }
  return accumulator;
}
var _arrayReduce = arrayReduce;
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index3, collection2) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index3, collection2);
  });
  return accumulator;
}
var _baseReduce = baseReduce;
function reduce2(collection, iteratee, accumulator) {
  var func = isArray_1(collection) ? _arrayReduce : _baseReduce, initAccum = arguments.length < 3;
  return func(collection, _baseIteratee(iteratee), accumulator, initAccum, _baseEach);
}
var reduce_1 = reduce2;
var stringTag$2 = "[object String]";
function isString3(value) {
  return typeof value == "string" || !isArray_1(value) && isObjectLike_1(value) && _baseGetTag(value) == stringTag$2;
}
var isString_1 = isString3;
var asciiSize = _baseProperty("length");
var _asciiSize = asciiSize;
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsZWJ = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
var _hasUnicode = hasUnicode;
var rsAstralRange$1 = "\\ud800-\\udfff";
var rsComboMarksRange$1 = "\\u0300-\\u036f";
var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange$1 + "]";
var rsCombo = "[" + rsComboRange$1 + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange$1 + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ$1 = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange$1 + "]?";
var rsOptJoin = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeSize(string) {
  var result = reUnicode.lastIndex = 0;
  while (reUnicode.test(string)) {
    ++result;
  }
  return result;
}
var _unicodeSize = unicodeSize;
function stringSize(string) {
  return _hasUnicode(string) ? _unicodeSize(string) : _asciiSize(string);
}
var _stringSize = stringSize;
var mapTag$4 = "[object Map]";
var setTag$4 = "[object Set]";
function size(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike_1(collection)) {
    return isString_1(collection) ? _stringSize(collection) : collection.length;
  }
  var tag = _getTag(collection);
  if (tag == mapTag$4 || tag == setTag$4) {
    return collection.size;
  }
  return _baseKeys(collection).length;
}
var size_1 = size;
function transform2(object, iteratee, accumulator) {
  var isArr = isArray_1(object), isArrLike = isArr || isBuffer_1(object) || isTypedArray_1(object);
  iteratee = _baseIteratee(iteratee);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor() : [];
    } else if (isObject_1(object)) {
      accumulator = isFunction_1(Ctor) ? _baseCreate(_getPrototype(object)) : {};
    } else {
      accumulator = {};
    }
  }
  (isArrLike ? _arrayEach : _baseForOwn)(object, function(value, index3, object2) {
    return iteratee(accumulator, value, index3, object2);
  });
  return accumulator;
}
var transform_1 = transform2;
var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray_1(value) || isArguments_1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable;
function baseFlatten(array2, depth, predicate, isStrict, result) {
  var index3 = -1, length = array2.length;
  predicate || (predicate = _isFlattenable);
  result || (result = []);
  while (++index3 < length) {
    var value = array2[index3];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        _arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten;
function baseFindIndex(array2, predicate, fromIndex, fromRight) {
  var length = array2.length, index3 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index3-- : ++index3 < length) {
    if (predicate(array2[index3], index3, array2)) {
      return index3;
    }
  }
  return -1;
}
var _baseFindIndex = baseFindIndex;
function baseIsNaN(value) {
  return value !== value;
}
var _baseIsNaN = baseIsNaN;
function strictIndexOf(array2, value, fromIndex) {
  var index3 = fromIndex - 1, length = array2.length;
  while (++index3 < length) {
    if (array2[index3] === value) {
      return index3;
    }
  }
  return -1;
}
var _strictIndexOf = strictIndexOf;
function baseIndexOf(array2, value, fromIndex) {
  return value === value ? _strictIndexOf(array2, value, fromIndex) : _baseFindIndex(array2, _baseIsNaN, fromIndex);
}
var _baseIndexOf = baseIndexOf;
function arrayIncludes(array2, value) {
  var length = array2 == null ? 0 : array2.length;
  return !!length && _baseIndexOf(array2, value, 0) > -1;
}
var _arrayIncludes = arrayIncludes;
function arrayIncludesWith(array2, value, comparator) {
  var index3 = -1, length = array2 == null ? 0 : array2.length;
  while (++index3 < length) {
    if (comparator(value, array2[index3])) {
      return true;
    }
  }
  return false;
}
var _arrayIncludesWith = arrayIncludesWith;
function noop5() {
}
var noop_1 = noop5;
var INFINITY$2 = 1 / 0;
var createSet = !(_Set && 1 / _setToArray(new _Set([, -0]))[1] == INFINITY$2) ? noop_1 : function(values2) {
  return new _Set(values2);
};
var _createSet = createSet;
var LARGE_ARRAY_SIZE2 = 200;
function baseUniq(array2, iteratee, comparator) {
  var index3 = -1, includes = _arrayIncludes, length = array2.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes = _arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE2) {
    var set3 = iteratee ? null : _createSet(array2);
    if (set3) {
      return _setToArray(set3);
    }
    isCommon = false;
    includes = _cacheHas;
    seen = new _SetCache();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index3 < length) {
      var value = array2[index3], computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      } else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
var _baseUniq = baseUniq;
var union = _baseRest(function(arrays) {
  return _baseUniq(_baseFlatten(arrays, 1, isArrayLikeObject_1, true));
});
var union_1 = union;
function baseValues(object, props) {
  return _arrayMap(props, function(key) {
    return object[key];
  });
}
var _baseValues = baseValues;
function values(object) {
  return object == null ? [] : _baseValues(object, keys_1(object));
}
var values_1 = values;
var lodash2;
if (typeof commonjsRequire === "function") {
  try {
    lodash2 = {
      clone: clone_1,
      constant: constant_1,
      each,
      filter: filter_1,
      has: has_1,
      isArray: isArray_1,
      isEmpty: isEmpty_1,
      isFunction: isFunction_1,
      isUndefined: isUndefined_1,
      keys: keys_1,
      map: map_1,
      reduce: reduce_1,
      size: size_1,
      transform: transform_1,
      union: union_1,
      values: values_1
    };
  } catch (e3) {
  }
}
if (!lodash2) {
  lodash2 = window._;
}
var lodash_1 = lodash2;
var graph = Graph;
var DEFAULT_EDGE_NAME = "\0";
var GRAPH_NODE = "\0";
var EDGE_KEY_DELIM = "";
function Graph(opts) {
  this._isDirected = lodash_1.has(opts, "directed") ? opts.directed : true;
  this._isMultigraph = lodash_1.has(opts, "multigraph") ? opts.multigraph : false;
  this._isCompound = lodash_1.has(opts, "compound") ? opts.compound : false;
  this._label = void 0;
  this._defaultNodeLabelFn = lodash_1.constant(void 0);
  this._defaultEdgeLabelFn = lodash_1.constant(void 0);
  this._nodes = {};
  if (this._isCompound) {
    this._parent = {};
    this._children = {};
    this._children[GRAPH_NODE] = {};
  }
  this._in = {};
  this._preds = {};
  this._out = {};
  this._sucs = {};
  this._edgeObjs = {};
  this._edgeLabels = {};
}
Graph.prototype._nodeCount = 0;
Graph.prototype._edgeCount = 0;
Graph.prototype.isDirected = function() {
  return this._isDirected;
};
Graph.prototype.isMultigraph = function() {
  return this._isMultigraph;
};
Graph.prototype.isCompound = function() {
  return this._isCompound;
};
Graph.prototype.setGraph = function(label2) {
  this._label = label2;
  return this;
};
Graph.prototype.graph = function() {
  return this._label;
};
Graph.prototype.setDefaultNodeLabel = function(newDefault) {
  if (!lodash_1.isFunction(newDefault)) {
    newDefault = lodash_1.constant(newDefault);
  }
  this._defaultNodeLabelFn = newDefault;
  return this;
};
Graph.prototype.nodeCount = function() {
  return this._nodeCount;
};
Graph.prototype.nodes = function() {
  return lodash_1.keys(this._nodes);
};
Graph.prototype.sources = function() {
  var self2 = this;
  return lodash_1.filter(this.nodes(), function(v3) {
    return lodash_1.isEmpty(self2._in[v3]);
  });
};
Graph.prototype.sinks = function() {
  var self2 = this;
  return lodash_1.filter(this.nodes(), function(v3) {
    return lodash_1.isEmpty(self2._out[v3]);
  });
};
Graph.prototype.setNodes = function(vs, value) {
  var args = arguments;
  var self2 = this;
  lodash_1.each(vs, function(v3) {
    if (args.length > 1) {
      self2.setNode(v3, value);
    } else {
      self2.setNode(v3);
    }
  });
  return this;
};
Graph.prototype.setNode = function(v3, value) {
  if (lodash_1.has(this._nodes, v3)) {
    if (arguments.length > 1) {
      this._nodes[v3] = value;
    }
    return this;
  }
  this._nodes[v3] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v3);
  if (this._isCompound) {
    this._parent[v3] = GRAPH_NODE;
    this._children[v3] = {};
    this._children[GRAPH_NODE][v3] = true;
  }
  this._in[v3] = {};
  this._preds[v3] = {};
  this._out[v3] = {};
  this._sucs[v3] = {};
  ++this._nodeCount;
  return this;
};
Graph.prototype.node = function(v3) {
  return this._nodes[v3];
};
Graph.prototype.hasNode = function(v3) {
  return lodash_1.has(this._nodes, v3);
};
Graph.prototype.removeNode = function(v3) {
  var self2 = this;
  if (lodash_1.has(this._nodes, v3)) {
    var removeEdge = function(e3) {
      self2.removeEdge(self2._edgeObjs[e3]);
    };
    delete this._nodes[v3];
    if (this._isCompound) {
      this._removeFromParentsChildList(v3);
      delete this._parent[v3];
      lodash_1.each(this.children(v3), function(child) {
        self2.setParent(child);
      });
      delete this._children[v3];
    }
    lodash_1.each(lodash_1.keys(this._in[v3]), removeEdge);
    delete this._in[v3];
    delete this._preds[v3];
    lodash_1.each(lodash_1.keys(this._out[v3]), removeEdge);
    delete this._out[v3];
    delete this._sucs[v3];
    --this._nodeCount;
  }
  return this;
};
Graph.prototype.setParent = function(v3, parent) {
  if (!this._isCompound) {
    throw new Error("Cannot set parent in a non-compound graph");
  }
  if (lodash_1.isUndefined(parent)) {
    parent = GRAPH_NODE;
  } else {
    parent += "";
    for (var ancestor = parent; !lodash_1.isUndefined(ancestor); ancestor = this.parent(ancestor)) {
      if (ancestor === v3) {
        throw new Error("Setting " + parent + " as parent of " + v3 + " would create a cycle");
      }
    }
    this.setNode(parent);
  }
  this.setNode(v3);
  this._removeFromParentsChildList(v3);
  this._parent[v3] = parent;
  this._children[parent][v3] = true;
  return this;
};
Graph.prototype._removeFromParentsChildList = function(v3) {
  delete this._children[this._parent[v3]][v3];
};
Graph.prototype.parent = function(v3) {
  if (this._isCompound) {
    var parent = this._parent[v3];
    if (parent !== GRAPH_NODE) {
      return parent;
    }
  }
};
Graph.prototype.children = function(v3) {
  if (lodash_1.isUndefined(v3)) {
    v3 = GRAPH_NODE;
  }
  if (this._isCompound) {
    var children2 = this._children[v3];
    if (children2) {
      return lodash_1.keys(children2);
    }
  } else if (v3 === GRAPH_NODE) {
    return this.nodes();
  } else if (this.hasNode(v3)) {
    return [];
  }
};
Graph.prototype.predecessors = function(v3) {
  var predsV = this._preds[v3];
  if (predsV) {
    return lodash_1.keys(predsV);
  }
};
Graph.prototype.successors = function(v3) {
  var sucsV = this._sucs[v3];
  if (sucsV) {
    return lodash_1.keys(sucsV);
  }
};
Graph.prototype.neighbors = function(v3) {
  var preds = this.predecessors(v3);
  if (preds) {
    return lodash_1.union(preds, this.successors(v3));
  }
};
Graph.prototype.isLeaf = function(v3) {
  var neighbors;
  if (this.isDirected()) {
    neighbors = this.successors(v3);
  } else {
    neighbors = this.neighbors(v3);
  }
  return neighbors.length === 0;
};
Graph.prototype.filterNodes = function(filter3) {
  var copy2 = new this.constructor({
    directed: this._isDirected,
    multigraph: this._isMultigraph,
    compound: this._isCompound
  });
  copy2.setGraph(this.graph());
  var self2 = this;
  lodash_1.each(this._nodes, function(value, v3) {
    if (filter3(v3)) {
      copy2.setNode(v3, value);
    }
  });
  lodash_1.each(this._edgeObjs, function(e3) {
    if (copy2.hasNode(e3.v) && copy2.hasNode(e3.w)) {
      copy2.setEdge(e3, self2.edge(e3));
    }
  });
  var parents = {};
  function findParent(v3) {
    var parent = self2.parent(v3);
    if (parent === void 0 || copy2.hasNode(parent)) {
      parents[v3] = parent;
      return parent;
    } else if (parent in parents) {
      return parents[parent];
    } else {
      return findParent(parent);
    }
  }
  if (this._isCompound) {
    lodash_1.each(copy2.nodes(), function(v3) {
      copy2.setParent(v3, findParent(v3));
    });
  }
  return copy2;
};
Graph.prototype.setDefaultEdgeLabel = function(newDefault) {
  if (!lodash_1.isFunction(newDefault)) {
    newDefault = lodash_1.constant(newDefault);
  }
  this._defaultEdgeLabelFn = newDefault;
  return this;
};
Graph.prototype.edgeCount = function() {
  return this._edgeCount;
};
Graph.prototype.edges = function() {
  return lodash_1.values(this._edgeObjs);
};
Graph.prototype.setPath = function(vs, value) {
  var self2 = this;
  var args = arguments;
  lodash_1.reduce(vs, function(v3, w3) {
    if (args.length > 1) {
      self2.setEdge(v3, w3, value);
    } else {
      self2.setEdge(v3, w3);
    }
    return w3;
  });
  return this;
};
Graph.prototype.setEdge = function() {
  var v3, w3, name, value;
  var valueSpecified = false;
  var arg0 = arguments[0];
  if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
    v3 = arg0.v;
    w3 = arg0.w;
    name = arg0.name;
    if (arguments.length === 2) {
      value = arguments[1];
      valueSpecified = true;
    }
  } else {
    v3 = arg0;
    w3 = arguments[1];
    name = arguments[3];
    if (arguments.length > 2) {
      value = arguments[2];
      valueSpecified = true;
    }
  }
  v3 = "" + v3;
  w3 = "" + w3;
  if (!lodash_1.isUndefined(name)) {
    name = "" + name;
  }
  var e3 = edgeArgsToId(this._isDirected, v3, w3, name);
  if (lodash_1.has(this._edgeLabels, e3)) {
    if (valueSpecified) {
      this._edgeLabels[e3] = value;
    }
    return this;
  }
  if (!lodash_1.isUndefined(name) && !this._isMultigraph) {
    throw new Error("Cannot set a named edge when isMultigraph = false");
  }
  this.setNode(v3);
  this.setNode(w3);
  this._edgeLabels[e3] = valueSpecified ? value : this._defaultEdgeLabelFn(v3, w3, name);
  var edgeObj = edgeArgsToObj(this._isDirected, v3, w3, name);
  v3 = edgeObj.v;
  w3 = edgeObj.w;
  Object.freeze(edgeObj);
  this._edgeObjs[e3] = edgeObj;
  incrementOrInitEntry(this._preds[w3], v3);
  incrementOrInitEntry(this._sucs[v3], w3);
  this._in[w3][e3] = edgeObj;
  this._out[v3][e3] = edgeObj;
  this._edgeCount++;
  return this;
};
Graph.prototype.edge = function(v3, w3, name) {
  var e3 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v3, w3, name);
  return this._edgeLabels[e3];
};
Graph.prototype.hasEdge = function(v3, w3, name) {
  var e3 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v3, w3, name);
  return lodash_1.has(this._edgeLabels, e3);
};
Graph.prototype.removeEdge = function(v3, w3, name) {
  var e3 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v3, w3, name);
  var edge = this._edgeObjs[e3];
  if (edge) {
    v3 = edge.v;
    w3 = edge.w;
    delete this._edgeLabels[e3];
    delete this._edgeObjs[e3];
    decrementOrRemoveEntry(this._preds[w3], v3);
    decrementOrRemoveEntry(this._sucs[v3], w3);
    delete this._in[w3][e3];
    delete this._out[v3][e3];
    this._edgeCount--;
  }
  return this;
};
Graph.prototype.inEdges = function(v3, u) {
  var inV = this._in[v3];
  if (inV) {
    var edges = lodash_1.values(inV);
    if (!u) {
      return edges;
    }
    return lodash_1.filter(edges, function(edge) {
      return edge.v === u;
    });
  }
};
Graph.prototype.outEdges = function(v3, w3) {
  var outV = this._out[v3];
  if (outV) {
    var edges = lodash_1.values(outV);
    if (!w3) {
      return edges;
    }
    return lodash_1.filter(edges, function(edge) {
      return edge.w === w3;
    });
  }
};
Graph.prototype.nodeEdges = function(v3, w3) {
  var inEdges = this.inEdges(v3, w3);
  if (inEdges) {
    return inEdges.concat(this.outEdges(v3, w3));
  }
};
function incrementOrInitEntry(map3, k3) {
  if (map3[k3]) {
    map3[k3]++;
  } else {
    map3[k3] = 1;
  }
}
function decrementOrRemoveEntry(map3, k3) {
  if (!--map3[k3]) {
    delete map3[k3];
  }
}
function edgeArgsToId(isDirected, v_, w_, name) {
  var v3 = "" + v_;
  var w3 = "" + w_;
  if (!isDirected && v3 > w3) {
    var tmp = v3;
    v3 = w3;
    w3 = tmp;
  }
  return v3 + EDGE_KEY_DELIM + w3 + EDGE_KEY_DELIM + (lodash_1.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
}
function edgeArgsToObj(isDirected, v_, w_, name) {
  var v3 = "" + v_;
  var w3 = "" + w_;
  if (!isDirected && v3 > w3) {
    var tmp = v3;
    v3 = w3;
    w3 = tmp;
  }
  var edgeObj = {v: v3, w: w3};
  if (name) {
    edgeObj.name = name;
  }
  return edgeObj;
}
function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}
var version3 = "2.1.8";
var lib2 = {
  Graph: graph,
  version: version3
};
var json = {
  write: write2,
  read: read2
};
function write2(g3) {
  var json2 = {
    options: {
      directed: g3.isDirected(),
      multigraph: g3.isMultigraph(),
      compound: g3.isCompound()
    },
    nodes: writeNodes(g3),
    edges: writeEdges(g3)
  };
  if (!lodash_1.isUndefined(g3.graph())) {
    json2.value = lodash_1.clone(g3.graph());
  }
  return json2;
}
function writeNodes(g3) {
  return lodash_1.map(g3.nodes(), function(v3) {
    var nodeValue = g3.node(v3);
    var parent = g3.parent(v3);
    var node = {v: v3};
    if (!lodash_1.isUndefined(nodeValue)) {
      node.value = nodeValue;
    }
    if (!lodash_1.isUndefined(parent)) {
      node.parent = parent;
    }
    return node;
  });
}
function writeEdges(g3) {
  return lodash_1.map(g3.edges(), function(e3) {
    var edgeValue = g3.edge(e3);
    var edge = {v: e3.v, w: e3.w};
    if (!lodash_1.isUndefined(e3.name)) {
      edge.name = e3.name;
    }
    if (!lodash_1.isUndefined(edgeValue)) {
      edge.value = edgeValue;
    }
    return edge;
  });
}
function read2(json2) {
  var g3 = new graph(json2.options).setGraph(json2.value);
  lodash_1.each(json2.nodes, function(entry) {
    g3.setNode(entry.v, entry.value);
    if (entry.parent) {
      g3.setParent(entry.v, entry.parent);
    }
  });
  lodash_1.each(json2.edges, function(entry) {
    g3.setEdge({v: entry.v, w: entry.w, name: entry.name}, entry.value);
  });
  return g3;
}
var components_1 = components2;
function components2(g3) {
  var visited = {};
  var cmpts = [];
  var cmpt;
  function dfs2(v3) {
    if (lodash_1.has(visited, v3))
      return;
    visited[v3] = true;
    cmpt.push(v3);
    lodash_1.each(g3.successors(v3), dfs2);
    lodash_1.each(g3.predecessors(v3), dfs2);
  }
  lodash_1.each(g3.nodes(), function(v3) {
    cmpt = [];
    dfs2(v3);
    if (cmpt.length) {
      cmpts.push(cmpt);
    }
  });
  return cmpts;
}
var priorityQueue = PriorityQueue;
function PriorityQueue() {
  this._arr = [];
  this._keyIndices = {};
}
PriorityQueue.prototype.size = function() {
  return this._arr.length;
};
PriorityQueue.prototype.keys = function() {
  return this._arr.map(function(x3) {
    return x3.key;
  });
};
PriorityQueue.prototype.has = function(key) {
  return lodash_1.has(this._keyIndices, key);
};
PriorityQueue.prototype.priority = function(key) {
  var index3 = this._keyIndices[key];
  if (index3 !== void 0) {
    return this._arr[index3].priority;
  }
};
PriorityQueue.prototype.min = function() {
  if (this.size() === 0) {
    throw new Error("Queue underflow");
  }
  return this._arr[0].key;
};
PriorityQueue.prototype.add = function(key, priority) {
  var keyIndices = this._keyIndices;
  key = String(key);
  if (!lodash_1.has(keyIndices, key)) {
    var arr = this._arr;
    var index3 = arr.length;
    keyIndices[key] = index3;
    arr.push({key, priority});
    this._decrease(index3);
    return true;
  }
  return false;
};
PriorityQueue.prototype.removeMin = function() {
  this._swap(0, this._arr.length - 1);
  var min2 = this._arr.pop();
  delete this._keyIndices[min2.key];
  this._heapify(0);
  return min2.key;
};
PriorityQueue.prototype.decrease = function(key, priority) {
  var index3 = this._keyIndices[key];
  if (priority > this._arr[index3].priority) {
    throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index3].priority + " New: " + priority);
  }
  this._arr[index3].priority = priority;
  this._decrease(index3);
};
PriorityQueue.prototype._heapify = function(i3) {
  var arr = this._arr;
  var l3 = 2 * i3;
  var r4 = l3 + 1;
  var largest = i3;
  if (l3 < arr.length) {
    largest = arr[l3].priority < arr[largest].priority ? l3 : largest;
    if (r4 < arr.length) {
      largest = arr[r4].priority < arr[largest].priority ? r4 : largest;
    }
    if (largest !== i3) {
      this._swap(i3, largest);
      this._heapify(largest);
    }
  }
};
PriorityQueue.prototype._decrease = function(index3) {
  var arr = this._arr;
  var priority = arr[index3].priority;
  var parent;
  while (index3 !== 0) {
    parent = index3 >> 1;
    if (arr[parent].priority < priority) {
      break;
    }
    this._swap(index3, parent);
    index3 = parent;
  }
};
PriorityQueue.prototype._swap = function(i3, j) {
  var arr = this._arr;
  var keyIndices = this._keyIndices;
  var origArrI = arr[i3];
  var origArrJ = arr[j];
  arr[i3] = origArrJ;
  arr[j] = origArrI;
  keyIndices[origArrJ.key] = i3;
  keyIndices[origArrI.key] = j;
};
var dijkstra_1 = dijkstra;
var DEFAULT_WEIGHT_FUNC = lodash_1.constant(1);
function dijkstra(g3, source2, weightFn, edgeFn) {
  return runDijkstra(g3, String(source2), weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function(v3) {
    return g3.outEdges(v3);
  });
}
function runDijkstra(g3, source2, weightFn, edgeFn) {
  var results = {};
  var pq = new priorityQueue();
  var v3, vEntry;
  var updateNeighbors = function(edge) {
    var w3 = edge.v !== v3 ? edge.v : edge.w;
    var wEntry = results[w3];
    var weight = weightFn(edge);
    var distance = vEntry.distance + weight;
    if (weight < 0) {
      throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
    }
    if (distance < wEntry.distance) {
      wEntry.distance = distance;
      wEntry.predecessor = v3;
      pq.decrease(w3, distance);
    }
  };
  g3.nodes().forEach(function(v4) {
    var distance = v4 === source2 ? 0 : Number.POSITIVE_INFINITY;
    results[v4] = {distance};
    pq.add(v4, distance);
  });
  while (pq.size() > 0) {
    v3 = pq.removeMin();
    vEntry = results[v3];
    if (vEntry.distance === Number.POSITIVE_INFINITY) {
      break;
    }
    edgeFn(v3).forEach(updateNeighbors);
  }
  return results;
}
var dijkstraAll_1 = dijkstraAll;
function dijkstraAll(g3, weightFunc, edgeFunc) {
  return lodash_1.transform(g3.nodes(), function(acc, v3) {
    acc[v3] = dijkstra_1(g3, v3, weightFunc, edgeFunc);
  }, {});
}
var tarjan_1 = tarjan;
function tarjan(g3) {
  var index3 = 0;
  var stack2 = [];
  var visited = {};
  var results = [];
  function dfs2(v3) {
    var entry = visited[v3] = {
      onStack: true,
      lowlink: index3,
      index: index3++
    };
    stack2.push(v3);
    g3.successors(v3).forEach(function(w4) {
      if (!lodash_1.has(visited, w4)) {
        dfs2(w4);
        entry.lowlink = Math.min(entry.lowlink, visited[w4].lowlink);
      } else if (visited[w4].onStack) {
        entry.lowlink = Math.min(entry.lowlink, visited[w4].index);
      }
    });
    if (entry.lowlink === entry.index) {
      var cmpt = [];
      var w3;
      do {
        w3 = stack2.pop();
        visited[w3].onStack = false;
        cmpt.push(w3);
      } while (v3 !== w3);
      results.push(cmpt);
    }
  }
  g3.nodes().forEach(function(v3) {
    if (!lodash_1.has(visited, v3)) {
      dfs2(v3);
    }
  });
  return results;
}
var findCycles_1 = findCycles;
function findCycles(g3) {
  return lodash_1.filter(tarjan_1(g3), function(cmpt) {
    return cmpt.length > 1 || cmpt.length === 1 && g3.hasEdge(cmpt[0], cmpt[0]);
  });
}
var floydWarshall_1 = floydWarshall;
var DEFAULT_WEIGHT_FUNC$1 = lodash_1.constant(1);
function floydWarshall(g3, weightFn, edgeFn) {
  return runFloydWarshall(g3, weightFn || DEFAULT_WEIGHT_FUNC$1, edgeFn || function(v3) {
    return g3.outEdges(v3);
  });
}
function runFloydWarshall(g3, weightFn, edgeFn) {
  var results = {};
  var nodes = g3.nodes();
  nodes.forEach(function(v3) {
    results[v3] = {};
    results[v3][v3] = {distance: 0};
    nodes.forEach(function(w3) {
      if (v3 !== w3) {
        results[v3][w3] = {distance: Number.POSITIVE_INFINITY};
      }
    });
    edgeFn(v3).forEach(function(edge) {
      var w3 = edge.v === v3 ? edge.w : edge.v;
      var d3 = weightFn(edge);
      results[v3][w3] = {distance: d3, predecessor: v3};
    });
  });
  nodes.forEach(function(k3) {
    var rowK = results[k3];
    nodes.forEach(function(i3) {
      var rowI = results[i3];
      nodes.forEach(function(j) {
        var ik2 = rowI[k3];
        var kj2 = rowK[j];
        var ij2 = rowI[j];
        var altDistance = ik2.distance + kj2.distance;
        if (altDistance < ij2.distance) {
          ij2.distance = altDistance;
          ij2.predecessor = kj2.predecessor;
        }
      });
    });
  });
  return results;
}
var topsort_1 = topsort;
topsort.CycleException = CycleException;
function topsort(g3) {
  var visited = {};
  var stack2 = {};
  var results = [];
  function visit(node) {
    if (lodash_1.has(stack2, node)) {
      throw new CycleException();
    }
    if (!lodash_1.has(visited, node)) {
      stack2[node] = true;
      visited[node] = true;
      lodash_1.each(g3.predecessors(node), visit);
      delete stack2[node];
      results.push(node);
    }
  }
  lodash_1.each(g3.sinks(), visit);
  if (lodash_1.size(visited) !== g3.nodeCount()) {
    throw new CycleException();
  }
  return results;
}
function CycleException() {
}
CycleException.prototype = new Error();
var isAcyclic_1 = isAcyclic;
function isAcyclic(g3) {
  try {
    topsort_1(g3);
  } catch (e3) {
    if (e3 instanceof topsort_1.CycleException) {
      return false;
    }
    throw e3;
  }
  return true;
}
var dfs_1 = dfs;
function dfs(g3, vs, order3) {
  if (!lodash_1.isArray(vs)) {
    vs = [vs];
  }
  var navigation = (g3.isDirected() ? g3.successors : g3.neighbors).bind(g3);
  var acc = [];
  var visited = {};
  lodash_1.each(vs, function(v3) {
    if (!g3.hasNode(v3)) {
      throw new Error("Graph does not have node: " + v3);
    }
    doDfs(g3, v3, order3 === "post", visited, navigation, acc);
  });
  return acc;
}
function doDfs(g3, v3, postorder2, visited, navigation, acc) {
  if (!lodash_1.has(visited, v3)) {
    visited[v3] = true;
    if (!postorder2) {
      acc.push(v3);
    }
    lodash_1.each(navigation(v3), function(w3) {
      doDfs(g3, w3, postorder2, visited, navigation, acc);
    });
    if (postorder2) {
      acc.push(v3);
    }
  }
}
var postorder_1 = postorder;
function postorder(g3, vs) {
  return dfs_1(g3, vs, "post");
}
var preorder_1 = preorder;
function preorder(g3, vs) {
  return dfs_1(g3, vs, "pre");
}
var prim_1 = prim;
function prim(g3, weightFunc) {
  var result = new graph();
  var parents = {};
  var pq = new priorityQueue();
  var v3;
  function updateNeighbors(edge) {
    var w3 = edge.v === v3 ? edge.w : edge.v;
    var pri = pq.priority(w3);
    if (pri !== void 0) {
      var edgeWeight = weightFunc(edge);
      if (edgeWeight < pri) {
        parents[w3] = v3;
        pq.decrease(w3, edgeWeight);
      }
    }
  }
  if (g3.nodeCount() === 0) {
    return result;
  }
  lodash_1.each(g3.nodes(), function(v4) {
    pq.add(v4, Number.POSITIVE_INFINITY);
    result.setNode(v4);
  });
  pq.decrease(g3.nodes()[0], 0);
  var init3 = false;
  while (pq.size() > 0) {
    v3 = pq.removeMin();
    if (lodash_1.has(parents, v3)) {
      result.setEdge(v3, parents[v3]);
    } else if (init3) {
      throw new Error("Input graph is not connected: " + g3);
    } else {
      init3 = true;
    }
    g3.nodeEdges(v3).forEach(updateNeighbors);
  }
  return result;
}
var alg = {
  components: components_1,
  dijkstra: dijkstra_1,
  dijkstraAll: dijkstraAll_1,
  findCycles: findCycles_1,
  floydWarshall: floydWarshall_1,
  isAcyclic: isAcyclic_1,
  postorder: postorder_1,
  preorder: preorder_1,
  prim: prim_1,
  tarjan: tarjan_1,
  topsort: topsort_1
};
var graphlib = {
  Graph: lib2.Graph,
  json,
  alg,
  version: lib2.version
};
var graphlib$1;
if (typeof commonjsRequire === "function") {
  try {
    graphlib$1 = graphlib;
  } catch (e3) {
  }
}
if (!graphlib$1) {
  graphlib$1 = window.graphlib;
}
var graphlib_1 = graphlib$1;
var CLONE_DEEP_FLAG$1 = 1;
var CLONE_SYMBOLS_FLAG$2 = 4;
function cloneDeep(value) {
  return _baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$2);
}
var cloneDeep_1 = cloneDeep;
var objectProto$32 = Object.prototype;
var hasOwnProperty$32 = objectProto$32.hasOwnProperty;
var defaults2 = _baseRest(function(object, sources) {
  object = Object(object);
  var index3 = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : void 0;
  if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }
  while (++index3 < length) {
    var source2 = sources[index3];
    var props = keysIn_1(source2);
    var propsIndex = -1;
    var propsLength = props.length;
    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];
      if (value === void 0 || eq_1(value, objectProto$32[key]) && !hasOwnProperty$32.call(object, key)) {
        object[key] = source2[key];
      }
    }
  }
  return object;
});
var defaults_12 = defaults2;
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike_1(collection)) {
      var iteratee = _baseIteratee(predicate);
      collection = keys_1(collection);
      predicate = function(key) {
        return iteratee(iterable[key], key, iterable);
      };
    }
    var index3 = findIndexFunc(collection, predicate, fromIndex);
    return index3 > -1 ? iterable[iteratee ? collection[index3] : index3] : void 0;
  };
}
var _createFind = createFind;
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index3 = string.length;
  while (index3-- && reWhitespace.test(string.charAt(index3))) {
  }
  return index3;
}
var _trimmedEndIndex = trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_1(value)) {
    return NAN;
  }
  if (isObject_1(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_1(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = _baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber;
var INFINITY$3 = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber_1(value);
  if (value === INFINITY$3 || value === -INFINITY$3) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_1 = toFinite;
function toInteger(value) {
  var result = toFinite_1(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_1 = toInteger;
var nativeMax2 = Math.max;
function findIndex(array2, predicate, fromIndex) {
  var length = array2 == null ? 0 : array2.length;
  if (!length) {
    return -1;
  }
  var index3 = fromIndex == null ? 0 : toInteger_1(fromIndex);
  if (index3 < 0) {
    index3 = nativeMax2(length + index3, 0);
  }
  return _baseFindIndex(array2, _baseIteratee(predicate), index3);
}
var findIndex_1 = findIndex;
var find2 = _createFind(findIndex_1);
var find_1 = find2;
function flatten3(array2) {
  var length = array2 == null ? 0 : array2.length;
  return length ? _baseFlatten(array2, 1) : [];
}
var flatten_1 = flatten3;
function forIn(object, iteratee) {
  return object == null ? object : _baseFor(object, _castFunction(iteratee), keysIn_1);
}
var forIn_1 = forIn;
function last(array2) {
  var length = array2 == null ? 0 : array2.length;
  return length ? array2[length - 1] : void 0;
}
var last_1 = last;
function mapValues(object, iteratee) {
  var result = {};
  iteratee = _baseIteratee(iteratee);
  _baseForOwn(object, function(value, key, object2) {
    _baseAssignValue(result, key, iteratee(value, key, object2));
  });
  return result;
}
var mapValues_1 = mapValues;
function baseExtremum(array2, iteratee, comparator) {
  var index3 = -1, length = array2.length;
  while (++index3 < length) {
    var value = array2[index3], current = iteratee(value);
    if (current != null && (computed === void 0 ? current === current && !isSymbol_1(current) : comparator(current, computed))) {
      var computed = current, result = value;
    }
  }
  return result;
}
var _baseExtremum = baseExtremum;
function baseGt(value, other) {
  return value > other;
}
var _baseGt = baseGt;
function max(array2) {
  return array2 && array2.length ? _baseExtremum(array2, identity_1, _baseGt) : void 0;
}
var max_1 = max;
var merge2 = _createAssigner(function(object, source2, srcIndex) {
  _baseMerge(object, source2, srcIndex);
});
var merge_1 = merge2;
function baseLt(value, other) {
  return value < other;
}
var _baseLt = baseLt;
function min(array2) {
  return array2 && array2.length ? _baseExtremum(array2, identity_1, _baseLt) : void 0;
}
var min_1 = min;
function minBy(array2, iteratee) {
  return array2 && array2.length ? _baseExtremum(array2, _baseIteratee(iteratee), _baseLt) : void 0;
}
var minBy_1 = minBy;
var now2 = function() {
  return _root.Date.now();
};
var now_1 = now2;
function baseSet(object, path, value, customizer) {
  if (!isObject_1(object)) {
    return object;
  }
  path = _castPath(path, object);
  var index3 = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index3 < length) {
    var key = _toKey(path[index3]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index3 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_1(objValue) ? objValue : _isIndex(path[index3 + 1]) ? [] : {};
      }
    }
    _assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var _baseSet = baseSet;
function basePickBy(object, paths, predicate) {
  var index3 = -1, length = paths.length, result = {};
  while (++index3 < length) {
    var path = paths[index3], value = _baseGet(object, path);
    if (predicate(value, path)) {
      _baseSet(result, _castPath(path, object), value);
    }
  }
  return result;
}
var _basePickBy = basePickBy;
function basePick(object, paths) {
  return _basePickBy(object, paths, function(value, path) {
    return hasIn_1(object, path);
  });
}
var _basePick = basePick;
function flatRest(func) {
  return _setToString(_overRest(func, void 0, flatten_1), func + "");
}
var _flatRest = flatRest;
var pick = _flatRest(function(object, paths) {
  return object == null ? {} : _basePick(object, paths);
});
var pick_1 = pick;
var nativeCeil = Math.ceil;
var nativeMax$1 = Math.max;
function baseRange(start3, end2, step, fromRight) {
  var index3 = -1, length = nativeMax$1(nativeCeil((end2 - start3) / (step || 1)), 0), result = Array(length);
  while (length--) {
    result[fromRight ? length : ++index3] = start3;
    start3 += step;
  }
  return result;
}
var _baseRange = baseRange;
function createRange(fromRight) {
  return function(start3, end2, step) {
    if (step && typeof step != "number" && _isIterateeCall(start3, end2, step)) {
      end2 = step = void 0;
    }
    start3 = toFinite_1(start3);
    if (end2 === void 0) {
      end2 = start3;
      start3 = 0;
    } else {
      end2 = toFinite_1(end2);
    }
    step = step === void 0 ? start3 < end2 ? 1 : -1 : toFinite_1(step);
    return _baseRange(start3, end2, step, fromRight);
  };
}
var _createRange = createRange;
var range = _createRange();
var range_1 = range;
function baseSortBy(array2, comparer) {
  var length = array2.length;
  array2.sort(comparer);
  while (length--) {
    array2[length] = array2[length].value;
  }
  return array2;
}
var _baseSortBy = baseSortBy;
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol_1(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol_1(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
var _compareAscending = compareAscending;
function compareMultiple(object, other, orders) {
  var index3 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
  while (++index3 < length) {
    var result = _compareAscending(objCriteria[index3], othCriteria[index3]);
    if (result) {
      if (index3 >= ordersLength) {
        return result;
      }
      var order3 = orders[index3];
      return result * (order3 == "desc" ? -1 : 1);
    }
  }
  return object.index - other.index;
}
var _compareMultiple = compareMultiple;
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = _arrayMap(iteratees, function(iteratee) {
      if (isArray_1(iteratee)) {
        return function(value) {
          return _baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        };
      }
      return iteratee;
    });
  } else {
    iteratees = [identity_1];
  }
  var index3 = -1;
  iteratees = _arrayMap(iteratees, _baseUnary(_baseIteratee));
  var result = _baseMap(collection, function(value, key, collection2) {
    var criteria = _arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return {criteria, index: ++index3, value};
  });
  return _baseSortBy(result, function(object, other) {
    return _compareMultiple(object, other, orders);
  });
}
var _baseOrderBy = baseOrderBy;
var sortBy = _baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && _isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && _isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return _baseOrderBy(collection, _baseFlatten(iteratees, 1), []);
});
var sortBy_1 = sortBy;
var idCounter = 0;
function uniqueId(prefix2) {
  var id3 = ++idCounter;
  return toString_1(prefix2) + id3;
}
var uniqueId_1 = uniqueId;
function baseZipObject(props, values2, assignFunc) {
  var index3 = -1, length = props.length, valsLength = values2.length, result = {};
  while (++index3 < length) {
    var value = index3 < valsLength ? values2[index3] : void 0;
    assignFunc(result, props[index3], value);
  }
  return result;
}
var _baseZipObject = baseZipObject;
function zipObject(props, values2) {
  return _baseZipObject(props || [], values2 || [], _assignValue);
}
var zipObject_1 = zipObject;
var lodash$1;
if (typeof commonjsRequire === "function") {
  try {
    lodash$1 = {
      cloneDeep: cloneDeep_1,
      constant: constant_1,
      defaults: defaults_12,
      each,
      filter: filter_1,
      find: find_1,
      flatten: flatten_1,
      forEach: forEach_1,
      forIn: forIn_1,
      has: has_1,
      isUndefined: isUndefined_1,
      last: last_1,
      map: map_1,
      mapValues: mapValues_1,
      max: max_1,
      merge: merge_1,
      min: min_1,
      minBy: minBy_1,
      now: now_1,
      pick: pick_1,
      range: range_1,
      reduce: reduce_1,
      sortBy: sortBy_1,
      uniqueId: uniqueId_1,
      values: values_1,
      zipObject: zipObject_1
    };
  } catch (e3) {
  }
}
if (!lodash$1) {
  lodash$1 = window._;
}
var lodash_1$1 = lodash$1;
var list2 = List2;
function List2() {
  var sentinel = {};
  sentinel._next = sentinel._prev = sentinel;
  this._sentinel = sentinel;
}
List2.prototype.dequeue = function() {
  var sentinel = this._sentinel;
  var entry = sentinel._prev;
  if (entry !== sentinel) {
    unlink(entry);
    return entry;
  }
};
List2.prototype.enqueue = function(entry) {
  var sentinel = this._sentinel;
  if (entry._prev && entry._next) {
    unlink(entry);
  }
  entry._next = sentinel._next;
  sentinel._next._prev = entry;
  sentinel._next = entry;
  entry._prev = sentinel;
};
List2.prototype.toString = function() {
  var strs = [];
  var sentinel = this._sentinel;
  var curr = sentinel._prev;
  while (curr !== sentinel) {
    strs.push(JSON.stringify(curr, filterOutLinks));
    curr = curr._prev;
  }
  return "[" + strs.join(", ") + "]";
};
function unlink(entry) {
  entry._prev._next = entry._next;
  entry._next._prev = entry._prev;
  delete entry._next;
  delete entry._prev;
}
function filterOutLinks(k3, v3) {
  if (k3 !== "_next" && k3 !== "_prev") {
    return v3;
  }
}
var Graph$1 = graphlib_1.Graph;
var greedyFas = greedyFAS;
var DEFAULT_WEIGHT_FN = lodash_1$1.constant(1);
function greedyFAS(g3, weightFn) {
  if (g3.nodeCount() <= 1) {
    return [];
  }
  var state = buildState(g3, weightFn || DEFAULT_WEIGHT_FN);
  var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
  return lodash_1$1.flatten(lodash_1$1.map(results, function(e3) {
    return g3.outEdges(e3.v, e3.w);
  }), true);
}
function doGreedyFAS(g3, buckets, zeroIdx) {
  var results = [];
  var sources = buckets[buckets.length - 1];
  var sinks = buckets[0];
  var entry;
  while (g3.nodeCount()) {
    while (entry = sinks.dequeue()) {
      removeNode(g3, buckets, zeroIdx, entry);
    }
    while (entry = sources.dequeue()) {
      removeNode(g3, buckets, zeroIdx, entry);
    }
    if (g3.nodeCount()) {
      for (var i3 = buckets.length - 2; i3 > 0; --i3) {
        entry = buckets[i3].dequeue();
        if (entry) {
          results = results.concat(removeNode(g3, buckets, zeroIdx, entry, true));
          break;
        }
      }
    }
  }
  return results;
}
function removeNode(g3, buckets, zeroIdx, entry, collectPredecessors) {
  var results = collectPredecessors ? [] : void 0;
  lodash_1$1.forEach(g3.inEdges(entry.v), function(edge) {
    var weight = g3.edge(edge);
    var uEntry = g3.node(edge.v);
    if (collectPredecessors) {
      results.push({v: edge.v, w: edge.w});
    }
    uEntry.out -= weight;
    assignBucket(buckets, zeroIdx, uEntry);
  });
  lodash_1$1.forEach(g3.outEdges(entry.v), function(edge) {
    var weight = g3.edge(edge);
    var w3 = edge.w;
    var wEntry = g3.node(w3);
    wEntry["in"] -= weight;
    assignBucket(buckets, zeroIdx, wEntry);
  });
  g3.removeNode(entry.v);
  return results;
}
function buildState(g3, weightFn) {
  var fasGraph = new Graph$1();
  var maxIn = 0;
  var maxOut = 0;
  lodash_1$1.forEach(g3.nodes(), function(v3) {
    fasGraph.setNode(v3, {v: v3, in: 0, out: 0});
  });
  lodash_1$1.forEach(g3.edges(), function(e3) {
    var prevWeight = fasGraph.edge(e3.v, e3.w) || 0;
    var weight = weightFn(e3);
    var edgeWeight = prevWeight + weight;
    fasGraph.setEdge(e3.v, e3.w, edgeWeight);
    maxOut = Math.max(maxOut, fasGraph.node(e3.v).out += weight);
    maxIn = Math.max(maxIn, fasGraph.node(e3.w)["in"] += weight);
  });
  var buckets = lodash_1$1.range(maxOut + maxIn + 3).map(function() {
    return new list2();
  });
  var zeroIdx = maxIn + 1;
  lodash_1$1.forEach(fasGraph.nodes(), function(v3) {
    assignBucket(buckets, zeroIdx, fasGraph.node(v3));
  });
  return {graph: fasGraph, buckets, zeroIdx};
}
function assignBucket(buckets, zeroIdx, entry) {
  if (!entry.out) {
    buckets[0].enqueue(entry);
  } else if (!entry["in"]) {
    buckets[buckets.length - 1].enqueue(entry);
  } else {
    buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
  }
}
var acyclic = {
  run,
  undo
};
function run(g3) {
  var fas = g3.graph().acyclicer === "greedy" ? greedyFas(g3, weightFn(g3)) : dfsFAS(g3);
  lodash_1$1.forEach(fas, function(e3) {
    var label2 = g3.edge(e3);
    g3.removeEdge(e3);
    label2.forwardName = e3.name;
    label2.reversed = true;
    g3.setEdge(e3.w, e3.v, label2, lodash_1$1.uniqueId("rev"));
  });
  function weightFn(g4) {
    return function(e3) {
      return g4.edge(e3).weight;
    };
  }
}
function dfsFAS(g3) {
  var fas = [];
  var stack2 = {};
  var visited = {};
  function dfs2(v3) {
    if (lodash_1$1.has(visited, v3)) {
      return;
    }
    visited[v3] = true;
    stack2[v3] = true;
    lodash_1$1.forEach(g3.outEdges(v3), function(e3) {
      if (lodash_1$1.has(stack2, e3.w)) {
        fas.push(e3);
      } else {
        dfs2(e3.w);
      }
    });
    delete stack2[v3];
  }
  lodash_1$1.forEach(g3.nodes(), dfs2);
  return fas;
}
function undo(g3) {
  lodash_1$1.forEach(g3.edges(), function(e3) {
    var label2 = g3.edge(e3);
    if (label2.reversed) {
      g3.removeEdge(e3);
      var forwardName = label2.forwardName;
      delete label2.reversed;
      delete label2.forwardName;
      g3.setEdge(e3.w, e3.v, label2, forwardName);
    }
  });
}
var Graph$2 = graphlib_1.Graph;
var util = {
  addDummyNode,
  simplify,
  asNonCompoundGraph,
  successorWeights,
  predecessorWeights,
  intersectRect,
  buildLayerMatrix,
  normalizeRanks,
  removeEmptyRanks,
  addBorderNode,
  maxRank,
  partition,
  time,
  notime
};
function addDummyNode(g3, type, attrs, name) {
  var v3;
  do {
    v3 = lodash_1$1.uniqueId(name);
  } while (g3.hasNode(v3));
  attrs.dummy = type;
  g3.setNode(v3, attrs);
  return v3;
}
function simplify(g3) {
  var simplified = new Graph$2().setGraph(g3.graph());
  lodash_1$1.forEach(g3.nodes(), function(v3) {
    simplified.setNode(v3, g3.node(v3));
  });
  lodash_1$1.forEach(g3.edges(), function(e3) {
    var simpleLabel = simplified.edge(e3.v, e3.w) || {weight: 0, minlen: 1};
    var label2 = g3.edge(e3);
    simplified.setEdge(e3.v, e3.w, {
      weight: simpleLabel.weight + label2.weight,
      minlen: Math.max(simpleLabel.minlen, label2.minlen)
    });
  });
  return simplified;
}
function asNonCompoundGraph(g3) {
  var simplified = new Graph$2({multigraph: g3.isMultigraph()}).setGraph(g3.graph());
  lodash_1$1.forEach(g3.nodes(), function(v3) {
    if (!g3.children(v3).length) {
      simplified.setNode(v3, g3.node(v3));
    }
  });
  lodash_1$1.forEach(g3.edges(), function(e3) {
    simplified.setEdge(e3, g3.edge(e3));
  });
  return simplified;
}
function successorWeights(g3) {
  var weightMap = lodash_1$1.map(g3.nodes(), function(v3) {
    var sucs = {};
    lodash_1$1.forEach(g3.outEdges(v3), function(e3) {
      sucs[e3.w] = (sucs[e3.w] || 0) + g3.edge(e3).weight;
    });
    return sucs;
  });
  return lodash_1$1.zipObject(g3.nodes(), weightMap);
}
function predecessorWeights(g3) {
  var weightMap = lodash_1$1.map(g3.nodes(), function(v3) {
    var preds = {};
    lodash_1$1.forEach(g3.inEdges(v3), function(e3) {
      preds[e3.v] = (preds[e3.v] || 0) + g3.edge(e3).weight;
    });
    return preds;
  });
  return lodash_1$1.zipObject(g3.nodes(), weightMap);
}
function intersectRect(rect, point) {
  var x3 = rect.x;
  var y4 = rect.y;
  var dx = point.x - x3;
  var dy = point.y - y4;
  var w3 = rect.width / 2;
  var h3 = rect.height / 2;
  if (!dx && !dy) {
    throw new Error("Not possible to find intersection inside of the rectangle");
  }
  var sx, sy;
  if (Math.abs(dy) * w3 > Math.abs(dx) * h3) {
    if (dy < 0) {
      h3 = -h3;
    }
    sx = h3 * dx / dy;
    sy = h3;
  } else {
    if (dx < 0) {
      w3 = -w3;
    }
    sx = w3;
    sy = w3 * dy / dx;
  }
  return {x: x3 + sx, y: y4 + sy};
}
function buildLayerMatrix(g3) {
  var layering = lodash_1$1.map(lodash_1$1.range(maxRank(g3) + 1), function() {
    return [];
  });
  lodash_1$1.forEach(g3.nodes(), function(v3) {
    var node = g3.node(v3);
    var rank2 = node.rank;
    if (!lodash_1$1.isUndefined(rank2)) {
      layering[rank2][node.order] = v3;
    }
  });
  return layering;
}
function normalizeRanks(g3) {
  var min2 = lodash_1$1.min(lodash_1$1.map(g3.nodes(), function(v3) {
    return g3.node(v3).rank;
  }));
  lodash_1$1.forEach(g3.nodes(), function(v3) {
    var node = g3.node(v3);
    if (lodash_1$1.has(node, "rank")) {
      node.rank -= min2;
    }
  });
}
function removeEmptyRanks(g3) {
  var offset2 = lodash_1$1.min(lodash_1$1.map(g3.nodes(), function(v3) {
    return g3.node(v3).rank;
  }));
  var layers = [];
  lodash_1$1.forEach(g3.nodes(), function(v3) {
    var rank2 = g3.node(v3).rank - offset2;
    if (!layers[rank2]) {
      layers[rank2] = [];
    }
    layers[rank2].push(v3);
  });
  var delta = 0;
  var nodeRankFactor = g3.graph().nodeRankFactor;
  lodash_1$1.forEach(layers, function(vs, i3) {
    if (lodash_1$1.isUndefined(vs) && i3 % nodeRankFactor !== 0) {
      --delta;
    } else if (delta) {
      lodash_1$1.forEach(vs, function(v3) {
        g3.node(v3).rank += delta;
      });
    }
  });
}
function addBorderNode(g3, prefix2, rank2, order3) {
  var node = {
    width: 0,
    height: 0
  };
  if (arguments.length >= 4) {
    node.rank = rank2;
    node.order = order3;
  }
  return addDummyNode(g3, "border", node, prefix2);
}
function maxRank(g3) {
  return lodash_1$1.max(lodash_1$1.map(g3.nodes(), function(v3) {
    var rank2 = g3.node(v3).rank;
    if (!lodash_1$1.isUndefined(rank2)) {
      return rank2;
    }
  }));
}
function partition(collection, fn) {
  var result = {lhs: [], rhs: []};
  lodash_1$1.forEach(collection, function(value) {
    if (fn(value)) {
      result.lhs.push(value);
    } else {
      result.rhs.push(value);
    }
  });
  return result;
}
function time(name, fn) {
  var start3 = lodash_1$1.now();
  try {
    return fn();
  } finally {
    console.log(name + " time: " + (lodash_1$1.now() - start3) + "ms");
  }
}
function notime(name, fn) {
  return fn();
}
var normalize = {
  run: run$1,
  undo: undo$1
};
function run$1(g3) {
  g3.graph().dummyChains = [];
  lodash_1$1.forEach(g3.edges(), function(edge) {
    normalizeEdge(g3, edge);
  });
}
function normalizeEdge(g3, e3) {
  var v3 = e3.v;
  var vRank = g3.node(v3).rank;
  var w3 = e3.w;
  var wRank = g3.node(w3).rank;
  var name = e3.name;
  var edgeLabel = g3.edge(e3);
  var labelRank = edgeLabel.labelRank;
  if (wRank === vRank + 1)
    return;
  g3.removeEdge(e3);
  var dummy, attrs, i3;
  for (i3 = 0, ++vRank; vRank < wRank; ++i3, ++vRank) {
    edgeLabel.points = [];
    attrs = {
      width: 0,
      height: 0,
      edgeLabel,
      edgeObj: e3,
      rank: vRank
    };
    dummy = util.addDummyNode(g3, "edge", attrs, "_d");
    if (vRank === labelRank) {
      attrs.width = edgeLabel.width;
      attrs.height = edgeLabel.height;
      attrs.dummy = "edge-label";
      attrs.labelpos = edgeLabel.labelpos;
    }
    g3.setEdge(v3, dummy, {weight: edgeLabel.weight}, name);
    if (i3 === 0) {
      g3.graph().dummyChains.push(dummy);
    }
    v3 = dummy;
  }
  g3.setEdge(v3, w3, {weight: edgeLabel.weight}, name);
}
function undo$1(g3) {
  lodash_1$1.forEach(g3.graph().dummyChains, function(v3) {
    var node = g3.node(v3);
    var origLabel = node.edgeLabel;
    var w3;
    g3.setEdge(node.edgeObj, origLabel);
    while (node.dummy) {
      w3 = g3.successors(v3)[0];
      g3.removeNode(v3);
      origLabel.points.push({x: node.x, y: node.y});
      if (node.dummy === "edge-label") {
        origLabel.x = node.x;
        origLabel.y = node.y;
        origLabel.width = node.width;
        origLabel.height = node.height;
      }
      v3 = w3;
      node = g3.node(v3);
    }
  });
}
var util$1 = {
  longestPath,
  slack
};
function longestPath(g3) {
  var visited = {};
  function dfs2(v3) {
    var label2 = g3.node(v3);
    if (lodash_1$1.has(visited, v3)) {
      return label2.rank;
    }
    visited[v3] = true;
    var rank2 = lodash_1$1.min(lodash_1$1.map(g3.outEdges(v3), function(e3) {
      return dfs2(e3.w) - g3.edge(e3).minlen;
    }));
    if (rank2 === Number.POSITIVE_INFINITY || rank2 === void 0 || rank2 === null) {
      rank2 = 0;
    }
    return label2.rank = rank2;
  }
  lodash_1$1.forEach(g3.sources(), dfs2);
}
function slack(g3, e3) {
  return g3.node(e3.w).rank - g3.node(e3.v).rank - g3.edge(e3).minlen;
}
var Graph$3 = graphlib_1.Graph;
var slack$1 = util$1.slack;
var feasibleTree_1 = feasibleTree;
function feasibleTree(g3) {
  var t4 = new Graph$3({directed: false});
  var start3 = g3.nodes()[0];
  var size2 = g3.nodeCount();
  t4.setNode(start3, {});
  var edge, delta;
  while (tightTree(t4, g3) < size2) {
    edge = findMinSlackEdge(t4, g3);
    delta = t4.hasNode(edge.v) ? slack$1(g3, edge) : -slack$1(g3, edge);
    shiftRanks(t4, g3, delta);
  }
  return t4;
}
function tightTree(t4, g3) {
  function dfs2(v3) {
    lodash_1$1.forEach(g3.nodeEdges(v3), function(e3) {
      var edgeV = e3.v, w3 = v3 === edgeV ? e3.w : edgeV;
      if (!t4.hasNode(w3) && !slack$1(g3, e3)) {
        t4.setNode(w3, {});
        t4.setEdge(v3, w3, {});
        dfs2(w3);
      }
    });
  }
  lodash_1$1.forEach(t4.nodes(), dfs2);
  return t4.nodeCount();
}
function findMinSlackEdge(t4, g3) {
  return lodash_1$1.minBy(g3.edges(), function(e3) {
    if (t4.hasNode(e3.v) !== t4.hasNode(e3.w)) {
      return slack$1(g3, e3);
    }
  });
}
function shiftRanks(t4, g3, delta) {
  lodash_1$1.forEach(t4.nodes(), function(v3) {
    g3.node(v3).rank += delta;
  });
}
var slack$2 = util$1.slack;
var initRank = util$1.longestPath;
var preorder$1 = graphlib_1.alg.preorder;
var postorder$1 = graphlib_1.alg.postorder;
var simplify$1 = util.simplify;
var networkSimplex_1 = networkSimplex;
networkSimplex.initLowLimValues = initLowLimValues;
networkSimplex.initCutValues = initCutValues;
networkSimplex.calcCutValue = calcCutValue;
networkSimplex.leaveEdge = leaveEdge;
networkSimplex.enterEdge = enterEdge;
networkSimplex.exchangeEdges = exchangeEdges;
function networkSimplex(g3) {
  g3 = simplify$1(g3);
  initRank(g3);
  var t4 = feasibleTree_1(g3);
  initLowLimValues(t4);
  initCutValues(t4, g3);
  var e3, f3;
  while (e3 = leaveEdge(t4)) {
    f3 = enterEdge(t4, g3, e3);
    exchangeEdges(t4, g3, e3, f3);
  }
}
function initCutValues(t4, g3) {
  var vs = postorder$1(t4, t4.nodes());
  vs = vs.slice(0, vs.length - 1);
  lodash_1$1.forEach(vs, function(v3) {
    assignCutValue(t4, g3, v3);
  });
}
function assignCutValue(t4, g3, child) {
  var childLab = t4.node(child);
  var parent = childLab.parent;
  t4.edge(child, parent).cutvalue = calcCutValue(t4, g3, child);
}
function calcCutValue(t4, g3, child) {
  var childLab = t4.node(child);
  var parent = childLab.parent;
  var childIsTail = true;
  var graphEdge = g3.edge(child, parent);
  var cutValue = 0;
  if (!graphEdge) {
    childIsTail = false;
    graphEdge = g3.edge(parent, child);
  }
  cutValue = graphEdge.weight;
  lodash_1$1.forEach(g3.nodeEdges(child), function(e3) {
    var isOutEdge = e3.v === child, other = isOutEdge ? e3.w : e3.v;
    if (other !== parent) {
      var pointsToHead = isOutEdge === childIsTail, otherWeight = g3.edge(e3).weight;
      cutValue += pointsToHead ? otherWeight : -otherWeight;
      if (isTreeEdge(t4, child, other)) {
        var otherCutValue = t4.edge(child, other).cutvalue;
        cutValue += pointsToHead ? -otherCutValue : otherCutValue;
      }
    }
  });
  return cutValue;
}
function initLowLimValues(tree, root3) {
  if (arguments.length < 2) {
    root3 = tree.nodes()[0];
  }
  dfsAssignLowLim(tree, {}, 1, root3);
}
function dfsAssignLowLim(tree, visited, nextLim, v3, parent) {
  var low = nextLim;
  var label2 = tree.node(v3);
  visited[v3] = true;
  lodash_1$1.forEach(tree.neighbors(v3), function(w3) {
    if (!lodash_1$1.has(visited, w3)) {
      nextLim = dfsAssignLowLim(tree, visited, nextLim, w3, v3);
    }
  });
  label2.low = low;
  label2.lim = nextLim++;
  if (parent) {
    label2.parent = parent;
  } else {
    delete label2.parent;
  }
  return nextLim;
}
function leaveEdge(tree) {
  return lodash_1$1.find(tree.edges(), function(e3) {
    return tree.edge(e3).cutvalue < 0;
  });
}
function enterEdge(t4, g3, edge) {
  var v3 = edge.v;
  var w3 = edge.w;
  if (!g3.hasEdge(v3, w3)) {
    v3 = edge.w;
    w3 = edge.v;
  }
  var vLabel = t4.node(v3);
  var wLabel = t4.node(w3);
  var tailLabel = vLabel;
  var flip2 = false;
  if (vLabel.lim > wLabel.lim) {
    tailLabel = wLabel;
    flip2 = true;
  }
  var candidates = lodash_1$1.filter(g3.edges(), function(edge2) {
    return flip2 === isDescendant(t4, t4.node(edge2.v), tailLabel) && flip2 !== isDescendant(t4, t4.node(edge2.w), tailLabel);
  });
  return lodash_1$1.minBy(candidates, function(edge2) {
    return slack$2(g3, edge2);
  });
}
function exchangeEdges(t4, g3, e3, f3) {
  var v3 = e3.v;
  var w3 = e3.w;
  t4.removeEdge(v3, w3);
  t4.setEdge(f3.v, f3.w, {});
  initLowLimValues(t4);
  initCutValues(t4, g3);
  updateRanks(t4, g3);
}
function updateRanks(t4, g3) {
  var root3 = lodash_1$1.find(t4.nodes(), function(v3) {
    return !g3.node(v3).parent;
  });
  var vs = preorder$1(t4, root3);
  vs = vs.slice(1);
  lodash_1$1.forEach(vs, function(v3) {
    var parent = t4.node(v3).parent, edge = g3.edge(v3, parent), flipped = false;
    if (!edge) {
      edge = g3.edge(parent, v3);
      flipped = true;
    }
    g3.node(v3).rank = g3.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
  });
}
function isTreeEdge(tree, u, v3) {
  return tree.hasEdge(u, v3);
}
function isDescendant(tree, vLabel, rootLabel) {
  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
}
var longestPath$1 = util$1.longestPath;
var rank_1 = rank;
function rank(g3) {
  switch (g3.graph().ranker) {
    case "network-simplex":
      networkSimplexRanker(g3);
      break;
    case "tight-tree":
      tightTreeRanker(g3);
      break;
    case "longest-path":
      longestPathRanker(g3);
      break;
    default:
      networkSimplexRanker(g3);
  }
}
var longestPathRanker = longestPath$1;
function tightTreeRanker(g3) {
  longestPath$1(g3);
  feasibleTree_1(g3);
}
function networkSimplexRanker(g3) {
  networkSimplex_1(g3);
}
var parentDummyChains_1 = parentDummyChains;
function parentDummyChains(g3) {
  var postorderNums = postorder$2(g3);
  lodash_1$1.forEach(g3.graph().dummyChains, function(v3) {
    var node = g3.node(v3);
    var edgeObj = node.edgeObj;
    var pathData = findPath(g3, postorderNums, edgeObj.v, edgeObj.w);
    var path = pathData.path;
    var lca = pathData.lca;
    var pathIdx = 0;
    var pathV = path[pathIdx];
    var ascending2 = true;
    while (v3 !== edgeObj.w) {
      node = g3.node(v3);
      if (ascending2) {
        while ((pathV = path[pathIdx]) !== lca && g3.node(pathV).maxRank < node.rank) {
          pathIdx++;
        }
        if (pathV === lca) {
          ascending2 = false;
        }
      }
      if (!ascending2) {
        while (pathIdx < path.length - 1 && g3.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {
          pathIdx++;
        }
        pathV = path[pathIdx];
      }
      g3.setParent(v3, pathV);
      v3 = g3.successors(v3)[0];
    }
  });
}
function findPath(g3, postorderNums, v3, w3) {
  var vPath = [];
  var wPath = [];
  var low = Math.min(postorderNums[v3].low, postorderNums[w3].low);
  var lim = Math.max(postorderNums[v3].lim, postorderNums[w3].lim);
  var parent;
  var lca;
  parent = v3;
  do {
    parent = g3.parent(parent);
    vPath.push(parent);
  } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
  lca = parent;
  parent = w3;
  while ((parent = g3.parent(parent)) !== lca) {
    wPath.push(parent);
  }
  return {path: vPath.concat(wPath.reverse()), lca};
}
function postorder$2(g3) {
  var result = {};
  var lim = 0;
  function dfs2(v3) {
    var low = lim;
    lodash_1$1.forEach(g3.children(v3), dfs2);
    result[v3] = {low, lim: lim++};
  }
  lodash_1$1.forEach(g3.children(), dfs2);
  return result;
}
var nestingGraph = {
  run: run$2,
  cleanup
};
function run$2(g3) {
  var root3 = util.addDummyNode(g3, "root", {}, "_root");
  var depths = treeDepths(g3);
  var height = lodash_1$1.max(lodash_1$1.values(depths)) - 1;
  var nodeSep = 2 * height + 1;
  g3.graph().nestingRoot = root3;
  lodash_1$1.forEach(g3.edges(), function(e3) {
    g3.edge(e3).minlen *= nodeSep;
  });
  var weight = sumWeights(g3) + 1;
  lodash_1$1.forEach(g3.children(), function(child) {
    dfs$1(g3, root3, nodeSep, weight, height, depths, child);
  });
  g3.graph().nodeRankFactor = nodeSep;
}
function dfs$1(g3, root3, nodeSep, weight, height, depths, v3) {
  var children2 = g3.children(v3);
  if (!children2.length) {
    if (v3 !== root3) {
      g3.setEdge(root3, v3, {weight: 0, minlen: nodeSep});
    }
    return;
  }
  var top2 = util.addBorderNode(g3, "_bt");
  var bottom2 = util.addBorderNode(g3, "_bb");
  var label2 = g3.node(v3);
  g3.setParent(top2, v3);
  label2.borderTop = top2;
  g3.setParent(bottom2, v3);
  label2.borderBottom = bottom2;
  lodash_1$1.forEach(children2, function(child) {
    dfs$1(g3, root3, nodeSep, weight, height, depths, child);
    var childNode = g3.node(child);
    var childTop = childNode.borderTop ? childNode.borderTop : child;
    var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
    var thisWeight = childNode.borderTop ? weight : 2 * weight;
    var minlen = childTop !== childBottom ? 1 : height - depths[v3] + 1;
    g3.setEdge(top2, childTop, {
      weight: thisWeight,
      minlen,
      nestingEdge: true
    });
    g3.setEdge(childBottom, bottom2, {
      weight: thisWeight,
      minlen,
      nestingEdge: true
    });
  });
  if (!g3.parent(v3)) {
    g3.setEdge(root3, top2, {weight: 0, minlen: height + depths[v3]});
  }
}
function treeDepths(g3) {
  var depths = {};
  function dfs2(v3, depth) {
    var children2 = g3.children(v3);
    if (children2 && children2.length) {
      lodash_1$1.forEach(children2, function(child) {
        dfs2(child, depth + 1);
      });
    }
    depths[v3] = depth;
  }
  lodash_1$1.forEach(g3.children(), function(v3) {
    dfs2(v3, 1);
  });
  return depths;
}
function sumWeights(g3) {
  return lodash_1$1.reduce(g3.edges(), function(acc, e3) {
    return acc + g3.edge(e3).weight;
  }, 0);
}
function cleanup(g3) {
  var graphLabel = g3.graph();
  g3.removeNode(graphLabel.nestingRoot);
  delete graphLabel.nestingRoot;
  lodash_1$1.forEach(g3.edges(), function(e3) {
    var edge = g3.edge(e3);
    if (edge.nestingEdge) {
      g3.removeEdge(e3);
    }
  });
}
var addBorderSegments_1 = addBorderSegments;
function addBorderSegments(g3) {
  function dfs2(v3) {
    var children2 = g3.children(v3);
    var node = g3.node(v3);
    if (children2.length) {
      lodash_1$1.forEach(children2, dfs2);
    }
    if (lodash_1$1.has(node, "minRank")) {
      node.borderLeft = [];
      node.borderRight = [];
      for (var rank2 = node.minRank, maxRank2 = node.maxRank + 1; rank2 < maxRank2; ++rank2) {
        addBorderNode$1(g3, "borderLeft", "_bl", v3, node, rank2);
        addBorderNode$1(g3, "borderRight", "_br", v3, node, rank2);
      }
    }
  }
  lodash_1$1.forEach(g3.children(), dfs2);
}
function addBorderNode$1(g3, prop, prefix2, sg2, sgNode, rank2) {
  var label2 = {width: 0, height: 0, rank: rank2, borderType: prop};
  var prev = sgNode[prop][rank2 - 1];
  var curr = util.addDummyNode(g3, "border", label2, prefix2);
  sgNode[prop][rank2] = curr;
  g3.setParent(curr, sg2);
  if (prev) {
    g3.setEdge(prev, curr, {weight: 1});
  }
}
var coordinateSystem = {
  adjust,
  undo: undo$2
};
function adjust(g3) {
  var rankDir = g3.graph().rankdir.toLowerCase();
  if (rankDir === "lr" || rankDir === "rl") {
    swapWidthHeight(g3);
  }
}
function undo$2(g3) {
  var rankDir = g3.graph().rankdir.toLowerCase();
  if (rankDir === "bt" || rankDir === "rl") {
    reverseY(g3);
  }
  if (rankDir === "lr" || rankDir === "rl") {
    swapXY(g3);
    swapWidthHeight(g3);
  }
}
function swapWidthHeight(g3) {
  lodash_1$1.forEach(g3.nodes(), function(v3) {
    swapWidthHeightOne(g3.node(v3));
  });
  lodash_1$1.forEach(g3.edges(), function(e3) {
    swapWidthHeightOne(g3.edge(e3));
  });
}
function swapWidthHeightOne(attrs) {
  var w3 = attrs.width;
  attrs.width = attrs.height;
  attrs.height = w3;
}
function reverseY(g3) {
  lodash_1$1.forEach(g3.nodes(), function(v3) {
    reverseYOne(g3.node(v3));
  });
  lodash_1$1.forEach(g3.edges(), function(e3) {
    var edge = g3.edge(e3);
    lodash_1$1.forEach(edge.points, reverseYOne);
    if (lodash_1$1.has(edge, "y")) {
      reverseYOne(edge);
    }
  });
}
function reverseYOne(attrs) {
  attrs.y = -attrs.y;
}
function swapXY(g3) {
  lodash_1$1.forEach(g3.nodes(), function(v3) {
    swapXYOne(g3.node(v3));
  });
  lodash_1$1.forEach(g3.edges(), function(e3) {
    var edge = g3.edge(e3);
    lodash_1$1.forEach(edge.points, swapXYOne);
    if (lodash_1$1.has(edge, "x")) {
      swapXYOne(edge);
    }
  });
}
function swapXYOne(attrs) {
  var x3 = attrs.x;
  attrs.x = attrs.y;
  attrs.y = x3;
}
var initOrder_1 = initOrder;
function initOrder(g3) {
  var visited = {};
  var simpleNodes = lodash_1$1.filter(g3.nodes(), function(v3) {
    return !g3.children(v3).length;
  });
  var maxRank2 = lodash_1$1.max(lodash_1$1.map(simpleNodes, function(v3) {
    return g3.node(v3).rank;
  }));
  var layers = lodash_1$1.map(lodash_1$1.range(maxRank2 + 1), function() {
    return [];
  });
  function dfs2(v3) {
    if (lodash_1$1.has(visited, v3))
      return;
    visited[v3] = true;
    var node = g3.node(v3);
    layers[node.rank].push(v3);
    lodash_1$1.forEach(g3.successors(v3), dfs2);
  }
  var orderedVs = lodash_1$1.sortBy(simpleNodes, function(v3) {
    return g3.node(v3).rank;
  });
  lodash_1$1.forEach(orderedVs, dfs2);
  return layers;
}
var crossCount_1 = crossCount;
function crossCount(g3, layering) {
  var cc3 = 0;
  for (var i3 = 1; i3 < layering.length; ++i3) {
    cc3 += twoLayerCrossCount(g3, layering[i3 - 1], layering[i3]);
  }
  return cc3;
}
function twoLayerCrossCount(g3, northLayer, southLayer) {
  var southPos = lodash_1$1.zipObject(southLayer, lodash_1$1.map(southLayer, function(v3, i3) {
    return i3;
  }));
  var southEntries = lodash_1$1.flatten(lodash_1$1.map(northLayer, function(v3) {
    return lodash_1$1.sortBy(lodash_1$1.map(g3.outEdges(v3), function(e3) {
      return {pos: southPos[e3.w], weight: g3.edge(e3).weight};
    }), "pos");
  }), true);
  var firstIndex = 1;
  while (firstIndex < southLayer.length)
    firstIndex <<= 1;
  var treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  var tree = lodash_1$1.map(new Array(treeSize), function() {
    return 0;
  });
  var cc3 = 0;
  lodash_1$1.forEach(southEntries.forEach(function(entry) {
    var index3 = entry.pos + firstIndex;
    tree[index3] += entry.weight;
    var weightSum = 0;
    while (index3 > 0) {
      if (index3 % 2) {
        weightSum += tree[index3 + 1];
      }
      index3 = index3 - 1 >> 1;
      tree[index3] += entry.weight;
    }
    cc3 += entry.weight * weightSum;
  }));
  return cc3;
}
var barycenter_1 = barycenter;
function barycenter(g3, movable) {
  return lodash_1$1.map(movable, function(v3) {
    var inV = g3.inEdges(v3);
    if (!inV.length) {
      return {v: v3};
    } else {
      var result = lodash_1$1.reduce(inV, function(acc, e3) {
        var edge = g3.edge(e3), nodeU = g3.node(e3.v);
        return {
          sum: acc.sum + edge.weight * nodeU.order,
          weight: acc.weight + edge.weight
        };
      }, {sum: 0, weight: 0});
      return {
        v: v3,
        barycenter: result.sum / result.weight,
        weight: result.weight
      };
    }
  });
}
var resolveConflicts_1 = resolveConflicts;
function resolveConflicts(entries, cg2) {
  var mappedEntries = {};
  lodash_1$1.forEach(entries, function(entry, i3) {
    var tmp = mappedEntries[entry.v] = {
      indegree: 0,
      in: [],
      out: [],
      vs: [entry.v],
      i: i3
    };
    if (!lodash_1$1.isUndefined(entry.barycenter)) {
      tmp.barycenter = entry.barycenter;
      tmp.weight = entry.weight;
    }
  });
  lodash_1$1.forEach(cg2.edges(), function(e3) {
    var entryV = mappedEntries[e3.v];
    var entryW = mappedEntries[e3.w];
    if (!lodash_1$1.isUndefined(entryV) && !lodash_1$1.isUndefined(entryW)) {
      entryW.indegree++;
      entryV.out.push(mappedEntries[e3.w]);
    }
  });
  var sourceSet = lodash_1$1.filter(mappedEntries, function(entry) {
    return !entry.indegree;
  });
  return doResolveConflicts(sourceSet);
}
function doResolveConflicts(sourceSet) {
  var entries = [];
  function handleIn(vEntry) {
    return function(uEntry) {
      if (uEntry.merged) {
        return;
      }
      if (lodash_1$1.isUndefined(uEntry.barycenter) || lodash_1$1.isUndefined(vEntry.barycenter) || uEntry.barycenter >= vEntry.barycenter) {
        mergeEntries(vEntry, uEntry);
      }
    };
  }
  function handleOut(vEntry) {
    return function(wEntry) {
      wEntry["in"].push(vEntry);
      if (--wEntry.indegree === 0) {
        sourceSet.push(wEntry);
      }
    };
  }
  while (sourceSet.length) {
    var entry = sourceSet.pop();
    entries.push(entry);
    lodash_1$1.forEach(entry["in"].reverse(), handleIn(entry));
    lodash_1$1.forEach(entry.out, handleOut(entry));
  }
  return lodash_1$1.map(lodash_1$1.filter(entries, function(entry2) {
    return !entry2.merged;
  }), function(entry2) {
    return lodash_1$1.pick(entry2, ["vs", "i", "barycenter", "weight"]);
  });
}
function mergeEntries(target, source2) {
  var sum = 0;
  var weight = 0;
  if (target.weight) {
    sum += target.barycenter * target.weight;
    weight += target.weight;
  }
  if (source2.weight) {
    sum += source2.barycenter * source2.weight;
    weight += source2.weight;
  }
  target.vs = source2.vs.concat(target.vs);
  target.barycenter = sum / weight;
  target.weight = weight;
  target.i = Math.min(source2.i, target.i);
  source2.merged = true;
}
var sort_1 = sort;
function sort(entries, biasRight) {
  var parts = util.partition(entries, function(entry) {
    return lodash_1$1.has(entry, "barycenter");
  });
  var sortable2 = parts.lhs, unsortable = lodash_1$1.sortBy(parts.rhs, function(entry) {
    return -entry.i;
  }), vs = [], sum = 0, weight = 0, vsIndex = 0;
  sortable2.sort(compareWithBias(!!biasRight));
  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  lodash_1$1.forEach(sortable2, function(entry) {
    vsIndex += entry.vs.length;
    vs.push(entry.vs);
    sum += entry.barycenter * entry.weight;
    weight += entry.weight;
    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  });
  var result = {vs: lodash_1$1.flatten(vs, true)};
  if (weight) {
    result.barycenter = sum / weight;
    result.weight = weight;
  }
  return result;
}
function consumeUnsortable(vs, unsortable, index3) {
  var last2;
  while (unsortable.length && (last2 = lodash_1$1.last(unsortable)).i <= index3) {
    unsortable.pop();
    vs.push(last2.vs);
    index3++;
  }
  return index3;
}
function compareWithBias(bias) {
  return function(entryV, entryW) {
    if (entryV.barycenter < entryW.barycenter) {
      return -1;
    } else if (entryV.barycenter > entryW.barycenter) {
      return 1;
    }
    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
  };
}
var sortSubgraph_1 = sortSubgraph;
function sortSubgraph(g3, v3, cg2, biasRight) {
  var movable = g3.children(v3);
  var node = g3.node(v3);
  var bl = node ? node.borderLeft : void 0;
  var br = node ? node.borderRight : void 0;
  var subgraphs = {};
  if (bl) {
    movable = lodash_1$1.filter(movable, function(w3) {
      return w3 !== bl && w3 !== br;
    });
  }
  var barycenters = barycenter_1(g3, movable);
  lodash_1$1.forEach(barycenters, function(entry) {
    if (g3.children(entry.v).length) {
      var subgraphResult = sortSubgraph(g3, entry.v, cg2, biasRight);
      subgraphs[entry.v] = subgraphResult;
      if (lodash_1$1.has(subgraphResult, "barycenter")) {
        mergeBarycenters(entry, subgraphResult);
      }
    }
  });
  var entries = resolveConflicts_1(barycenters, cg2);
  expandSubgraphs(entries, subgraphs);
  var result = sort_1(entries, biasRight);
  if (bl) {
    result.vs = lodash_1$1.flatten([bl, result.vs, br], true);
    if (g3.predecessors(bl).length) {
      var blPred = g3.node(g3.predecessors(bl)[0]), brPred = g3.node(g3.predecessors(br)[0]);
      if (!lodash_1$1.has(result, "barycenter")) {
        result.barycenter = 0;
        result.weight = 0;
      }
      result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
      result.weight += 2;
    }
  }
  return result;
}
function expandSubgraphs(entries, subgraphs) {
  lodash_1$1.forEach(entries, function(entry) {
    entry.vs = lodash_1$1.flatten(entry.vs.map(function(v3) {
      if (subgraphs[v3]) {
        return subgraphs[v3].vs;
      }
      return v3;
    }), true);
  });
}
function mergeBarycenters(target, other) {
  if (!lodash_1$1.isUndefined(target.barycenter)) {
    target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
    target.weight += other.weight;
  } else {
    target.barycenter = other.barycenter;
    target.weight = other.weight;
  }
}
var Graph$4 = graphlib_1.Graph;
var buildLayerGraph_1 = buildLayerGraph;
function buildLayerGraph(g3, rank2, relationship) {
  var root3 = createRootNode(g3), result = new Graph$4({compound: true}).setGraph({root: root3}).setDefaultNodeLabel(function(v3) {
    return g3.node(v3);
  });
  lodash_1$1.forEach(g3.nodes(), function(v3) {
    var node = g3.node(v3), parent = g3.parent(v3);
    if (node.rank === rank2 || node.minRank <= rank2 && rank2 <= node.maxRank) {
      result.setNode(v3);
      result.setParent(v3, parent || root3);
      lodash_1$1.forEach(g3[relationship](v3), function(e3) {
        var u = e3.v === v3 ? e3.w : e3.v, edge = result.edge(u, v3), weight = !lodash_1$1.isUndefined(edge) ? edge.weight : 0;
        result.setEdge(u, v3, {weight: g3.edge(e3).weight + weight});
      });
      if (lodash_1$1.has(node, "minRank")) {
        result.setNode(v3, {
          borderLeft: node.borderLeft[rank2],
          borderRight: node.borderRight[rank2]
        });
      }
    }
  });
  return result;
}
function createRootNode(g3) {
  var v3;
  while (g3.hasNode(v3 = lodash_1$1.uniqueId("_root")))
    ;
  return v3;
}
var addSubgraphConstraints_1 = addSubgraphConstraints;
function addSubgraphConstraints(g3, cg2, vs) {
  var prev = {}, rootPrev;
  lodash_1$1.forEach(vs, function(v3) {
    var child = g3.parent(v3), parent, prevChild;
    while (child) {
      parent = g3.parent(child);
      if (parent) {
        prevChild = prev[parent];
        prev[parent] = child;
      } else {
        prevChild = rootPrev;
        rootPrev = child;
      }
      if (prevChild && prevChild !== child) {
        cg2.setEdge(prevChild, child);
        return;
      }
      child = parent;
    }
  });
}
var Graph$5 = graphlib_1.Graph;
var order_1 = order2;
function order2(g3) {
  var maxRank2 = util.maxRank(g3), downLayerGraphs = buildLayerGraphs(g3, lodash_1$1.range(1, maxRank2 + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g3, lodash_1$1.range(maxRank2 - 1, -1, -1), "outEdges");
  var layering = initOrder_1(g3);
  assignOrder(g3, layering);
  var bestCC = Number.POSITIVE_INFINITY, best;
  for (var i3 = 0, lastBest = 0; lastBest < 4; ++i3, ++lastBest) {
    sweepLayerGraphs(i3 % 2 ? downLayerGraphs : upLayerGraphs, i3 % 4 >= 2);
    layering = util.buildLayerMatrix(g3);
    var cc3 = crossCount_1(g3, layering);
    if (cc3 < bestCC) {
      lastBest = 0;
      best = lodash_1$1.cloneDeep(layering);
      bestCC = cc3;
    }
  }
  assignOrder(g3, best);
}
function buildLayerGraphs(g3, ranks, relationship) {
  return lodash_1$1.map(ranks, function(rank2) {
    return buildLayerGraph_1(g3, rank2, relationship);
  });
}
function sweepLayerGraphs(layerGraphs, biasRight) {
  var cg2 = new Graph$5();
  lodash_1$1.forEach(layerGraphs, function(lg2) {
    var root3 = lg2.graph().root;
    var sorted = sortSubgraph_1(lg2, root3, cg2, biasRight);
    lodash_1$1.forEach(sorted.vs, function(v3, i3) {
      lg2.node(v3).order = i3;
    });
    addSubgraphConstraints_1(lg2, cg2, sorted.vs);
  });
}
function assignOrder(g3, layering) {
  lodash_1$1.forEach(layering, function(layer) {
    lodash_1$1.forEach(layer, function(v3, i3) {
      g3.node(v3).order = i3;
    });
  });
}
var Graph$6 = graphlib_1.Graph;
var bk2 = {
  positionX,
  findType1Conflicts,
  findType2Conflicts,
  addConflict,
  hasConflict,
  verticalAlignment,
  horizontalCompaction,
  alignCoordinates,
  findSmallestWidthAlignment,
  balance
};
function findType1Conflicts(g3, layering) {
  var conflicts = {};
  function visitLayer(prevLayer, layer) {
    var k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = lodash_1$1.last(layer);
    lodash_1$1.forEach(layer, function(v3, i3) {
      var w3 = findOtherInnerSegmentNode(g3, v3), k1 = w3 ? g3.node(w3).order : prevLayerLength;
      if (w3 || v3 === lastNode) {
        lodash_1$1.forEach(layer.slice(scanPos, i3 + 1), function(scanNode) {
          lodash_1$1.forEach(g3.predecessors(scanNode), function(u) {
            var uLabel = g3.node(u), uPos = uLabel.order;
            if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g3.node(scanNode).dummy)) {
              addConflict(conflicts, u, scanNode);
            }
          });
        });
        scanPos = i3 + 1;
        k0 = k1;
      }
    });
    return layer;
  }
  lodash_1$1.reduce(layering, visitLayer);
  return conflicts;
}
function findType2Conflicts(g3, layering) {
  var conflicts = {};
  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
    var v3;
    lodash_1$1.forEach(lodash_1$1.range(southPos, southEnd), function(i3) {
      v3 = south[i3];
      if (g3.node(v3).dummy) {
        lodash_1$1.forEach(g3.predecessors(v3), function(u) {
          var uNode = g3.node(u);
          if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
            addConflict(conflicts, u, v3);
          }
        });
      }
    });
  }
  function visitLayer(north, south) {
    var prevNorthPos = -1, nextNorthPos, southPos = 0;
    lodash_1$1.forEach(south, function(v3, southLookahead) {
      if (g3.node(v3).dummy === "border") {
        var predecessors = g3.predecessors(v3);
        if (predecessors.length) {
          nextNorthPos = g3.node(predecessors[0]).order;
          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
          southPos = southLookahead;
          prevNorthPos = nextNorthPos;
        }
      }
      scan(south, southPos, south.length, nextNorthPos, north.length);
    });
    return south;
  }
  lodash_1$1.reduce(layering, visitLayer);
  return conflicts;
}
function findOtherInnerSegmentNode(g3, v3) {
  if (g3.node(v3).dummy) {
    return lodash_1$1.find(g3.predecessors(v3), function(u) {
      return g3.node(u).dummy;
    });
  }
}
function addConflict(conflicts, v3, w3) {
  if (v3 > w3) {
    var tmp = v3;
    v3 = w3;
    w3 = tmp;
  }
  var conflictsV = conflicts[v3];
  if (!conflictsV) {
    conflicts[v3] = conflictsV = {};
  }
  conflictsV[w3] = true;
}
function hasConflict(conflicts, v3, w3) {
  if (v3 > w3) {
    var tmp = v3;
    v3 = w3;
    w3 = tmp;
  }
  return lodash_1$1.has(conflicts[v3], w3);
}
function verticalAlignment(g3, layering, conflicts, neighborFn) {
  var root3 = {}, align = {}, pos = {};
  lodash_1$1.forEach(layering, function(layer) {
    lodash_1$1.forEach(layer, function(v3, order3) {
      root3[v3] = v3;
      align[v3] = v3;
      pos[v3] = order3;
    });
  });
  lodash_1$1.forEach(layering, function(layer) {
    var prevIdx = -1;
    lodash_1$1.forEach(layer, function(v3) {
      var ws = neighborFn(v3);
      if (ws.length) {
        ws = lodash_1$1.sortBy(ws, function(w4) {
          return pos[w4];
        });
        var mp = (ws.length - 1) / 2;
        for (var i3 = Math.floor(mp), il = Math.ceil(mp); i3 <= il; ++i3) {
          var w3 = ws[i3];
          if (align[v3] === v3 && prevIdx < pos[w3] && !hasConflict(conflicts, v3, w3)) {
            align[w3] = v3;
            align[v3] = root3[v3] = root3[w3];
            prevIdx = pos[w3];
          }
        }
      }
    });
  });
  return {root: root3, align};
}
function horizontalCompaction(g3, layering, root3, align, reverseSep) {
  var xs = {}, blockG = buildBlockGraph(g3, layering, root3, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
  function iterate(setXsFunc, nextNodesFunc) {
    var stack2 = blockG.nodes();
    var elem = stack2.pop();
    var visited = {};
    while (elem) {
      if (visited[elem]) {
        setXsFunc(elem);
      } else {
        visited[elem] = true;
        stack2.push(elem);
        stack2 = stack2.concat(nextNodesFunc(elem));
      }
      elem = stack2.pop();
    }
  }
  function pass1(elem) {
    xs[elem] = blockG.inEdges(elem).reduce(function(acc, e3) {
      return Math.max(acc, xs[e3.v] + blockG.edge(e3));
    }, 0);
  }
  function pass2(elem) {
    var min2 = blockG.outEdges(elem).reduce(function(acc, e3) {
      return Math.min(acc, xs[e3.w] - blockG.edge(e3));
    }, Number.POSITIVE_INFINITY);
    var node = g3.node(elem);
    if (min2 !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
      xs[elem] = Math.max(xs[elem], min2);
    }
  }
  iterate(pass1, blockG.predecessors.bind(blockG));
  iterate(pass2, blockG.successors.bind(blockG));
  lodash_1$1.forEach(align, function(v3) {
    xs[v3] = xs[root3[v3]];
  });
  return xs;
}
function buildBlockGraph(g3, layering, root3, reverseSep) {
  var blockGraph = new Graph$6(), graphLabel = g3.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
  lodash_1$1.forEach(layering, function(layer) {
    var u;
    lodash_1$1.forEach(layer, function(v3) {
      var vRoot = root3[v3];
      blockGraph.setNode(vRoot);
      if (u) {
        var uRoot = root3[u], prevMax = blockGraph.edge(uRoot, vRoot);
        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g3, v3, u), prevMax || 0));
      }
      u = v3;
    });
  });
  return blockGraph;
}
function findSmallestWidthAlignment(g3, xss) {
  return lodash_1$1.minBy(lodash_1$1.values(xss), function(xs) {
    var max2 = Number.NEGATIVE_INFINITY;
    var min2 = Number.POSITIVE_INFINITY;
    lodash_1$1.forIn(xs, function(x3, v3) {
      var halfWidth = width(g3, v3) / 2;
      max2 = Math.max(x3 + halfWidth, max2);
      min2 = Math.min(x3 - halfWidth, min2);
    });
    return max2 - min2;
  });
}
function alignCoordinates(xss, alignTo) {
  var alignToVals = lodash_1$1.values(alignTo), alignToMin = lodash_1$1.min(alignToVals), alignToMax = lodash_1$1.max(alignToVals);
  lodash_1$1.forEach(["u", "d"], function(vert) {
    lodash_1$1.forEach(["l", "r"], function(horiz) {
      var alignment = vert + horiz, xs = xss[alignment], delta;
      if (xs === alignTo)
        return;
      var xsVals = lodash_1$1.values(xs);
      delta = horiz === "l" ? alignToMin - lodash_1$1.min(xsVals) : alignToMax - lodash_1$1.max(xsVals);
      if (delta) {
        xss[alignment] = lodash_1$1.mapValues(xs, function(x3) {
          return x3 + delta;
        });
      }
    });
  });
}
function balance(xss, align) {
  return lodash_1$1.mapValues(xss.ul, function(ignore, v3) {
    if (align) {
      return xss[align.toLowerCase()][v3];
    } else {
      var xs = lodash_1$1.sortBy(lodash_1$1.map(xss, v3));
      return (xs[1] + xs[2]) / 2;
    }
  });
}
function positionX(g3) {
  var layering = util.buildLayerMatrix(g3);
  var conflicts = lodash_1$1.merge(findType1Conflicts(g3, layering), findType2Conflicts(g3, layering));
  var xss = {};
  var adjustedLayering;
  lodash_1$1.forEach(["u", "d"], function(vert) {
    adjustedLayering = vert === "u" ? layering : lodash_1$1.values(layering).reverse();
    lodash_1$1.forEach(["l", "r"], function(horiz) {
      if (horiz === "r") {
        adjustedLayering = lodash_1$1.map(adjustedLayering, function(inner) {
          return lodash_1$1.values(inner).reverse();
        });
      }
      var neighborFn = (vert === "u" ? g3.predecessors : g3.successors).bind(g3);
      var align = verticalAlignment(g3, adjustedLayering, conflicts, neighborFn);
      var xs = horizontalCompaction(g3, adjustedLayering, align.root, align.align, horiz === "r");
      if (horiz === "r") {
        xs = lodash_1$1.mapValues(xs, function(x3) {
          return -x3;
        });
      }
      xss[vert + horiz] = xs;
    });
  });
  var smallestWidth = findSmallestWidthAlignment(g3, xss);
  alignCoordinates(xss, smallestWidth);
  return balance(xss, g3.graph().align);
}
function sep(nodeSep, edgeSep, reverseSep) {
  return function(g3, v3, w3) {
    var vLabel = g3.node(v3);
    var wLabel = g3.node(w3);
    var sum = 0;
    var delta;
    sum += vLabel.width / 2;
    if (lodash_1$1.has(vLabel, "labelpos")) {
      switch (vLabel.labelpos.toLowerCase()) {
        case "l":
          delta = -vLabel.width / 2;
          break;
        case "r":
          delta = vLabel.width / 2;
          break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;
    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;
    sum += wLabel.width / 2;
    if (lodash_1$1.has(wLabel, "labelpos")) {
      switch (wLabel.labelpos.toLowerCase()) {
        case "l":
          delta = wLabel.width / 2;
          break;
        case "r":
          delta = -wLabel.width / 2;
          break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;
    return sum;
  };
}
function width(g3, v3) {
  return g3.node(v3).width;
}
var positionX$1 = bk2.positionX;
var position_1 = position;
function position(g3) {
  g3 = util.asNonCompoundGraph(g3);
  positionY(g3);
  lodash_1$1.forEach(positionX$1(g3), function(x3, v3) {
    g3.node(v3).x = x3;
  });
}
function positionY(g3) {
  var layering = util.buildLayerMatrix(g3);
  var rankSep = g3.graph().ranksep;
  var prevY = 0;
  lodash_1$1.forEach(layering, function(layer) {
    var maxHeight = lodash_1$1.max(lodash_1$1.map(layer, function(v3) {
      return g3.node(v3).height;
    }));
    lodash_1$1.forEach(layer, function(v3) {
      g3.node(v3).y = prevY + maxHeight / 2;
    });
    prevY += maxHeight + rankSep;
  });
}
var normalizeRanks$1 = util.normalizeRanks;
var removeEmptyRanks$1 = util.removeEmptyRanks;
var util$2 = util;
var Graph$7 = graphlib_1.Graph;
var layout_1 = layout;
function layout(g3, opts) {
  var time2 = opts && opts.debugTiming ? util$2.time : util$2.notime;
  time2("layout", function() {
    var layoutGraph = time2("  buildLayoutGraph", function() {
      return buildLayoutGraph(g3);
    });
    time2("  runLayout", function() {
      runLayout(layoutGraph, time2);
    });
    time2("  updateInputGraph", function() {
      updateInputGraph(g3, layoutGraph);
    });
  });
}
function runLayout(g3, time2) {
  time2("    makeSpaceForEdgeLabels", function() {
    makeSpaceForEdgeLabels(g3);
  });
  time2("    removeSelfEdges", function() {
    removeSelfEdges(g3);
  });
  time2("    acyclic", function() {
    acyclic.run(g3);
  });
  time2("    nestingGraph.run", function() {
    nestingGraph.run(g3);
  });
  time2("    rank", function() {
    rank_1(util$2.asNonCompoundGraph(g3));
  });
  time2("    injectEdgeLabelProxies", function() {
    injectEdgeLabelProxies(g3);
  });
  time2("    removeEmptyRanks", function() {
    removeEmptyRanks$1(g3);
  });
  time2("    nestingGraph.cleanup", function() {
    nestingGraph.cleanup(g3);
  });
  time2("    normalizeRanks", function() {
    normalizeRanks$1(g3);
  });
  time2("    assignRankMinMax", function() {
    assignRankMinMax(g3);
  });
  time2("    removeEdgeLabelProxies", function() {
    removeEdgeLabelProxies(g3);
  });
  time2("    normalize.run", function() {
    normalize.run(g3);
  });
  time2("    parentDummyChains", function() {
    parentDummyChains_1(g3);
  });
  time2("    addBorderSegments", function() {
    addBorderSegments_1(g3);
  });
  time2("    order", function() {
    order_1(g3);
  });
  time2("    insertSelfEdges", function() {
    insertSelfEdges(g3);
  });
  time2("    adjustCoordinateSystem", function() {
    coordinateSystem.adjust(g3);
  });
  time2("    position", function() {
    position_1(g3);
  });
  time2("    positionSelfEdges", function() {
    positionSelfEdges(g3);
  });
  time2("    removeBorderNodes", function() {
    removeBorderNodes(g3);
  });
  time2("    normalize.undo", function() {
    normalize.undo(g3);
  });
  time2("    fixupEdgeLabelCoords", function() {
    fixupEdgeLabelCoords(g3);
  });
  time2("    undoCoordinateSystem", function() {
    coordinateSystem.undo(g3);
  });
  time2("    translateGraph", function() {
    translateGraph(g3);
  });
  time2("    assignNodeIntersects", function() {
    assignNodeIntersects(g3);
  });
  time2("    reversePoints", function() {
    reversePointsForReversedEdges(g3);
  });
  time2("    acyclic.undo", function() {
    acyclic.undo(g3);
  });
}
function updateInputGraph(inputGraph, layoutGraph) {
  lodash_1$1.forEach(inputGraph.nodes(), function(v3) {
    var inputLabel = inputGraph.node(v3);
    var layoutLabel = layoutGraph.node(v3);
    if (inputLabel) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
      if (layoutGraph.children(v3).length) {
        inputLabel.width = layoutLabel.width;
        inputLabel.height = layoutLabel.height;
      }
    }
  });
  lodash_1$1.forEach(inputGraph.edges(), function(e3) {
    var inputLabel = inputGraph.edge(e3);
    var layoutLabel = layoutGraph.edge(e3);
    inputLabel.points = layoutLabel.points;
    if (lodash_1$1.has(layoutLabel, "x")) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
    }
  });
  inputGraph.graph().width = layoutGraph.graph().width;
  inputGraph.graph().height = layoutGraph.graph().height;
}
var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
var graphDefaults = {ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb"};
var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
var nodeNumAttrs = ["width", "height"];
var nodeDefaults = {width: 0, height: 0};
var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
var edgeDefaults = {
  minlen: 1,
  weight: 1,
  width: 0,
  height: 0,
  labeloffset: 10,
  labelpos: "r"
};
var edgeAttrs = ["labelpos"];
function buildLayoutGraph(inputGraph) {
  var g3 = new Graph$7({multigraph: true, compound: true});
  var graph2 = canonicalize(inputGraph.graph());
  g3.setGraph(lodash_1$1.merge({}, graphDefaults, selectNumberAttrs(graph2, graphNumAttrs), lodash_1$1.pick(graph2, graphAttrs)));
  lodash_1$1.forEach(inputGraph.nodes(), function(v3) {
    var node = canonicalize(inputGraph.node(v3));
    g3.setNode(v3, lodash_1$1.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));
    g3.setParent(v3, inputGraph.parent(v3));
  });
  lodash_1$1.forEach(inputGraph.edges(), function(e3) {
    var edge = canonicalize(inputGraph.edge(e3));
    g3.setEdge(e3, lodash_1$1.merge({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), lodash_1$1.pick(edge, edgeAttrs)));
  });
  return g3;
}
function makeSpaceForEdgeLabels(g3) {
  var graph2 = g3.graph();
  graph2.ranksep /= 2;
  lodash_1$1.forEach(g3.edges(), function(e3) {
    var edge = g3.edge(e3);
    edge.minlen *= 2;
    if (edge.labelpos.toLowerCase() !== "c") {
      if (graph2.rankdir === "TB" || graph2.rankdir === "BT") {
        edge.width += edge.labeloffset;
      } else {
        edge.height += edge.labeloffset;
      }
    }
  });
}
function injectEdgeLabelProxies(g3) {
  lodash_1$1.forEach(g3.edges(), function(e3) {
    var edge = g3.edge(e3);
    if (edge.width && edge.height) {
      var v3 = g3.node(e3.v);
      var w3 = g3.node(e3.w);
      var label2 = {rank: (w3.rank - v3.rank) / 2 + v3.rank, e: e3};
      util$2.addDummyNode(g3, "edge-proxy", label2, "_ep");
    }
  });
}
function assignRankMinMax(g3) {
  var maxRank2 = 0;
  lodash_1$1.forEach(g3.nodes(), function(v3) {
    var node = g3.node(v3);
    if (node.borderTop) {
      node.minRank = g3.node(node.borderTop).rank;
      node.maxRank = g3.node(node.borderBottom).rank;
      maxRank2 = lodash_1$1.max(maxRank2, node.maxRank);
    }
  });
  g3.graph().maxRank = maxRank2;
}
function removeEdgeLabelProxies(g3) {
  lodash_1$1.forEach(g3.nodes(), function(v3) {
    var node = g3.node(v3);
    if (node.dummy === "edge-proxy") {
      g3.edge(node.e).labelRank = node.rank;
      g3.removeNode(v3);
    }
  });
}
function translateGraph(g3) {
  var minX = Number.POSITIVE_INFINITY;
  var maxX = 0;
  var minY = Number.POSITIVE_INFINITY;
  var maxY = 0;
  var graphLabel = g3.graph();
  var marginX = graphLabel.marginx || 0;
  var marginY = graphLabel.marginy || 0;
  function getExtremes(attrs) {
    var x3 = attrs.x;
    var y4 = attrs.y;
    var w3 = attrs.width;
    var h3 = attrs.height;
    minX = Math.min(minX, x3 - w3 / 2);
    maxX = Math.max(maxX, x3 + w3 / 2);
    minY = Math.min(minY, y4 - h3 / 2);
    maxY = Math.max(maxY, y4 + h3 / 2);
  }
  lodash_1$1.forEach(g3.nodes(), function(v3) {
    getExtremes(g3.node(v3));
  });
  lodash_1$1.forEach(g3.edges(), function(e3) {
    var edge = g3.edge(e3);
    if (lodash_1$1.has(edge, "x")) {
      getExtremes(edge);
    }
  });
  minX -= marginX;
  minY -= marginY;
  lodash_1$1.forEach(g3.nodes(), function(v3) {
    var node = g3.node(v3);
    node.x -= minX;
    node.y -= minY;
  });
  lodash_1$1.forEach(g3.edges(), function(e3) {
    var edge = g3.edge(e3);
    lodash_1$1.forEach(edge.points, function(p3) {
      p3.x -= minX;
      p3.y -= minY;
    });
    if (lodash_1$1.has(edge, "x")) {
      edge.x -= minX;
    }
    if (lodash_1$1.has(edge, "y")) {
      edge.y -= minY;
    }
  });
  graphLabel.width = maxX - minX + marginX;
  graphLabel.height = maxY - minY + marginY;
}
function assignNodeIntersects(g3) {
  lodash_1$1.forEach(g3.edges(), function(e3) {
    var edge = g3.edge(e3);
    var nodeV = g3.node(e3.v);
    var nodeW = g3.node(e3.w);
    var p1, p22;
    if (!edge.points) {
      edge.points = [];
      p1 = nodeW;
      p22 = nodeV;
    } else {
      p1 = edge.points[0];
      p22 = edge.points[edge.points.length - 1];
    }
    edge.points.unshift(util$2.intersectRect(nodeV, p1));
    edge.points.push(util$2.intersectRect(nodeW, p22));
  });
}
function fixupEdgeLabelCoords(g3) {
  lodash_1$1.forEach(g3.edges(), function(e3) {
    var edge = g3.edge(e3);
    if (lodash_1$1.has(edge, "x")) {
      if (edge.labelpos === "l" || edge.labelpos === "r") {
        edge.width -= edge.labeloffset;
      }
      switch (edge.labelpos) {
        case "l":
          edge.x -= edge.width / 2 + edge.labeloffset;
          break;
        case "r":
          edge.x += edge.width / 2 + edge.labeloffset;
          break;
      }
    }
  });
}
function reversePointsForReversedEdges(g3) {
  lodash_1$1.forEach(g3.edges(), function(e3) {
    var edge = g3.edge(e3);
    if (edge.reversed) {
      edge.points.reverse();
    }
  });
}
function removeBorderNodes(g3) {
  lodash_1$1.forEach(g3.nodes(), function(v3) {
    if (g3.children(v3).length) {
      var node = g3.node(v3);
      var t4 = g3.node(node.borderTop);
      var b3 = g3.node(node.borderBottom);
      var l3 = g3.node(lodash_1$1.last(node.borderLeft));
      var r4 = g3.node(lodash_1$1.last(node.borderRight));
      node.width = Math.abs(r4.x - l3.x);
      node.height = Math.abs(b3.y - t4.y);
      node.x = l3.x + node.width / 2;
      node.y = t4.y + node.height / 2;
    }
  });
  lodash_1$1.forEach(g3.nodes(), function(v3) {
    if (g3.node(v3).dummy === "border") {
      g3.removeNode(v3);
    }
  });
}
function removeSelfEdges(g3) {
  lodash_1$1.forEach(g3.edges(), function(e3) {
    if (e3.v === e3.w) {
      var node = g3.node(e3.v);
      if (!node.selfEdges) {
        node.selfEdges = [];
      }
      node.selfEdges.push({e: e3, label: g3.edge(e3)});
      g3.removeEdge(e3);
    }
  });
}
function insertSelfEdges(g3) {
  var layers = util$2.buildLayerMatrix(g3);
  lodash_1$1.forEach(layers, function(layer) {
    var orderShift = 0;
    lodash_1$1.forEach(layer, function(v3, i3) {
      var node = g3.node(v3);
      node.order = i3 + orderShift;
      lodash_1$1.forEach(node.selfEdges, function(selfEdge) {
        util$2.addDummyNode(g3, "selfedge", {
          width: selfEdge.label.width,
          height: selfEdge.label.height,
          rank: node.rank,
          order: i3 + ++orderShift,
          e: selfEdge.e,
          label: selfEdge.label
        }, "_se");
      });
      delete node.selfEdges;
    });
  });
}
function positionSelfEdges(g3) {
  lodash_1$1.forEach(g3.nodes(), function(v3) {
    var node = g3.node(v3);
    if (node.dummy === "selfedge") {
      var selfNode = g3.node(node.e.v);
      var x3 = selfNode.x + selfNode.width / 2;
      var y4 = selfNode.y;
      var dx = node.x - x3;
      var dy = selfNode.height / 2;
      g3.setEdge(node.e, node.label);
      g3.removeNode(v3);
      node.label.points = [
        {x: x3 + 2 * dx / 3, y: y4 - dy},
        {x: x3 + 5 * dx / 6, y: y4 - dy},
        {x: x3 + dx, y: y4},
        {x: x3 + 5 * dx / 6, y: y4 + dy},
        {x: x3 + 2 * dx / 3, y: y4 + dy}
      ];
      node.label.x = node.x;
      node.label.y = node.y;
    }
  });
}
function selectNumberAttrs(obj, attrs) {
  return lodash_1$1.mapValues(lodash_1$1.pick(obj, attrs), Number);
}
function canonicalize(attrs) {
  var newAttrs = {};
  lodash_1$1.forEach(attrs, function(v3, k3) {
    newAttrs[k3.toLowerCase()] = v3;
  });
  return newAttrs;
}
var Graph$8 = graphlib_1.Graph;
var debug = {
  debugOrdering
};
function debugOrdering(g3) {
  var layerMatrix = util.buildLayerMatrix(g3);
  var h3 = new Graph$8({compound: true, multigraph: true}).setGraph({});
  lodash_1$1.forEach(g3.nodes(), function(v3) {
    h3.setNode(v3, {label: v3});
    h3.setParent(v3, "layer" + g3.node(v3).rank);
  });
  lodash_1$1.forEach(g3.edges(), function(e3) {
    h3.setEdge(e3.v, e3.w, {}, e3.name);
  });
  lodash_1$1.forEach(layerMatrix, function(layer, i3) {
    var layerV = "layer" + i3;
    h3.setNode(layerV, {rank: "same"});
    lodash_1$1.reduce(layer, function(u, v3) {
      h3.setEdge(u, v3, {style: "invis"});
      return v3;
    });
  });
  return h3;
}
var version$1 = "0.8.5";
var dagre = {
  graphlib: graphlib_1,
  layout: layout_1,
  debug,
  util: {
    time: util.time,
    notime: util.notime
  },
  version: version$1
};
var dagre_default = dagre;

// build/authentication/components/diagram/auto-layout.js
var dagreGraph = new dagre_default.graphlib.Graph();
dagreGraph.setDefaultEdgeLabel(() => ({}));
var nodeWidth = 130;
var nodeHeight = 28;
var getLayoutedElements = (elements, direction = "LR") => {
  const isHorizontal = direction === "LR";
  dagreGraph.setGraph({rankdir: direction});
  elements.forEach((element) => {
    if (isNode(element)) {
      dagreGraph.setNode(element.id, {
        width: nodeWidth,
        height: nodeHeight
      });
    } else {
      dagreGraph.setEdge(element.source, element.target);
    }
  });
  dagre_default.layout(dagreGraph);
  return elements.map((element) => {
    if (isNode(element)) {
      const nodeWithPosition = dagreGraph.node(element.id);
      element.targetPosition = isHorizontal ? Position.Left : Position.Top;
      element.sourcePosition = isHorizontal ? Position.Right : Position.Bottom;
      element.position = {
        x: nodeWithPosition.x - nodeWidth / 2 + Math.random() / 1e3,
        y: nodeWithPosition.y - nodeHeight / 2
      };
    }
    return element;
  });
};

// build/authentication/components/FlowDiagram.js
var createEdge = (fromNode, toNode) => ({
  id: `edge-${fromNode}-to-${toNode}`,
  type: "buttonEdge",
  source: fromNode,
  target: toNode,
  data: {
    onEdgeClick: (evt, id3) => {
      evt.stopPropagation();
      alert(`hello ${id3}`);
    }
  }
});
var createNode = (ex) => {
  let nodeType = void 0;
  if (ex.executionList) {
    nodeType = "startSubFlow";
  }
  if (ex.displayName?.startsWith("Condition")) {
    nodeType = "conditional";
  }
  return {
    id: ex.id,
    type: nodeType,
    sourcePosition: Position.Right,
    targetPosition: Position.Left,
    data: {label: ex.displayName},
    position: {x: 0, y: 0}
  };
};
var renderParallelNodes = (start3, execution, end2) => {
  const elements = [];
  elements.push(createNode(execution));
  elements.push(createEdge(start3.id, execution.id));
  elements.push(createEdge(execution.id, end2.id));
  return elements;
};
var renderSequentialNodes = (start3, execution, end2, prefExecution, isFirst, isLast) => {
  const elements = [];
  elements.push(createNode(execution));
  if (isFirst) {
    elements.push(createEdge(start3.id, execution.id));
  } else {
    elements.push(createEdge(prefExecution.id, execution.id));
  }
  if (isLast) {
    elements.push(createEdge(execution.id, end2.id));
  }
  return elements;
};
var renderSubFlow = (execution, start3, end2, prefExecution) => {
  const elements = [];
  elements.push({
    id: execution.id,
    type: "startSubFlow",
    sourcePosition: Position.Right,
    targetPosition: Position.Left,
    data: {label: execution.displayName},
    position: {x: 0, y: 0}
  });
  const endSubFlowId = `flow-end-${execution.id}`;
  elements.push({
    id: endSubFlowId,
    type: "endSubFlow",
    sourcePosition: Position.Right,
    targetPosition: Position.Left,
    data: {label: execution.displayName},
    position: {x: 0, y: 0}
  });
  elements.push(createEdge(prefExecution && prefExecution.requirement !== "ALTERNATIVE" ? prefExecution.id : start3.id, execution.id));
  elements.push(createEdge(endSubFlowId, end2.id));
  return elements.concat(renderFlow(execution, execution.executionList, {
    ...execution,
    id: endSubFlowId
  }));
};
var renderFlow = (start3, executionList, end2) => {
  let elements = [];
  for (let index3 = 0; index3 < executionList.length; index3++) {
    const execution = executionList[index3];
    if (execution.executionList) {
      elements = elements.concat(renderSubFlow(execution, start3, end2, executionList[index3 - 1]));
    } else {
      if (execution.requirement === "ALTERNATIVE" || execution.requirement === "DISABLED") {
        elements = elements.concat(renderParallelNodes(start3, execution, end2));
      } else {
        elements = elements.concat(renderSequentialNodes(start3, execution, end2, executionList[index3 - 1], index3 === 0, index3 === executionList.length - 1));
      }
    }
  }
  return elements;
};
var FlowDiagram = ({
  executionList: {expandableList}
}) => {
  let elements = [
    {
      id: "start",
      sourcePosition: Position.Right,
      type: "input",
      data: {label: "Start"},
      position: {x: 0, y: 0},
      className: "keycloak__authentication__input_node"
    },
    {
      id: "end",
      targetPosition: Position.Left,
      type: "output",
      data: {label: "End"},
      position: {x: 0, y: 0},
      className: "keycloak__authentication__output_node"
    }
  ];
  elements = elements.concat(renderFlow({id: "start"}, expandableList, {id: "end"}));
  const onLoad = (reactFlowInstance) => reactFlowInstance.fitView();
  const [layoutedElements, setElements3] = useState(getLayoutedElements(elements));
  const [expandDrawer, setExpandDrawer] = useState(false);
  const onElementClick = (_event, element) => {
    if (isNode(element))
      setExpandDrawer(!expandDrawer);
  };
  const onElementsRemove = (elementsToRemove) => setElements3((els) => removeElements(elementsToRemove, els));
  return /* @__PURE__ */ react.createElement(Drawer, {
    isExpanded: expandDrawer,
    onExpand: () => setExpandDrawer(true)
  }, /* @__PURE__ */ react.createElement(DrawerContent, {
    panelContent: /* @__PURE__ */ react.createElement(DrawerPanelContent, null, /* @__PURE__ */ react.createElement(DrawerHead, null, /* @__PURE__ */ react.createElement("span", {
      tabIndex: expandDrawer ? 0 : -1
    }, "drawer-panel"), /* @__PURE__ */ react.createElement(DrawerActions, null, /* @__PURE__ */ react.createElement(DrawerCloseButton, {
      onClick: () => setExpandDrawer(false)
    }))))
  }, /* @__PURE__ */ react.createElement(DrawerContentBody, null, /* @__PURE__ */ react.createElement(react_flow_renderer_default, {
    nodeTypes: {
      conditional: ConditionalNode,
      startSubFlow: StartSubFlowNode,
      endSubFlow: EndSubFlowNode
    },
    edgeTypes: {
      buttonEdge: ButtonEdge
    },
    onElementClick,
    onElementsRemove,
    onLoad,
    elements: layoutedElements,
    nodesConnectable: false
  }, /* @__PURE__ */ react.createElement(index$2, null), /* @__PURE__ */ react.createElement(index$1, null), /* @__PURE__ */ react.createElement(index2, null)))));
};

// build/authentication/FlowDetails.js
var FlowDetails = () => {
  const {t: t4} = useTranslation("authentication");
  const adminClient = useAdminClient();
  const {addAlert} = useAlerts();
  const {id: id3, usedBy, builtIn} = useParams();
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const [tableView, setTableView] = useState(true);
  const [flow, setFlow] = useState();
  const [executionList, setExecutionList] = useState();
  const [dragged, setDragged] = useState();
  const [liveText, setLiveText] = useState("");
  useFetch(async () => {
    const flows = await adminClient.authenticationManagement.getFlows();
    const flow2 = flows.find((f3) => f3.id === id3);
    const executions = await adminClient.authenticationManagement.getExecutions({
      flow: flow2?.alias
    });
    return {flow: flow2, executions};
  }, ({flow: flow2, executions}) => {
    setFlow(flow2);
    setExecutionList(new ExecutionList(executions));
  }, [key]);
  const executeChange = async (ex, change) => {
    try {
      let id22 = ex.id;
      if ("parent" in change) {
        await adminClient.authenticationManagement.delExecution({id: id22});
        const result = await adminClient.authenticationManagement.addExecutionToFlow({
          flow: change.parent?.displayName || flow?.alias,
          provider: ex.providerId
        });
        id22 = result.id;
      }
      const times = change.newIndex - change.oldIndex;
      const requests = [];
      for (let index3 = 0; index3 < Math.abs(times); index3++) {
        if (times > 0) {
          requests.push(adminClient.authenticationManagement.lowerPriorityExecution({
            id: id22
          }));
        } else {
          requests.push(adminClient.authenticationManagement.raisePriorityExecution({
            id: id22
          }));
        }
      }
      await Promise.all(requests);
      refresh();
      addAlert(t4("updateFlowSuccess"), AlertVariant.success);
    } catch (error2) {
      addAlert(t4("updateFlowError", {
        error: error2.response?.data?.errorMessage || error2
      }), AlertVariant.danger);
    }
  };
  const update = async (execution) => {
    try {
      await adminClient.authenticationManagement.updateExecution({flow: flow?.alias}, execution);
      refresh();
      addAlert(t4("updateFlowSuccess"), AlertVariant.success);
    } catch (error2) {
      addAlert(t4("updateFlowError", {
        error: error2.response?.data?.errorMessage || error2
      }), AlertVariant.danger);
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: toUpperCase(flow?.alias || ""),
    badges: [
      {text: /* @__PURE__ */ react.createElement(Label, null, t4(usedBy))},
      builtIn ? {
        text: /* @__PURE__ */ react.createElement(Label, {
          className: "keycloak_authentication-section__usedby_label",
          icon: /* @__PURE__ */ react.createElement(CheckCircleIcon, null)
        }, t4("buildIn")),
        id: "builtIn"
      } : {}
    ]
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, executionList?.expandableList?.length && /* @__PURE__ */ react.createElement(Toolbar, {
    id: "toolbar"
  }, /* @__PURE__ */ react.createElement(ToolbarContent, null, /* @__PURE__ */ react.createElement(ToggleGroup, null, /* @__PURE__ */ react.createElement(ToggleGroupItem, {
    icon: /* @__PURE__ */ react.createElement(TableIcon, null),
    "aria-label": t4("tableView"),
    buttonId: "tableView",
    isSelected: tableView,
    onChange: () => setTableView(true)
  }), /* @__PURE__ */ react.createElement(ToggleGroupItem, {
    icon: /* @__PURE__ */ react.createElement("i", {
      className: "fas fa-project-diagram"
    }),
    "aria-label": t4("diagramView"),
    buttonId: "diagramView",
    isSelected: !tableView,
    onChange: () => setTableView(false)
  })))), tableView && executionList?.expandableList?.length && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DataList, {
    "aria-label": "flows",
    onDragFinish: (order3) => {
      const withoutHeaderId = order3.slice(1);
      setLiveText(t4("common:onDragFinish", {list: dragged?.displayName}));
      const change = executionList.getChange(dragged, withoutHeaderId);
      executeChange(dragged, change);
    },
    onDragStart: (id22) => {
      const item = executionList.findExecution(id22);
      setLiveText(t4("common:onDragStart", {item: item.displayName}));
      setDragged(item);
      if (item.executionList && !item.isCollapsed) {
        item.isCollapsed = true;
        setExecutionList(executionList.clone());
      }
    },
    onDragMove: () => setLiveText(t4("common:onDragMove", {item: dragged?.displayName})),
    onDragCancel: () => setLiveText(t4("common:onDragCancel")),
    itemOrder: [
      "header",
      ...executionList.order().map((ex) => ex.id)
    ]
  }, /* @__PURE__ */ react.createElement(FlowHeader, null), /* @__PURE__ */ react.createElement(react.Fragment, null, executionList.expandableList.map((execution) => /* @__PURE__ */ react.createElement(FlowRow, {
    key: execution.id,
    execution,
    onRowClick: (execution2) => {
      execution2.isCollapsed = !execution2.isCollapsed;
      setExecutionList(executionList.clone());
    },
    onRowChange: update
  })))), /* @__PURE__ */ react.createElement("div", {
    className: "pf-screen-reader",
    "aria-live": "assertive"
  }, liveText)), !tableView && executionList?.expandableList && /* @__PURE__ */ react.createElement(FlowDiagram, {
    executionList
  }), !executionList?.expandableList || executionList.expandableList.length === 0 && /* @__PURE__ */ react.createElement(EmptyExecutionState, null)));
};

// build/authentication/routes/Flow.js
var FlowRoute = {
  path: "/:realm/authentication/:id/:usedBy/:builtIn?",
  component: FlowDetails,
  breadcrumb: (t4) => t4("authentication:flowDetails"),
  access: "manage-authorization"
};
var toFlow = (params) => ({
  pathname: generatePath(FlowRoute.path, params)
});

// build/authentication/AuthenticationSection.js
var realmFlows = [
  "browserFlow",
  "registrationFlow",
  "directGrantFlow",
  "resetCredentialsFlow",
  "clientAuthenticationFlow",
  "dockerAuthenticationFlow"
];
var AuthenticationSection = () => {
  const {t: t4} = useTranslation("authentication");
  const adminClient = useAdminClient();
  const {realm: realm2} = useRealm();
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const {addAlert, addError} = useAlerts();
  const [selectedFlow, setSelectedFlow] = useState();
  const [open2, setOpen] = useState(false);
  const loader = async () => {
    const clients2 = await adminClient.clients.find();
    const idps = await adminClient.identityProviders.find();
    const realmRep = await adminClient.realms.findOne({realm: realm2});
    const defaultFlows = Object.entries(realmRep).filter((entry) => realmFlows.includes(entry[0])).map((entry) => entry[1]);
    const flows = await adminClient.authenticationManagement.getFlows();
    for (const flow of flows) {
      flow.usedBy = {values: []};
      const client2 = clients2.find((client22) => client22.authenticationFlowBindingOverrides && (client22.authenticationFlowBindingOverrides["direct_grant"] === flow.id || client22.authenticationFlowBindingOverrides["browser"] === flow.id));
      if (client2) {
        flow.usedBy.type = "specificClients";
        flow.usedBy.values.push(client2.clientId);
      }
      const idp = idps.find((idp2) => idp2.firstBrokerLoginFlowAlias === flow.alias || idp2.postBrokerLoginFlowAlias === flow.alias);
      if (idp) {
        flow.usedBy.type = "specificProviders";
        flow.usedBy.values.push(idp.alias);
      }
      const isDefault = defaultFlows.includes(flow.alias);
      if (isDefault) {
        flow.usedBy.type = "default";
      }
    }
    return flows;
  };
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: "authentication:deleteConfirmFlow",
    children: /* @__PURE__ */ react.createElement(Trans, {
      i18nKey: "authentication:deleteConfirmFlowMessage"
    }, " ", /* @__PURE__ */ react.createElement("strong", null, {flow: selectedFlow ? selectedFlow.alias : ""}), "."),
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        await adminClient.authenticationManagement.deleteFlow({
          flowId: selectedFlow.id
        });
        refresh();
        addAlert(t4("deleteFlowSuccess"), AlertVariant.success);
      } catch (error2) {
        addError("authentication:deleteFlowError", error2);
      }
    }
  });
  const UsedBy = ({id: id3, usedBy: {type, values: values2}}) => /* @__PURE__ */ react.createElement(react.Fragment, null, (type === "specificProviders" || type === "specificClients") && /* @__PURE__ */ react.createElement(Popover, {
    key: id3,
    "aria-label": t4("usedBy"),
    bodyContent: /* @__PURE__ */ react.createElement("div", {
      key: `usedBy-${id3}-${values2}`
    }, t4("appliedBy" + (type === "specificClients" ? "Clients" : "Providers")), " ", values2.map((used, index3) => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement("strong", null, used), index3 < values2.length - 1 ? ", " : "")))
  }, /* @__PURE__ */ react.createElement(Button, {
    variant: ButtonVariant.link,
    key: `button-${id3}`
  }, /* @__PURE__ */ react.createElement(CheckCircleIcon, {
    className: "keycloak_authentication-section__usedby",
    key: `icon-${id3}`
  }), " ", t4(type))), type === "default" && /* @__PURE__ */ react.createElement(Button, {
    key: id3,
    variant: ButtonVariant.link,
    isDisabled: true
  }, /* @__PURE__ */ react.createElement(CheckCircleIcon, {
    className: "keycloak_authentication-section__usedby",
    key: `icon-${id3}`
  }), " ", t4("default")), !type && /* @__PURE__ */ react.createElement(Button, {
    key: id3,
    variant: ButtonVariant.link,
    isDisabled: true
  }, t4("notInUse")));
  const AliasRenderer = ({
    id: id3,
    alias,
    usedBy,
    builtIn
  }) => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Link, {
    to: toFlow({
      realm: realm2,
      id: id3,
      usedBy: usedBy.type || "notInUse",
      builtIn: builtIn ? "builtIn" : void 0
    }),
    key: `link-${id3}`
  }, toUpperCase(alias)), " ", builtIn && /* @__PURE__ */ react.createElement(Label, {
    key: `label-${id3}`
  }, t4("buildIn")));
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DeleteConfirm, null), open2 && /* @__PURE__ */ react.createElement(DuplicateFlowModal, {
    name: selectedFlow ? selectedFlow.alias : "",
    description: selectedFlow?.description,
    toggleDialog: () => setOpen(!open2),
    onComplete: () => {
      refresh();
      setOpen(false);
    }
  }), /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: "authentication:title",
    divider: false
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    className: "pf-u-p-0"
  }, /* @__PURE__ */ react.createElement(KeycloakTabs, {
    isBox: true
  }, /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "flows",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("flows"))
  }, /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    loader,
    ariaLabelKey: "authentication:title",
    searchPlaceholderKey: "authentication:searchForEvent",
    toolbarItem: /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      component: Link,
      to: toCreateFlow({realm: realm2})
    }, t4("createFlow"))),
    actionResolver: ({data}) => {
      const defaultActions = [
        {
          title: t4("duplicate"),
          onClick: () => {
            setOpen(true);
            setSelectedFlow(data);
          }
        }
      ];
      if (data.builtIn || data.usedBy.values.length > 0) {
        return defaultActions;
      } else {
        return [
          {
            title: t4("common:delete"),
            onClick: () => {
              setSelectedFlow(data);
              toggleDeleteDialog();
            }
          },
          ...defaultActions
        ];
      }
    },
    columns: [
      {
        name: "alias",
        displayKey: "authentication:flowName",
        cellRenderer: AliasRenderer
      },
      {
        name: "usedBy",
        displayKey: "authentication:usedBy",
        cellRenderer: UsedBy
      },
      {
        name: "description",
        displayKey: "common:description"
      }
    ],
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      message: t4("emptyEvents"),
      instructions: t4("emptyEventsInstructions")
    })
  })))));
};

// build/authentication/routes/Authentication.js
var AuthenticationRoute = {
  path: "/:realm/authentication",
  component: AuthenticationSection,
  breadcrumb: (t4) => t4("authentication"),
  access: "view-realm"
};

// build/authentication/routes.js
var routes = [AuthenticationRoute, CreateFlowRoute, FlowRoute];
var routes_default = routes;

// build/client-scopes/add/MapperDialog.js
var AddMapperDialog = (props) => {
  const {t: t4} = useTranslation("client-scopes");
  const serverInfo2 = useServerInfo();
  const protocol = props.protocol;
  const protocolMappers = serverInfo2.protocolMapperTypes[protocol];
  const builtInMappers = serverInfo2.builtinProtocolMappers[protocol];
  const [filter3, setFilter] = useState([]);
  const allRows = builtInMappers.map((mapper) => {
    const mapperType = protocolMappers.filter((type) => type.id === mapper.protocolMapper)[0];
    return {
      item: mapper,
      selected: false,
      cells: [mapper.name, mapperType.helpText]
    };
  });
  const [rows, setRows] = useState(allRows);
  if (props.filter && props.filter.length !== filter3.length) {
    setFilter(props.filter);
    const nameFilter = props.filter.map((f3) => f3.name);
    setRows([...allRows.filter((row) => !nameFilter.includes(row.item.name))]);
  }
  const selectedRows = rows.filter((row) => row.selected).map((row) => row.item);
  const isBuiltIn = !!props.filter;
  return /* @__PURE__ */ react.createElement(Modal, {
    variant: ModalVariant.medium,
    title: t4("chooseAMapperType"),
    isOpen: props.open,
    onClose: props.toggleDialog,
    actions: isBuiltIn ? [
      /* @__PURE__ */ react.createElement(Button, {
        id: "modal-confirm",
        "data-testid": "modalConfirm",
        key: "confirm",
        isDisabled: rows.length === 0 || selectedRows.length === 0,
        onClick: () => {
          props.onConfirm(selectedRows);
          props.toggleDialog();
        }
      }, t4("common:add")),
      /* @__PURE__ */ react.createElement(Button, {
        id: "modal-cancel",
        key: "cancel",
        variant: ButtonVariant.link,
        onClick: () => {
          props.toggleDialog();
        }
      }, t4("common:cancel"))
    ] : []
  }, /* @__PURE__ */ react.createElement(TextContent, null, /* @__PURE__ */ react.createElement(Text, null, t4("predefinedMappingDescription"))), !isBuiltIn && /* @__PURE__ */ react.createElement(DataList, {
    onSelectDataListItem: (id3) => {
      const mapper = protocolMappers.find((mapper2) => mapper2.id === id3);
      props.onConfirm(mapper);
      props.toggleDialog();
    },
    "aria-label": t4("chooseAMapperType"),
    isCompact: true
  }, protocolMappers.map((mapper) => /* @__PURE__ */ react.createElement(DataListItem, {
    "aria-label": mapper.name,
    key: mapper.id,
    id: mapper.id
  }, /* @__PURE__ */ react.createElement(DataListItemRow, null, /* @__PURE__ */ react.createElement(DataListItemCells, {
    dataListCells: [
      /* @__PURE__ */ react.createElement(DataListCell, {
        key: `name-${mapper.id}`
      }, /* @__PURE__ */ react.createElement(react.Fragment, null, mapper.name)),
      /* @__PURE__ */ react.createElement(DataListCell, {
        key: `helpText-${mapper.id}`
      }, /* @__PURE__ */ react.createElement(react.Fragment, null, mapper.helpText))
    ]
  }))))), isBuiltIn && rows.length > 0 && /* @__PURE__ */ react.createElement(Table, {
    variant: TableVariant.compact,
    cells: [t4("common:name"), t4("common:description")],
    onSelect: (_23, isSelected, rowIndex) => {
      rows[rowIndex].selected = isSelected;
      setRows([...rows]);
    },
    canSelectAll: false,
    rows,
    "aria-label": t4("chooseAMapperType")
  }, /* @__PURE__ */ react.createElement(TableHeader, null), /* @__PURE__ */ react.createElement(TableBody, null)), isBuiltIn && rows.length === 0 && /* @__PURE__ */ react.createElement(ListEmptyState, {
    message: t4("common:emptyMappers"),
    instructions: t4("common:emptyBuiltInMappersInstructions")
  }));
};

// build/client-scopes/details/MappingDetails.js
var MappingDetails = () => {
  const {t: t4} = useTranslation("client-scopes");
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const {id: id3, mapperId} = useParams();
  const {register, errors, setValue, control, handleSubmit} = useForm();
  const [mapping, setMapping] = useState();
  const [typeOpen, setTypeOpen] = useState(false);
  const [configProperties, setConfigProperties] = useState();
  const history = useHistory();
  const {realm: realm2} = useRealm();
  const serverInfo2 = useServerInfo();
  const isGuid = /^[{]?[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}[}]?$/;
  useFetch(async () => {
    if (mapperId.match(isGuid)) {
      const data = await adminClient.clientScopes.findProtocolMapper({
        id: id3,
        mapperId
      });
      if (data) {
        Object.entries(data).map((entry) => {
          convertToFormValues(entry[1], "config", setValue);
        });
      }
      const mapperTypes = serverInfo2.protocolMapperTypes[data.protocol];
      const properties = mapperTypes.find((type) => type.id === data.protocolMapper)?.properties;
      return {
        configProperties: properties,
        mapping: data
      };
    } else {
      const scope = await adminClient.clientScopes.findOne({id: id3});
      const protocolMappers = serverInfo2.protocolMapperTypes[scope.protocol];
      const mapping2 = protocolMappers.find((mapper) => mapper.id === mapperId);
      return {
        mapping: {
          name: mapping2.name,
          protocol: scope.protocol,
          protocolMapper: mapperId
        }
      };
    }
  }, (result) => {
    setConfigProperties(result.configProperties);
    setMapping(result.mapping);
  }, []);
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: "common:deleteMappingTitle",
    messageKey: "common:deleteMappingConfirm",
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        await adminClient.clientScopes.delProtocolMapper({
          id: id3,
          mapperId
        });
        addAlert(t4("common:mappingDeletedSuccess"), AlertVariant.success);
        history.push(`/${realm2}/client-scopes/${id3}/mappers`);
      } catch (error2) {
        addError("common:mappingDeletedError", error2);
      }
    }
  });
  const save = async (formMapping) => {
    const config2 = convertFormValuesToObject(formMapping.config);
    const map3 = {...mapping, ...formMapping, config: config2};
    const key = mapperId.match(isGuid) ? "Updated" : "Created";
    try {
      if (mapperId.match(isGuid)) {
        await adminClient.clientScopes.updateProtocolMapper({id: id3, mapperId}, map3);
      } else {
        await adminClient.clientScopes.addProtocolMapper({id: id3}, map3);
      }
      addAlert(t4(`common:mapping${key}Success`), AlertVariant.success);
    } catch (error2) {
      addError(`common:mapping${key}Error`, error2);
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DeleteConfirm, null), /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: mapping ? mapping.name : t4("common:addMapper"),
    subKey: mapperId.match(isGuid) ? mapperId : "",
    badges: [{text: mapping?.protocol}],
    dropdownItems: mapperId.match(isGuid) ? [
      /* @__PURE__ */ react.createElement(DropdownItem, {
        key: "delete",
        value: "delete",
        onClick: toggleDeleteDialog
      }, t4("common:delete"))
    ] : void 0
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    onSubmit: handleSubmit(save),
    role: "manage-clients"
  }, /* @__PURE__ */ react.createElement(react.Fragment, null, !mapperId.match(isGuid) && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:name"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:mapperName",
      forLabel: t4("common:name"),
      forID: "name"
    }),
    fieldId: "name",
    isRequired: true,
    validated: errors.name ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register({required: true}),
    type: "text",
    id: "name",
    name: "name",
    validated: errors.name ? ValidatedOptions.error : ValidatedOptions.default
  }))), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("realmRolePrefix"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:prefix",
      forLabel: t4("realmRolePrefix"),
      forID: "prefix"
    }),
    fieldId: "prefix"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register(),
    type: "text",
    id: "prefix",
    name: "config.usermodel-realmRoleMapping-rolePrefix"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("multiValued"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:multiValued",
      forLabel: t4("multiValued"),
      forID: "multiValued"
    }),
    fieldId: "multiValued"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.multivalued",
    control,
    defaultValue: "false",
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "multiValued",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value === "true",
      onChange: (value2) => onChange("" + value2)
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("tokenClaimName"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:tokenClaimName",
      forLabel: t4("tokenClaimName"),
      forID: "claimName"
    }),
    fieldId: "claimName"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register(),
    type: "text",
    id: "claimName",
    name: "config.claim-name"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("claimJsonType"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:claimJsonType",
      forLabel: t4("claimJsonType"),
      forID: "claimJsonType"
    }),
    fieldId: "claimJsonType"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.jsonType-label",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "claimJsonType",
      onToggle: () => setTypeOpen(!typeOpen),
      onSelect: (_23, value2) => {
        onChange(value2);
        setTypeOpen(false);
      },
      selections: value,
      variant: SelectVariant.single,
      "aria-label": t4("claimJsonType"),
      isOpen: typeOpen
    }, configProperties && configProperties.find((property2) => property2.name === "jsonType.label")?.options.map((option) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: option === value,
      key: option,
      value: option
    })))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    hasNoPaddingTop: true,
    label: t4("addClaimTo"),
    fieldId: "addClaimTo"
  }, /* @__PURE__ */ react.createElement(Flex, null, /* @__PURE__ */ react.createElement(FlexItem, null, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.id-token-claim",
    defaultValue: "false",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Checkbox, {
      label: t4("idToken"),
      id: "idToken",
      isChecked: value === "true",
      onChange: (value2) => onChange("" + value2)
    })
  })), /* @__PURE__ */ react.createElement(FlexItem, null, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.access-token-claim",
    defaultValue: "false",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Checkbox, {
      label: t4("accessToken"),
      id: "accessToken",
      isChecked: value === "true",
      onChange: (value2) => onChange("" + value2)
    })
  })), /* @__PURE__ */ react.createElement(FlexItem, null, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.userinfo-token-claim",
    defaultValue: "false",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Checkbox, {
      label: t4("userInfo"),
      id: "userInfo",
      isChecked: value === "true",
      onChange: (value2) => onChange("" + value2)
    })
  })))), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "primary",
    type: "submit"
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link"
  }, t4("common:cancel"))))));
};

// build/client-scopes/routes/Mapper.js
var MapperRoute = {
  path: "/:realm/client-scopes/:id/mappers/:mapperId",
  component: MappingDetails,
  breadcrumb: (t4) => t4("common:mappingDetails"),
  access: "view-clients"
};
var toMapper = (params) => ({
  pathname: generatePath(MapperRoute.path, params)
});

// build/client-scopes/details/MapperList.js
var MapperList = ({clientScope, refresh}) => {
  const {t: t4} = useTranslation("client-scopes");
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const history = useHistory();
  const {realm: realm2} = useRealm();
  const url = `/${realm2}/client-scopes/${clientScope.id}/mappers`;
  const [mapperAction, setMapperAction] = useState(false);
  const mapperList = clientScope.protocolMappers;
  const mapperTypes = useServerInfo().protocolMapperTypes[clientScope.protocol];
  const [key, setKey] = useState(0);
  useEffect(() => setKey(new Date().getTime()), [mapperList]);
  const [addMapperDialogOpen, setAddMapperDialogOpen] = useState(false);
  const [filter3, setFilter] = useState(clientScope.protocolMappers);
  const toggleAddMapperDialog = (buildIn) => {
    if (buildIn) {
      setFilter(mapperList || []);
    } else {
      setFilter(void 0);
    }
    setAddMapperDialogOpen(!addMapperDialogOpen);
  };
  const addMappers = async (mappers) => {
    if (filter3 === void 0) {
      const mapper = mappers;
      history.push(`${url}/${mapper.id}`);
    } else {
      try {
        await adminClient.clientScopes.addMultipleProtocolMappers({id: clientScope.id}, mappers);
        refresh();
        addAlert(t4("common:mappingCreatedSuccess"), AlertVariant.success);
      } catch (error2) {
        addError("common:mappingCreatedError", error2);
      }
    }
  };
  const loader = async () => Promise.resolve((mapperList || []).map((mapper) => {
    const mapperType = mapperTypes.filter((type) => type.id === mapper.protocolMapper)[0];
    return {
      ...mapper,
      category: mapperType.category,
      type: mapperType.name,
      priority: mapperType.priority
    };
  }).sort((a2, b3) => a2.priority - b3.priority));
  const MapperLink = ({id: id3, name}) => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Link, {
    to: toMapper({realm: realm2, id: clientScope.id, mapperId: id3})
  }, name));
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(AddMapperDialog, {
    protocol: clientScope.protocol,
    filter: filter3,
    onConfirm: addMappers,
    open: addMapperDialogOpen,
    toggleDialog: () => setAddMapperDialogOpen(!addMapperDialogOpen)
  }), /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    loader,
    ariaLabelKey: "client-scopes:clientScopeList",
    searchPlaceholderKey: "common:searchForMapper",
    toolbarItem: /* @__PURE__ */ react.createElement(Dropdown, {
      onSelect: () => setMapperAction(false),
      toggle: /* @__PURE__ */ react.createElement(DropdownToggle, {
        isPrimary: true,
        id: "mapperAction",
        onToggle: () => setMapperAction(!mapperAction),
        toggleIndicator: CaretDownIcon
      }, t4("common:addMapper")),
      isOpen: mapperAction,
      dropdownItems: [
        /* @__PURE__ */ react.createElement(DropdownItem, {
          key: "predefined",
          onClick: () => toggleAddMapperDialog(true)
        }, t4("fromPredefinedMapper")),
        /* @__PURE__ */ react.createElement(DropdownItem, {
          key: "byConfiguration",
          onClick: () => toggleAddMapperDialog(false)
        }, t4("byConfiguration"))
      ]
    }),
    actions: [
      {
        title: t4("common:delete"),
        onRowClick: async (mapper) => {
          try {
            await adminClient.clientScopes.delProtocolMapper({
              id: clientScope.id,
              mapperId: mapper.id
            });
            addAlert(t4("common:mappingDeletedSuccess"), AlertVariant.success);
            refresh();
          } catch (error2) {
            addError("common:mappingDeletedError", error2);
          }
          return true;
        }
      }
    ],
    columns: [
      {
        name: "name",
        cellRenderer: MapperLink
      },
      {name: "category"},
      {
        name: "type"
      },
      {
        name: "priority"
      }
    ],
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      message: t4("common:emptyMappers"),
      instructions: t4("common:emptyMappersInstructions"),
      secondaryActions: [
        {
          text: t4("common:emptyPrimaryAction"),
          onClick: () => toggleAddMapperDialog(true)
        },
        {
          text: t4("emptySecondaryAction"),
          onClick: () => toggleAddMapperDialog(false)
        }
      ]
    })
  }));
};

// build/components/client-scope/ClientScopeTypes.js
var ClientScope;
(function(ClientScope2) {
  ClientScope2["default"] = "default";
  ClientScope2["optional"] = "optional";
})(ClientScope || (ClientScope = {}));
var AllClientScopes;
(function(AllClientScopes2) {
  AllClientScopes2["none"] = "none";
})(AllClientScopes || (AllClientScopes = {}));
var clientScopeTypes = Object.keys(ClientScope);
var allClientScopeTypes = Object.keys({
  ...AllClientScopes,
  ...ClientScope
});
var clientScopeTypesSelectOptions = (t4, scopeTypes = clientScopeTypes) => scopeTypes.map((type) => /* @__PURE__ */ react.createElement(SelectOption, {
  key: type,
  value: type
}, t4(`common:clientScope.${type}`)));
var clientScopeTypesDropdown = (t4, onClick) => clientScopeTypes.map((type) => /* @__PURE__ */ react.createElement(DropdownItem, {
  key: type,
  onClick: () => onClick(type)
}, t4(`common:clientScope.${type}`)));
var CellDropdown = ({
  clientScope,
  type,
  onSelect,
  all: all2 = false
}) => {
  const {t: t4} = useTranslation();
  const [open2, setOpen] = useState(false);
  return /* @__PURE__ */ react.createElement(Select, {
    className: `keycloak__client-scope__${type}`,
    key: clientScope.id,
    onToggle: () => setOpen(!open2),
    isOpen: open2,
    selections: [type],
    onSelect: (_23, value) => {
      onSelect(all2 ? value : value);
      setOpen(false);
    }
  }, clientScopeTypesSelectOptions(t4, all2 ? allClientScopeTypes : clientScopeTypes));
};
var changeScope = async (adminClient, clientScope, changeTo) => {
  await removeScope(adminClient, clientScope);
  await addScope(adminClient, clientScope, changeTo);
};
var castAdminClient = (adminClient) => adminClient.clientScopes;
var removeScope = async (adminClient, clientScope) => {
  if (clientScope.type !== AllClientScopes.none)
    await castAdminClient(adminClient)[`delDefault${clientScope.type === ClientScope.optional ? "Optional" : ""}ClientScope`]({
      id: clientScope.id
    });
};
var addScope = async (adminClient, clientScope, type) => {
  if (type !== AllClientScopes.none)
    await castAdminClient(adminClient)[`addDefault${type === ClientScope.optional ? "Optional" : ""}ClientScope`]({
      id: clientScope.id
    });
};

// build/client-scopes/details/ScopeForm.js
var ScopeForm = ({clientScope, save}) => {
  const {t: t4} = useTranslation("client-scopes");
  const {register, control, handleSubmit, errors, setValue} = useForm({
    defaultValues: {attributes: {"display-on-consent-screen": "true"}}
  });
  const history = useHistory();
  const {realm: realm2} = useRealm();
  const providers = useLoginProviders();
  const [open2, isOpen] = useState(false);
  const [openType, setOpenType] = useState(false);
  const {id: id3} = useParams();
  const displayOnConsentScreen = useWatch({
    control,
    name: "attributes.display-on-consent-screen"
  });
  useEffect(() => {
    Object.entries(clientScope).map((entry) => {
      if (entry[0] === "attributes") {
        convertToFormValues(entry[1], "attributes", setValue);
      }
      setValue(entry[0], entry[1]);
    });
  }, [clientScope]);
  return /* @__PURE__ */ react.createElement(Form, {
    isHorizontal: true,
    onSubmit: handleSubmit(save),
    className: "pf-u-mt-md"
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:name"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      id: "name-help-icon",
      helpText: "client-scopes-help:name",
      forLabel: t4("common:name"),
      forID: t4(`common:helpLabel`, {label: t4("common:name")})
    }),
    fieldId: "kc-name",
    isRequired: true,
    validated: errors.name ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register({required: true}),
    type: "text",
    id: "kc-name",
    name: "name",
    validated: errors.name ? ValidatedOptions.error : ValidatedOptions.default
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:description"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:description",
      forLabel: t4("common:description"),
      forID: t4(`common:helpLabel`, {label: t4("common:description")})
    }),
    fieldId: "kc-description",
    validated: errors.description ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:maxLength", {length: 255})
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register({
      maxLength: 255
    }),
    validated: errors.description ? ValidatedOptions.error : ValidatedOptions.default,
    type: "text",
    id: "kc-description",
    name: "description"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("type"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:type",
      forLabel: t4("type"),
      forID: t4(`common:helpLabel`, {label: t4("type")})
    }),
    fieldId: "type"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "type",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      id: "type",
      variant: SelectVariant.single,
      isOpen: openType,
      selections: value,
      onToggle: () => setOpenType(!openType),
      onSelect: (_23, value2) => {
        onChange(value2);
        setOpenType(false);
      }
    }, clientScopeTypesSelectOptions(t4, allClientScopeTypes))
  })), !id3 && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("protocol"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:protocol",
      forLabel: "protocol",
      forID: t4(`common:helpLabel`, {label: t4("protocol")})
    }),
    fieldId: "kc-protocol"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "protocol",
    defaultValue: providers[0],
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-protocol",
      required: true,
      onToggle: () => isOpen(!open2),
      onSelect: (_23, value2) => {
        onChange(value2);
        isOpen(false);
      },
      selections: value,
      variant: SelectVariant.single,
      "aria-label": t4("selectEncryptionType"),
      isOpen: open2
    }, providers.map((option) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: option === value,
      key: option,
      value: option
    })))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    hasNoPaddingTop: true,
    label: t4("displayOnConsentScreen"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:displayOnConsentScreen",
      forLabel: t4("displayOnConsentScreen"),
      forID: t4(`common:helpLabel`, {
        label: t4("displayOnConsentScreen")
      })
    }),
    fieldId: "kc-display.on.consent.screen"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.display-on-consent-screen",
    control,
    defaultValue: "true",
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-display.on.consent.screen-switch",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value === "true",
      onChange: (value2) => onChange("" + value2)
    })
  })), displayOnConsentScreen === "true" && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("consentScreenText"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:consentScreenText",
      forLabel: t4("consentScreenText"),
      forID: t4(`common:helpLabel`, {label: t4("consentScreenText")})
    }),
    fieldId: "kc-consent-screen-text"
  }, /* @__PURE__ */ react.createElement(TextArea, {
    ref: register,
    type: "text",
    id: "kc-consent-screen-text",
    name: "attributes.consent-screen-text"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    hasNoPaddingTop: true,
    label: t4("includeInTokenScope"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:includeInTokenScope",
      forLabel: t4("includeInTokenScope"),
      forID: t4(`common:helpLabel`, {label: t4("includeInTokenScope")})
    }),
    fieldId: "includeInTokenScope"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.include-in-token-scope",
    control,
    defaultValue: "true",
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "includeInTokenScope-switch",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value === "true",
      onChange: (value2) => onChange("" + value2)
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("guiOrder"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:guiOrder",
      forLabel: t4("guiOrder"),
      forID: t4(`common:helpLabel`, {label: t4("guiOrder")})
    }),
    fieldId: "kc-gui-order"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.gui-order",
    defaultValue: 1,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(NumberInput, {
      type: "text",
      id: "kc-gui-order",
      value,
      onPlus: () => onChange(value + 1),
      onMinus: () => onChange(value - 1),
      onChange: (event) => onChange(Number(event.target.value))
    })
  })), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "primary",
    type: "submit"
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: () => history.push(`/${realm2}/client-scopes`)
  }, t4("common:cancel"))));
};

// build/components/role-mapping/AddRoleMappingModal.js
var realmRole = {
  name: "realmRoles"
};
var AddRoleMappingModal = ({
  id: id3,
  name,
  type,
  isRadio: isRadio3 = false,
  onAssign,
  onClose
}) => {
  const {t: t4} = useTranslation("clients");
  const adminClient = useAdminClient();
  const [clients2, setClients] = useState([]);
  const [searchToggle, setSearchToggle] = useState(false);
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const [selectedClients, setSelectedClients] = useState([]);
  const [selectedRows, setSelectedRows] = useState([]);
  useFetch(async () => {
    const clients22 = await adminClient.clients.find();
    return (await Promise.all(clients22.map(async (client2) => {
      let roles2 = [];
      switch (type) {
        case "service-account":
          roles2 = await adminClient.users.listAvailableClientRoleMappings({
            id: id3,
            clientUniqueId: client2.id
          });
          break;
        case "client-scope":
          roles2 = await adminClient.clientScopes.listAvailableClientScopeMappings({
            id: id3,
            client: client2.id
          });
          break;
        case "user-fed":
          roles2 = await adminClient.roles.find();
          break;
      }
      return {
        roles: roles2,
        client: client2
      };
    }))).flat().filter((row) => row.roles.length !== 0).map((row) => {
      return {...row.client, numberOfRoles: row.roles.length};
    });
  }, (clients22) => {
    setClients(clients22);
  }, []);
  useEffect(refresh, [searchToggle]);
  const removeClient = (client2) => {
    setSelectedClients(selectedClients.filter((item) => item.id !== client2.id));
  };
  const loader = async () => {
    const realmRolesSelected = lodash.findIndex(selectedClients, (client2) => client2.name === "realmRoles");
    let selected = selectedClients;
    if (realmRolesSelected !== -1) {
      selected = selectedClients.filter((client2) => client2.name !== "realmRoles");
    }
    let availableRoles = [];
    switch (type) {
      case "service-account":
        availableRoles = await adminClient.users.listAvailableRealmRoleMappings({
          id: id3
        });
        break;
      case "client-scope":
        availableRoles = await adminClient.clientScopes.listAvailableRealmScopeMappings({
          id: id3
        });
        break;
      case "user-fed":
        availableRoles = await adminClient.roles.find();
        break;
    }
    const realmRoles = availableRoles.map((role) => {
      return {
        role,
        client: void 0
      };
    });
    const allClients = selectedClients.length !== 0 ? selected : await adminClient.clients.find();
    const roles2 = (await Promise.all(allClients.map(async (client2) => {
      let clientAvailableRoles = [];
      switch (type) {
        case "service-account":
          clientAvailableRoles = await adminClient.users.listAvailableClientRoleMappings({
            id: id3,
            clientUniqueId: client2.id
          });
          break;
        case "client-scope":
          clientAvailableRoles = await adminClient.clientScopes.listAvailableClientScopeMappings({id: id3, client: client2.id});
          break;
        case "user-fed":
          clientAvailableRoles = await adminClient.clients.listRoles({
            id: client2.id
          });
          break;
      }
      return clientAvailableRoles.map((role) => {
        return {
          role,
          client: client2
        };
      });
    }))).flat();
    return [
      ...realmRolesSelected !== -1 || selected.length === 0 ? realmRoles : [],
      ...roles2
    ];
  };
  const createSelectGroup = (clients22) => [
    /* @__PURE__ */ react.createElement(SelectGroup, {
      key: "role",
      label: t4("realmRoles")
    }, /* @__PURE__ */ react.createElement(SelectOption, {
      key: "realmRoles",
      value: realmRole
    }, t4("realmRoles"))),
    /* @__PURE__ */ react.createElement(Divider, {
      key: "divider"
    }),
    /* @__PURE__ */ react.createElement(SelectGroup, {
      key: "group",
      label: t4("clients")
    }, clients22.map((client2) => /* @__PURE__ */ react.createElement(SelectOption, {
      key: client2.id,
      value: client2
    }, client2.clientId)))
  ];
  return /* @__PURE__ */ react.createElement(Modal, {
    variant: ModalVariant.large,
    title: t4("assignRolesTo", {client: name}),
    isOpen: true,
    onClose,
    actions: [
      /* @__PURE__ */ react.createElement(Button, {
        "data-testid": "assign",
        key: "confirm",
        isDisabled: selectedRows?.length === 0,
        variant: "primary",
        onClick: () => {
          onAssign(selectedRows);
          onClose();
        }
      }, t4("assign")),
      /* @__PURE__ */ react.createElement(Button, {
        "data-testid": "cancel",
        key: "cancel",
        variant: "link",
        onClick: onClose
      }, t4("common:cancel"))
    ]
  }, /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    onSelect: (rows) => setSelectedRows([...rows]),
    searchPlaceholderKey: "clients:searchByRoleName",
    searchTypeComponent: /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Select, {
      toggleId: "role",
      onToggle: () => setSearchToggle(!searchToggle),
      isOpen: searchToggle,
      variant: isRadio3 ? SelectVariant.single : SelectVariant.checkbox,
      hasInlineFilter: true,
      placeholderText: /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FilterIcon, null), " ", t4("filterByOrigin")),
      isGrouped: true,
      onFilter: (evt) => {
        const value = evt?.target.value || "";
        return createSelectGroup(clients2.filter((client2) => client2.clientId?.includes(value)));
      },
      selections: selectedClients,
      onClear: () => setSelectedClients([]),
      onSelect: (_23, selection2) => {
        const client2 = selection2;
        if (selectedClients.includes(client2)) {
          removeClient(client2);
        } else {
          setSelectedClients([...selectedClients, client2]);
        }
      }
    }, createSelectGroup(clients2))),
    subToolbar: /* @__PURE__ */ react.createElement(ToolbarItem, {
      widths: {default: "100%"}
    }, /* @__PURE__ */ react.createElement(ChipGroup, null, selectedClients.map((client2) => /* @__PURE__ */ react.createElement(Chip, {
      key: `chip-${client2.id}`,
      onClick: () => {
        removeClient(client2);
        refresh();
      }
    }, client2.clientId || t4("realmRoles"), /* @__PURE__ */ react.createElement(Badge, {
      isRead: true
    }, client2.numberOfRoles))))),
    canSelectAll: true,
    isRadio: isRadio3,
    loader,
    ariaLabelKey: "clients:roles",
    columns: [
      {
        name: "name",
        cellRenderer: ServiceRole
      },
      {
        name: "role.description",
        displayKey: t4("description")
      }
    ]
  }));
};

// build/components/role-mapping/RoleMapping.js
var mapRoles = (assignedRoles, effectiveRoles, hide2) => {
  return [
    ...hide2 ? assignedRoles.map((row) => ({
      ...row,
      role: {
        ...row.role,
        isInherited: false
      }
    })) : effectiveRoles.map((row) => ({
      ...row,
      role: {
        ...row.role,
        isInherited: assignedRoles.find((r4) => r4.role.id === row.role.id) === void 0
      }
    }))
  ];
};
var ServiceRole = ({role, client: client2}) => /* @__PURE__ */ react.createElement(react.Fragment, null, client2 && /* @__PURE__ */ react.createElement(Badge, {
  key: `${client2.id}-${role.id}`,
  isRead: true,
  className: "keycloak-admin--role-mapping__client-name"
}, client2.clientId), role.name);
var RoleMapping = ({
  name,
  id: id3,
  type,
  loader,
  save,
  onHideRolesToggle
}) => {
  const {t: t4} = useTranslation("clients");
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const [hide2, setHide] = useState(false);
  const [showAssign, setShowAssign] = useState(false);
  const [selected, setSelected] = useState([]);
  const assignRoles = async (rows) => {
    await save(rows);
    refresh();
  };
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: "clients:removeMappingTitle",
    messageKey: t4("removeMappingConfirm", {count: selected.length}),
    continueButtonLabel: "common:remove",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        switch (type) {
          case "service-account":
            await Promise.all(selected.map((row) => {
              const role = {id: row.role.id, name: row.role.name};
              if (row.client) {
                return adminClient.users.delClientRoleMappings({
                  id: id3,
                  clientUniqueId: row.client.id,
                  roles: [role]
                });
              } else {
                return adminClient.users.delRealmRoleMappings({
                  id: id3,
                  roles: [role]
                });
              }
            }));
            break;
          case "client-scope":
            await Promise.all(selected.map((row) => {
              const role = {id: row.role.id, name: row.role.name};
              if (row.client) {
                return adminClient.clientScopes.delClientScopeMappings({
                  id: id3,
                  client: row.client.id
                }, [role]);
              } else {
                return adminClient.clientScopes.delRealmScopeMappings({
                  id: id3
                }, [role]);
              }
            }));
            break;
        }
        addAlert(t4("clientScopeRemoveSuccess"), AlertVariant.success);
        refresh();
      } catch (error2) {
        addError("clients:clientScopeRemoveError", error2);
      }
    }
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, showAssign && /* @__PURE__ */ react.createElement(AddRoleMappingModal, {
    id: id3,
    type,
    name,
    onAssign: assignRoles,
    onClose: () => setShowAssign(false)
  }), /* @__PURE__ */ react.createElement(DeleteConfirm, null), /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    "data-testid": "assigned-roles",
    key,
    loader,
    canSelectAll: true,
    onSelect: (rows) => setSelected(rows),
    searchPlaceholderKey: "clients:searchByName",
    ariaLabelKey: "clients:clientScopeList",
    isRowDisabled: (value) => value.role.isInherited || false,
    toolbarItem: /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Checkbox, {
      label: t4("hideInheritedRoles"),
      id: "hideInheritedRoles",
      isChecked: hide2,
      onChange: (check2) => {
        setHide(check2);
        onHideRolesToggle();
        refresh();
      }
    })), /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      "data-testid": "assignRole",
      onClick: () => setShowAssign(true)
    }, t4("assignRole"))), /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      variant: "link",
      "data-testid": "unAssignRole",
      onClick: toggleDeleteDialog,
      isDisabled: selected.length === 0
    }, t4("unAssignRole")))),
    actions: [
      {
        title: t4("unAssignRole"),
        onRowClick: async (role) => {
          setSelected([role]);
          toggleDeleteDialog();
          return false;
        }
      }
    ],
    columns: [
      {
        name: "role.name",
        displayKey: t4("name"),
        cellRenderer: ServiceRole
      },
      {
        name: "role.parent.name",
        displayKey: t4("inherentFrom"),
        cellFormatters: [emptyFormatter()]
      },
      {
        name: "role.description",
        displayKey: t4("description"),
        cellFormatters: [emptyFormatter()]
      }
    ],
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      message: t4("noRoles"),
      instructions: t4("noRolesInstructions"),
      primaryActionText: t4("assignRole"),
      onPrimaryAction: () => setShowAssign(true)
    })
  }));
};

// build/client-scopes/form/ClientScopeForm.js
var ClientScopeForm = () => {
  const {t: t4} = useTranslation("client-scopes");
  const [clientScope, setClientScope] = useState();
  const history = useHistory();
  const {realm: realm2} = useRealm();
  const [hide2, setHide] = useState(false);
  const adminClient = useAdminClient();
  const {id: id3, type} = useParams();
  const {addAlert, addError} = useAlerts();
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  useFetch(async () => {
    if (id3) {
      return {
        ...await adminClient.clientScopes.findOne({id: id3}),
        type
      };
    }
  }, (clientScope2) => {
    setClientScope(clientScope2);
  }, [key, id3]);
  const loader = async () => {
    const assignedRoles = (await adminClient.clientScopes.listRealmScopeMappings({id: id3})).map((role) => ({role}));
    const effectiveRoles = (await adminClient.clientScopes.listCompositeRealmScopeMappings({id: id3})).map((role) => ({role}));
    const clients2 = await adminClient.clients.find();
    const clientRoles = (await Promise.all(clients2.map(async (client2) => {
      const clientAssignedRoles = (await adminClient.clientScopes.listClientScopeMappings({
        id: id3,
        client: client2.id
      })).map((role) => ({role, client: client2}));
      const clientEffectiveRoles = (await adminClient.clientScopes.listCompositeClientScopeMappings({
        id: id3,
        client: client2.id
      })).map((role) => ({role, client: client2}));
      return mapRoles(clientAssignedRoles, clientEffectiveRoles, hide2);
    }))).flat();
    return [...mapRoles(assignedRoles, effectiveRoles, hide2), ...clientRoles];
  };
  const save = async (clientScopes2) => {
    try {
      clientScopes2.attributes = convertFormValuesToObject(clientScopes2.attributes);
      if (id3) {
        await adminClient.clientScopes.update({id: id3}, clientScopes2);
        changeScope(adminClient, {...clientScopes2, id: id3, type}, clientScopes2.type);
      } else {
        await adminClient.clientScopes.create(clientScopes2);
        const scope = await adminClient.clientScopes.findOneByName({
          name: clientScopes2.name
        });
        changeScope(adminClient, {...clientScopes2, id: scope.id}, clientScopes2.type);
        history.push(`/${realm2}/client-scopes/${scope.id}/${clientScopes2.type || "none"}/settings`);
      }
      addAlert(t4((id3 ? "update" : "create") + "Success"), AlertVariant.success);
    } catch (error2) {
      addError(`client-scopes:${id3 ? "update" : "create"}Error`, error2);
    }
  };
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: t4("deleteClientScope", {
      count: 1,
      name: clientScope?.name
    }),
    messageKey: "client-scopes:deleteConfirm",
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        await adminClient.clientScopes.del({id: id3});
        addAlert(t4("deletedSuccess"), AlertVariant.success);
      } catch (error2) {
        addError("client-scopes:deleteError", error2);
      }
    }
  });
  const assignRoles = async (rows) => {
    try {
      const realmRoles = rows.filter((row) => row.client === void 0).map((row) => row.role).flat();
      await adminClient.clientScopes.addRealmScopeMappings({
        id: id3
      }, realmRoles);
      await Promise.all(rows.filter((row) => row.client !== void 0).map((row) => adminClient.clientScopes.addClientScopeMappings({
        id: id3,
        client: row.client.id
      }, [row.role])));
      addAlert(t4("roleMappingUpdatedSuccess"), AlertVariant.success);
    } catch (error2) {
      addError("client-scopes:roleMappingUpdatedError", error2);
    }
  };
  if (id3 && !clientScope) {
    return /* @__PURE__ */ react.createElement("div", {
      className: "pf-u-text-align-center"
    }, /* @__PURE__ */ react.createElement(Spinner, null));
  }
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DeleteConfirm, null), /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: clientScope ? clientScope.name : "client-scopes:createClientScope",
    dropdownItems: clientScope ? [
      /* @__PURE__ */ react.createElement(DropdownItem, {
        key: "delete",
        onClick: () => toggleDeleteDialog()
      }, t4("common:delete"))
    ] : void 0,
    badges: [{text: clientScope ? clientScope.protocol : void 0}],
    divider: !id3
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    className: "pf-u-p-0"
  }, !id3 && /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(ScopeForm, {
    save,
    clientScope: {}
  })), id3 && clientScope && /* @__PURE__ */ react.createElement(KeycloakTabs, {
    isBox: true
  }, /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "settings",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("common:settings"))
  }, /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(ScopeForm, {
    save,
    clientScope
  }))), /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "mappers",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("common:mappers"))
  }, /* @__PURE__ */ react.createElement(MapperList, {
    clientScope,
    refresh
  })), /* @__PURE__ */ react.createElement(Tab, {
    "data-testid": "scopeTab",
    eventKey: "scope",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("scope"))
  }, /* @__PURE__ */ react.createElement(RoleMapping, {
    id: id3,
    name: clientScope.name,
    type: "client-scope",
    loader,
    save: assignRoles,
    onHideRolesToggle: () => setHide(!hide2)
  })))));
};

// build/client-scopes/routes/ClientScope.js
var ClientScopeRoute = {
  path: "/:realm/client-scopes/:id/:type/:tab",
  component: ClientScopeForm,
  breadcrumb: (t4) => t4("client-scopes:clientScopeDetails"),
  access: "view-clients"
};
var toClientScope = (params) => ({
  pathname: generatePath(ClientScopeRoute.path, params)
});

// build/client-scopes/ChangeTypeDialog.js
var ChangeTypeDialog = ({
  selectedClientScopes,
  onConfirm,
  onClose
}) => {
  const {t: t4} = useTranslation("client-scopes");
  const [value, setValue] = useState(AllClientScopes.none);
  return /* @__PURE__ */ react.createElement(Modal, {
    title: t4("changeType"),
    isOpen: true,
    onClose,
    variant: "small",
    description: t4("changeTypeIntro", {count: selectedClientScopes}),
    actions: [
      /* @__PURE__ */ react.createElement(Button, {
        "data-testid": "change-scope-dialog-confirm",
        key: "confirm",
        onClick: () => onConfirm(value)
      }, t4("common:continue")),
      /* @__PURE__ */ react.createElement(Button, {
        key: "cancel",
        variant: ButtonVariant.link,
        onClick: onClose
      }, t4("common:cancel"))
    ]
  }, /* @__PURE__ */ react.createElement(Form, {
    isHorizontal: true
  }, allClientScopeTypes.map((scope) => /* @__PURE__ */ react.createElement(Radio, {
    key: scope,
    isChecked: scope === value,
    name: `radio-${scope}`,
    onChange: (_val, event) => {
      const {value: value2} = event.currentTarget;
      setValue(value2);
    },
    label: t4(`common:clientScope.${scope}`),
    id: `radio-${scope}`,
    value: scope
  }))));
};

// build/client-scopes/routes/NewClientScope.js
var NewClientScopeRoute = {
  path: "/:realm/client-scopes/new",
  component: ClientScopeForm,
  breadcrumb: (t4) => t4("client-scopes:createClientScope"),
  access: "manage-clients"
};
var toNewClientScope = (params) => ({
  pathname: generatePath(NewClientScopeRoute.path, params)
});

// build/client-scopes/ClientScopesSection.js
var ClientScopesSection = () => {
  const {realm: realm2} = useRealm();
  const {t: t4} = useTranslation("client-scopes");
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const [kebabOpen, setKebabOpen] = useState(false);
  const [changeTypeOpen, setChangeTypeOpen] = useState(false);
  const [selectedScopes, setSelectedScopes] = useState([]);
  const loader = async () => {
    const defaultScopes = await adminClient.clientScopes.listDefaultClientScopes();
    const optionalScopes = await adminClient.clientScopes.listDefaultOptionalClientScopes();
    const clientScopes2 = (await adminClient.clientScopes.find()).map((scope) => {
      return {
        ...scope,
        type: defaultScopes.find((defaultScope) => defaultScope.name === scope.name) ? ClientScope.default : optionalScopes.find((optionalScope) => optionalScope.name === scope.name) ? ClientScope.optional : AllClientScopes.none
      };
    });
    return clientScopes2;
  };
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: t4("deleteClientScope", {
      count: selectedScopes.length,
      name: selectedScopes[0]?.name
    }),
    messageKey: "client-scopes:deleteConfirm",
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        for (const scope of selectedScopes) {
          try {
            await removeScope(adminClient, scope);
          } catch (error2) {
            console.warn("could not remove scope", error2.response?.data?.errorMessage || error2);
          }
          await adminClient.clientScopes.del({id: scope.id});
        }
        addAlert(t4("deletedSuccess"), AlertVariant.success);
        refresh();
      } catch (error2) {
        addError("client-scopes:deleteError", error2);
      }
    }
  });
  const TypeSelector = (scope) => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(CellDropdown, {
    clientScope: scope,
    type: scope.type,
    all: true,
    onSelect: async (value) => {
      try {
        await changeScope(adminClient, scope, value);
        addAlert(t4("clientScopeSuccess"), AlertVariant.success);
        refresh();
      } catch (error2) {
        addError("client-scopes:clientScopeError", error2);
      }
    }
  }));
  const ClientScopeDetailLink = ({
    id: id3,
    type,
    name
  }) => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Link, {
    key: id3,
    to: toClientScope({realm: realm2, id: id3, type, tab: "settings"})
  }, name));
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DeleteConfirm, null), changeTypeOpen && /* @__PURE__ */ react.createElement(ChangeTypeDialog, {
    selectedClientScopes: selectedScopes.length,
    onConfirm: (type) => {
      selectedScopes.map(async (scope) => {
        try {
          await changeScope(adminClient, scope, type);
          addAlert(t4("clientScopeSuccess"), AlertVariant.success);
          refresh();
        } catch (error2) {
          addError("client-scopes:clientScopeError", error2);
        }
      });
      setChangeTypeOpen(false);
    },
    onClose: () => setChangeTypeOpen(false)
  }), /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: "clientScopes",
    subKey: "client-scopes:clientScopeExplain"
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    className: "pf-u-p-0"
  }, /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    loader,
    ariaLabelKey: "client-scopes:clientScopeList",
    searchPlaceholderKey: "client-scopes:searchFor",
    onSelect: (clientScopes2) => setSelectedScopes([...clientScopes2]),
    canSelectAll: true,
    toolbarItem: /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      component: Link,
      to: toNewClientScope({realm: realm2})
    }, t4("createClientScope"))), /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Dropdown, {
      toggle: /* @__PURE__ */ react.createElement(KebabToggle, {
        onToggle: () => setKebabOpen(!kebabOpen)
      }),
      isOpen: kebabOpen,
      isPlain: true,
      dropdownItems: [
        /* @__PURE__ */ react.createElement(DropdownItem, {
          key: "changeType",
          component: "button",
          isDisabled: selectedScopes.length === 0,
          onClick: () => {
            setChangeTypeOpen(true);
            setKebabOpen(false);
          }
        }, t4("changeType")),
        /* @__PURE__ */ react.createElement(DropdownItem, {
          key: "action",
          component: "button",
          isDisabled: selectedScopes.length === 0,
          onClick: () => {
            toggleDeleteDialog();
            setKebabOpen(false);
          }
        }, t4("common:delete"))
      ]
    }))),
    actions: [
      {
        title: t4("common:export")
      },
      {
        title: t4("common:delete"),
        onRowClick: (clientScope) => {
          setSelectedScopes([clientScope]);
          toggleDeleteDialog();
        }
      }
    ],
    columns: [
      {
        name: "name",
        cellRenderer: ClientScopeDetailLink
      },
      {name: "description", cellFormatters: [emptyFormatter()]},
      {name: "type", cellRenderer: TypeSelector},
      {
        name: "protocol",
        displayKey: "client-scopes:protocol",
        cellFormatters: [upperCaseFormatter()],
        transforms: [cellWidth(15)]
      },
      {
        name: "attributes['gui.order']",
        displayKey: "client-scopes:displayOrder",
        cellFormatters: [emptyFormatter()],
        transforms: [cellWidth(15)]
      }
    ]
  })));
};

// build/client-scopes/routes/ClientScopes.js
var ClientScopesRoute = {
  path: "/:realm/client-scopes",
  component: ClientScopesSection,
  breadcrumb: (t4) => t4("client-scopes:clientScopeList"),
  access: "view-clients"
};

// build/client-scopes/add/RoleMappingForm.js
var RoleMappingForm = () => {
  const {realm: realm2} = useRealm();
  const adminClient = useAdminClient();
  const history = useHistory();
  const {addAlert} = useAlerts();
  const {t: t4} = useTranslation("client-scopes");
  const {register, handleSubmit, control, errors} = useForm();
  const {id: id3} = useParams();
  const [roleOpen, setRoleOpen] = useState(false);
  const [clientsOpen, setClientsOpen] = useState(false);
  const [clients2, setClients] = useState([]);
  const [selectedClient, setSelectedClient] = useState();
  const [clientRoles, setClientRoles] = useState([]);
  useFetch(async () => {
    const clients22 = await adminClient.clients.find();
    const asyncFilter = async (predicate) => {
      const results = await Promise.all(clients22.map(predicate));
      return clients22.filter((_23, index3) => results[index3]);
    };
    const filteredClients = await asyncFilter(async (client2) => (await adminClient.clients.listRoles({id: client2.id})).length > 0);
    filteredClients.map((client2) => client2.toString = function() {
      return this.clientId;
    });
    return filteredClients;
  }, (filteredClients) => setClients(filteredClients), []);
  useFetch(async () => {
    const client2 = selectedClient;
    if (client2 && client2.name !== "realmRoles") {
      const clientRoles2 = await adminClient.clients.listRoles({
        id: client2.id
      });
      return clientRoles2;
    } else {
      return await adminClient.roles.find();
    }
  }, (clientRoles2) => setClientRoles(clientRoles2), [selectedClient]);
  const save = async (mapping) => {
    try {
      await adminClient.clientScopes.addProtocolMapper({id: id3}, mapping);
      addAlert(t4("mapperCreateSuccess"));
    } catch (error2) {
      addAlert(t4("mapperCreateError", error2));
    }
  };
  const createSelectGroup = (clients22) => {
    return [
      /* @__PURE__ */ react.createElement(SelectGroup, {
        key: "role",
        label: t4("roleGroup")
      }, /* @__PURE__ */ react.createElement(SelectOption, {
        key: "realmRoles",
        value: {
          name: "realmRoles",
          toString: () => t4("realmRoles")
        }
      }, realm2)),
      /* @__PURE__ */ react.createElement(Divider, {
        key: "divider"
      }),
      /* @__PURE__ */ react.createElement(SelectGroup, {
        key: "group",
        label: t4("clientGroup")
      }, clients22.map((client2) => /* @__PURE__ */ react.createElement(SelectOption, {
        key: client2.id,
        value: client2
      }, client2.clientId)))
    ];
  };
  const roleSelectOptions = () => {
    const createItem = (role) => /* @__PURE__ */ react.createElement(SelectOption, {
      key: role.id,
      value: role
    }, role.name);
    return clientRoles.map((role) => createItem(role));
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: "common:addMapper",
    subKey: "client-scopes:addMapperExplain"
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    onSubmit: handleSubmit(save),
    role: "manage-clients"
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:mapperType"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:protocolMapper",
      forLabel: t4("common:mapperType"),
      forID: "protocolMapper"
    }),
    fieldId: "protocolMapper"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register(),
    type: "text",
    id: "protocolMapper",
    name: "protocolMapper",
    isReadOnly: true
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:name"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:mapperName",
      forLabel: t4("common:name"),
      forID: "name"
    }),
    fieldId: "name",
    isRequired: true,
    validated: errors.name ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register({required: true}),
    type: "text",
    id: "name",
    name: "name",
    validated: errors.name ? ValidatedOptions.error : ValidatedOptions.default
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:role"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:role",
      forLabel: t4("common:role"),
      forID: "role"
    }),
    validated: errors["config.role"] ? "error" : "default",
    helperTextInvalid: t4("common:required"),
    fieldId: "role"
  }, /* @__PURE__ */ react.createElement(Split, {
    hasGutter: true
  }, /* @__PURE__ */ react.createElement(SplitItem, null, /* @__PURE__ */ react.createElement(Select, {
    toggleId: "role",
    onToggle: () => setClientsOpen(!clientsOpen),
    isOpen: clientsOpen,
    variant: SelectVariant.typeahead,
    typeAheadAriaLabel: t4("selectASourceOfRoles"),
    placeholderText: t4("selectASourceOfRoles"),
    isGrouped: true,
    onFilter: (evt) => {
      const textInput = evt?.target.value || "";
      if (textInput === "") {
        return createSelectGroup(clients2);
      } else {
        return createSelectGroup(clients2.filter((client2) => client2.name.toLowerCase().includes(textInput.toLowerCase())));
      }
    },
    selections: selectedClient,
    onClear: () => setSelectedClient(void 0),
    onSelect: (_23, value) => {
      if (value) {
        setSelectedClient(value);
        setClientsOpen(false);
      }
    }
  }, createSelectGroup(clients2))), /* @__PURE__ */ react.createElement(SplitItem, null, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.role",
    defaultValue: "",
    control,
    rules: {required: true},
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      onToggle: () => setRoleOpen(!roleOpen),
      isOpen: roleOpen,
      variant: SelectVariant.typeahead,
      placeholderText: selectedClient && selectedClient.name !== "realmRoles" ? t4("clientRoles") : t4("selectARole"),
      isDisabled: !selectedClient,
      typeAheadAriaLabel: t4("selectARole"),
      selections: value.name,
      onSelect: (_23, value2) => {
        onChange(value2);
        setRoleOpen(false);
      },
      onClear: () => onChange("")
    }, roleSelectOptions())
  })))), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("newRoleName"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:newRoleName",
      forLabel: t4("newRoleName"),
      forID: "newRoleName"
    }),
    fieldId: "newRoleName"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register(),
    type: "text",
    id: "newRoleName",
    name: "config.new-role-name"
  })), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "primary",
    type: "submit"
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: () => history.push("..")
  }, t4("common:cancel"))))));
};

// build/client-scopes/routes/OidcRoleNameMapper.js
var OidcRoleNameMapperRoute = {
  path: "/:realm/client-scopes/:id/mappers/oidc-role-name-mapper",
  component: RoleMappingForm,
  breadcrumb: (t4) => t4("common:mappingDetails"),
  access: "view-clients"
};

// build/client-scopes/routes.js
var routes2 = [
  NewClientScopeRoute,
  OidcRoleNameMapperRoute,
  MapperRoute,
  ClientScopeRoute,
  ClientScopesRoute
];
var routes_default2 = routes2;

// build/components/download-dialog/DownloadDialog.js
var DownloadDialog = ({
  id: id3,
  open: open2,
  toggleDialog,
  protocol = "openid-connect"
}) => {
  const adminClient = useAdminClient();
  const {t: t4} = useTranslation("common");
  const {enabled} = useHelp();
  const serverInfo2 = useServerInfo();
  const configFormats = serverInfo2.clientInstallations[protocol];
  const [selected, setSelected] = useState(configFormats[configFormats.length - 1].id);
  const [snippet, setSnippet] = useState("");
  const [openType, setOpenType] = useState(false);
  const selectedConfig = useMemo(() => configFormats?.find((config2) => config2.id === selected) ?? null, [selected]);
  useFetch(async () => {
    const snippet2 = await adminClient.clients.getInstallationProviders({
      id: id3,
      providerId: selected
    });
    if (typeof snippet2 === "string") {
      return snippet2;
    } else {
      return JSON.stringify(snippet2, void 0, 3);
    }
  }, (snippet2) => setSnippet(snippet2), [id3, selected]);
  useEffect(() => setSnippet(""), [id3, selected]);
  return /* @__PURE__ */ react.createElement(ConfirmDialogModal, {
    titleKey: t4("clients:downloadAdaptorTitle"),
    continueButtonLabel: t4("download"),
    onConfirm: () => {
      const config2 = configFormats.find((config22) => config22.id === selected);
      file_saver_default.saveAs(new Blob([snippet], {type: config2.mediaType}), config2.filename);
    },
    open: open2,
    toggleDialog,
    variant: ModalVariant.medium
  }, /* @__PURE__ */ react.createElement(Form, null, /* @__PURE__ */ react.createElement(Stack, {
    hasGutter: true
  }, enabled && /* @__PURE__ */ react.createElement(StackItem, null, /* @__PURE__ */ react.createElement(Alert, {
    id: id3,
    title: t4("clients:description"),
    variant: AlertVariant.info,
    isInline: true
  }, configFormats.find((configFormat) => configFormat.id === selected)?.helpText)), /* @__PURE__ */ react.createElement(StackItem, null, /* @__PURE__ */ react.createElement(FormGroup, {
    fieldId: "type",
    label: t4("clients:formatOption"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: t4("clients-help:downloadType"),
      forLabel: t4("clients:formatOption"),
      forID: "type"
    })
  }, /* @__PURE__ */ react.createElement(Select, {
    toggleId: "type",
    isOpen: openType,
    onToggle: (isExpanded) => setOpenType(isExpanded),
    variant: SelectVariant.single,
    value: selected,
    selections: selected,
    onSelect: (_23, value) => {
      setSelected(value.toString());
      setOpenType(false);
    },
    "aria-label": "Select Input",
    menuAppendTo: () => document.body
  }, configFormats.map((configFormat) => /* @__PURE__ */ react.createElement(SelectOption, {
    key: configFormat.id,
    value: configFormat.id,
    isSelected: selected === configFormat.id
  }, configFormat.displayType))))), !selectedConfig?.downloadOnly && /* @__PURE__ */ react.createElement(StackItem, {
    isFilled: true
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    fieldId: "details",
    label: t4("clients:details"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: t4("clients-help:details"),
      forLabel: t4("clients:details"),
      forID: "details"
    })
  }, /* @__PURE__ */ react.createElement(TextArea, {
    id: "details",
    readOnly: true,
    rows: 12,
    resizeOrientation: "vertical",
    value: snippet,
    "aria-label": "text area example"
  }))))));
};

// build/components/multi-line-input/MultiLineInput.js
function convertToMultiline(fields) {
  return (fields && fields.length > 0 ? fields : [""]).map((field) => {
    return {value: field};
  });
}
function toValue(formValue) {
  return formValue?.map((field) => field.value);
}
var MultiLineInput = ({
  name,
  addButtonLabel,
  ...rest
}) => {
  const {t: t4} = useTranslation();
  const {register, control, reset} = useFormContext();
  const {fields, append, remove: remove3} = useFieldArray({
    name,
    control
  });
  const currentValues = useWatch({control, name});
  useEffect(() => {
    reset({
      [name]: [{value: ""}]
    });
  }, []);
  return /* @__PURE__ */ react.createElement(react.Fragment, null, fields.map(({id: id3, value}, index3) => /* @__PURE__ */ react.createElement(Fragment, {
    key: id3
  }, /* @__PURE__ */ react.createElement(InputGroup, null, /* @__PURE__ */ react.createElement(TextInput, {
    id: id3,
    ref: register(),
    name: `${name}[${index3}].value`,
    defaultValue: value,
    ...rest
  }), /* @__PURE__ */ react.createElement(Button, {
    variant: ButtonVariant.link,
    onClick: () => remove3(index3),
    tabIndex: -1,
    "aria-label": t4("common:remove"),
    isDisabled: index3 === fields.length - 1
  }, /* @__PURE__ */ react.createElement(MinusCircleIcon, null))), index3 === fields.length - 1 && /* @__PURE__ */ react.createElement(Button, {
    variant: ButtonVariant.link,
    onClick: () => append({}),
    tabIndex: -1,
    "aria-label": t4("common:add"),
    isDisabled: rest.isDisabled || !(currentValues && currentValues[index3]?.value)
  }, /* @__PURE__ */ react.createElement(PlusCircleIcon, null), " ", t4(addButtonLabel || "common:add")))));
};

// build/components/attribute-form/AttributeForm.js
var arrayToAttributes = (attributeArray) => {
  const initValue = {};
  return attributeArray.reduce((acc, attribute) => {
    acc[attribute.key] = [attribute.value];
    return acc;
  }, initValue);
};
var attributesToArray = (attributes) => {
  if (!attributes || Object.keys(attributes).length == 0) {
    return [];
  }
  return Object.keys(attributes).map((key) => ({
    key,
    value: attributes[key][0]
  }));
};
var AttributesForm = ({
  form: {handleSubmit, register, formState, errors, watch},
  array: {fields, append, remove: remove3},
  reset,
  save
}) => {
  const {t: t4} = useTranslation("roles");
  const columns = ["Key", "Value"];
  const watchLast = watch(`attributes[${fields.length - 1}].key`, "");
  useEffect(() => {
    if (fields.length === 0) {
      append({key: "", value: ""});
    }
  }, [fields]);
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-realm",
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(TableComposable, {
    className: "kc-attributes__table",
    "aria-label": "Role attribute keys and values",
    variant: "compact",
    borders: false
  }, /* @__PURE__ */ react.createElement(Thead, null, /* @__PURE__ */ react.createElement(Tr, null, /* @__PURE__ */ react.createElement(Th2, {
    id: "key",
    width: 40
  }, columns[0]), /* @__PURE__ */ react.createElement(Th2, {
    id: "value",
    width: 40
  }, columns[1]))), /* @__PURE__ */ react.createElement(Tbody, null, fields.map((attribute, rowIndex) => /* @__PURE__ */ react.createElement(Tr, {
    key: attribute.id
  }, /* @__PURE__ */ react.createElement(Td2, {
    key: `${attribute.id}-key`,
    id: `text-input-${rowIndex}-key`,
    dataLabel: columns[0]
  }, /* @__PURE__ */ react.createElement(TextInput, {
    name: `attributes[${rowIndex}].key`,
    ref: register(),
    "aria-label": "key-input",
    defaultValue: attribute.key,
    validated: errors.attributes && errors.attributes[rowIndex] ? "error" : "default"
  })), /* @__PURE__ */ react.createElement(Td2, {
    key: `${attribute}-value`,
    id: `text-input-${rowIndex}-value`,
    dataLabel: columns[1]
  }, /* @__PURE__ */ react.createElement(TextInput, {
    name: `attributes[${rowIndex}].value`,
    ref: register(),
    "aria-label": "value-input",
    defaultValue: attribute.value
  })), rowIndex !== fields.length - 1 && fields.length - 1 !== 0 && /* @__PURE__ */ react.createElement(Td2, {
    key: "minus-button",
    id: `kc-minus-button-${rowIndex}`,
    dataLabel: columns[2]
  }, /* @__PURE__ */ react.createElement(Button, {
    id: `minus-button-${rowIndex}`,
    "aria-label": `remove ${attribute.key} with value ${attribute.value} `,
    variant: "link",
    className: "kc-attributes__minus-icon",
    onClick: () => remove3(rowIndex)
  }, /* @__PURE__ */ react.createElement(MinusCircleIcon, null))), rowIndex === fields.length - 1 && /* @__PURE__ */ react.createElement(Td2, {
    key: "add-button",
    id: "add-button",
    dataLabel: columns[2]
  }, fields.length !== 1 && /* @__PURE__ */ react.createElement(Button, {
    id: `minus-button-${rowIndex}`,
    "aria-label": `remove ${attribute.key} with value ${attribute.value} `,
    variant: "link",
    className: "kc-attributes__minus-icon",
    onClick: () => remove3(rowIndex)
  }, /* @__PURE__ */ react.createElement(MinusCircleIcon, null))))), /* @__PURE__ */ react.createElement(Tr, null, /* @__PURE__ */ react.createElement(Td2, null, /* @__PURE__ */ react.createElement(Button, {
    "aria-label": t4("roles:addAttributeText"),
    id: "plus-icon",
    variant: "link",
    className: "kc-attributes__plus-icon",
    onClick: () => append({key: "", value: ""}),
    icon: /* @__PURE__ */ react.createElement(PlusCircleIcon, null),
    isDisabled: !watchLast
  }, t4("roles:addAttributeText")))))), /* @__PURE__ */ react.createElement(ActionGroup, {
    className: "kc-attributes__action-group"
  }, /* @__PURE__ */ react.createElement(Button, {
    variant: "primary",
    type: "submit",
    isDisabled: !watchLast
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    onClick: reset,
    variant: "link",
    isDisabled: !formState.isDirty
  }, t4("common:revert")))));
};

// build/realm-roles/RealmRoleForm.js
var RealmRoleForm = ({
  form: {handleSubmit, errors, register, getValues},
  save,
  editMode,
  reset
}) => {
  const {t: t4} = useTranslation("roles");
  return /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    onSubmit: handleSubmit(save),
    role: "manage-realm",
    className: "pf-u-mt-lg"
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("roleName"),
    fieldId: "kc-name",
    isRequired: true,
    validated: errors.name ? "error" : "default",
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register({required: !editMode}),
    type: "text",
    id: "kc-name",
    name: "name",
    isReadOnly: editMode
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:description"),
    fieldId: "kc-description",
    validated: errors.description ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: errors.description?.message
  }, /* @__PURE__ */ react.createElement(TextArea, {
    name: "description",
    "aria-label": "description",
    isDisabled: getValues().name?.includes("default-roles"),
    ref: register({
      maxLength: {
        value: 255,
        message: t4("common:maxLength", {length: 255})
      }
    }),
    type: "text",
    validated: errors.description ? ValidatedOptions.error : ValidatedOptions.default,
    id: "kc-role-description"
  })), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "primary",
    onClick: save,
    "data-testid": "realm-roles-save-button"
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    onClick: () => reset(),
    variant: "link"
  }, editMode ? t4("common:revert") : t4("common:cancel"))));
};

// build/realm-roles/AssociatedRolesModal.js
var AssociatedRolesModal = (props) => {
  const {t: t4} = useTranslation("roles");
  const [name, setName] = useState("");
  const adminClient = useAdminClient();
  const [selectedRows, setSelectedRows] = useState([]);
  const [isFilterDropdownOpen, setIsFilterDropdownOpen] = useState(false);
  const [filterType, setFilterType] = useState("roles");
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const {id: id3} = useParams();
  const alphabetize = (rolesList) => {
    return lodash.sortBy(rolesList, (role) => role.name?.toUpperCase());
  };
  const loader = async () => {
    const roles2 = await adminClient.roles.find();
    const existingAdditionalRoles = await adminClient.roles.getCompositeRoles({
      id: id3
    });
    const allRoles = [...roles2, ...existingAdditionalRoles];
    const filterDupes = allRoles.filter((thing, index3, self2) => index3 === self2.findIndex((t22) => t22.name === thing.name));
    const clients2 = await adminClient.clients.find();
    filterDupes.filter((role) => role.clientRole).map((role) => role.clientId = clients2.find((client2) => client2.id === role.containerId).clientId);
    return alphabetize(filterDupes).filter((role) => {
      return props.existingCompositeRoles.find((existing) => existing.name === role.name) === void 0 && role.name !== name;
    });
  };
  const AliasRenderer = ({id: id22, name: name2, clientId}) => {
    return /* @__PURE__ */ react.createElement(react.Fragment, null, clientId && /* @__PURE__ */ react.createElement(Label, {
      color: "blue",
      key: `label-${id22}`
    }, clientId), " ", name2);
  };
  const clientRolesLoader = async () => {
    const clients2 = await adminClient.clients.find();
    const clientIdArray = clients2.map((client2) => client2.id);
    let rolesList = [];
    for (const id22 of clientIdArray) {
      const clientRolesList = await adminClient.clients.listRoles({
        id: id22
      });
      rolesList = [...rolesList, ...clientRolesList];
    }
    const existingAdditionalRoles = await adminClient.roles.getCompositeRoles({
      id: id3
    });
    rolesList.filter((role) => role.clientRole).map((role) => role.clientId = clients2.find((client2) => client2.id === role.containerId).clientId);
    return alphabetize(rolesList).filter((role) => {
      return existingAdditionalRoles.find((existing) => existing.name === role.name) === void 0 && role.name !== name;
    });
  };
  useEffect(() => {
    refresh();
  }, [filterType]);
  useFetch(async () => {
    if (id3)
      return await adminClient.roles.findOneById({id: id3});
  }, (fetchedRole) => {
    if (fetchedRole) {
      setName(fetchedRole.name);
    } else {
      setName(t4("createRole"));
    }
  }, []);
  const onFilterDropdownToggle = () => {
    setIsFilterDropdownOpen(!isFilterDropdownOpen);
  };
  const onFilterDropdownSelect = (filterType2) => {
    if (filterType2 === "roles") {
      setFilterType("clients");
    }
    if (filterType2 === "clients") {
      setFilterType("roles");
    }
    setIsFilterDropdownOpen(!isFilterDropdownOpen);
  };
  return /* @__PURE__ */ react.createElement(Modal, {
    "data-testid": "addAssociatedRole",
    title: t4("roles:associatedRolesModalTitle", {name}),
    isOpen: props.open,
    onClose: props.toggleDialog,
    variant: ModalVariant.large,
    actions: [
      /* @__PURE__ */ react.createElement(Button, {
        key: "add",
        "data-testid": "add-associated-roles-button",
        variant: "primary",
        isDisabled: !selectedRows?.length,
        onClick: () => {
          props.toggleDialog();
          props.onConfirm(selectedRows);
        }
      }, t4("common:add")),
      /* @__PURE__ */ react.createElement(Button, {
        key: "cancel",
        variant: "link",
        onClick: () => {
          props.toggleDialog();
        }
      }, t4("common:cancel"))
    ]
  }, /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    loader: filterType === "roles" ? loader : clientRolesLoader,
    ariaLabelKey: "roles:roleList",
    searchPlaceholderKey: "roles:searchFor",
    searchTypeComponent: /* @__PURE__ */ react.createElement(Dropdown, {
      onSelect: () => onFilterDropdownSelect(filterType),
      "data-testid": "filter-type-dropdown",
      toggle: /* @__PURE__ */ react.createElement(DropdownToggle, {
        id: "toggle-id-9",
        onToggle: onFilterDropdownToggle,
        toggleIndicator: CaretDownIcon,
        icon: /* @__PURE__ */ react.createElement(FilterIcon, null)
      }, "Filter by ", filterType),
      isOpen: isFilterDropdownOpen,
      dropdownItems: [
        /* @__PURE__ */ react.createElement(DropdownItem, {
          "data-testid": "filter-type-dropdown-item",
          key: "filter-type"
        }, filterType === "roles" ? t4("filterByClients") : t4("filterByRoles"), " ")
      ]
    }),
    canSelectAll: true,
    onSelect: (rows) => {
      setSelectedRows([...rows]);
    },
    columns: [
      {
        name: "name",
        displayKey: "roles:roleName",
        cellRenderer: AliasRenderer
      },
      {
        name: "description",
        displayKey: "common:description"
      }
    ],
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      hasIcon: true,
      message: t4("noRoles"),
      instructions: t4("noRolesInstructions"),
      primaryActionText: t4("createRole")
    })
  }));
};

// build/realm-roles/AssociatedRolesTab.js
var AssociatedRolesTab = ({
  additionalRoles,
  addComposites,
  parentRole,
  onRemove: onRemove2
}) => {
  const {t: t4} = useTranslation("roles");
  const history = useHistory();
  const {addAlert, addError} = useAlerts();
  const {url} = useRouteMatch();
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const [selectedRows, setSelectedRows] = useState([]);
  const [isInheritedHidden, setIsInheritedHidden] = useState(false);
  const [allRoles, setAllRoles] = useState([]);
  const [open2, setOpen] = useState(false);
  const adminClient = useAdminClient();
  const {id: id3} = useParams();
  const inheritanceMap = react.useRef({});
  const getSubRoles = async (role, allRoles2) => {
    const allCompositeRoles = await adminClient.roles.getCompositeRoles({
      id: role.id
    });
    const newRoles = allCompositeRoles.reduce(async (acc, newRole) => {
      const resolvedRoles = await acc;
      if (!allRoles2.find((ar) => ar.id === newRole.id)) {
        inheritanceMap.current[newRole.id] = role.name;
        resolvedRoles.push(newRole);
        const subRoles = await getSubRoles(newRole, [
          ...allRoles2,
          ...resolvedRoles
        ]);
        resolvedRoles.push(...subRoles);
      }
      return acc;
    }, Promise.resolve([]));
    return newRoles;
  };
  const loader = async () => {
    const alphabetize = (rolesList) => {
      return lodash.sortBy(rolesList, (role) => role.name?.toUpperCase());
    };
    const clients2 = await adminClient.clients.find();
    if (isInheritedHidden) {
      setAllRoles(additionalRoles);
      return alphabetize(additionalRoles.filter((role) => role.containerId === "master" && !inheritanceMap.current[role.id]));
    }
    const fetchedRoles = additionalRoles.reduce(async (acc, role) => {
      const resolvedRoles = await acc;
      resolvedRoles.push(role);
      const subRoles = await getSubRoles(role, resolvedRoles);
      resolvedRoles.push(...subRoles);
      return acc;
    }, Promise.resolve([]));
    return fetchedRoles.then((results) => {
      const filterDupes = results.filter((thing, index3, self2) => index3 === self2.findIndex((t22) => t22.name === thing.name));
      filterDupes.filter((role) => role.clientRole).map((role) => role.clientId = clients2.find((client2) => client2.id === role.containerId).clientId);
      return alphabetize(additionalRoles);
    });
  };
  useEffect(() => {
    refresh();
  }, [additionalRoles, isInheritedHidden]);
  const InheritedRoleName = (role) => {
    return /* @__PURE__ */ react.createElement(react.Fragment, null, inheritanceMap.current[role.id]);
  };
  const AliasRenderer = ({id: id22, name, clientId}) => {
    return /* @__PURE__ */ react.createElement(react.Fragment, null, clientId && /* @__PURE__ */ react.createElement(Label, {
      color: "blue",
      key: `label-${id22}`
    }, clientId), " ", name);
  };
  const toggleModal = () => setOpen(!open2);
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: "roles:roleRemoveAssociatedRoleConfirm",
    messageKey: t4("roles:roleRemoveAssociatedText", {
      role: selectedRows.map((r4) => r4.name),
      roleName: parentRole.name
    }),
    continueButtonLabel: "common:remove",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        await adminClient.roles.delCompositeRoles({id: id3}, selectedRows);
        onRemove2(selectedRows);
        setSelectedRows([]);
        addAlert(t4("associatedRolesRemoved"), AlertVariant.success);
      } catch (error2) {
        addError("roles:roleDeleteError", error2);
      }
    }
  });
  const [toggleDeleteAssociatedRolesDialog, DeleteAssociatedRolesConfirm] = useConfirmDialog({
    titleKey: t4("roles:removeAssociatedRoles") + "?",
    messageKey: t4("roles:removeAllAssociatedRolesConfirmDialog", {
      name: parentRole?.name || t4("createRole")
    }),
    continueButtonLabel: "common:remove",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        if (selectedRows.length >= allRoles.length) {
          onRemove2(selectedRows);
          const loc = url.replace(/\/AssociatedRoles/g, "/details");
          history.push(loc);
        }
        onRemove2(selectedRows);
        await adminClient.roles.delCompositeRoles({id: id3}, selectedRows);
        addAlert(t4("associatedRolesRemoved"), AlertVariant.success);
        refresh();
      } catch (error2) {
        addError("roles:roleDeleteError", error2);
      }
    }
  });
  const goToCreate = () => history.push(`${url}/add-role`);
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    padding: {default: "noPadding"}
  }, /* @__PURE__ */ react.createElement(DeleteConfirm, null), /* @__PURE__ */ react.createElement(DeleteAssociatedRolesConfirm, null), /* @__PURE__ */ react.createElement(AssociatedRolesModal, {
    onConfirm: addComposites,
    existingCompositeRoles: additionalRoles,
    open: open2,
    toggleDialog: () => setOpen(!open2)
  }), /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    loader,
    ariaLabelKey: "roles:roleList",
    searchPlaceholderKey: "roles:searchFor",
    canSelectAll: true,
    onSelect: (rows) => {
      setSelectedRows([...rows]);
    },
    toolbarItem: /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Checkbox, {
      label: "Hide inherited roles",
      key: "associated-roles-check",
      id: "kc-hide-inherited-roles-checkbox",
      onChange: () => setIsInheritedHidden(!isInheritedHidden),
      isChecked: isInheritedHidden
    })), /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      key: "add-role-button",
      onClick: () => toggleModal(),
      "data-testid": "add-role-button"
    }, t4("addRole"))), /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      variant: "link",
      isDisabled: selectedRows.length === 0,
      key: "remove-role-button",
      onClick: () => {
        toggleDeleteAssociatedRolesDialog();
      }
    }, t4("removeRoles")))),
    actions: [
      {
        title: t4("common:remove"),
        onRowClick: (role) => {
          setSelectedRows([role]);
          toggleDeleteDialog();
        }
      }
    ],
    columns: [
      {
        name: "name",
        displayKey: "roles:roleName",
        cellRenderer: AliasRenderer,
        cellFormatters: [emptyFormatter()]
      },
      {
        name: "containerId",
        displayKey: "roles:inheritedFrom",
        cellRenderer: InheritedRoleName,
        cellFormatters: [emptyFormatter()]
      },
      {
        name: "description",
        displayKey: "common:description",
        cellFormatters: [emptyFormatter()]
      }
    ],
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      hasIcon: true,
      message: t4("noRoles"),
      instructions: t4("noRolesInstructions"),
      primaryActionText: t4("createRole"),
      onPrimaryAction: goToCreate
    })
  })));
};

// build/realm-roles/UsersInRoleTab.js
var UsersInRoleTab = () => {
  const history = useHistory();
  const {realm: realm2} = useRealm();
  const {t: t4} = useTranslation("roles");
  const {id: id3, clientId} = useParams();
  const adminClient = useAdminClient();
  const loader = async (first, max2) => {
    const role = await adminClient.roles.findOneById({id: id3});
    if (role.clientRole) {
      return adminClient.clients.findUsersWithRole({
        roleName: role.name,
        id: clientId,
        first,
        max: max2
      });
    }
    return adminClient.roles.findUsersWithRole({
      name: role.name,
      first,
      max: max2
    });
  };
  const {enabled} = useHelp();
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(PageSection, {
    "data-testid": "users-page",
    variant: "light"
  }, /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    isPaginated: true,
    loader,
    ariaLabelKey: "roles:roleList",
    searchPlaceholderKey: "",
    toolbarItem: enabled && /* @__PURE__ */ react.createElement(Popover, {
      "aria-label": "Basic popover",
      position: "bottom",
      bodyContent: /* @__PURE__ */ react.createElement("div", null, t4("roles:whoWillAppearPopoverText"), /* @__PURE__ */ react.createElement(Button, {
        className: "kc-groups-link",
        variant: "link",
        onClick: () => history.push(`/${realm2}/groups`)
      }, t4("groups")), t4("or"), /* @__PURE__ */ react.createElement(Button, {
        className: "kc-users-link",
        variant: "link",
        onClick: () => history.push(`/${realm2}/users`)
      }, t4("users"), ".")),
      footerContent: t4("roles:whoWillAppearPopoverFooterText")
    }, /* @__PURE__ */ react.createElement(Button, {
      variant: "link",
      className: "kc-who-will-appear-button",
      key: "who-will-appear-button",
      icon: /* @__PURE__ */ react.createElement(QuestionCircleIcon, null)
    }, t4("roles:whoWillAppearLinkText"))),
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      hasIcon: true,
      message: t4("noDirectUsers"),
      instructions: /* @__PURE__ */ react.createElement("div", null, t4("noUsersEmptyStateDescription"), /* @__PURE__ */ react.createElement(Button, {
        className: "kc-groups-link-empty-state",
        variant: "link",
        onClick: () => history.push(`/${realm2}/groups`)
      }, t4("groups")), t4("or"), /* @__PURE__ */ react.createElement(Button, {
        className: "kc-users-link-empty-state",
        variant: "link",
        onClick: () => history.push(`/${realm2}/users`)
      }, t4("users")), t4("noUsersEmptyStateDescriptionContinued"))
    }),
    columns: [
      {
        name: "username",
        displayKey: "roles:userName",
        cellFormatters: [emptyFormatter()]
      },
      {
        name: "email",
        displayKey: "roles:email",
        cellFormatters: [emptyFormatter()]
      },
      {
        name: "lastName",
        displayKey: "roles:lastName",
        cellFormatters: [emptyFormatter()]
      },
      {
        name: "firstName",
        displayKey: "roles:firstName",
        cellFormatters: [upperCaseFormatter(), emptyFormatter()]
      }
    ]
  })));
};

// build/realm-roles/RealmRoleTabs.js
var RealmRoleTabs = () => {
  const {t: t4} = useTranslation("roles");
  const form2 = useForm({mode: "onChange"});
  const history = useHistory();
  const adminClient = useAdminClient();
  const [role, setRole] = useState();
  const {id: id3, clientId} = useParams();
  const {url} = useRouteMatch();
  const {realm: realmName} = useRealm();
  const [key, setKey] = useState("");
  const refresh = () => {
    setKey(`${new Date().getTime()}`);
  };
  const [additionalRoles, setAdditionalRoles] = useState([]);
  const {addAlert, addError} = useAlerts();
  const [open2, setOpen] = useState(false);
  const convert = (role2) => {
    const {attributes, ...rest} = role2;
    return {
      attributes: attributesToArray(attributes),
      ...rest
    };
  };
  const [realm2, setRealm] = useState();
  useFetch(() => adminClient.realms.findOne({realm: realmName}), (realm22) => {
    setRealm(realm22);
  }, []);
  useEffect(() => {
    const update = async () => {
      if (id3) {
        const fetchedRole = await adminClient.roles.findOneById({id: id3});
        const allAdditionalRoles = await adminClient.roles.getCompositeRoles({
          id: id3
        });
        setAdditionalRoles(allAdditionalRoles);
        const convertedRole = convert(fetchedRole);
        Object.entries(convertedRole).map((entry) => {
          form2.setValue(entry[0], entry[1]);
        });
        setRole(convertedRole);
      }
    };
    setTimeout(update, 100);
  }, [key]);
  const {fields, append, remove: remove3} = useFieldArray({
    control: form2.control,
    name: "attributes"
  });
  const save = async () => {
    try {
      const role2 = form2.getValues();
      if (role2.attributes && role2.attributes[role2.attributes.length - 1].key === "") {
        form2.setValue("attributes", role2.attributes.slice(0, role2.attributes.length - 1));
      }
      if (!await form2.trigger()) {
        return;
      }
      const {attributes, ...rest} = role2;
      const roleRepresentation = rest;
      if (id3) {
        if (attributes) {
          roleRepresentation.attributes = arrayToAttributes(attributes);
        }
        if (!clientId) {
          await adminClient.roles.updateById({id: id3}, roleRepresentation);
        } else {
          await adminClient.clients.updateRole({id: clientId, roleName: role2.name}, roleRepresentation);
        }
        await adminClient.roles.createComposite({roleId: id3, realm: realmName}, additionalRoles);
        setRole(role2);
        form2.reset(role2);
      } else {
        let createdRole;
        if (!clientId) {
          await adminClient.roles.create(roleRepresentation);
          createdRole = await adminClient.roles.findOneByName({
            name: role2.name
          });
        } else {
          await adminClient.clients.createRole({
            id: clientId,
            name: role2.name
          });
          if (role2.description) {
            await adminClient.clients.updateRole({id: clientId, roleName: role2.name}, roleRepresentation);
          }
          createdRole = await adminClient.clients.findRole({
            id: clientId,
            roleName: role2.name
          });
        }
        setRole(convert(createdRole));
        history.push(url.substr(0, url.lastIndexOf("/") + 1) + createdRole.id + "/details");
      }
      addAlert(t4(id3 ? "roleSaveSuccess" : "roleCreated"), AlertVariant.success);
    } catch (error2) {
      addError(`roles:${id3 ? "roleSave" : "roleCreate"}Error`, error2);
    }
  };
  const addComposites = async (composites) => {
    const compositeArray = composites;
    setAdditionalRoles([...additionalRoles, ...compositeArray]);
    try {
      await adminClient.roles.createComposite({roleId: id3, realm: realmName}, compositeArray);
      history.push(url.substr(0, url.lastIndexOf("/") + 1) + "AssociatedRoles");
      refresh();
      addAlert(t4("addAssociatedRolesSuccess"), AlertVariant.success);
    } catch (error2) {
      addError("roles:addAssociatedRolesError", error2);
    }
  };
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: "roles:roleDeleteConfirm",
    messageKey: t4("roles:roleDeleteConfirmDialog", {
      name: role?.name || t4("createRole")
    }),
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        if (!clientId) {
          await adminClient.roles.delById({id: id3});
        } else {
          await adminClient.clients.delRole({
            id: clientId,
            roleName: role.name
          });
        }
        addAlert(t4("roleDeletedSuccess"), AlertVariant.success);
        history.push(url.substr(0, url.indexOf("/roles") + "/roles".length));
      } catch (error2) {
        addError("roles:roleDeleteError", error2);
      }
    }
  });
  const dropdownItems = url.includes("AssociatedRoles") && !realm2?.defaultRole ? [
    /* @__PURE__ */ react.createElement(DropdownItem, {
      key: "delete-all-associated",
      component: "button",
      onClick: () => toggleDeleteAllAssociatedRolesDialog()
    }, t4("roles:removeAllAssociatedRoles")),
    /* @__PURE__ */ react.createElement(DropdownItem, {
      key: "delete-role",
      component: "button",
      onClick: () => {
        toggleDeleteDialog();
      }
    }, t4("deleteRole"))
  ] : id3 && realm2?.defaultRole && url.includes("AssociatedRoles") ? [
    /* @__PURE__ */ react.createElement(DropdownItem, {
      key: "delete-all-associated",
      component: "button",
      onClick: () => toggleDeleteAllAssociatedRolesDialog()
    }, t4("roles:removeAllAssociatedRoles"))
  ] : [
    /* @__PURE__ */ react.createElement(DropdownItem, {
      key: "toggle-modal",
      "data-testid": "add-roles",
      component: "button",
      onClick: () => toggleModal()
    }, t4("addAssociatedRolesText")),
    /* @__PURE__ */ react.createElement(DropdownItem, {
      key: "delete-role",
      component: "button",
      onClick: () => toggleDeleteDialog()
    }, t4("deleteRole"))
  ];
  const [
    toggleDeleteAllAssociatedRolesDialog,
    DeleteAllAssociatedRolesConfirm
  ] = useConfirmDialog({
    titleKey: t4("roles:removeAllAssociatedRoles") + "?",
    messageKey: t4("roles:removeAllAssociatedRolesConfirmDialog", {
      name: role?.name || t4("createRole")
    }),
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        await adminClient.roles.delCompositeRoles({id: id3}, additionalRoles);
        addAlert(t4("compositeRoleOff"), AlertVariant.success, t4("compositesRemovedAlertDescription"));
        const loc = url.replace(/\/AssociatedRoles/g, "/details");
        history.push(loc);
        refresh();
      } catch (error2) {
        addError("roles:roleDeleteError", error2);
      }
    }
  });
  const toggleModal = () => setOpen(!open2);
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DeleteConfirm, null), /* @__PURE__ */ react.createElement(DeleteAllAssociatedRolesConfirm, null), /* @__PURE__ */ react.createElement(AssociatedRolesModal, {
    onConfirm: addComposites,
    existingCompositeRoles: additionalRoles,
    open: open2,
    toggleDialog: () => setOpen(!open2)
  }), /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: role?.name || t4("createRole"),
    badges: [
      {
        id: "composite-role-badge",
        text: additionalRoles.length > 0 ? t4("composite") : "",
        readonly: true
      }
    ],
    subKey: id3 ? "" : "roles:roleCreateExplain",
    actionsDropdownId: "roles-actions-dropdown",
    dropdownItems,
    divider: !id3
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    className: "pf-u-p-0"
  }, id3 && /* @__PURE__ */ react.createElement(KeycloakTabs, {
    isBox: true
  }, /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "details",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("details"))
  }, /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(RealmRoleForm, {
    reset: () => form2.reset(role),
    form: form2,
    save,
    editMode: true
  }))), additionalRoles.length > 0 && /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "AssociatedRoles",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("associatedRolesText"))
  }, /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, role && /* @__PURE__ */ react.createElement(AssociatedRolesTab, {
    additionalRoles,
    addComposites,
    parentRole: role,
    onRemove: () => refresh()
  }))), form2.getValues().name !== realm2?.defaultRole?.name && /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "attributes",
    className: "kc-attributes-tab",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("common:attributes"))
  }, /* @__PURE__ */ react.createElement(AttributesForm, {
    form: form2,
    save,
    array: {fields, append, remove: remove3},
    reset: () => form2.reset(role)
  })), form2.getValues().name !== realm2?.defaultRole?.name && /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "users-in-role",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("usersInRole"))
  }, /* @__PURE__ */ react.createElement(UsersInRoleTab, {
    "data-cy": "users-in-role-tab"
  }))), !id3 && /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(RealmRoleForm, {
    reset: () => form2.reset(),
    form: form2,
    save,
    editMode: false
  }))));
};

// build/realm-roles/routes/RealmRole.js
var RealmRoleRoute = {
  path: "/:realm/roles/:id/:tab?",
  component: RealmRoleTabs,
  breadcrumb: (t4) => t4("roles:roleDetails"),
  access: ["view-realm", "view-users"]
};
var toRealmRole = (params) => ({
  pathname: generatePath(RealmRoleRoute.path, params)
});

// build/realm-roles/RolesList.js
var RoleLink = ({children: children2, role}) => {
  const {realm: realm2} = useRealm();
  return /* @__PURE__ */ react.createElement(Link, {
    key: role.id,
    to: toRealmRole({realm: realm2, id: role.id})
  }, children2);
};
var RolesList = ({
  loader,
  paginated = true,
  parentRoleId,
  messageBundle = "roles"
}) => {
  const {t: t4} = useTranslation(messageBundle);
  const history = useHistory();
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const {url} = useRouteMatch();
  const {realm: realmName} = useRealm();
  const [realm2, setRealm] = useState();
  const [selectedRole, setSelectedRole] = useState();
  useFetch(() => adminClient.realms.findOne({realm: realmName}), (realm22) => {
    setRealm(realm22);
  }, []);
  const RoleDetailLink = (role) => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(RoleLink, {
    role
  }, role.name), role.name?.includes("default-role") ? /* @__PURE__ */ react.createElement(HelpItem, {
    helpText: t4("defaultRole"),
    forLabel: t4("defaultRole"),
    forID: "kc-defaultRole",
    id: "default-role-help-icon"
  }) : "");
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: "roles:roleDeleteConfirm",
    messageKey: t4("roles:roleDeleteConfirmDialog", {
      selectedRoleName: selectedRole ? selectedRole.name : ""
    }),
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        if (!parentRoleId) {
          await adminClient.roles.delById({
            id: selectedRole.id
          });
        } else {
          await adminClient.roles.delCompositeRoles({id: parentRoleId}, [
            selectedRole
          ]);
        }
        setSelectedRole(void 0);
        addAlert(t4("roleDeletedSuccess"), AlertVariant.success);
      } catch (error2) {
        addError("roles:roleDeleteError", error2);
      }
    }
  });
  const goToCreate = () => history.push(`${url}/add-role`);
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DeleteConfirm, null), /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key: selectedRole ? selectedRole.id : "roleList",
    loader,
    ariaLabelKey: "roles:roleList",
    searchPlaceholderKey: "roles:searchFor",
    isPaginated: paginated,
    toolbarItem: /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Button, {
      onClick: goToCreate
    }, t4("createRole"))),
    actions: [
      {
        title: t4("common:delete"),
        onRowClick: (role) => {
          setSelectedRole(role);
          if (role.name === realm2.defaultRole.name) {
            addAlert(t4("defaultRoleDeleteError"), AlertVariant.danger);
          } else
            toggleDeleteDialog();
        }
      }
    ],
    columns: [
      {
        name: "name",
        displayKey: "roles:roleName",
        cellRenderer: RoleDetailLink
      },
      {
        name: "composite",
        displayKey: "roles:composite",
        cellFormatters: [upperCaseFormatter(), emptyFormatter()]
      },
      {
        name: "description",
        displayKey: "common:description",
        cellFormatters: [emptyFormatter()]
      }
    ],
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      hasIcon: true,
      message: t4("noRoles"),
      instructions: t4("noRolesInstructions"),
      primaryActionText: t4("createRole"),
      onPrimaryAction: goToCreate
    })
  }));
};

// build/clients/AdvancedTab.js
var import_moment = __toModule(require_moment());

// build/components/scroll-form/ScrollPanel.js
var ScrollPanel = (props) => {
  const {title: title3, children: children2, scrollId, ...rest} = props;
  return /* @__PURE__ */ react.createElement("section", {
    ...rest,
    className: "kc-form-panel__panel"
  }, /* @__PURE__ */ react.createElement(Title, {
    headingLevel: "h1",
    size: "xl",
    className: "kc-form-panel__title",
    id: scrollId,
    tabIndex: 0
  }, title3), children2);
};

// build/components/scroll-form/FormPanel.js
var FormPanel = ({
  title: title3,
  children: children2,
  scrollId,
  className
}) => {
  return /* @__PURE__ */ react.createElement(Card, {
    className,
    isFlat: true
  }, /* @__PURE__ */ react.createElement(CardHeader, {
    className: "kc-form-panel__header"
  }, /* @__PURE__ */ react.createElement(CardTitle, {
    tabIndex: 0
  }, /* @__PURE__ */ react.createElement(Title, {
    headingLevel: "h1",
    size: "xl",
    className: "kc-form-panel__title",
    id: scrollId,
    tabIndex: 0
  }, title3))), /* @__PURE__ */ react.createElement(CardBody, {
    className: "kc-form-panel__body"
  }, children2));
};

// build/components/scroll-form/ScrollForm.js
var spacesToHyphens = (string) => {
  return string.replace(/\s+/g, "-");
};
var ScrollForm = ({
  sections: sections2,
  borders = false,
  children: children2,
  ...rest
}) => {
  const {t: t4} = useTranslation("common");
  const nodes = Children.toArray(children2);
  return /* @__PURE__ */ react.createElement(Grid, {
    hasGutter: true,
    ...rest
  }, /* @__PURE__ */ react.createElement(GridItem, {
    span: 8
  }, sections2.map((cat, index3) => /* @__PURE__ */ react.createElement(Fragment, {
    key: cat
  }, !borders && /* @__PURE__ */ react.createElement(ScrollPanel, {
    scrollId: spacesToHyphens(cat),
    title: cat
  }, nodes[index3]), borders && /* @__PURE__ */ react.createElement(FormPanel, {
    scrollId: spacesToHyphens(cat),
    title: cat,
    className: "kc-form-panel__panel"
  }, nodes[index3])))), /* @__PURE__ */ react.createElement(GridItem, {
    span: 4
  }, /* @__PURE__ */ react.createElement(PageSection, {
    className: "kc-scroll-form--sticky"
  }, /* @__PURE__ */ react.createElement(JumpLinks, {
    isVertical: true,
    scrollableSelector: `#${mainPageContentId}`,
    label: t4("jumpToSection"),
    offset: 100
  }, sections2.map((cat) => /* @__PURE__ */ react.createElement(JumpLinksItem, {
    key: cat,
    href: `#${spacesToHyphens(cat)}`
  }, cat))))));
};

// build/components/time-selector/TimeSelector.js
var TimeSelector = ({
  value,
  units = ["seconds", "minutes", "hours", "days"],
  onChange,
  className,
  ...rest
}) => {
  const {t: t4} = useTranslation("common");
  const allTimes = [
    {unit: "seconds", label: t4("times.seconds"), multiplier: 1},
    {unit: "minutes", label: t4("times.minutes"), multiplier: 60},
    {unit: "hours", label: t4("times.hours"), multiplier: 3600},
    {unit: "days", label: t4("times.days"), multiplier: 86400}
  ];
  const times = units.map((unit) => allTimes.find((time2) => time2.unit === unit));
  const defaultMultiplier = allTimes.find((time2) => time2.unit === units[0])?.multiplier;
  const [timeValue, setTimeValue] = useState("");
  const [multiplier, setMultiplier] = useState(defaultMultiplier);
  const [open2, setOpen] = useState(false);
  useEffect(() => {
    const x3 = times.reduce((v3, time2) => value % time2.multiplier === 0 && v3 < time2.multiplier ? time2.multiplier : v3, 1);
    if (value) {
      setMultiplier(x3);
      setTimeValue(value / x3);
    } else {
      setTimeValue("");
      setMultiplier(defaultMultiplier);
    }
  }, [value]);
  const updateTimeout = (timeout2, times2 = multiplier) => {
    if (timeout2 !== "") {
      onChange(timeout2 * (times2 || 1));
      setTimeValue(timeout2);
    } else {
      onChange("");
    }
  };
  return /* @__PURE__ */ react.createElement(Split, {
    hasGutter: true,
    className
  }, /* @__PURE__ */ react.createElement(SplitItem, null, /* @__PURE__ */ react.createElement(TextInput, {
    ...rest,
    type: "number",
    id: `kc-time-${new Date().getTime()}`,
    "aria-label": "kc-time",
    min: "0",
    value: timeValue,
    className: `${className}-input`,
    onChange: (value2) => {
      updateTimeout(value2 === "" ? value2 : parseInt(value2));
    }
  })), /* @__PURE__ */ react.createElement(SplitItem, {
    id: `${className}-select-menu`
  }, /* @__PURE__ */ react.createElement(Select, {
    variant: SelectVariant.single,
    "aria-label": t4("unitLabel"),
    className: `${className}-select`,
    onSelect: (_23, value2) => {
      setMultiplier(value2);
      updateTimeout(timeValue, value2);
      setOpen(false);
    },
    selections: [multiplier],
    onToggle: () => {
      setOpen(!open2);
    },
    isOpen: open2
  }, times.map((time2) => /* @__PURE__ */ react.createElement(SelectOption, {
    id: time2.label,
    key: time2.label,
    value: time2.multiplier
  }, time2.label)))));
};

// build/clients/advanced/AddHostDialog.js
var AddHostDialog = ({
  clientId: id3,
  isOpen,
  onAdded,
  onClose
}) => {
  const {t: t4} = useTranslation("clients");
  const {register, getValues} = useForm();
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  return /* @__PURE__ */ react.createElement(Modal, {
    title: t4("addNode"),
    isOpen,
    onClose,
    variant: "small",
    actions: [
      /* @__PURE__ */ react.createElement(Button, {
        id: "add-node-confirm",
        key: "confirm",
        onClick: async () => {
          try {
            const node = getValues("node");
            await adminClient.clients.addClusterNode({
              id: id3,
              node
            });
            onAdded(node);
            addAlert(t4("addedNodeSuccess"), AlertVariant.success);
          } catch (error2) {
            addError("clients:addedNodeFail", error2);
          }
          onClose();
        }
      }, t4("common:save")),
      /* @__PURE__ */ react.createElement(Button, {
        id: "add-node-cancel",
        key: "cancel",
        variant: ButtonVariant.link,
        onClick: () => onClose()
      }, t4("common:cancel"))
    ]
  }, /* @__PURE__ */ react.createElement(Form, {
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("nodeHost"),
    fieldId: "nodeHost"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    id: "nodeHost",
    ref: register,
    name: "node"
  }))));
};

// build/clients/advanced/TokenLifespan.js
var never = "tokenLifespan.never";
var expires = "tokenLifespan.expires";
var TokenLifespan = ({
  id: id3,
  name,
  defaultValue,
  control,
  units
}) => {
  const {t: t4} = useTranslation("clients");
  const [open2, setOpen] = useState(false);
  return /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4(id3),
    fieldId: id3,
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: `clients-help:${id3}`,
      forLabel: t4(id3),
      forID: t4(`common:helpLabel`, {
        label: t4(id3)
      })
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name,
    defaultValue,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Split, {
      hasGutter: true
    }, /* @__PURE__ */ react.createElement(SplitItem, null, /* @__PURE__ */ react.createElement(Select, {
      variant: SelectVariant.single,
      onToggle: (isExpanded) => setOpen(isExpanded),
      isOpen: open2,
      onSelect: (_23, value2) => {
        onChange(value2);
        setOpen(false);
      },
      selections: [
        typeof value === "number" && value !== -1 ? t4(expires) : t4(never)
      ]
    }, /* @__PURE__ */ react.createElement(SelectOption, {
      value: -1
    }, t4(never)), /* @__PURE__ */ react.createElement(SelectOption, {
      value: 60
    }, t4(expires)))), /* @__PURE__ */ react.createElement(SplitItem, null, typeof value === "number" && value !== -1 && /* @__PURE__ */ react.createElement(TimeSelector, {
      units,
      value,
      onChange
    })))
  }));
};

// build/clients/advanced/AdvancedSettings.js
var AdvancedSettings = ({
  control,
  save,
  reset,
  protocol
}) => {
  const {t: t4} = useTranslation("clients");
  const [open2, setOpen] = useState(false);
  return /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-realm",
    isHorizontal: true
  }, protocol !== "openid-connect" && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("assertionLifespan"),
    fieldId: "assertionLifespan",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:assertionLifespan",
      forLabel: t4("assertionLifespan"),
      forID: t4(`common:helpLabel`, {label: t4("assertionLifespan")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.saml-assertion-lifespan",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      units: ["minutes", "days", "hours"],
      value,
      onChange
    })
  })), protocol === "openid-connect" && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(TokenLifespan, {
    id: "accessTokenLifespan",
    name: "attributes.access-token-lifespan",
    defaultValue: "",
    units: ["minutes", "days", "hours"],
    control
  }), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("oAuthMutual"),
    fieldId: "oAuthMutual",
    hasNoPaddingTop: true,
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:oAuthMutual",
      forLabel: t4("oAuthMutual"),
      forID: t4(`common:helpLabel`, {label: t4("oAuthMutual")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.tls-client-certificate-bound-access-tokens",
    defaultValue: false,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "oAuthMutual-switch",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value === "true",
      onChange: (value2) => onChange("" + value2)
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("keyForCodeExchange"),
    fieldId: "keyForCodeExchange",
    hasNoPaddingTop: true,
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:keyForCodeExchange",
      forLabel: t4("keyForCodeExchange"),
      forID: t4(`common:helpLabel`, {
        label: t4("keyForCodeExchange")
      })
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.pkce-code-challenge-method",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "keyForCodeExchange",
      variant: SelectVariant.single,
      onToggle: () => setOpen(!open2),
      isOpen: open2,
      onSelect: (_23, value2) => {
        onChange(value2);
        setOpen(false);
      },
      selections: [value || t4("common:choose")]
    }, ["", "S256", "plain"].map((v3) => /* @__PURE__ */ react.createElement(SelectOption, {
      key: v3,
      value: v3
    }, v3 || t4("common:choose"))))
  }))), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "tertiary",
    onClick: save
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: reset
  }, t4("common:revert"))));
};

// build/clients/advanced/AuthenticationOverrides.js
var AuthenticationOverrides = ({
  protocol,
  control,
  save,
  reset
}) => {
  const adminClient = useAdminClient();
  const {t: t4} = useTranslation("clients");
  const [flows, setFlows] = useState([]);
  const [browserFlowOpen, setBrowserFlowOpen] = useState(false);
  const [directGrantOpen, setDirectGrantOpen] = useState(false);
  useFetch(() => adminClient.authenticationManagement.getFlows(), (flows2) => {
    let filteredFlows = [
      ...flows2.filter((flow) => flow.providerId !== "client-flow")
    ];
    filteredFlows = lodash.sortBy(filteredFlows, [(f3) => f3.alias]);
    setFlows([
      /* @__PURE__ */ react.createElement(SelectOption, {
        key: "empty",
        value: ""
      }, t4("common:choose")),
      ...filteredFlows.map((flow) => /* @__PURE__ */ react.createElement(SelectOption, {
        key: flow.id,
        value: flow.id
      }, flow.alias))
    ]);
  }, []);
  return /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-clients",
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("browserFlow"),
    fieldId: "browserFlow",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:browserFlow",
      forLabel: t4("browserFlow"),
      forID: t4(`common:helpLabel`, {label: t4("browserFlow")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "authenticationFlowBindingOverrides.browser",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "browserFlow",
      variant: SelectVariant.single,
      onToggle: () => setBrowserFlowOpen(!browserFlowOpen),
      isOpen: browserFlowOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setBrowserFlowOpen(false);
      },
      selections: [value]
    }, flows)
  })), protocol === "openid-connect" && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("directGrant"),
    fieldId: "directGrant",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:directGrant",
      forLabel: t4("directGrant"),
      forID: t4(`common:helpLabel`, {label: t4("directGrant")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "authenticationFlowBindingOverrides.direct_grant",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "directGrant",
      variant: SelectVariant.single,
      onToggle: () => setDirectGrantOpen(!directGrantOpen),
      isOpen: directGrantOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setDirectGrantOpen(false);
      },
      selections: [value]
    }, flows)
  })), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "tertiary",
    onClick: save
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: reset
  }, t4("common:revert"))));
};

// build/clients/advanced/FineGrainOpenIdConnect.js
var FineGrainOpenIdConnect = ({
  control,
  save,
  reset
}) => {
  const {t: t4} = useTranslation("clients");
  const providers = useServerInfo().providers;
  const clientSignatureProviders = providers?.clientSignature.providers;
  const contentEncryptionProviders = providers?.contentencryption.providers;
  const cekManagementProviders = providers?.cekmanagement.providers;
  const signatureProviders = providers?.signature.providers;
  const [accessTokenOpen, setAccessTokenOpen] = useState(false);
  const [idTokenOpen, setIdTokenOpen] = useState(false);
  const [idTokenKeyManagementOpen, setIdTokenKeyManagementOpen] = useState(false);
  const [idTokenContentOpen, setIdTokenContentOpen] = useState(false);
  const [userInfoSignedResponseOpen, setUserInfoSignedResponseOpen] = useState(false);
  const [requestObjectSignatureOpen, setRequestObjectSignatureOpen] = useState(false);
  const [requestObjectRequiredOpen, setRequestObjectRequiredOpen] = useState(false);
  const keyOptions = [
    /* @__PURE__ */ react.createElement(SelectOption, {
      key: "empty",
      value: ""
    }, t4("common:choose")),
    ...sortProviders(clientSignatureProviders).map((p3) => /* @__PURE__ */ react.createElement(SelectOption, {
      key: p3,
      value: p3
    }))
  ];
  const cekManagementOptions = [
    /* @__PURE__ */ react.createElement(SelectOption, {
      key: "empty",
      value: ""
    }, t4("common:choose")),
    ...sortProviders(cekManagementProviders).map((p3) => /* @__PURE__ */ react.createElement(SelectOption, {
      key: p3,
      value: p3
    }))
  ];
  const signatureOptions = [
    /* @__PURE__ */ react.createElement(SelectOption, {
      key: "unsigned",
      value: ""
    }, t4("unsigned")),
    ...sortProviders(signatureProviders).map((p3) => /* @__PURE__ */ react.createElement(SelectOption, {
      key: p3,
      value: p3
    }))
  ];
  const contentOptions = [
    /* @__PURE__ */ react.createElement(SelectOption, {
      key: "empty",
      value: ""
    }, t4("common:choose")),
    ...sortProviders(contentEncryptionProviders).map((p3) => /* @__PURE__ */ react.createElement(SelectOption, {
      key: p3,
      value: p3
    }))
  ];
  const requestObjectOptions = [
    /* @__PURE__ */ react.createElement(SelectOption, {
      key: "any",
      value: "any"
    }, t4("common:any")),
    /* @__PURE__ */ react.createElement(SelectOption, {
      key: "none",
      value: "none"
    }, t4("common:none")),
    ...sortProviders(clientSignatureProviders).map((p3) => /* @__PURE__ */ react.createElement(SelectOption, {
      key: p3,
      value: p3
    }))
  ];
  const requestObjectRequiredOptions = [
    "not required",
    "request or request_uri",
    "request only",
    "request_uri only"
  ].map((p3) => /* @__PURE__ */ react.createElement(SelectOption, {
    key: p3,
    value: p3
  }, t4(`requestObject.${p3}`)));
  const selectOptionToString = (value, options) => {
    const selectOption = options.find((s2) => s2.props.value === value);
    return selectOption?.props.children || selectOption?.props.value;
  };
  return /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-clients",
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("accessTokenSignatureAlgorithm"),
    fieldId: "accessTokenSignatureAlgorithm",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:accessTokenSignatureAlgorithm",
      forLabel: t4("accessTokenSignatureAlgorithm"),
      forID: "accessTokenSignatureAlgorithm"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.access-token-signed-response-alg",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "accessTokenSignatureAlgorithm",
      variant: SelectVariant.single,
      onToggle: () => setAccessTokenOpen(!accessTokenOpen),
      isOpen: accessTokenOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setAccessTokenOpen(false);
      },
      selections: [selectOptionToString(value, keyOptions)]
    }, keyOptions)
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("idTokenSignatureAlgorithm"),
    fieldId: "kc-id-token-signature",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:idTokenSignatureAlgorithm",
      forLabel: t4("idTokenSignatureAlgorithm"),
      forID: "idTokenSignatureAlgorithm"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.id-token-signed-response-alg",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "idTokenSignatureAlgorithm",
      variant: SelectVariant.single,
      onToggle: () => setIdTokenOpen(!idTokenOpen),
      isOpen: idTokenOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setIdTokenOpen(false);
      },
      selections: [selectOptionToString(value, keyOptions)]
    }, keyOptions)
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("idTokenEncryptionKeyManagementAlgorithm"),
    fieldId: "idTokenEncryptionKeyManagementAlgorithm",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:idTokenEncryptionKeyManagementAlgorithm",
      forLabel: t4("idTokenEncryptionKeyManagementAlgorithm"),
      forID: "idTokenEncryptionKeyManagementAlgorithm"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.id-token-encrypted-response-alg",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "idTokenEncryptionKeyManagementAlgorithm",
      variant: SelectVariant.single,
      onToggle: () => setIdTokenKeyManagementOpen(!idTokenKeyManagementOpen),
      isOpen: idTokenKeyManagementOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setIdTokenKeyManagementOpen(false);
      },
      selections: [selectOptionToString(value, cekManagementOptions)]
    }, cekManagementOptions)
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("idTokenEncryptionContentEncryptionAlgorithm"),
    fieldId: "idTokenEncryptionContentEncryptionAlgorithm",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:idTokenEncryptionContentEncryptionAlgorithm",
      forLabel: t4("idTokenEncryptionContentEncryptionAlgorithm"),
      forID: "idTokenEncryptionContentEncryptionAlgorithm"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.id-token-encrypted-response-enc",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "idTokenEncryptionContentEncryptionAlgorithm",
      variant: SelectVariant.single,
      onToggle: () => setIdTokenContentOpen(!idTokenContentOpen),
      isOpen: idTokenContentOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setIdTokenContentOpen(false);
      },
      selections: [selectOptionToString(value, contentOptions)]
    }, contentOptions)
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("userInfoSignedResponseAlgorithm"),
    fieldId: "userInfoSignedResponseAlgorithm",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:userInfoSignedResponseAlgorithm",
      forLabel: t4("userInfoSignedResponseAlgorithm"),
      forID: "userInfoSignedResponseAlgorithm"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.user-info-response-signature-alg",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "userInfoSignedResponseAlgorithm",
      variant: SelectVariant.single,
      onToggle: () => setUserInfoSignedResponseOpen(!userInfoSignedResponseOpen),
      isOpen: userInfoSignedResponseOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setUserInfoSignedResponseOpen(false);
      },
      selections: [selectOptionToString(value, signatureOptions)]
    }, signatureOptions)
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("requestObjectSignatureAlgorithm"),
    fieldId: "requestObjectSignatureAlgorithm",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:requestObjectSignatureAlgorithm",
      forLabel: t4("requestObjectSignatureAlgorithm"),
      forID: "requestObjectSignatureAlgorithm"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.request_object_signature_alg",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "requestObjectSignatureAlgorithm",
      variant: SelectVariant.single,
      onToggle: () => setRequestObjectSignatureOpen(!requestObjectSignatureOpen),
      isOpen: requestObjectSignatureOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setRequestObjectSignatureOpen(false);
      },
      selections: [selectOptionToString(value, requestObjectOptions)]
    }, requestObjectOptions)
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("requestObjectRequired"),
    fieldId: "requestObjectRequired",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:requestObjectRequired",
      forLabel: t4("requestObjectRequired"),
      forID: "requestObjectRequired"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.request-object-required",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "requestObjectRequired",
      variant: SelectVariant.single,
      onToggle: () => setRequestObjectRequiredOpen(!requestObjectRequiredOpen),
      isOpen: requestObjectRequiredOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setRequestObjectRequiredOpen(false);
      },
      selections: [
        selectOptionToString(value, requestObjectRequiredOptions)
      ]
    }, requestObjectRequiredOptions)
  })), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    id: "fineGrainSave",
    variant: "tertiary",
    onClick: save
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    id: "fineGrainRevert",
    variant: "link",
    onClick: reset
  }, t4("common:revert"))));
};

// build/clients/advanced/FineGrainSamlEndpointConfig.js
var FineGrainSamlEndpointConfig = ({
  control: {register},
  save,
  reset
}) => {
  const {t: t4} = useTranslation("clients");
  return /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-realm",
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("assertionConsumerServicePostBindingURL"),
    fieldId: "assertionConsumerServicePostBindingURL",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:assertionConsumerServicePostBindingURL",
      forLabel: t4("assertionConsumerServicePostBindingURL"),
      forID: "assertionConsumerServicePostBindingURL"
    })
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register(),
    type: "text",
    id: "assertionConsumerServicePostBindingURL",
    name: "attributes.saml_assertion_consumer_url_post"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("assertionConsumerServiceRedirectBindingURL"),
    fieldId: "assertionConsumerServiceRedirectBindingURL",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:assertionConsumerServiceRedirectBindingURL",
      forLabel: t4("assertionConsumerServiceRedirectBindingURL"),
      forID: "assertionConsumerServiceRedirectBindingURL"
    })
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register(),
    type: "text",
    id: "assertionConsumerServiceRedirectBindingURL",
    name: "attributes.saml_assertion_consumer_url_redirect"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("logoutServicePostBindingURL"),
    fieldId: "logoutServicePostBindingURL",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:logoutServicePostBindingURL",
      forLabel: t4("logoutServicePostBindingURL"),
      forID: "logoutServicePostBindingURL"
    })
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register(),
    type: "text",
    id: "logoutServicePostBindingURL",
    name: "attributes.saml_single_logout_service_url_post"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("logoutServiceRedirectBindingURL"),
    fieldId: "logoutServiceRedirectBindingURL",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:logoutServiceRedirectBindingURL",
      forLabel: t4("logoutServiceRedirectBindingURL"),
      forID: "logoutServiceRedirectBindingURL"
    })
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register(),
    type: "text",
    id: "logoutServiceRedirectBindingURL",
    name: "attributes.saml_single_logout_service_url_redirect"
  })), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "tertiary",
    onClick: save
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: reset
  }, t4("common:revert"))));
};

// build/clients/advanced/OpenIdConnectCompatibilityModes.js
var OpenIdConnectCompatibilityModes = ({
  control,
  save,
  reset
}) => {
  const {t: t4} = useTranslation("clients");
  return /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-realm",
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("excludeSessionStateFromAuthenticationResponse"),
    fieldId: "excludeSessionStateFromAuthenticationResponse",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:excludeSessionStateFromAuthenticationResponse",
      forLabel: t4("excludeSessionStateFromAuthenticationResponse"),
      forID: t4(`common:helpLabel`, {
        label: t4("excludeSessionStateFromAuthenticationResponse")
      })
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.exclude-session-state-from-auth-response",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "excludeSessionStateFromAuthenticationResponse-switch",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value === "true",
      onChange: (value2) => onChange("" + value2)
    })
  })), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "tertiary",
    onClick: save
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: reset
  }, t4("common:revert"))));
};

// build/clients/AdvancedTab.js
var AdvancedTab = ({
  save,
  client: {
    id: id3,
    registeredNodes,
    attributes,
    protocol,
    authenticationFlowBindingOverrides
  }
}) => {
  const {t: t4} = useTranslation("clients");
  const adminClient = useAdminClient();
  const {realm: realm2} = useRealm();
  const {addAlert, addError} = useAlerts();
  const revocationFieldName = "notBefore";
  const openIdConnect = "openid-connect";
  const {getValues, setValue, register, control, reset} = useFormContext();
  const [expanded, setExpanded] = useState(false);
  const [selectedNode, setSelectedNode] = useState("");
  const [addNodeOpen, setAddNodeOpen] = useState(false);
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const [nodes, setNodes] = useState(registeredNodes || {});
  const setNotBefore = (time2, messageKey) => {
    setValue(revocationFieldName, time2);
    save({messageKey});
  };
  const parseResult = (result, prefixKey) => {
    const successCount = result.successRequests?.length || 0;
    const failedCount = result.failedRequests?.length || 0;
    if (successCount === 0 && failedCount === 0) {
      addAlert(t4("noAdminUrlSet"), AlertVariant.warning);
    } else if (failedCount > 0) {
      addAlert(t4(prefixKey + "Success", {successNodes: result.successRequests}), AlertVariant.success);
      addAlert(t4(prefixKey + "Fail", {failedNodes: result.failedRequests}), AlertVariant.danger);
    } else {
      addAlert(t4(prefixKey + "Success", {successNodes: result.successRequests}), AlertVariant.success);
    }
  };
  const resetFields = (names) => {
    const values2 = {};
    for (const name of names) {
      values2[`attributes.${name}`] = attributes ? attributes[name.replace(/-/g, ".")] || "" : "";
    }
    reset(values2);
  };
  const push = async () => {
    const result = await adminClient.clients.pushRevocation({
      id: id3
    });
    parseResult(result, "notBeforePush");
  };
  const testCluster = async () => {
    const result = await adminClient.clients.testNodesAvailable({id: id3});
    parseResult(result, "testCluster");
  };
  const [toggleDeleteNodeConfirm, DeleteNodeConfirm] = useConfirmDialog({
    titleKey: "clients:deleteNode",
    messageKey: t4("deleteNodeBody", {
      node: selectedNode
    }),
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        await adminClient.clients.deleteClusterNode({
          id: id3,
          node: selectedNode
        });
        setNodes({
          ...Object.keys(nodes).reduce((object, key2) => {
            if (key2 !== selectedNode) {
              object[key2] = nodes[key2];
            }
            return object;
          }, {})
        });
        refresh();
        addAlert(t4("deleteNodeSuccess"), AlertVariant.success);
      } catch (error2) {
        addError("clients:deleteNodeFail", error2);
      }
    }
  });
  useEffect(() => {
    register(revocationFieldName);
  }, [register]);
  const formatDate = () => {
    const date = getValues(revocationFieldName);
    if (date > 0) {
      return (0, import_moment.default)(date * 1e3).format("LLL");
    } else {
      return t4("common:none");
    }
  };
  const sections2 = [
    t4("revocation"),
    t4("clustering"),
    protocol === openIdConnect ? t4("fineGrainOpenIdConnectConfiguration") : t4("fineGrainSamlEndpointConfig"),
    t4("advancedSettings"),
    t4("authenticationOverrides")
  ];
  if (protocol === openIdConnect) {
    sections2.splice(3, 0, t4("openIdConnectCompatibilityModes"));
  }
  return /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    className: "pf-u-py-0"
  }, /* @__PURE__ */ react.createElement(ScrollForm, {
    sections: sections2,
    borders: true
  }, /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Text, {
    className: "pf-u-pb-lg"
  }, /* @__PURE__ */ react.createElement(Trans, {
    i18nKey: "clients-help:notBeforeIntro"
  }, "In order to successfully push setup url on", /* @__PURE__ */ react.createElement(Link, {
    to: toClient({realm: realm2, clientId: id3, tab: "settings"})
  }, t4("settings")), "tab")), /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-clients",
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("notBefore"),
    fieldId: "kc-not-before",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:notBefore",
      forLabel: t4("notBefore"),
      forID: t4(`common:helpLabel`, {label: t4("notBefore")})
    })
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-not-before",
    name: "notBefore",
    isReadOnly: true,
    value: formatDate()
  })), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    id: "setToNow",
    variant: "tertiary",
    onClick: () => {
      setNotBefore(import_moment.default.now() / 1e3, "notBeforeSetToNow");
    }
  }, t4("setToNow")), /* @__PURE__ */ react.createElement(Button, {
    id: "clear",
    variant: "tertiary",
    onClick: () => {
      setNotBefore(0, "notBeforeNowClear");
    }
  }, t4("clear")), /* @__PURE__ */ react.createElement(Button, {
    id: "push",
    variant: "secondary",
    onClick: push
  }, t4("push"))))), /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-clients",
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("nodeReRegistrationTimeout"),
    fieldId: "kc-node-reregistration-timeout",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:nodeReRegistrationTimeout",
      forLabel: t4("nodeReRegistrationTimeout"),
      forID: t4(`common:helpLabel`, {
        label: t4("nodeReRegistrationTimeout")
      })
    })
  }, /* @__PURE__ */ react.createElement(Split, {
    hasGutter: true
  }, /* @__PURE__ */ react.createElement(SplitItem, null, /* @__PURE__ */ react.createElement(Controller, {
    name: "nodeReRegistrationTimeout",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      value,
      onChange
    })
  })), /* @__PURE__ */ react.createElement(SplitItem, null, /* @__PURE__ */ react.createElement(Button, {
    variant: ButtonVariant.secondary,
    onClick: () => save()
  }, t4("common:save")))))), /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DeleteNodeConfirm, null), /* @__PURE__ */ react.createElement(AddHostDialog, {
    clientId: id3,
    isOpen: addNodeOpen,
    onAdded: (node) => {
      nodes[node] = import_moment.default.now() / 1e3;
      refresh();
    },
    onClose: () => setAddNodeOpen(false)
  }), /* @__PURE__ */ react.createElement(ExpandableSection, {
    toggleText: t4("registeredClusterNodes"),
    onToggle: () => setExpanded(!expanded),
    isExpanded: expanded
  }, /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    ariaLabelKey: "registeredClusterNodes",
    loader: () => Promise.resolve(Object.entries(nodes || {}).map((entry) => {
      return {host: entry[0], registration: entry[1]};
    })),
    toolbarItem: /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      id: "testClusterAvailability",
      onClick: testCluster,
      variant: ButtonVariant.secondary,
      isDisabled: Object.keys(nodes).length === 0
    }, t4("testClusterAvailability"))), /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      id: "registerNodeManually",
      onClick: () => setAddNodeOpen(true),
      variant: ButtonVariant.tertiary
    }, t4("registerNodeManually")))),
    actions: [
      {
        title: t4("common:delete"),
        onRowClick: (node) => {
          setSelectedNode(node.host);
          toggleDeleteNodeConfirm();
        }
      }
    ],
    columns: [
      {
        name: "host",
        displayKey: "clients:nodeHost"
      },
      {
        name: "registration",
        displayKey: "clients:lastRegistration",
        cellFormatters: [
          (value) => value ? (0, import_moment.default)(parseInt(value.toString()) * 1e3).format("LLL") : ""
        ]
      }
    ],
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      message: t4("noNodes"),
      instructions: t4("noNodesInstructions"),
      primaryActionText: t4("registerNodeManually"),
      onPrimaryAction: () => setAddNodeOpen(true)
    })
  })))), /* @__PURE__ */ react.createElement(react.Fragment, null, protocol === openIdConnect && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Text, {
    className: "pf-u-pb-lg"
  }, t4("clients-help:fineGrainOpenIdConnectConfiguration")), /* @__PURE__ */ react.createElement(FineGrainOpenIdConnect, {
    control,
    save: () => save(),
    reset: () => convertToFormValues(attributes, "attributes", setValue)
  })), protocol !== openIdConnect && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Text, {
    className: "pf-u-pb-lg"
  }, t4("clients-help:fineGrainSamlEndpointConfig")), /* @__PURE__ */ react.createElement(FineGrainSamlEndpointConfig, {
    control,
    save: () => save(),
    reset: () => convertToFormValues(attributes, "attributes", setValue)
  }))), protocol === openIdConnect && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Text, {
    className: "pf-u-pb-lg"
  }, t4("clients-help:openIdConnectCompatibilityModes")), /* @__PURE__ */ react.createElement(OpenIdConnectCompatibilityModes, {
    control,
    save: () => save(),
    reset: () => resetFields(["exclude-session-state-from-auth-response"])
  })), /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Text, {
    className: "pf-u-pb-lg"
  }, t4("clients-help:advancedSettings" + toUpperCase(protocol || ""))), /* @__PURE__ */ react.createElement(AdvancedSettings, {
    protocol,
    control,
    save: () => save(),
    reset: () => {
      resetFields([
        "saml-assertion-lifespan",
        "access-token-lifespan",
        "tls-client-certificate-bound-access-tokens",
        "pkce-code-challenge-method"
      ]);
    }
  })), /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Text, {
    className: "pf-u-pb-lg"
  }, t4("clients-help:authenticationOverrides")), /* @__PURE__ */ react.createElement(AuthenticationOverrides, {
    protocol,
    control,
    save: () => save(),
    reset: () => {
      setValue("authenticationFlowBindingOverrides.browser", authenticationFlowBindingOverrides?.browser);
      setValue("authenticationFlowBindingOverrides.direct_grant", authenticationFlowBindingOverrides?.direct_grant);
    }
  }))));
};

// build/clients/ClientDescription.js
var ClientDescription = () => {
  const {t: t4} = useTranslation("clients");
  const {register, errors} = useFormContext();
  return /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-clients",
    unWrap: true
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:clientId",
      forLabel: t4("common:clientId"),
      forID: "kc-client-id"
    }),
    label: t4("common:clientId"),
    fieldId: "kc-client-id",
    helperTextInvalid: t4("common:required"),
    validated: errors.clientId ? ValidatedOptions.error : ValidatedOptions.default,
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register({required: true}),
    type: "text",
    id: "kc-client-id",
    name: "clientId",
    validated: errors.clientId ? ValidatedOptions.error : ValidatedOptions.default
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:clientName",
      forLabel: t4("common:name"),
      forID: "kc-name"
    }),
    label: t4("common:name"),
    fieldId: "kc-name"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register(),
    type: "text",
    id: "kc-name",
    name: "name"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:description",
      forLabel: t4("common:description"),
      forID: "kc-description"
    }),
    label: t4("common:description"),
    fieldId: "kc-description",
    validated: errors.description ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: errors.description?.message
  }, /* @__PURE__ */ react.createElement(TextArea, {
    ref: register({
      maxLength: {
        value: 255,
        message: t4("common:maxLength", {length: 255})
      }
    }),
    type: "text",
    id: "kc-description",
    name: "description",
    validated: errors.description ? ValidatedOptions.error : ValidatedOptions.default
  })));
};

// build/clients/add/CapabilityConfig.js
var CapabilityConfig = ({
  unWrap,
  protocol: type
}) => {
  const {t: t4} = useTranslation("clients");
  const {control, watch, setValue} = useFormContext();
  const protocol = type || watch("protocol");
  const clientAuthentication = watch("publicClient");
  const authorization = watch("authorizationServicesEnabled");
  return /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-clients",
    unWrap,
    className: "keycloak__capability-config__form"
  }, /* @__PURE__ */ react.createElement(react.Fragment, null, protocol === "openid-connect" && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    hasNoPaddingTop: true,
    label: t4("clientAuthentication"),
    fieldId: "kc-authentication",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:authentication",
      forLabel: t4("authentication"),
      forID: t4(`common:helpLabel`, {label: t4("authentication")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "publicClient",
    defaultValue: false,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      "data-testid": "authentication",
      id: "kc-authentication-switch",
      name: "publicClient",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: !value,
      onChange: (value2) => {
        onChange(!value2);
        if (!value2) {
          setValue("authorizationServicesEnabled", false);
          setValue("serviceAccountsEnabled", false);
        }
      }
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    hasNoPaddingTop: true,
    label: t4("clientAuthorization"),
    fieldId: "kc-authorization",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:authorization",
      forLabel: t4("authorization"),
      forID: t4(`common:helpLabel`, {label: t4("authorization")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "authorizationServicesEnabled",
    defaultValue: false,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      "data-testid": "authorization",
      id: "kc-authorization-switch",
      name: "authorizationServicesEnabled",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value && !clientAuthentication,
      onChange: (value2) => {
        onChange(value2);
        if (value2) {
          setValue("serviceAccountsEnabled", true);
        }
      },
      isDisabled: clientAuthentication
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    hasNoPaddingTop: true,
    label: t4("authenticationFlow"),
    fieldId: "kc-flow"
  }, /* @__PURE__ */ react.createElement(Grid, null, /* @__PURE__ */ react.createElement(GridItem, {
    lg: 4,
    sm: 6
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "standardFlowEnabled",
    defaultValue: true,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(InputGroup, null, /* @__PURE__ */ react.createElement(Checkbox, {
      "data-testid": "standard",
      label: t4("standardFlow"),
      id: "kc-flow-standard",
      name: "standardFlowEnabled",
      isChecked: value,
      onChange
    }), /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:standardFlow",
      forLabel: t4("standardFlow"),
      forID: t4(`common:helpLabel`, {
        label: t4("standardFlow")
      })
    }))
  })), /* @__PURE__ */ react.createElement(GridItem, {
    lg: 8,
    sm: 6
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "directAccessGrantsEnabled",
    defaultValue: true,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(InputGroup, null, /* @__PURE__ */ react.createElement(Checkbox, {
      "data-testid": "direct",
      label: t4("directAccess"),
      id: "kc-flow-direct",
      name: "directAccessGrantsEnabled",
      isChecked: value,
      onChange
    }), /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:directAccess",
      forLabel: t4("directAccess"),
      forID: t4(`common:helpLabel`, {
        label: t4("directAccess")
      })
    }))
  })), /* @__PURE__ */ react.createElement(GridItem, {
    lg: 4,
    sm: 6
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "implicitFlowEnabled",
    defaultValue: false,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(InputGroup, null, /* @__PURE__ */ react.createElement(Checkbox, {
      "data-testid": "implicit",
      label: t4("implicitFlow"),
      id: "kc-flow-implicit",
      name: "implicitFlowEnabled",
      isChecked: value,
      onChange
    }), /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:implicitFlow",
      forLabel: t4("implicitFlow"),
      forID: t4(`common:helpLabel`, {
        label: t4("implicitFlow")
      })
    }))
  })), /* @__PURE__ */ react.createElement(GridItem, {
    lg: 8,
    sm: 6
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "serviceAccountsEnabled",
    defaultValue: false,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(InputGroup, null, /* @__PURE__ */ react.createElement(Checkbox, {
      "data-testid": "service-account",
      label: t4("serviceAccount"),
      id: "kc-flow-service-account",
      name: "serviceAccountsEnabled",
      isChecked: value || clientAuthentication && authorization,
      onChange,
      isDisabled: clientAuthentication && !authorization || !clientAuthentication && authorization
    }), /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:serviceAccount",
      forLabel: t4("serviceAccount"),
      forID: t4(`common:helpLabel`, {
        label: t4("serviceAccount")
      })
    }))
  })))))), /* @__PURE__ */ react.createElement(react.Fragment, null, protocol === "saml" && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:encryptAssertions",
      forLabel: t4("encryptAssertions"),
      forID: t4(`common:helpLabel`, {
        label: t4("encryptAssertions")
      })
    }),
    label: t4("encryptAssertions"),
    fieldId: "kc-encrypt",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.saml_encrypt",
    control,
    defaultValue: "false",
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      "data-testid": "encrypt",
      id: "kc-encrypt",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value === "true",
      onChange: (value2) => onChange("" + value2)
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:clientSignature",
      forLabel: t4("clientSignature"),
      forID: t4(`common:helpLabel`, {label: t4("clientSignature")})
    }),
    label: t4("clientSignature"),
    fieldId: "kc-client-signature",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.saml_client_signature",
    control,
    defaultValue: "false",
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      "data-testid": "client-signature",
      id: "kc-client-signature",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value === "true",
      onChange: (value2) => onChange("" + value2)
    })
  })))));
};

// build/clients/advanced/SaveReset.js
var SaveReset = ({name, save, reset, ...rest}) => {
  const {t: t4} = useTranslation("common");
  return /* @__PURE__ */ react.createElement(ActionGroup, {
    ...rest
  }, /* @__PURE__ */ react.createElement(Button, {
    "data-testid": name + "Save",
    onClick: save
  }, t4("save")), /* @__PURE__ */ react.createElement(Button, {
    "data-testid": name + "Revert",
    variant: "link",
    onClick: reset
  }, t4("revert")));
};

// build/clients/ClientSettings.js
var ClientSettings = ({save, reset}) => {
  const {register, control, watch} = useFormContext();
  const {t: t4} = useTranslation("clients");
  const [loginThemeOpen, setLoginThemeOpen] = useState(false);
  const loginThemes = useServerInfo().themes["login"];
  const consentRequired = watch("consentRequired");
  const displayOnConsentScreen = watch("attributes.display-on-consent-screen");
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ScrollForm, {
    className: "pf-u-px-lg",
    sections: [
      t4("generalSettings"),
      t4("capabilityConfig"),
      t4("accessSettings"),
      t4("loginSettings")
    ]
  }, /* @__PURE__ */ react.createElement(Form, {
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(ClientDescription, null)), /* @__PURE__ */ react.createElement(CapabilityConfig, null), /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-clients"
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("rootUrl"),
    fieldId: "kc-root-url",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:rootUrl",
      forLabel: t4("rootUrl"),
      forID: "kc-root-url"
    })
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-root-url",
    name: "rootUrl",
    ref: register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("validRedirectUri"),
    fieldId: "kc-redirect",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:validRedirectURIs",
      forLabel: t4("validRedirectUri"),
      forID: t4(`common:helpLabel`, {label: t4("validRedirectUri")})
    })
  }, /* @__PURE__ */ react.createElement(MultiLineInput, {
    name: "redirectUris",
    "aria-label": t4("validRedirectUri"),
    addButtonLabel: "clients:addRedirectUri"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("homeURL"),
    fieldId: "kc-home-url",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:homeURL",
      forLabel: t4("homeURL"),
      forID: t4(`common:helpLabel`, {label: t4("homeURL")})
    })
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-home-url",
    name: "baseUrl",
    ref: register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("webOrigins"),
    fieldId: "kc-web-origins",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:webOrigins",
      forLabel: t4("webOrigins"),
      forID: t4(`common:helpLabel`, {label: t4("webOrigins")})
    })
  }, /* @__PURE__ */ react.createElement(MultiLineInput, {
    name: "webOrigins",
    "aria-label": t4("webOrigins"),
    addButtonLabel: "clients:addWebOrigins"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("adminURL"),
    fieldId: "kc-admin-url",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:adminURL",
      forLabel: t4("adminURL"),
      forID: "kc-admin-url"
    })
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-admin-url",
    name: "adminUrl",
    ref: register
  }))), /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-clients"
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("loginTheme"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:loginTheme",
      forLabel: t4("loginTheme"),
      forID: "loginTheme"
    }),
    fieldId: "loginTheme"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.login_theme",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "loginTheme",
      onToggle: () => setLoginThemeOpen(!loginThemeOpen),
      onSelect: (_23, value2) => {
        onChange(value2);
        setLoginThemeOpen(false);
      },
      selections: value || t4("common:choose"),
      variant: SelectVariant.single,
      "aria-label": t4("loginTheme"),
      isOpen: loginThemeOpen
    }, /* @__PURE__ */ react.createElement(SelectOption, {
      key: "empty",
      value: ""
    }, t4("common:choose")), /* @__PURE__ */ react.createElement(react.Fragment, null, loginThemes && loginThemes.map((theme) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: theme.name === value,
      key: theme.name,
      value: theme.name
    }))))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("consentRequired"),
    fieldId: "kc-consent",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "consentRequired",
    defaultValue: false,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-consent-switch",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value,
      onChange
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("displayOnClient"),
    fieldId: "kc-display-on-client",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.display-on-consent-screen",
    defaultValue: false,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-display-on-client-switch",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value === "true",
      onChange: (value2) => onChange("" + value2),
      isDisabled: !consentRequired
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("consentScreenText"),
    fieldId: "kc-consent-screen-text"
  }, /* @__PURE__ */ react.createElement(TextArea, {
    id: "kc-consent-screen-text",
    name: "attributes.consent-screen-text",
    ref: register,
    isDisabled: !(consentRequired && displayOnConsentScreen === "true")
  })), /* @__PURE__ */ react.createElement(SaveReset, {
    className: "keycloak__form_actions",
    name: "settings",
    save,
    reset
  }))));
};

// build/clients/credentials/ClientSecret.js
var ClientSecret = ({secret, toggle}) => {
  const {t: t4} = useTranslation("clients");
  const {formState} = useFormContext();
  return /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("clientSecret"),
    fieldId: "kc-client-secret"
  }, /* @__PURE__ */ react.createElement(Split, {
    hasGutter: true
  }, /* @__PURE__ */ react.createElement(SplitItem, {
    isFilled: true
  }, /* @__PURE__ */ react.createElement(ClipboardCopy, {
    id: "kc-client-secret",
    isReadOnly: true
  }, secret)), /* @__PURE__ */ react.createElement(SplitItem, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "secondary",
    onClick: toggle,
    isDisabled: formState.isDirty
  }, t4("regenerate")))));
};

// build/clients/credentials/SignedJWT.js
var SignedJWT = () => {
  const {control} = useFormContext();
  const providers = sortProviders(useServerInfo().providers.clientSignature.providers);
  const {t: t4} = useTranslation("clients");
  const [open2, isOpen] = useState(false);
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("signatureAlgorithm"),
    fieldId: "kc-signature-algorithm",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:signature-algorithm",
      forLabel: t4("signatureAlgorithm"),
      forID: "kc-signature-algorithm"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.token-endpoint-auth-signing-alg",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      maxHeight: 200,
      toggleId: "kc-signature-algorithm",
      onToggle: () => isOpen(!open2),
      onSelect: (_23, value2) => {
        onChange(value2);
        isOpen(false);
      },
      selections: value || t4("anyAlgorithm"),
      variant: SelectVariant.single,
      "aria-label": t4("signatureAlgorithm"),
      isOpen: open2
    }, /* @__PURE__ */ react.createElement(SelectOption, {
      selected: value === "",
      key: "any",
      value: ""
    }, t4("anyAlgorithm")), /* @__PURE__ */ react.createElement(react.Fragment, null, providers.map((option) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: option === value,
      key: option,
      value: option
    }))))
  })));
};

// build/clients/credentials/X509.js
var X509 = () => {
  const {t: t4} = useTranslation("clients");
  const {register, errors} = useFormContext();
  return /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("subject"),
    fieldId: "kc-subject",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:subject",
      forLabel: t4("subject"),
      forID: "kc-subject"
    }),
    helperTextInvalid: t4("common:required"),
    validated: errors.attributes && errors.attributes["x509-subjectdn"] ? ValidatedOptions.error : ValidatedOptions.default,
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register({required: true}),
    type: "text",
    id: "kc-subject",
    name: "attributes.x509-subjectdn",
    validated: errors.attributes && errors.attributes["x509-subjectdn"] ? ValidatedOptions.error : ValidatedOptions.default
  }));
};

// build/clients/credentials/Credentials.js
var Credentials = ({clientId, save}) => {
  const {t: t4} = useTranslation("clients");
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const [providers, setProviders] = useState([]);
  const {
    control,
    formState: {isDirty}
  } = useFormContext();
  const clientAuthenticatorType = useWatch({
    control,
    name: "clientAuthenticatorType",
    defaultValue: ""
  });
  const [secret, setSecret] = useState("");
  const [accessToken, setAccessToken] = useState("");
  const [open2, isOpen] = useState(false);
  useFetch(async () => {
    const providers2 = await adminClient.authenticationManagement.getClientAuthenticatorProviders({id: clientId});
    const secret2 = await adminClient.clients.getClientSecret({
      id: clientId
    });
    return {
      providers: providers2,
      secret: secret2.value
    };
  }, ({providers: providers2, secret: secret2}) => {
    setProviders(providers2);
    setSecret(secret2);
  }, []);
  async function regenerate(call, message) {
    try {
      const data = await call(clientId);
      addAlert(t4(`${message}Success`), AlertVariant.success);
      return data;
    } catch (error2) {
      addError(`clients:${message}Error`, error2);
    }
  }
  const regenerateClientSecret = async () => {
    const secret2 = await regenerate((clientId2) => adminClient.clients.generateNewClientSecret({id: clientId2}), "clientSecret");
    setSecret(secret2?.value || "");
  };
  const [toggleClientSecretConfirm, ClientSecretConfirm] = useConfirmDialog({
    titleKey: "clients:confirmClientSecretTitle",
    messageKey: "clients:confirmClientSecretBody",
    continueButtonLabel: "common:yes",
    cancelButtonLabel: "common:no",
    onConfirm: regenerateClientSecret
  });
  const regenerateAccessToken = async () => {
    const accessToken2 = await regenerate((clientId2) => adminClient.clients.generateRegistrationAccessToken({id: clientId2}), "accessToken");
    setAccessToken(accessToken2?.registrationAccessToken || "");
  };
  const [toggleAccessTokenConfirm, AccessTokenConfirm] = useConfirmDialog({
    titleKey: "clients:confirmAccessTokenTitle",
    messageKey: "clients:confirmAccessTokenBody",
    continueButtonLabel: "common:yes",
    cancelButtonLabel: "common:no",
    onConfirm: regenerateAccessToken
  });
  return /* @__PURE__ */ react.createElement(PageSection, null, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    className: "pf-u-mt-md",
    role: "manage-clients"
  }, /* @__PURE__ */ react.createElement(ClientSecretConfirm, null), /* @__PURE__ */ react.createElement(AccessTokenConfirm, null), /* @__PURE__ */ react.createElement(Card, {
    isFlat: true
  }, /* @__PURE__ */ react.createElement(CardBody, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("clientAuthenticator"),
    fieldId: "kc-client-authenticator-type",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:client-authenticator-type",
      forLabel: t4("clientAuthenticator"),
      forID: "kc-client-authenticator-type"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "clientAuthenticatorType",
    control,
    defaultValue: "",
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-client-authenticator-type",
      required: true,
      onToggle: () => isOpen(!open2),
      onSelect: (_23, value2) => {
        onChange(value2);
        isOpen(false);
      },
      selections: value,
      variant: SelectVariant.single,
      "aria-label": t4("clientAuthenticator"),
      isOpen: open2
    }, providers.map((option) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: option.id === value,
      key: option.id,
      value: option.id
    }, option.displayName)))
  })), clientAuthenticatorType === "client-jwt" && /* @__PURE__ */ react.createElement(SignedJWT, null), clientAuthenticatorType === "client-x509" && /* @__PURE__ */ react.createElement(X509, null), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "primary",
    onClick: () => save(),
    isDisabled: !isDirty
  }, t4("common:save")))), (clientAuthenticatorType === "client-secret" || clientAuthenticatorType === "client-secret-jwt") && /* @__PURE__ */ react.createElement(Divider, null), (clientAuthenticatorType === "client-secret" || clientAuthenticatorType === "client-secret-jwt") && /* @__PURE__ */ react.createElement(CardBody, null, /* @__PURE__ */ react.createElement(ClientSecret, {
    secret,
    toggle: toggleClientSecretConfirm
  }))), /* @__PURE__ */ react.createElement(Card, {
    isFlat: true
  }, /* @__PURE__ */ react.createElement(CardBody, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("registrationAccessToken"),
    fieldId: "kc-access-token",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:registration-access-token",
      forLabel: t4("registrationAccessToken"),
      forID: "kc-access-token"
    })
  }, /* @__PURE__ */ react.createElement(Split, {
    hasGutter: true
  }, /* @__PURE__ */ react.createElement(SplitItem, {
    isFilled: true
  }, /* @__PURE__ */ react.createElement(ClipboardCopy, {
    id: "kc-access-token",
    isReadOnly: true
  }, accessToken)), /* @__PURE__ */ react.createElement(SplitItem, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "secondary",
    onClick: toggleAccessTokenConfirm,
    isDisabled: isDirty
  }, t4("regenerate")))))))));
};

// build/components/password-input/PasswordInput.js
var PasswordInputBase = ({innerRef, ...rest}) => {
  const {t: t4} = useTranslation("common-help");
  const [hidePassword, setHidePassword] = useState(true);
  return /* @__PURE__ */ react.createElement(InputGroup, null, /* @__PURE__ */ react.createElement(TextInput, {
    ...rest,
    type: hidePassword ? "password" : "text",
    ref: innerRef
  }), /* @__PURE__ */ react.createElement(Button, {
    variant: "control",
    "aria-label": t4("showPassword"),
    onClick: () => setHidePassword(!hidePassword)
  }, hidePassword ? /* @__PURE__ */ react.createElement(EyeIcon, null) : /* @__PURE__ */ react.createElement(EyeSlashIcon, null)));
};
var PasswordInput = react.forwardRef((props, ref) => /* @__PURE__ */ react.createElement(PasswordInputBase, {
  ...props,
  innerRef: ref
}));
PasswordInput.displayName = "PasswordInput";

// build/clients/keys/StoreSettings.js
var StoreSettings = ({
  register,
  hidePassword = false
}) => {
  const {t: t4} = useTranslation("clients");
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("keyAlias"),
    fieldId: "keyAlias",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:keyAlias",
      forLabel: t4("keyAlias"),
      forID: "keyAlias"
    })
  }, /* @__PURE__ */ react.createElement(TextInput, {
    "data-testid": "keyAlias",
    type: "text",
    id: "keyAlias",
    name: "keyAlias",
    ref: register
  })), !hidePassword && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("keyPassword"),
    fieldId: "keyPassword",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:keyPassword",
      forLabel: t4("keyPassword"),
      forID: "keyPassword"
    })
  }, /* @__PURE__ */ react.createElement(PasswordInput, {
    "data-testid": "keyPassword",
    id: "keyPassword",
    name: "keyPassword",
    ref: register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("storePassword"),
    fieldId: "storePassword",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:storePassword",
      forLabel: t4("storePassword"),
      forID: "storePassword"
    })
  }, /* @__PURE__ */ react.createElement(PasswordInput, {
    "data-testid": "storePassword",
    id: "storePassword",
    name: "storePassword",
    ref: register
  })));
};

// build/clients/keys/GenerateKeyDialog.js
var GenerateKeyDialog = ({
  save,
  toggleDialog
}) => {
  const {t: t4} = useTranslation("clients");
  const {register, control, handleSubmit} = useForm();
  const [openArchiveFormat, setOpenArchiveFormat] = useState(false);
  return /* @__PURE__ */ react.createElement(Modal, {
    variant: ModalVariant.medium,
    title: t4("generateKeys"),
    isOpen: true,
    onClose: toggleDialog,
    actions: [
      /* @__PURE__ */ react.createElement(Button, {
        id: "modal-confirm",
        key: "confirm",
        "data-testid": "confirm",
        onClick: () => {
          handleSubmit((config2) => {
            save(config2);
            toggleDialog();
          })();
        }
      }, t4("generate")),
      /* @__PURE__ */ react.createElement(Button, {
        id: "modal-cancel",
        key: "cancel",
        "data-testid": "cancel",
        variant: ButtonVariant.link,
        onClick: () => {
          toggleDialog();
        }
      }, t4("common:cancel"))
    ]
  }, /* @__PURE__ */ react.createElement(TextContent, null, /* @__PURE__ */ react.createElement(Text, null, t4("clients-help:generateKeysDescription"))), /* @__PURE__ */ react.createElement(Form, {
    className: "pf-u-pt-lg"
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("archiveFormat"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:archiveFormat",
      forLabel: t4("archiveFormat"),
      forID: "archiveFormat"
    }),
    fieldId: "archiveFormat"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "format",
    defaultValue: "JKS",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "archiveFormat",
      onToggle: () => setOpenArchiveFormat(!openArchiveFormat),
      onSelect: (_23, value2) => {
        onChange(value2);
        setOpenArchiveFormat(false);
      },
      selections: value,
      variant: SelectVariant.single,
      "aria-label": t4("archiveFormat"),
      isOpen: openArchiveFormat
    }, ["JKS", "PKCS12"].map((option) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: option === value,
      key: option,
      value: option
    })))
  })), /* @__PURE__ */ react.createElement(StoreSettings, {
    register
  })));
};

// build/clients/keys/ImportKeyDialog.js
var baseFormats = ["JKS", "PKCS12"];
var formats = baseFormats.concat([
  "Certificate PEM",
  "Public Key PEM",
  "JSON Web Key Set"
]);
var ImportKeyDialog = ({
  save,
  toggleDialog
}) => {
  const {t: t4} = useTranslation("clients");
  const {register, control, handleSubmit} = useForm();
  const [openArchiveFormat, setOpenArchiveFormat] = useState(false);
  const format = useWatch({
    control,
    name: "keystoreFormat",
    defaultValue: "JKS"
  });
  return /* @__PURE__ */ react.createElement(Modal, {
    variant: ModalVariant.medium,
    title: t4("generateKeys"),
    isOpen: true,
    onClose: toggleDialog,
    actions: [
      /* @__PURE__ */ react.createElement(Button, {
        id: "modal-confirm",
        key: "confirm",
        onClick: () => {
          handleSubmit((importFile) => {
            save(importFile);
            toggleDialog();
          })();
        }
      }, t4("import")),
      /* @__PURE__ */ react.createElement(Button, {
        id: "modal-cancel",
        key: "cancel",
        variant: ButtonVariant.link,
        onClick: () => {
          toggleDialog();
        }
      }, t4("common:cancel"))
    ]
  }, /* @__PURE__ */ react.createElement(TextContent, null, /* @__PURE__ */ react.createElement(Text, null, t4("clients-help:generateKeysDescription"))), /* @__PURE__ */ react.createElement(Form, {
    className: "pf-u-pt-lg"
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("archiveFormat"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:archiveFormat",
      forLabel: t4("archiveFormat"),
      forID: "archiveFormat"
    }),
    fieldId: "archiveFormat"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "keystoreFormat",
    control,
    defaultValue: "JKS",
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "archiveFormat",
      onToggle: () => setOpenArchiveFormat(!openArchiveFormat),
      onSelect: (_23, value2) => {
        onChange(value2);
        setOpenArchiveFormat(false);
      },
      selections: value,
      variant: SelectVariant.single,
      "aria-label": t4("archiveFormat"),
      isOpen: openArchiveFormat
    }, formats.map((option) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: option === value,
      key: option,
      value: option
    })))
  })), baseFormats.includes(format) && /* @__PURE__ */ react.createElement(StoreSettings, {
    register,
    hidePassword: true
  }), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("importFile"),
    fieldId: "importFile"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "file",
    control,
    defaultValue: "",
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(FileUpload, {
      id: "importFile",
      value: value.value,
      filename: value.filename,
      onChange: (value2, filename) => onChange({value: value2, filename})
    })
  }))));
};

// build/clients/keys/Keys.js
var attr = "jwt.credential";
var Keys = ({clientId, save}) => {
  const {t: t4} = useTranslation("clients");
  const {
    control,
    register,
    formState: {isDirty}
  } = useFormContext();
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const [keyInfo, setKeyInfo] = useState();
  const [openGenerateKeys, setOpenGenerateKeys] = useState(false);
  const [openImportKeys, setOpenImportKeys] = useState(false);
  const useJwksUrl = useWatch({
    control,
    name: "attributes.use-jwks-url",
    defaultValue: "false"
  });
  useFetch(() => adminClient.clients.getKeyInfo({id: clientId, attr}), (info2) => setKeyInfo(info2), []);
  const generate = async (config2) => {
    try {
      const keyStore = await adminClient.clients.generateAndDownloadKey({
        id: clientId,
        attr
      }, config2);
      file_saver_default.saveAs(new Blob([keyStore], {type: "application/octet-stream"}), `keystore.${config2.format == "PKCS12" ? "p12" : "jks"}`);
      addAlert(t4("generateSuccess"), AlertVariant.success);
    } catch (error2) {
      addError("clients:generateError", error2);
    }
  };
  const importKey = async (importFile) => {
    try {
      const formData = new FormData();
      const {file, ...rest} = importFile;
      Object.entries(rest).map((entry) => formData.append(entry[0], entry[1]));
      formData.append("file", file.value);
      await adminClient.clients.uploadCertificate({id: clientId, attr}, formData);
      addAlert(t4("importSuccess"), AlertVariant.success);
    } catch (error2) {
      addError("clients:importError", error2);
    }
  };
  return /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    className: "keycloak__form"
  }, openGenerateKeys && /* @__PURE__ */ react.createElement(GenerateKeyDialog, {
    toggleDialog: () => setOpenGenerateKeys(!openGenerateKeys),
    save: generate
  }), openImportKeys && /* @__PURE__ */ react.createElement(ImportKeyDialog, {
    toggleDialog: () => setOpenImportKeys(!openImportKeys),
    save: importKey
  }), /* @__PURE__ */ react.createElement(Card, {
    isFlat: true
  }, /* @__PURE__ */ react.createElement(CardHeader, null, /* @__PURE__ */ react.createElement(CardTitle, null, t4("jwksUrlConfig"))), /* @__PURE__ */ react.createElement(CardBody, null, /* @__PURE__ */ react.createElement(TextContent, null, /* @__PURE__ */ react.createElement(Text, null, t4("keysIntro")))), /* @__PURE__ */ react.createElement(CardBody, null, /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-clients",
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    hasNoPaddingTop: true,
    label: t4("useJwksUrl"),
    fieldId: "useJwksUrl",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:useJwksUrl",
      forLabel: t4("useJwksUrl"),
      forID: t4(`common:helpLabel`, {label: t4("useJwksUrl")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.use-jwks-url",
    defaultValue: "false",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      "data-testid": "useJwksUrl",
      id: "useJwksUrl-switch",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value === "true",
      onChange: (value2) => onChange(`${value2}`)
    })
  })), useJwksUrl !== "true" && /* @__PURE__ */ react.createElement(react.Fragment, null, keyInfo ? /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("certificate"),
    fieldId: "certificate",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:certificate",
      forLabel: t4("certificate"),
      forID: "certificate"
    })
  }, /* @__PURE__ */ react.createElement(TextArea, {
    readOnly: true,
    rows: 5,
    id: "certificate",
    value: keyInfo.certificate
  })) : "No client certificate configured"), useJwksUrl === "true" && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("jwksUrl"),
    fieldId: "jwksUrl",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:jwksUrl",
      forLabel: t4("jwksUrl"),
      forID: "jwksUrl"
    })
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "jwksUrl",
    name: "attributes.jwks-url",
    ref: register
  })), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    "data-testid": "saveKeys",
    onClick: save,
    isDisabled: !isDirty
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    "data-testid": "generate",
    variant: "secondary",
    onClick: () => setOpenGenerateKeys(true)
  }, t4("generateNewKeys")), /* @__PURE__ */ react.createElement(Button, {
    "data-testid": "import",
    variant: "secondary",
    onClick: () => setOpenImportKeys(true),
    isDisabled: useJwksUrl === "true"
  }, t4("import")))))));
};

// build/clients/initial-access/InitialAccessTokenList.js
var import_moment2 = __toModule(require_moment());

// build/clients/initial-access/AccessTokenDialog.js
var AccessTokenDialog = ({
  token: token2,
  toggleDialog
}) => {
  const {t: t4} = useTranslation("clients");
  return /* @__PURE__ */ react.createElement(Modal, {
    title: t4("initialAccessTokenDetails"),
    isOpen: true,
    onClose: toggleDialog,
    variant: ModalVariant.medium
  }, /* @__PURE__ */ react.createElement(Alert, {
    title: t4("copyInitialAccessToken"),
    isInline: true,
    variant: AlertVariant.warning
  }), /* @__PURE__ */ react.createElement(Form, {
    className: "pf-u-mt-md"
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("initialAccessToken"),
    fieldId: "initialAccessToken"
  }, /* @__PURE__ */ react.createElement(ClipboardCopy, {
    id: "initialAccessToken",
    isReadOnly: true
  }, token2))));
};

// build/clients/initial-access/CreateInitialAccessToken.js
var CreateInitialAccessToken = () => {
  const {t: t4} = useTranslation("clients");
  const {handleSubmit, control} = useForm();
  const adminClient = useAdminClient();
  const {realm: realm2} = useRealm();
  const {addAlert, addError} = useAlerts();
  const history = useHistory();
  const [token2, setToken] = useState("");
  const save = async (clientToken) => {
    try {
      const access = await adminClient.realms.createClientsInitialAccess({realm: realm2}, clientToken);
      setToken(access.token);
    } catch (error2) {
      addError("clients:tokenSaveError", error2);
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, token2 && /* @__PURE__ */ react.createElement(AccessTokenDialog, {
    token: token2,
    toggleDialog: () => {
      setToken("");
      addAlert(t4("tokenSaveSuccess"), AlertVariant.success);
      history.push(toClients({realm: realm2, tab: "initialAccessToken"}));
    }
  }), /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: "clients:createToken",
    subKey: "clients-help:createToken"
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "create-client",
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("expiration"),
    fieldId: "expiration",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:expiration",
      forLabel: t4("expiration"),
      forID: "expiration"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "expiration",
    defaultValue: 86400,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      "data-testid": "expiration",
      value,
      onChange,
      units: ["days", "hours", "minutes", "seconds"]
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("count"),
    fieldId: "count",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:count",
      forLabel: t4("count"),
      forID: "count"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "count",
    defaultValue: 1,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(NumberInput, {
      "data-testid": "count",
      inputName: "count",
      inputAriaLabel: t4("count"),
      min: 1,
      value,
      onPlus: () => onChange(value + 1),
      onMinus: () => onChange(value - 1),
      onChange: (event) => onChange(Number(event.target.value))
    })
  })), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "primary",
    type: "submit",
    "data-testid": "save"
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    "data-testid": "cancel",
    variant: "link",
    component: Link,
    to: toClients({realm: realm2, tab: "initialAccessToken"})
  }, t4("common:cancel"))))));
};

// build/clients/routes/CreateInitialAccessToken.js
var CreateInitialAccessTokenRoute = {
  path: "/:realm/clients/initialAccessToken/create",
  component: CreateInitialAccessToken,
  breadcrumb: (t4) => t4("clients:createToken"),
  access: "manage-clients"
};
var toCreateInitialAccessToken = (params) => ({
  pathname: generatePath(CreateInitialAccessTokenRoute.path, params)
});

// build/clients/initial-access/InitialAccessTokenList.js
var InitialAccessTokenList = () => {
  const {t: t4} = useTranslation("clients");
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const {realm: realm2} = useRealm();
  const history = useHistory();
  const [token2, setToken] = useState();
  const loader = async () => await adminClient.realms.getClientsInitialAccess({realm: realm2});
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: "clients:tokenDeleteConfirmTitle",
    messageKey: t4("tokenDeleteConfirm", token2),
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        await adminClient.realms.delClientsInitialAccess({
          realm: realm2,
          id: token2.id
        });
        addAlert(t4("tokenDeleteSuccess"), AlertVariant.success);
        setToken(void 0);
      } catch (error2) {
        addError("tokenDeleteError", error2);
      }
    }
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DeleteConfirm, null), /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key: token2?.id,
    ariaLabelKey: "clients:initialAccessToken",
    searchPlaceholderKey: "clients:searchInitialAccessToken",
    loader,
    toolbarItem: /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Button, {
      component: Link,
      to: toCreateInitialAccessToken({realm: realm2})
    }, t4("common:create"))),
    actions: [
      {
        title: t4("common:delete"),
        onRowClick: (token22) => {
          setToken(token22);
          toggleDeleteDialog();
        }
      }
    ],
    columns: [
      {
        name: "id",
        displayKey: "common:id"
      },
      {
        name: "timestamp",
        displayKey: "clients:timestamp",
        cellRenderer: (row) => (0, import_moment2.default)(row.timestamp * 1e3).format("LLL")
      },
      {
        name: "expiration",
        displayKey: "clients:expires",
        cellRenderer: (row) => (0, import_moment2.default)(row.timestamp * 1e3 + row.expiration * 1e3).format("LLL")
      },
      {
        name: "count",
        displayKey: "clients:count"
      },
      {
        name: "remainingCount",
        displayKey: "clients:remainingCount",
        transforms: [wrappable]
      }
    ],
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      message: t4("noTokens"),
      instructions: t4("noTokensInstructions"),
      primaryActionText: t4("common:create"),
      onPrimaryAction: () => history.push(toCreateInitialAccessToken({realm: realm2}))
    })
  }));
};

// build/clients/import/ImportForm.js
var ImportForm = () => {
  const {t: t4} = useTranslation("clients");
  const history = useHistory();
  const adminClient = useAdminClient();
  const {realm: realm2} = useRealm();
  const form2 = useForm();
  const {register, handleSubmit, setValue} = form2;
  const [imported, setImported] = useState({});
  const {addAlert, addError} = useAlerts();
  const handleFileChange = (obj) => {
    const defaultClient = {
      protocol: "",
      clientId: "",
      name: "",
      description: ""
    };
    Object.entries(obj || defaultClient).forEach((entries) => {
      if (entries[0] === "attributes") {
        convertToFormValues(entries[1], "attributes", form2.setValue);
      } else {
        setValue(entries[0], entries[1]);
      }
    });
    setImported(obj || defaultClient);
  };
  const save = async (client2) => {
    try {
      const newClient = await adminClient.clients.create({
        ...imported,
        ...client2,
        attributes: convertFormValuesToObject(client2.attributes || {})
      });
      addAlert(t4("clientImportSuccess"), AlertVariant.success);
      history.push(toClient({realm: realm2, clientId: newClient.id, tab: "settings"}));
    } catch (error2) {
      addError("clients:clientImportError", error2);
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: "clients:importClient",
    subKey: "clients:clientsExplain"
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    onSubmit: handleSubmit(save),
    role: "manage-clients"
  }, /* @__PURE__ */ react.createElement(FormProvider, {
    ...form2
  }, /* @__PURE__ */ react.createElement(JsonFileUpload, {
    id: "realm-file",
    onChange: handleFileChange
  }), /* @__PURE__ */ react.createElement(ClientDescription, null), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:type"),
    fieldId: "kc-type"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-type",
    name: "protocol",
    isReadOnly: true,
    ref: register()
  })), /* @__PURE__ */ react.createElement(CapabilityConfig, {
    unWrap: true
  }), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "primary",
    type: "submit"
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    component: Link,
    to: toClients({realm: realm2})
  }, t4("common:cancel")))))));
};

// build/clients/routes/ImportClient.js
var ImportClientRoute = {
  path: "/:realm/clients/import-client",
  component: ImportForm,
  breadcrumb: (t4) => t4("clients:importClient"),
  access: "manage-clients"
};
var toImportClient = (params) => ({
  pathname: generatePath(ImportClientRoute.path, params)
});

// build/clients/ClientsSection.js
var ClientsSection = () => {
  const {t: t4} = useTranslation("clients");
  const {addAlert, addError} = useAlerts();
  const adminClient = useAdminClient();
  const {realm: realm2} = useRealm();
  const baseUrl = getBaseUrl(adminClient);
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const [selectedClient, setSelectedClient] = useState();
  const loader = async (first, max2, search) => {
    const params = {
      first,
      max: max2
    };
    if (search) {
      params.clientId = search;
      params.search = "true";
    }
    return await adminClient.clients.find({...params});
  };
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: t4("clientDelete", {clientId: selectedClient?.clientId}),
    messageKey: "clients:clientDeleteConfirm",
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        await adminClient.clients.del({
          id: selectedClient.id
        });
        addAlert(t4("clientDeletedSuccess"), AlertVariant.success);
        refresh();
      } catch (error2) {
        addError("client:clientDeleteError", error2);
      }
    }
  });
  const ClientDetailLink = (client2) => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Link, {
    key: client2.id,
    to: toClient({realm: realm2, clientId: client2.id, tab: "settings"})
  }, client2.clientId, !client2.enabled && /* @__PURE__ */ react.createElement(Badge, {
    key: `${client2.id}-disabled`,
    isRead: true,
    className: "pf-u-ml-sm"
  }, t4("common:disabled"))));
  const ClientDescription2 = (client2) => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(TableText, {
    wrapModifier: "truncate"
  }, emptyFormatter()(client2.description)));
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: "clients:clientList",
    subKey: "clients:clientsExplain",
    divider: false
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    className: "pf-u-p-0"
  }, /* @__PURE__ */ react.createElement(KeycloakTabs, {
    isBox: true
  }, /* @__PURE__ */ react.createElement(Tab, {
    "data-testid": "list",
    eventKey: "list",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("clientsList"))
  }, /* @__PURE__ */ react.createElement(DeleteConfirm, null), /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    emptyState: /* @__PURE__ */ react.createElement(react.Fragment, null, " "),
    loader,
    isPaginated: true,
    ariaLabelKey: "clients:clientList",
    searchPlaceholderKey: "clients:searchForClient",
    toolbarItem: /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      component: Link,
      to: toAddClient({realm: realm2})
    }, t4("createClient"))), /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      component: Link,
      to: toImportClient({realm: realm2}),
      variant: "link"
    }, t4("importClient")))),
    actions: [
      {
        title: t4("common:export"),
        onRowClick: (client2) => {
          exportClient(client2);
        }
      },
      {
        title: t4("common:delete"),
        onRowClick: (client2) => {
          setSelectedClient(client2);
          toggleDeleteDialog();
        }
      }
    ],
    columns: [
      {
        name: "clientId",
        displayKey: "common:clientId",
        cellRenderer: ClientDetailLink
      },
      {name: "protocol", displayKey: "common:type"},
      {
        name: "description",
        displayKey: "common:description",
        transforms: [cellWidth(20)],
        cellRenderer: ClientDescription2
      },
      {
        name: "baseUrl",
        displayKey: "clients:homeURL",
        cellFormatters: [formattedLinkTableCell(), emptyFormatter()],
        cellRenderer: (client2) => {
          if (client2.rootUrl) {
            if (!client2.rootUrl.startsWith("http") || client2.rootUrl.indexOf("$") !== -1) {
              client2.rootUrl = client2.rootUrl.replace("${authBaseUrl}", baseUrl).replace("${authAdminUrl}", baseUrl) + (client2.baseUrl ? client2.baseUrl.substr(1) : "");
            }
          }
          return client2.rootUrl;
        }
      }
    ]
  })), /* @__PURE__ */ react.createElement(Tab, {
    "data-testid": "initialAccessToken",
    eventKey: "initialAccessToken",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("initialAccessToken"))
  }, /* @__PURE__ */ react.createElement(InitialAccessTokenList, null)))));
};

// build/clients/routes/Clients.js
var ClientsRoute = {
  path: "/:realm/clients/:tab?",
  component: ClientsSection,
  breadcrumb: (t4) => t4("clients:clientList"),
  access: "query-clients"
};
var toClients = (params) => ({
  pathname: generatePath(ClientsRoute.path, params)
});

// build/clients/scopes/AddScopeDialog.js
var AddScopeDialog = ({
  clientScopes: clientScopes2,
  open: open2,
  toggleDialog,
  onAdd: onAdd2
}) => {
  const {t: t4} = useTranslation("clients");
  const [addToggle, setAddToggle] = useState(false);
  const [rows, setRows] = useState([]);
  const loader = () => Promise.resolve(clientScopes2);
  const action = (scope) => {
    const scopes = rows.map((row) => {
      return {scope: row, type: scope};
    });
    onAdd2(scopes);
    setAddToggle(false);
    toggleDialog();
  };
  return /* @__PURE__ */ react.createElement(Modal, {
    variant: ModalVariant.medium,
    title: t4("addClientScopesTo", {clientId: "test"}),
    isOpen: open2,
    onClose: toggleDialog,
    actions: [
      /* @__PURE__ */ react.createElement(Dropdown, {
        className: "keycloak__client-scopes-add__add-dropdown",
        id: "add-dropdown",
        key: "add-dropdown",
        direction: DropdownDirection.up,
        isOpen: addToggle,
        toggle: /* @__PURE__ */ react.createElement(DropdownToggle, {
          isDisabled: rows.length === 0,
          onToggle: () => setAddToggle(!addToggle),
          isPrimary: true,
          toggleIndicator: CaretUpIcon,
          id: "add-scope-toggle"
        }, t4("common:add")),
        dropdownItems: clientScopeTypesDropdown(t4, action)
      }),
      /* @__PURE__ */ react.createElement(Button, {
        id: "modal-cancel",
        key: "cancel",
        variant: ButtonVariant.link,
        onClick: () => {
          setRows([]);
          toggleDialog();
        }
      }, t4("common:cancel"))
    ]
  }, /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    loader,
    ariaLabelKey: "client-scopes:chooseAMapperType",
    searchPlaceholderKey: "client-scopes:searchFor",
    canSelectAll: true,
    onSelect: (rows2) => setRows(rows2),
    columns: [
      {
        name: "name"
      },
      {
        name: "description"
      }
    ]
  }));
};

// build/clients/scopes/ClientScopes.js
var castAdminClient2 = (adminClient) => adminClient.clients;
var changeScope2 = async (adminClient, clientId, clientScope, type, changeTo) => {
  await removeScope2(adminClient, clientId, clientScope, type);
  await addScope2(adminClient, clientId, clientScope, changeTo);
};
var removeScope2 = async (adminClient, clientId, clientScope, type) => {
  const typeToName = toUpperCase(type);
  await castAdminClient2(adminClient)[`del${typeToName}ClientScope`]({
    id: clientId,
    clientScopeId: clientScope.id
  });
};
var addScope2 = async (adminClient, clientId, clientScope, type) => {
  const typeToName = toUpperCase(type);
  await castAdminClient2(adminClient)[`add${typeToName}ClientScope`]({
    id: clientId,
    clientScopeId: clientScope.id
  });
};
var ClientScopes = ({clientId, protocol}) => {
  const {t: t4} = useTranslation("clients");
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const [searchToggle, setSearchToggle] = useState(false);
  const [searchType, setSearchType] = useState("client");
  const [addToggle, setAddToggle] = useState(false);
  const [addDialogOpen, setAddDialogOpen] = useState(false);
  const [kebabOpen, setKebabOpen] = useState(false);
  const [rest, setRest] = useState();
  const [selectedRows, setSelectedRows] = useState([]);
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const loader = async () => {
    const defaultClientScopes = await adminClient.clients.listDefaultClientScopes({id: clientId});
    const optionalClientScopes = await adminClient.clients.listOptionalClientScopes({id: clientId});
    const clientScopes2 = await adminClient.clientScopes.find();
    const find3 = (id3) => clientScopes2.find((clientScope) => id3 === clientScope.id);
    const optional = optionalClientScopes.map((c4) => {
      const scope = find3(c4.id);
      return {
        ...c4,
        type: ClientScope.optional,
        description: scope.description
      };
    });
    const defaultScopes = defaultClientScopes.map((c4) => {
      const scope = find3(c4.id);
      return {
        ...c4,
        type: ClientScope.default,
        description: scope.description
      };
    });
    const rows = [...optional, ...defaultScopes];
    const names = rows.map((row) => row.name);
    setRest(clientScopes2.filter((scope) => !names.includes(scope.name)).filter((scope) => scope.protocol === protocol));
    return rows;
  };
  const TypeSelector = (scope) => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(CellDropdown, {
    clientScope: scope,
    type: scope.type,
    onSelect: async (value) => {
      try {
        await changeScope2(adminClient, clientId, scope, scope.type, value);
        addAlert(t4("clientScopeSuccess"), AlertVariant.success);
        refresh();
      } catch (error2) {
        addError("clients:clientScopeError", error2);
      }
    }
  }));
  return /* @__PURE__ */ react.createElement(react.Fragment, null, rest && /* @__PURE__ */ react.createElement(AddScopeDialog, {
    clientScopes: rest,
    open: addDialogOpen,
    toggleDialog: () => setAddDialogOpen(!addDialogOpen),
    onAdd: async (scopes) => {
      try {
        await Promise.all(scopes.map(async (scope) => await addScope2(adminClient, clientId, scope.scope, scope.type)));
        addAlert(t4("clientScopeSuccess"), AlertVariant.success);
        refresh();
      } catch (error2) {
        addError("clients:clientScopeError", error2);
      }
    }
  }), /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    loader,
    ariaLabelKey: "clients:clientScopeList",
    searchPlaceholderKey: "clients:searchByName",
    canSelectAll: true,
    onSelect: (rows) => setSelectedRows([...rows]),
    searchTypeComponent: /* @__PURE__ */ react.createElement(Dropdown, {
      className: "keycloak__client-scopes__searchtype",
      toggle: /* @__PURE__ */ react.createElement(DropdownToggle, {
        id: "toggle-id",
        onToggle: () => setSearchToggle(!searchToggle)
      }, /* @__PURE__ */ react.createElement(FilterIcon, null), " ", t4(`clientScopeSearch.${searchType}`)),
      "aria-label": "Select Input",
      isOpen: searchToggle,
      dropdownItems: [
        /* @__PURE__ */ react.createElement(DropdownItem, {
          key: "client",
          onClick: () => {
            setSearchType("client");
            setSearchToggle(false);
          }
        }, t4("clientScopeSearch.client")),
        /* @__PURE__ */ react.createElement(DropdownItem, {
          key: "assigned",
          onClick: () => {
            setSearchType("assigned");
            setSearchToggle(false);
          }
        }, t4("clientScopeSearch.assigned"))
      ]
    }),
    toolbarItem: /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      onClick: () => setAddDialogOpen(true)
    }, t4("addClientScope"))), /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Select, {
      id: "add-dropdown",
      key: "add-dropdown",
      isOpen: addToggle,
      selections: [],
      isDisabled: selectedRows.length === 0,
      placeholderText: t4("changeTypeTo"),
      onToggle: () => setAddToggle(!addToggle),
      onSelect: async (_23, value) => {
        try {
          await Promise.all(selectedRows.map((row) => {
            return changeScope2(adminClient, clientId, {...row}, row.type, value);
          }));
          setAddToggle(false);
          refresh();
          addAlert(t4("clientScopeSuccess"), AlertVariant.success);
        } catch (error2) {
          addError("clients:clientScopeError", error2);
        }
      }
    }, clientScopeTypesSelectOptions(t4))), /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Dropdown, {
      toggle: /* @__PURE__ */ react.createElement(KebabToggle, {
        onToggle: () => setKebabOpen(!kebabOpen)
      }),
      isOpen: kebabOpen,
      isPlain: true,
      dropdownItems: [
        /* @__PURE__ */ react.createElement(DropdownItem, {
          key: "deleteAll",
          isDisabled: selectedRows.length === 0,
          onClick: async () => {
            try {
              await Promise.all(selectedRows.map(async (row) => {
                await removeScope2(adminClient, clientId, {...row}, row.type);
              }));
              setKebabOpen(false);
              addAlert(t4("clientScopeRemoveSuccess"), AlertVariant.success);
              refresh();
            } catch (error2) {
              addError("clients:clientScopeRemoveError", error2);
            }
          }
        }, t4("common:remove"))
      ]
    }))),
    columns: [
      {
        name: "name",
        displayKey: "clients:assignedClientScope"
      },
      {
        name: "type",
        displayKey: "clients:assignedType",
        cellRenderer: TypeSelector
      },
      {name: "description"}
    ],
    actions: [
      {
        title: t4("common:remove"),
        onRowClick: async (row) => {
          try {
            await removeScope2(adminClient, clientId, row, row.type);
            addAlert(t4("clientScopeRemoveSuccess"), AlertVariant.success);
            refresh();
          } catch (error2) {
            addError("clients:clientScopeRemoveError", error2);
          }
          return true;
        }
      }
    ],
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      message: t4("clients:emptyClientScopes"),
      instructions: t4("clients:emptyClientScopesInstructions"),
      primaryActionText: t4("clients:emptyClientScopesPrimaryAction"),
      onPrimaryAction: () => setAddDialogOpen(true)
    })
  }));
};

// build/clients/scopes/EvaluateScopes.js
var ProtocolMappers = ({
  protocolMappers
}) => {
  const [key, setKey] = useState(0);
  useEffect(() => {
    setKey(key + 1);
  }, [protocolMappers]);
  return /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    loader: () => Promise.resolve(protocolMappers),
    ariaLabelKey: "clients:effectiveProtocolMappers",
    searchPlaceholderKey: "clients:searchForProtocol",
    columns: [
      {
        name: "mapperName",
        displayKey: "common:name"
      },
      {
        name: "containerName",
        displayKey: "clients:parentClientScope"
      },
      {
        name: "type.category",
        displayKey: "common:category"
      },
      {
        name: "type.priority",
        displayKey: "common:priority"
      }
    ]
  });
};
var EffectiveRoles = ({
  effectiveRoles
}) => {
  const [key, setKey] = useState(0);
  useEffect(() => {
    setKey(key + 1);
  }, [effectiveRoles]);
  return /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    loader: () => Promise.resolve(effectiveRoles),
    ariaLabelKey: "client:effectiveRoleScopeMappings",
    searchPlaceholderKey: "clients:searchForRole",
    columns: [
      {
        name: "name",
        displayKey: "clients:role"
      },
      {
        name: "containerId",
        displayKey: "clients:origin"
      }
    ]
  });
};
var EvaluateScopes = ({clientId, protocol}) => {
  const prefix2 = "openid";
  const {t: t4} = useTranslation("clients");
  const {enabled} = useHelp();
  const adminClient = useAdminClient();
  const {realm: realm2} = useRealm();
  const mapperTypes = useServerInfo().protocolMapperTypes[protocol];
  const [selectableScopes, setSelectableScopes] = useState([]);
  const [isScopeOpen, setIsScopeOpen] = useState(false);
  const [isUserOpen, setIsUserOpen] = useState(false);
  const [selected, setSelected] = useState([prefix2]);
  const [activeTab, setActiveTab] = useState(0);
  const [userItems, setUserItems] = useState([]);
  const [userSearch, setUserSearch] = useState("");
  const [user, setUser] = useState();
  const [key, setKey] = useState("");
  const refresh = () => setKey(`${new Date().getTime()}`);
  const [effectiveRoles, setEffectiveRoles] = useState([]);
  const [protocolMappers, setProtocolMappers] = useState([]);
  const [accessToken, setAccessToken] = useState("");
  const tabContent1 = useRef(null);
  const tabContent2 = useRef(null);
  const tabContent3 = useRef(null);
  useFetch(() => adminClient.clients.listOptionalClientScopes({id: clientId}), (optionalClientScopes) => setSelectableScopes(optionalClientScopes), []);
  const toString4 = (user2) => {
    return t4("common:fullName", {
      givenName: user2.firstName,
      familyName: user2.lastName
    }).trim() || user2.username || "";
  };
  useFetch(() => {
    if (userSearch.length > 2) {
      return adminClient.users.find({search: userSearch});
    } else {
      return Promise.resolve([]);
    }
  }, (users2) => setUserItems(users2.map((user2) => {
    user2.toString = function() {
      return toString4(this);
    };
    return user2;
  }).map((user2) => /* @__PURE__ */ react.createElement(SelectOption, {
    key: user2.id,
    value: user2
  }))), [userSearch]);
  useFetch(async () => {
    const scope = selected.join(" ");
    const effectiveRoles2 = await adminClient.clients.evaluatePermission({
      id: clientId,
      roleContainer: realm2,
      scope,
      type: "granted"
    });
    const mapperList = await adminClient.clients.evaluateListProtocolMapper({
      id: clientId,
      scope
    });
    return {
      mapperList,
      effectiveRoles: effectiveRoles2
    };
  }, ({mapperList, effectiveRoles: effectiveRoles2}) => {
    setEffectiveRoles(effectiveRoles2);
    mapperList.map((mapper) => {
      mapper.type = mapperTypes.filter((type) => type.id === mapper.protocolMapper)[0];
    });
    setProtocolMappers(mapperList);
    refresh();
  }, [selected]);
  useFetch(() => {
    const scope = selected.join(" ");
    if (user) {
      return adminClient.clients.evaluateGenerateAccessToken({
        id: clientId,
        userId: user.id,
        scope
      });
    } else {
      return Promise.resolve({});
    }
  }, (accessToken2) => {
    setAccessToken(JSON.stringify(accessToken2, void 0, 3));
  }, [user, selected]);
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, enabled && /* @__PURE__ */ react.createElement(TextContent, {
    className: "keycloak__scopes_evaluate__intro"
  }, /* @__PURE__ */ react.createElement(Text, null, /* @__PURE__ */ react.createElement(QuestionCircleIcon, null), " ", t4("clients-help:evaluateExplain"))), /* @__PURE__ */ react.createElement(Form, {
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("scopeParameter"),
    fieldId: "scopeParameter",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:scopeParameter",
      forLabel: t4("scopeParameter"),
      forID: "scopeParameter"
    })
  }, /* @__PURE__ */ react.createElement(Split, {
    hasGutter: true
  }, /* @__PURE__ */ react.createElement(SplitItem, {
    isFilled: true
  }, /* @__PURE__ */ react.createElement(Select, {
    toggleId: "scopeParameter",
    variant: SelectVariant.typeaheadMulti,
    typeAheadAriaLabel: t4("scopeParameter"),
    onToggle: () => setIsScopeOpen(!isScopeOpen),
    isOpen: isScopeOpen,
    selections: selected,
    onSelect: (_23, value) => {
      const option = value;
      if (selected.includes(option)) {
        if (option !== prefix2) {
          setSelected(selected.filter((item) => item !== option));
        }
      } else {
        setSelected([...selected, option]);
      }
    },
    "aria-labelledby": t4("scopeParameter"),
    placeholderText: t4("scopeParameterPlaceholder")
  }, selectableScopes.map((option, index3) => /* @__PURE__ */ react.createElement(SelectOption, {
    key: index3,
    value: option.name
  })))), /* @__PURE__ */ react.createElement(SplitItem, null, /* @__PURE__ */ react.createElement(ClipboardCopy, {
    className: "keycloak__scopes_evaluate__clipboard-copy"
  }, selected.join(" "))))), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("user"),
    fieldId: "user",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:user",
      forLabel: t4("user"),
      forID: "user"
    })
  }, /* @__PURE__ */ react.createElement(Select, {
    toggleId: "user",
    variant: SelectVariant.typeahead,
    typeAheadAriaLabel: t4("user"),
    onToggle: () => setIsUserOpen(!isUserOpen),
    onFilter: (e3) => {
      const value = e3?.target.value || "";
      setUserSearch(value);
      return userItems;
    },
    onClear: () => {
      setUser(void 0);
      setUserSearch("");
    },
    selections: [user],
    onSelect: (_23, value) => {
      setUser(value);
      setUserSearch("");
      setIsUserOpen(false);
    },
    isOpen: isUserOpen
  })))), /* @__PURE__ */ react.createElement(Grid, {
    hasGutter: true,
    className: "keycloak__scopes_evaluate__tabs"
  }, /* @__PURE__ */ react.createElement(GridItem, {
    span: 8
  }, /* @__PURE__ */ react.createElement(TabContent, {
    "aria-labelledby": "pf-tab-0-effectiveProtocolMappers",
    eventKey: 0,
    id: "effectiveProtocolMappers",
    ref: tabContent1
  }, /* @__PURE__ */ react.createElement(ProtocolMappers, {
    protocolMappers
  })), /* @__PURE__ */ react.createElement(TabContent, {
    "aria-labelledby": "pf-tab-0-effectiveRoleScopeMappings",
    eventKey: 1,
    id: "effectiveRoleScopeMappings",
    ref: tabContent2,
    hidden: true
  }, /* @__PURE__ */ react.createElement(EffectiveRoles, {
    effectiveRoles
  })), /* @__PURE__ */ react.createElement(TabContent, {
    "aria-labelledby": "pf-tab-0-generatedAccessToken",
    eventKey: 2,
    id: "generatedAccessToken",
    ref: tabContent3,
    hidden: true
  }, user && /* @__PURE__ */ react.createElement(TextArea, {
    rows: 20,
    id: "accessToken",
    value: accessToken
  }), !user && /* @__PURE__ */ react.createElement(EmptyState, {
    variant: "large"
  }, /* @__PURE__ */ react.createElement(Title, {
    headingLevel: "h4",
    size: "lg"
  }, t4("noGeneratedAccessToken")), /* @__PURE__ */ react.createElement(EmptyStateBody, null, t4("generatedAccessTokenIsDisabled"))))), /* @__PURE__ */ react.createElement(GridItem, {
    span: 4
  }, /* @__PURE__ */ react.createElement(Tabs, {
    id: "tabs",
    key,
    isVertical: true,
    activeKey: activeTab,
    onSelect: (_23, key2) => setActiveTab(key2)
  }, /* @__PURE__ */ react.createElement(Tab, {
    id: "effectiveProtocolMappers",
    "aria-controls": "effectiveProtocolMappers",
    eventKey: 0,
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("effectiveProtocolMappers"), " ", /* @__PURE__ */ react.createElement(HelpItem, {
      forID: "effectiveProtocolMappers",
      forLabel: t4("effectiveProtocolMappers"),
      helpText: "clients-help:effectiveProtocolMappers",
      noVerticalAlign: false,
      unWrap: true
    })),
    tabContentRef: tabContent1
  }), /* @__PURE__ */ react.createElement(Tab, {
    id: "effectiveRoleScopeMappings",
    "aria-controls": "effectiveRoleScopeMappings",
    eventKey: 1,
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("effectiveRoleScopeMappings"), " ", /* @__PURE__ */ react.createElement(HelpItem, {
      forID: "effectiveRoleScopeMappings",
      forLabel: t4("effectiveRoleScopeMappings"),
      helpText: "clients-help:effectiveRoleScopeMappings",
      noVerticalAlign: false,
      unWrap: true
    })),
    tabContentRef: tabContent2
  }), /* @__PURE__ */ react.createElement(Tab, {
    id: "generatedAccessToken",
    "aria-controls": "generatedAccessToken",
    eventKey: 2,
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("generatedAccessToken"), " ", /* @__PURE__ */ react.createElement(HelpItem, {
      forID: "generatedAccessToken",
      forLabel: t4("generatedAccessToken"),
      helpText: "clients-help:generatedAccessToken",
      noVerticalAlign: false,
      unWrap: true
    })),
    tabContentRef: tabContent3
  })))));
};

// build/clients/service-account/ServiceAccount.js
var ServiceAccount = ({client: client2}) => {
  const {t: t4} = useTranslation("clients");
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const [hide2, setHide] = useState(false);
  const [serviceAccount, setServiceAccount] = useState();
  useFetch(() => adminClient.clients.getServiceAccountUser({
    id: client2.id
  }), (serviceAccount2) => setServiceAccount(serviceAccount2), []);
  const loader = async () => {
    const serviceAccount2 = await adminClient.clients.getServiceAccountUser({
      id: client2.id
    });
    const id3 = serviceAccount2.id;
    const assignedRoles = (await adminClient.users.listRealmRoleMappings({id: id3})).map((role) => ({role}));
    const effectiveRoles = (await adminClient.users.listCompositeRealmRoleMappings({id: id3})).map((role) => ({role}));
    const clients2 = await adminClient.clients.find();
    const clientRoles = (await Promise.all(clients2.map(async (client22) => {
      const clientAssignedRoles = (await adminClient.users.listClientRoleMappings({
        id: id3,
        clientUniqueId: client22.id
      })).map((role) => ({role, client: client22}));
      const clientEffectiveRoles = (await adminClient.users.listCompositeClientRoleMappings({
        id: id3,
        clientUniqueId: client22.id
      })).map((role) => ({role, client: client22}));
      return mapRoles(clientAssignedRoles, clientEffectiveRoles, hide2);
    }))).flat();
    return [...mapRoles(assignedRoles, effectiveRoles, hide2), ...clientRoles];
  };
  const assignRoles = async (rows) => {
    try {
      const realmRoles = rows.filter((row) => row.client === void 0).map((row) => row.role).flat();
      adminClient.users.addRealmRoleMappings({
        id: serviceAccount?.id,
        roles: realmRoles
      });
      await Promise.all(rows.filter((row) => row.client !== void 0).map((row) => adminClient.users.addClientRoleMappings({
        id: serviceAccount?.id,
        clientUniqueId: row.client.id,
        roles: [row.role]
      })));
      addAlert(t4("roleMappingUpdatedSuccess"), AlertVariant.success);
    } catch (error2) {
      addError("clients:roleMappingUpdatedError", error2);
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, serviceAccount && /* @__PURE__ */ react.createElement(RoleMapping, {
    name: client2.clientId,
    id: serviceAccount.id,
    type: "service-account",
    loader,
    save: assignRoles,
    onHideRolesToggle: () => setHide(!hide2)
  }));
};

// build/clients/ClientDetails.js
var ClientDetailHeader = ({
  onChange,
  value,
  save,
  client: client2,
  toggleDownloadDialog,
  toggleDeleteDialog
}) => {
  const {t: t4} = useTranslation("clients");
  const [toggleDisableDialog, DisableConfirm] = useConfirmDialog({
    titleKey: "clients:disableConfirmTitle",
    messageKey: "clients:disableConfirm",
    continueButtonLabel: "common:disable",
    onConfirm: () => {
      onChange(!value);
      save();
    }
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DisableConfirm, null), /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: client2 ? client2.clientId : "",
    subKey: "clients:clientsExplain",
    badges: [{text: client2.protocol}],
    divider: false,
    helpTextKey: "clients-help:enableDisable",
    dropdownItems: [
      /* @__PURE__ */ react.createElement(DropdownItem, {
        key: "download",
        onClick: () => toggleDownloadDialog()
      }, t4("downloadAdapterConfig")),
      /* @__PURE__ */ react.createElement(DropdownItem, {
        key: "export",
        onClick: () => exportClient(client2)
      }, t4("common:export")),
      /* @__PURE__ */ react.createElement(Divider, {
        key: "divider"
      }),
      /* @__PURE__ */ react.createElement(DropdownItem, {
        key: "delete",
        onClick: () => toggleDeleteDialog()
      }, t4("common:delete"))
    ],
    isEnabled: value,
    onToggle: (value2) => {
      if (!value2) {
        toggleDisableDialog();
      } else {
        onChange(value2);
        save();
      }
    }
  }));
};
var ClientDetails = () => {
  const {t: t4} = useTranslation("clients");
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const {realm: realm2} = useRealm();
  const history = useHistory();
  const [downloadDialogOpen, setDownloadDialogOpen] = useState(false);
  const toggleDownloadDialog = () => setDownloadDialogOpen(!downloadDialogOpen);
  const [changeAuthenticatorOpen, setChangeAuthenticatorOpen] = useState(false);
  const toggleChangeAuthenticator = () => setChangeAuthenticatorOpen(!changeAuthenticatorOpen);
  const [activeTab2, setActiveTab2] = useState(30);
  const form2 = useForm();
  const {clientId} = useParams();
  const clientAuthenticatorType = useWatch({
    control: form2.control,
    name: "clientAuthenticatorType",
    defaultValue: "client-secret"
  });
  const [client2, setClient] = useState();
  const loader = async () => {
    const roles2 = await adminClient.clients.listRoles({id: clientId});
    return lodash.sortBy(roles2, (role) => role.name?.toUpperCase());
  };
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: "clients:clientDeleteConfirmTitle",
    messageKey: "clients:clientDeleteConfirm",
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        await adminClient.clients.del({id: clientId});
        addAlert(t4("clientDeletedSuccess"), AlertVariant.success);
        history.push(toClients({realm: realm2}));
      } catch (error2) {
        addError("clients:clientDeleteError", error2);
      }
    }
  });
  const setupForm = (client22) => {
    const {redirectUris, webOrigins, ...formValues} = client22;
    form2.reset(formValues);
    Object.entries(client22).map((entry) => {
      if (entry[0] === "redirectUris" || entry[0] === "webOrigins") {
        form2.setValue(entry[0], convertToMultiline(entry[1]));
      } else if (entry[0] === "attributes") {
        convertToFormValues(entry[1], "attributes", form2.setValue);
      } else {
        form2.setValue(entry[0], entry[1]);
      }
    });
  };
  useFetch(() => adminClient.clients.findOne({id: clientId}), (fetchedClient) => {
    setClient(fetchedClient);
    setupForm(fetchedClient);
  }, [clientId]);
  const save = async ({confirmed = false, messageKey = "clientSaveSuccess"} = {
    confirmed: false,
    messageKey: "clientSaveSuccess"
  }) => {
    if (await form2.trigger()) {
      if (!client2?.publicClient && client2?.clientAuthenticatorType !== clientAuthenticatorType && !confirmed) {
        toggleChangeAuthenticator();
        return;
      }
      const redirectUris = toValue(form2.getValues()["redirectUris"]);
      const webOrigins = toValue(form2.getValues()["webOrigins"]);
      const attributes = convertFormValuesToObject(form2.getValues()["attributes"]);
      try {
        const newClient = {
          ...client2,
          ...form2.getValues(),
          redirectUris,
          webOrigins,
          attributes
        };
        await adminClient.clients.update({id: clientId}, newClient);
        setupForm(newClient);
        setClient(newClient);
        addAlert(t4(messageKey), AlertVariant.success);
      } catch (error2) {
        addError("client:clientSaveError", error2);
      }
    }
  };
  if (!client2) {
    return /* @__PURE__ */ react.createElement("div", {
      className: "pf-u-text-align-center"
    }, /* @__PURE__ */ react.createElement(Spinner, null));
  }
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ConfirmDialogModal, {
    continueButtonLabel: "common:yes",
    titleKey: t4("changeAuthenticatorConfirmTitle", {
      clientAuthenticatorType
    }),
    open: changeAuthenticatorOpen,
    toggleDialog: toggleChangeAuthenticator,
    onConfirm: () => save({confirmed: true})
  }, /* @__PURE__ */ react.createElement(react.Fragment, null, t4("changeAuthenticatorConfirm", {
    clientAuthenticatorType
  }), clientAuthenticatorType === "client-jwt" && /* @__PURE__ */ react.createElement(Alert, {
    variant: "info",
    isInline: true,
    title: t4("signedJWTConfirm")
  }))), /* @__PURE__ */ react.createElement(DeleteConfirm, null), /* @__PURE__ */ react.createElement(DownloadDialog, {
    id: client2.id,
    protocol: client2.protocol,
    open: downloadDialogOpen,
    toggleDialog: toggleDownloadDialog
  }), /* @__PURE__ */ react.createElement(Controller, {
    name: "enabled",
    control: form2.control,
    defaultValue: true,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(ClientDetailHeader, {
      value,
      onChange,
      client: client2,
      save,
      toggleDeleteDialog,
      toggleDownloadDialog
    })
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    className: "pf-u-p-0"
  }, /* @__PURE__ */ react.createElement(FormProvider, {
    ...form2
  }, /* @__PURE__ */ react.createElement(KeycloakTabs, {
    isBox: true
  }, /* @__PURE__ */ react.createElement(Tab, {
    id: "settings",
    eventKey: "settings",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("common:settings"))
  }, /* @__PURE__ */ react.createElement(ClientSettings, {
    save: () => save(),
    reset: () => setupForm(client2)
  })), !client2.publicClient && /* @__PURE__ */ react.createElement(Tab, {
    id: "keys",
    eventKey: "keys",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("keys"))
  }, /* @__PURE__ */ react.createElement(Keys, {
    clientId,
    save: () => save()
  })), !client2.publicClient && /* @__PURE__ */ react.createElement(Tab, {
    id: "credentials",
    eventKey: "credentials",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("credentials"))
  }, /* @__PURE__ */ react.createElement(Credentials, {
    clientId,
    save: () => save()
  })), /* @__PURE__ */ react.createElement(Tab, {
    id: "roles",
    eventKey: "roles",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("roles"))
  }, /* @__PURE__ */ react.createElement(RolesList, {
    loader,
    paginated: false,
    messageBundle: "clients"
  })), /* @__PURE__ */ react.createElement(Tab, {
    id: "clientScopes",
    eventKey: "clientScopes",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("clientScopes"))
  }, /* @__PURE__ */ react.createElement(Tabs, {
    activeKey: activeTab2,
    onSelect: (_23, key) => setActiveTab2(key)
  }, /* @__PURE__ */ react.createElement(Tab, {
    id: "setup",
    eventKey: 30,
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("setup"))
  }, /* @__PURE__ */ react.createElement(ClientScopes, {
    clientId,
    protocol: client2.protocol
  })), /* @__PURE__ */ react.createElement(Tab, {
    id: "evaluate",
    eventKey: 31,
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("evaluate"))
  }, /* @__PURE__ */ react.createElement(EvaluateScopes, {
    clientId,
    protocol: client2.protocol
  })))), client2.serviceAccountsEnabled && /* @__PURE__ */ react.createElement(Tab, {
    id: "serviceAccount",
    eventKey: "serviceAccount",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("serviceAccount"))
  }, /* @__PURE__ */ react.createElement(ServiceAccount, {
    client: client2
  })), /* @__PURE__ */ react.createElement(Tab, {
    id: "advanced",
    eventKey: "advanced",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("advanced"))
  }, /* @__PURE__ */ react.createElement(AdvancedTab, {
    save,
    client: client2
  }))))));
};

// build/clients/routes/Client.js
var ClientRoute = {
  path: "/:realm/clients/:clientId/:tab",
  component: ClientDetails,
  breadcrumb: (t4) => t4("clients:clientSettings"),
  access: "view-clients"
};
var toClient = (params) => ({
  pathname: generatePath(ClientRoute.path, params)
});

// build/clients/add/GeneralSettings.js
var GeneralSettings = () => {
  const {t: t4} = useTranslation("clients");
  const {errors, control} = useFormContext();
  const providers = useLoginProviders();
  const [open2, isOpen] = useState(false);
  return /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-clients"
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("clientType"),
    fieldId: "kc-type",
    validated: errors.protocol ? "error" : "default",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "clients-help:clientType",
      forLabel: t4("clientType"),
      forID: t4(`common:helpLabel`, {label: t4("clientType")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "protocol",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      id: "kc-type",
      onToggle: () => isOpen(!open2),
      onSelect: (_23, value2) => {
        onChange(value2);
        isOpen(false);
      },
      selections: value,
      variant: SelectVariant.single,
      "aria-label": t4("selectEncryptionType"),
      isOpen: open2
    }, providers.map((option) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: option === value,
      key: option,
      value: option
    })))
  })), /* @__PURE__ */ react.createElement(ClientDescription, null));
};

// build/clients/add/NewClientForm.js
var NewClientForm = () => {
  const {t: t4} = useTranslation("clients");
  const {realm: realm2} = useRealm();
  const adminClient = useAdminClient();
  const history = useHistory();
  const [showCapabilityConfig, setShowCapabilityConfig] = useState(false);
  const [client2, setClient] = useState({
    protocol: "openid-connect",
    clientId: "",
    name: "",
    description: "",
    publicClient: true,
    authorizationServicesEnabled: false,
    serviceAccountsEnabled: false,
    implicitFlowEnabled: false,
    directAccessGrantsEnabled: true,
    standardFlowEnabled: true
  });
  const {addAlert, addError} = useAlerts();
  const methods = useForm({defaultValues: client2});
  const save = async () => {
    try {
      const newClient = await adminClient.clients.create({...client2});
      addAlert(t4("createSuccess"), AlertVariant.success);
      history.push(toClient({realm: realm2, clientId: newClient.id, tab: "settings"}));
    } catch (error2) {
      addError("clients:createError", error2);
    }
  };
  const forward = async (onNext) => {
    if (await methods.trigger()) {
      setClient({...client2, ...methods.getValues()});
      setShowCapabilityConfig(true);
      onNext?.();
    }
  };
  const back = () => {
    setClient({...client2, ...methods.getValues()});
    methods.reset({...client2, ...methods.getValues()});
  };
  const onGoToStep = (newStep) => {
    if (newStep.id === "generalSettings") {
      back();
    } else {
      forward();
    }
  };
  const Footer = () => /* @__PURE__ */ react.createElement(WizardFooter, null, /* @__PURE__ */ react.createElement(WizardContextConsumer, null, ({activeStep, onNext, onBack, onClose}) => {
    return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Button, {
      variant: "primary",
      type: "submit",
      onClick: () => {
        forward(onNext);
      }
    }, activeStep.name === t4("capabilityConfig") ? t4("common:save") : t4("common:next")), /* @__PURE__ */ react.createElement(Button, {
      variant: "secondary",
      onClick: () => {
        back();
        onBack();
      },
      isDisabled: activeStep.name === t4("generalSettings")
    }, t4("common:back")), /* @__PURE__ */ react.createElement(Button, {
      variant: "link",
      onClick: onClose
    }, t4("common:cancel")));
  }));
  const title3 = t4("createClient");
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: "clients:createClient",
    subKey: "clients:clientsExplain"
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(FormProvider, {
    ...methods
  }, /* @__PURE__ */ react.createElement(Wizard, {
    onClose: () => history.push(toClients({realm: realm2})),
    navAriaLabel: `${title3} steps`,
    mainAriaLabel: `${title3} content`,
    steps: [
      {
        id: "generalSettings",
        name: t4("generalSettings"),
        component: /* @__PURE__ */ react.createElement(GeneralSettings, null)
      },
      ...showCapabilityConfig ? [
        {
          id: "capabilityConfig",
          name: t4("capabilityConfig"),
          component: /* @__PURE__ */ react.createElement(CapabilityConfig, {
            protocol: client2.protocol
          })
        }
      ] : []
    ],
    footer: /* @__PURE__ */ react.createElement(Footer, null),
    onSave: save,
    onGoToStep
  }))));
};

// build/clients/routes/AddClient.js
var AddClientRoute = {
  path: "/:realm/clients/add-client",
  component: NewClientForm,
  breadcrumb: (t4) => t4("clients:createClient"),
  access: "manage-clients"
};
var toAddClient = (params) => ({
  pathname: generatePath(AddClientRoute.path, params)
});

// build/clients/routes.js
var routes3 = [
  AddClientRoute,
  ImportClientRoute,
  ClientsRoute,
  CreateInitialAccessTokenRoute,
  ClientRoute
];
var routes_default3 = routes3;

// build/dashboard/routes.js
var routes4 = [DashboardRoute];
var routes_default4 = routes4;

// build/events/EventsSection.js
var import_moment6 = __toModule(require_moment());

// build/realm-settings/AddMessageBundleModal.js
var AddMessageBundleModal = ({
  handleModalToggle,
  save
}) => {
  const {t: t4} = useTranslation("groups");
  const {register, errors, handleSubmit} = useForm();
  return /* @__PURE__ */ react.createElement(Modal, {
    variant: ModalVariant.small,
    title: t4("realm-settings:addMessageBundle"),
    isOpen: true,
    onClose: handleModalToggle,
    actions: [
      /* @__PURE__ */ react.createElement(Button, {
        "data-testid": "add-bundle-confirm-button",
        key: "confirm",
        variant: "primary",
        type: "submit",
        form: "bundle-form"
      }, t4("common:create")),
      /* @__PURE__ */ react.createElement(Button, {
        id: "modal-cancel",
        key: "cancel",
        variant: ButtonVariant.link,
        onClick: () => {
          handleModalToggle();
        }
      }, t4("common:cancel"))
    ]
  }, /* @__PURE__ */ react.createElement(Form, {
    id: "bundle-form",
    isHorizontal: true,
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("realm-settings:key"),
    name: "key",
    fieldId: "email-id",
    helperTextInvalid: t4("users:emailInvalid"),
    validated: errors.email ? ValidatedOptions.error : ValidatedOptions.default,
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    "data-testid": "key-input",
    ref: register({required: true}),
    autoFocus: true,
    type: "text",
    id: "add-key",
    name: "key",
    validated: errors.email ? ValidatedOptions.error : ValidatedOptions.default
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("realm-settings:value"),
    name: "add-value",
    fieldId: "value-id",
    helperTextInvalid: t4("users:emailInvalid"),
    validated: errors.email ? ValidatedOptions.error : ValidatedOptions.default,
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    "data-testid": "value-input",
    ref: register({required: true}),
    autoFocus: true,
    type: "text",
    id: "add-value",
    name: "value",
    validated: errors.email ? ValidatedOptions.error : ValidatedOptions.default
  }))));
};

// build/realm-settings/LocalizationTab.js
var LocalizationTab = ({
  save,
  reset,
  realm: realm2,
  refresh
}) => {
  const {t: t4} = useTranslation("realm-settings");
  const adminClient = useAdminClient();
  const [addMessageBundleModalOpen, setAddMessageBundleModalOpen] = useState(false);
  const [key, setKey] = useState(0);
  const [supportedLocalesOpen, setSupportedLocalesOpen] = useState(false);
  const [defaultLocaleOpen, setDefaultLocaleOpen] = useState(false);
  const {getValues, control, handleSubmit} = useFormContext();
  const [valueSelected, setValueSelected] = useState(false);
  const themeTypes = useServerInfo().themes;
  const bundleForm = useForm({mode: "onChange"});
  const {addAlert, addError} = useAlerts();
  const {realm: currentRealm} = useRealm();
  const watchSupportedLocales = useWatch({
    control,
    name: "supportedLocales",
    defaultValue: themeTypes?.account[0].locales
  });
  const internationalizationEnabled = useWatch({
    control,
    name: "internationalizationEnabled",
    defaultValue: realm2?.internationalizationEnabled
  });
  const loader = async () => {
    if (realm2) {
      const result = await adminClient.realms.getRealmLocalizationTexts({
        realm: realm2.realm,
        selectedLocale: getValues("defaultLocale") || "en"
      });
      return Object.keys(result).map((key2) => [key2, result[key2]]);
    }
    return [[]];
  };
  const handleModalToggle = () => {
    setAddMessageBundleModalOpen(!addMessageBundleModalOpen);
  };
  const addKeyValue = async (pair) => {
    try {
      adminClient.setConfig({
        requestConfig: {headers: {"Content-Type": "text/plain"}}
      });
      await adminClient.realms.addLocalization({
        realm: currentRealm,
        selectedLocale: getValues("defaultLocale") || "en",
        key: pair.key
      }, pair.value);
      adminClient.setConfig({
        realmName: currentRealm
      });
      refresh();
      addAlert(t4("pairCreatedSuccess"), AlertVariant.success);
    } catch (error2) {
      addError("realm-settings:pairCreatedError", error2);
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, addMessageBundleModalOpen && /* @__PURE__ */ react.createElement(AddMessageBundleModal, {
    handleModalToggle,
    save: (pair) => {
      addKeyValue(pair);
      handleModalToggle();
    },
    form: bundleForm
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(FormPanel, {
    className: "kc-login-screen",
    title: "Login screen customization"
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-realm",
    className: "pf-u-mt-lg",
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("internationalization"),
    fieldId: "kc-internationalization"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "internationalizationEnabled",
    control,
    defaultValue: false,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-l-internationalization",
      label: t4("common:enabled"),
      labelOff: t4("common:disabled"),
      isChecked: internationalizationEnabled,
      "data-testid": value ? "internationalization-enabled" : "internationalization-disabled",
      onChange
    })
  })), internationalizationEnabled && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("supportedLocales"),
    fieldId: "kc-l-supported-locales"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "supportedLocales",
    control,
    defaultValue: themeTypes?.account[0].locales,
    render: ({onChange}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-l-supported-locales",
      onToggle: () => {
        setSupportedLocalesOpen(!supportedLocalesOpen);
      },
      onSelect: (_23, v3) => {
        const option = v3;
        if (!watchSupportedLocales) {
          onChange([option]);
        } else if (watchSupportedLocales.includes(option)) {
          onChange(watchSupportedLocales.filter((item) => item !== option));
        } else {
          onChange([...watchSupportedLocales, option]);
        }
      },
      onClear: () => {
        onChange([]);
      },
      selections: watchSupportedLocales,
      variant: SelectVariant.typeaheadMulti,
      "aria-label": t4("supportedLocales"),
      isOpen: supportedLocalesOpen,
      placeholderText: "Select locales"
    }, themeTypes?.login[0].locales.map((locale, idx) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: true,
      key: `locale-${idx}`,
      value: locale
    }, t4(`allSupportedLocales.${locale}`))))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("defaultLocale"),
    fieldId: "kc-l-default-locale"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "defaultLocale",
    control,
    defaultValue: realm2?.defaultLocale,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-default-locale",
      onToggle: () => setDefaultLocaleOpen(!defaultLocaleOpen),
      onSelect: (_23, value2) => {
        onChange(value2);
        setValueSelected(true);
        setKey(new Date().getTime());
        setDefaultLocaleOpen(false);
      },
      selections: valueSelected ? t4(`allSupportedLocales.${value}`) : realm2.defaultLocale !== "" ? t4(`allSupportedLocales.${realm2.defaultLocale || "en"}`) : t4("placeholderText"),
      variant: SelectVariant.single,
      "aria-label": t4("defaultLocale"),
      isOpen: defaultLocaleOpen,
      placeholderText: t4("placeholderText"),
      "data-testid": "select-default-locale"
    }, watchSupportedLocales.map((locale, idx) => /* @__PURE__ */ react.createElement(SelectOption, {
      key: `default-locale-${idx}`,
      value: locale
    }, t4(`allSupportedLocales.${locale}`))))
  }))), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "primary",
    type: "submit",
    "data-testid": "localization-tab-save"
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: reset
  }, t4("common:revert"))))), /* @__PURE__ */ react.createElement(FormPanel, {
    className: "kc-message-bundles",
    title: "Edit message bundles"
  }, /* @__PURE__ */ react.createElement(TextContent, {
    className: "messageBundleDescription"
  }, t4("messageBundleDescription")), /* @__PURE__ */ react.createElement("div", {
    className: "tableBorder"
  }, /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    loader,
    ariaLabelKey: "client-scopes:clientScopeList",
    toolbarItem: /* @__PURE__ */ react.createElement(Button, {
      "data-testid": "add-bundle-button",
      onClick: () => setAddMessageBundleModalOpen(true)
    }, t4("addMessageBundle")),
    searchPlaceholderKey: " ",
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      hasIcon: true,
      message: t4("noMessageBundles"),
      instructions: t4("noMessageBundlesInstructions"),
      onPrimaryAction: handleModalToggle,
      primaryActionText: t4("addMessageBundle")
    }),
    canSelectAll: true,
    columns: [
      {
        name: "Key",
        cellRenderer: (row) => row[0]
      },
      {
        name: "Value",
        cellRenderer: (row) => row[1]
      }
    ]
  })))));
};

// build/realm-settings/AddUserEmailModal.js
var AddUserEmailModal = ({
  handleModalToggle,
  save
}) => {
  const {t: t4} = useTranslation("groups");
  const {register, errors, handleSubmit, watch} = useForm();
  const watchEmailInput = watch("email", "");
  return /* @__PURE__ */ react.createElement(Modal, {
    variant: ModalVariant.small,
    title: t4("realm-settings:provideEmailTitle"),
    isOpen: true,
    onClose: handleModalToggle,
    actions: [
      /* @__PURE__ */ react.createElement(Button, {
        "data-testid": "modal-test-connection-button",
        key: "confirm",
        variant: "primary",
        type: "submit",
        form: "email-form",
        isDisabled: !watchEmailInput
      }, t4("realm-settings:testConnection")),
      /* @__PURE__ */ react.createElement(Button, {
        id: "modal-cancel",
        key: "cancel",
        variant: ButtonVariant.link,
        onClick: () => {
          handleModalToggle();
        }
      }, t4("common:cancel"))
    ]
  }, /* @__PURE__ */ react.createElement(TextContent, {
    className: "kc-provide-email-text"
  }, t4("realm-settings:provideEmail")), /* @__PURE__ */ react.createElement(Form, {
    id: "email-form",
    isHorizontal: true,
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    className: "kc-email-form-group",
    name: "add-email-address",
    fieldId: "email-id",
    helperTextInvalid: t4("users:emailInvalid"),
    validated: errors.email ? ValidatedOptions.error : ValidatedOptions.default,
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    "data-testid": "email-address-input",
    ref: register({required: true, pattern: emailRegexPattern}),
    autoFocus: true,
    type: "text",
    id: "add-email",
    name: "email",
    validated: errors.email ? ValidatedOptions.error : ValidatedOptions.default
  }))));
};

// build/realm-settings/EmailTab.js
var RealmSettingsEmailTab = ({
  realm: initialRealm,
  user
}) => {
  const {t: t4} = useTranslation("realm-settings");
  const adminClient = useAdminClient();
  const {realm: realmName} = useRealm();
  const {addAlert, addError} = useAlerts();
  const {whoAmI: whoAmI2} = useWhoAmI();
  const [realm2, setRealm] = useState(initialRealm);
  const [userEmailModalOpen, setUserEmailModalOpen] = useState(false);
  const [currentUser, setCurrentUser] = useState();
  const {
    register,
    control,
    handleSubmit,
    errors,
    watch,
    setValue,
    reset: resetForm,
    getValues
  } = useForm();
  const userForm = useForm({mode: "onChange"});
  const watchFromValue = watch("smtpServer.from", "");
  const watchHostValue = watch("smtpServer.host", "");
  const authenticationEnabled = useWatch({
    control,
    name: "smtpServer.authentication",
    defaultValue: {}
  });
  useEffect(() => {
    reset();
  }, [realm2]);
  useEffect(() => {
    setCurrentUser(user);
  }, []);
  const handleModalToggle = () => {
    setUserEmailModalOpen(!userEmailModalOpen);
  };
  const save = async (form2) => {
    try {
      const savedRealm = {...realm2, ...form2};
      await adminClient.realms.update({realm: realmName}, savedRealm);
      setRealm(savedRealm);
      addAlert(t4("saveSuccess"), AlertVariant.success);
    } catch (error2) {
      addError("realm-settings:saveError", error2);
    }
  };
  const saveAndTestEmail = async (email) => {
    if (email) {
      await adminClient.users.update({id: whoAmI2.getUserId()}, email);
      const updated = await adminClient.users.findOne({
        id: whoAmI2.getUserId()
      });
      setCurrentUser(updated);
      await save(getValues());
      testConnection();
    } else {
      const user2 = await adminClient.users.findOne({id: whoAmI2.getUserId()});
      if (!user2.email) {
        handleModalToggle();
      } else {
        await save(getValues());
        testConnection();
      }
    }
  };
  const reset = () => {
    if (realm2) {
      resetForm(realm2);
      Object.entries(realm2).map((entry) => setValue(entry[0], entry[1]));
    }
  };
  const testConnection = async () => {
    try {
      await adminClient.realms.testSMTPConnection({realm: realm2.realm}, getValues()["smtpServer"] || {});
      addAlert(t4("testConnectionSuccess"), AlertVariant.success);
    } catch (error2) {
      addError("realm-settings:testConnectionError", error2);
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, userEmailModalOpen && /* @__PURE__ */ react.createElement(AddUserEmailModal, {
    handleModalToggle,
    testConnection,
    save: (email) => {
      saveAndTestEmail(email);
      handleModalToggle();
    },
    form: userForm,
    user: currentUser
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(FormPanel, {
    title: t4("template"),
    className: "kc-email-template"
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-realm",
    className: "pf-u-mt-lg",
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("from"),
    fieldId: "kc-display-name",
    isRequired: true,
    validated: errors.smtpServer?.from ? "error" : "default",
    helperTextInvalid: t4("users:emailInvalid")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "email",
    id: "kc-sender-email-address",
    "data-testid": "sender-email-address",
    name: "smtpServer.from",
    ref: register({
      pattern: emailRegexPattern,
      required: true
    }),
    placeholder: "Sender email address",
    validated: errors.smtpServer?.from ? "error" : "default"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("fromDisplayName"),
    fieldId: "kc-from-display-name",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:fromDisplayName",
      forLabel: t4("authentication"),
      forID: t4(`common:helpLabel`, {label: t4("authentication")})
    })
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-from-display-name",
    "data-testid": "from-display-name",
    name: "smtpServer.fromDisplayName",
    ref: register,
    placeholder: "Display name for Sender email address"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("replyTo"),
    fieldId: "kc-reply-to",
    validated: errors.smtpServer?.replyTo ? "error" : "default",
    helperTextInvalid: t4("users:emailInvalid")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "email",
    id: "kc-reply-to",
    name: "smtpServer.replyTo",
    ref: register({
      pattern: emailRegexPattern
    }),
    placeholder: "Reply to email address",
    validated: errors.smtpServer?.replyTo ? "error" : "default"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("replyToDisplayName"),
    fieldId: "kc-reply-to-display-name",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:replyToDisplayName",
      forLabel: t4("replyToDisplayName"),
      forID: t4(`common:helpLabel`, {
        label: t4("replyToDisplayName")
      })
    })
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-reply-to-display-name",
    name: "smtpServer.replyToDisplayName",
    ref: register,
    placeholder: 'Display name for "reply to" email address'
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("envelopeFrom"),
    fieldId: "kc-envelope-from",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:envelopeFrom",
      forLabel: t4("envelopeFrom"),
      forID: t4(`common:helpLabel`, {label: t4("envelopeFrom")})
    })
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-envelope-from",
    name: "smtpServer.envelopeFrom",
    ref: register,
    placeholder: "Sender envelope email address"
  })))), /* @__PURE__ */ react.createElement(FormPanel, {
    className: "kc-email-connection",
    title: t4("connectionAndAuthentication")
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-realm",
    className: "pf-u-mt-lg",
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("host"),
    fieldId: "kc-host",
    isRequired: true,
    validated: errors.smtpServer?.host ? "error" : "default",
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-host",
    name: "smtpServer.host",
    ref: register({required: true}),
    placeholder: "SMTP host",
    validated: errors.smtpServer?.host ? "error" : "default"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("port"),
    fieldId: "kc-port"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-port",
    name: "smtpServer.port",
    ref: register,
    placeholder: "SMTP port (defaults to 25)"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("encryption"),
    fieldId: "kc-html-display-name"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "smtpServer.ssl",
    control,
    defaultValue: "false",
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Checkbox, {
      id: "kc-enable-ssl",
      "data-testid": "enable-ssl",
      label: t4("enableSSL"),
      ref: register,
      isChecked: value === "true",
      onChange: (value2) => onChange("" + value2)
    })
  }), /* @__PURE__ */ react.createElement(Controller, {
    name: "smtpServer.starttls",
    control,
    defaultValue: "false",
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Checkbox, {
      id: "kc-enable-start-tls",
      "data-testid": "enable-start-tls",
      label: t4("enableStartTLS"),
      ref: register,
      isChecked: value === "true",
      onChange: (value2) => onChange("" + value2)
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    hasNoPaddingTop: true,
    label: t4("authentication"),
    fieldId: "kc-authentication"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "smtpServer.authentication",
    control,
    defaultValue: authenticationEnabled,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-authentication-switch",
      "data-testid": "email-authentication-switch",
      label: t4("common:enabled"),
      labelOff: t4("common:disabled"),
      isChecked: value === "true",
      onChange: (value2) => {
        onChange("" + value2);
      }
    })
  })), authenticationEnabled === "true" && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("username"),
    fieldId: "kc-username",
    isRequired: true,
    validated: errors.smtpServer?.user ? "error" : "default",
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-username",
    "data-testid": "username-input",
    name: "smtpServer.user",
    ref: register({required: true}),
    placeholder: "Login username",
    validated: errors.smtpServer?.user ? "error" : "default"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("password"),
    fieldId: "kc-username",
    isRequired: true,
    validated: errors.smtpServer?.password ? "error" : "default",
    helperTextInvalid: t4("common:required"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:password",
      forLabel: t4("password"),
      forID: t4(`common:helpLabel`, {label: t4("password")})
    })
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "password",
    id: "kc-password",
    "data-testid": "password-input",
    name: "smtpServer.password",
    ref: register({required: true}),
    placeholder: "Login password",
    validated: errors.smtpServer?.password ? "error" : "default"
  }))), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "primary",
    type: "submit",
    "data-testid": "email-tab-save"
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    variant: "secondary",
    onClick: () => saveAndTestEmail(),
    "data-testid": "test-connection-button",
    isDisabled: !(emailRegexPattern.test(watchFromValue) && watchHostValue)
  }, t4("realm-settings:testConnection")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: reset
  }, t4("common:revert")))))));
};

// build/realm-settings/event-config/EventConfigForm.js
var EventConfigForm = ({
  type,
  form: form2,
  reset,
  clear
}) => {
  const {t: t4} = useTranslation("realm-settings");
  const {
    control,
    watch,
    setValue,
    formState: {isDirty}
  } = form2;
  const eventKey = type === "admin" ? "adminEventsEnabled" : "eventsEnabled";
  const eventsEnabled = watch(eventKey);
  const [toggleDisableDialog, DisableConfirm] = useConfirmDialog({
    titleKey: "realm-settings:events-disable-title",
    messageKey: "realm-settings:events-disable-confirm",
    continueButtonLabel: "realm-settings:confirm",
    onConfirm: () => setValue(eventKey, false)
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DisableConfirm, null), /* @__PURE__ */ react.createElement(FormGroup, {
    hasNoPaddingTop: true,
    label: t4("saveEvents"),
    fieldId: eventKey,
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: `realm-settings-help:save-${type}-events`,
      forLabel: t4("saveEvents"),
      forID: t4(`common:helpLabel`, {label: t4("saveEvents")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: eventKey,
    defaultValue: false,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      "data-testid": eventKey,
      id: `${eventKey}-switch`,
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value,
      onChange: (value2) => {
        if (!value2) {
          toggleDisableDialog();
        } else {
          onChange(value2);
        }
      }
    })
  })), eventsEnabled && /* @__PURE__ */ react.createElement(react.Fragment, null, type === "admin" && /* @__PURE__ */ react.createElement(FormGroup, {
    hasNoPaddingTop: true,
    label: t4("includeRepresentation"),
    fieldId: "includeRepresentation",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:includeRepresentation",
      forLabel: t4("includeRepresentation"),
      forID: t4(`common:helpLabel`, {
        label: t4("includeRepresentation")
      })
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "adminEventsDetailsEnabled",
    defaultValue: false,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      "data-testid": "includeRepresentation",
      id: "includeRepresentation",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value,
      onChange
    })
  })), type === "user" && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("expiration"),
    fieldId: "expiration",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:expiration",
      forLabel: t4("expiration"),
      forID: t4(`common:helpLabel`, {label: t4("expiration")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "eventsExpiration",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  }))), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "primary",
    type: "submit",
    id: `save-${type}`,
    "data-testid": `save-${type}`,
    isDisabled: !isDirty
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: reset
  }, t4("common:revert"))), /* @__PURE__ */ react.createElement(Divider, null), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("clearEvents"),
    fieldId: `clear-${type}-events`,
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: `realm-settings-help:${type}-clearEvents`,
      forLabel: t4("clearEvents"),
      forID: `clear-${type}-events`
    })
  }, /* @__PURE__ */ react.createElement(Button, {
    variant: "danger",
    id: `clear-${type}-events`,
    "data-testid": `clear-${type}-events`,
    onClick: () => clear()
  }, t4("clearEvents"))));
};

// build/realm-settings/event-config/EventsTypeTable.js
function EventsTypeTable({
  loader,
  addTypes,
  onSelect,
  onDelete
}) {
  const {t: t4} = useTranslation("realm-settings");
  const DescriptionCell = (event) => /* @__PURE__ */ react.createElement(Fragment, {
    key: event.id
  }, t4(`eventTypes.${event.id}.description`));
  return /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    ariaLabelKey: "userEventsRegistered",
    searchPlaceholderKey: "realm-settings:searchEventType",
    loader,
    onSelect: onSelect ? onSelect : void 0,
    canSelectAll: !!onSelect,
    toolbarItem: /* @__PURE__ */ react.createElement(react.Fragment, null, addTypes && /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      id: "addTypes",
      onClick: addTypes,
      "data-testid": "addTypes"
    }, t4("addSavedTypes")))),
    actions: !onDelete ? [] : [
      {
        title: t4("common:delete"),
        onRowClick: onDelete
      }
    ],
    columns: [
      {
        name: "id",
        displayKey: "realm-settings:eventType",
        cellFormatters: [
          (data) => t4(`eventTypes.${data}.name`)
        ]
      },
      {
        name: "description",
        displayKey: "description",
        cellRenderer: DescriptionCell
      }
    ],
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      message: t4("emptyEvents"),
      instructions: t4("emptyEventsInstructions")
    })
  });
}

// build/realm-settings/event-config/AddEventTypesDialog.js
var AddEventTypesDialog = ({
  onConfirm,
  onClose,
  configured
}) => {
  const {t: t4} = useTranslation("realm-settings");
  const {enums} = useServerInfo();
  const [selectedTypes, setSelectedTypes] = useState([]);
  return /* @__PURE__ */ react.createElement(Modal, {
    variant: ModalVariant.medium,
    title: t4("addTypes"),
    isOpen: true,
    onClose,
    actions: [
      /* @__PURE__ */ react.createElement(Button, {
        "data-testid": "addEventTypeConfirm",
        key: "confirm",
        variant: "primary",
        onClick: () => onConfirm(selectedTypes)
      }, t4("common:add")),
      /* @__PURE__ */ react.createElement(Button, {
        "data-testid": "moveCancel",
        key: "cancel",
        variant: "link",
        onClick: onClose
      }, t4("common:cancel"))
    ]
  }, /* @__PURE__ */ react.createElement(EventsTypeTable, {
    onSelect: (selected) => setSelectedTypes(selected),
    loader: () => Promise.resolve(enums["eventType"].filter((type) => !configured.includes(type)).map((id3) => {
      return {id: id3};
    }))
  }));
};

// build/realm-settings/event-config/EventsTab.js
var EventsTab = () => {
  const {t: t4} = useTranslation("realm-settings");
  const form2 = useForm();
  const {setValue, handleSubmit, watch, reset} = form2;
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const [tableKey, setTableKey] = useState(0);
  const reload = () => setTableKey(new Date().getTime());
  const [activeTab, setActiveTab] = useState("user");
  const [events, setEvents] = useState();
  const [type, setType] = useState();
  const [addEventType, setAddEventType] = useState(false);
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const {realm: realm2} = useRealm();
  const setupForm = (eventConfig) => {
    reset(eventConfig);
    setEvents(eventConfig);
    Object.entries(eventConfig || {}).forEach((entry) => setValue(entry[0], entry[1]));
  };
  const clear = async (type2) => {
    setType(type2);
    toggleDeleteDialog();
  };
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: "realm-settings:deleteEvents",
    messageKey: "realm-settings:deleteEventsConfirm",
    continueButtonLabel: "common:clear",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        switch (type) {
          case "admin":
            await adminClient.realms.clearAdminEvents({realm: realm2});
            break;
          case "user":
            await adminClient.realms.clearEvents({realm: realm2});
            break;
        }
        addAlert(t4(`${type}-events-cleared`), AlertVariant.success);
      } catch (error2) {
        addError(`realm-settings:${type}-events-cleared-error`, error2);
      }
    }
  });
  useFetch(() => adminClient.realms.getConfigEvents({realm: realm2}), (eventConfig) => {
    setupForm(eventConfig);
    reload();
  }, [key]);
  const save = async (eventConfig) => {
    try {
      await adminClient.realms.updateConfigEvents({realm: realm2}, eventConfig);
      setupForm({...events, ...eventConfig});
      addAlert(t4("eventConfigSuccessfully"), AlertVariant.success);
    } catch (error2) {
      addError("realm-settings:eventConfigError", error2);
    }
  };
  const addEventTypes = async (eventTypes) => {
    const eventsTypes = eventTypes.map((type2) => type2.id);
    const enabledEvents = events.enabledEventTypes?.concat(eventsTypes);
    await addEvents(enabledEvents);
  };
  const addEvents = async (events2 = []) => {
    const eventConfig = {...form2.getValues(), enabledEventTypes: events2};
    await save(eventConfig);
    setAddEventType(false);
    refresh();
  };
  const eventsEnabled = watch("eventsEnabled") || false;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DeleteConfirm, null), addEventType && /* @__PURE__ */ react.createElement(AddEventTypesDialog, {
    onConfirm: (eventTypes) => addEventTypes(eventTypes),
    configured: events?.enabledEventTypes || [],
    onClose: () => setAddEventType(false)
  }), /* @__PURE__ */ react.createElement(Tabs, {
    activeKey: activeTab,
    onSelect: (_23, key2) => setActiveTab(key2)
  }, /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "user",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("userEventsSettings")),
    "data-testid": "rs-events-tab"
  }, /* @__PURE__ */ react.createElement(PageSection, null, /* @__PURE__ */ react.createElement(Title, {
    headingLevel: "h1",
    size: "xl"
  }, t4("userEventsConfig"))), /* @__PURE__ */ react.createElement(PageSection, null, /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-events",
    isHorizontal: true,
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(EventConfigForm, {
    type: "user",
    form: form2,
    reset: () => setupForm(events),
    clear: () => clear("user")
  }))), eventsEnabled && /* @__PURE__ */ react.createElement(PageSection, null, /* @__PURE__ */ react.createElement(EventsTypeTable, {
    key: tableKey,
    addTypes: () => setAddEventType(true),
    loader: () => Promise.resolve(events?.enabledEventTypes?.map((id3) => {
      return {id: id3};
    }) || []),
    onDelete: (value) => {
      const enabledEventTypes = events?.enabledEventTypes?.filter((e3) => e3 !== value.id);
      addEvents(enabledEventTypes);
      setEvents({...events, enabledEventTypes});
    }
  }))), /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "admin",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("adminEventsSettings")),
    "data-testid": "rs-events-tab"
  }, /* @__PURE__ */ react.createElement(PageSection, null, /* @__PURE__ */ react.createElement(Title, {
    headingLevel: "h4",
    size: "xl"
  }, t4("adminEventsConfig"))), /* @__PURE__ */ react.createElement(PageSection, null, /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-events",
    isHorizontal: true,
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(EventConfigForm, {
    type: "admin",
    form: form2,
    reset: () => setupForm(events),
    clear: () => clear("admin")
  }))))));
};

// build/realm-settings/GeneralTab.js
var RealmSettingsGeneralTab = ({
  save,
  reset
}) => {
  const {t: t4} = useTranslation("realm-settings");
  const adminClient = useAdminClient();
  const {realm: realmName} = useRealm();
  const {
    register,
    control,
    handleSubmit,
    formState: {isDirty}
  } = useFormContext();
  const [open2, setOpen] = useState(false);
  const baseUrl = getBaseUrl(adminClient);
  const requireSslTypes = ["all", "external", "none"];
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-realm",
    className: "pf-u-mt-lg",
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("realmId"),
    fieldId: "kc-realm-id",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(ClipboardCopy, {
    isReadOnly: true
  }, realmName)), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("displayName"),
    fieldId: "kc-display-name"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-display-name",
    name: "displayName",
    ref: register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("htmlDisplayName"),
    fieldId: "kc-html-display-name"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-html-display-name",
    name: "displayNameHtml",
    ref: register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("frontendUrl"),
    fieldId: "kc-frontend-url",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:frontendUrl",
      forLabel: t4("frontendUrl"),
      forID: t4(`common:helpLabel`, {label: t4("frontendUrl")})
    })
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-frontend-url",
    name: "attributes.frontendUrl",
    ref: register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("requireSsl"),
    fieldId: "kc-require-ssl",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:requireSsl",
      forLabel: t4("requireSsl"),
      forID: t4(`common:helpLabel`, {label: t4("requireSsl")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "sslRequired",
    defaultValue: "none",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-require-ssl",
      onToggle: () => setOpen(!open2),
      onSelect: (_23, value2) => {
        onChange(value2);
        setOpen(false);
      },
      selections: value,
      variant: SelectVariant.single,
      "aria-label": t4("requireSsl"),
      isOpen: open2
    }, requireSslTypes.map((sslType) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: sslType === value,
      key: sslType,
      value: sslType
    }, t4(`sslType.${sslType}`))))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    hasNoPaddingTop: true,
    label: t4("userManagedAccess"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:userManagedAccess",
      forLabel: t4("userManagedAccess"),
      forID: t4(`common:helpLabel`, {label: t4("userManagedAccess")})
    }),
    fieldId: "kc-user-manged-access"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "userManagedAccessAllowed",
    control,
    defaultValue: false,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-user-managed-access",
      "data-testid": "user-managed-access-switch",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value,
      onChange
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("endpoints"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:endpoints",
      forLabel: t4("endpoints"),
      forID: t4(`common:helpLabel`, {label: t4("endpoints")})
    }),
    fieldId: "kc-endpoints"
  }, /* @__PURE__ */ react.createElement(Stack, null, /* @__PURE__ */ react.createElement(StackItem, null, /* @__PURE__ */ react.createElement(FormattedLink, {
    href: `${baseUrl}realms/${realmName}/.well-known/openid-configuration`,
    title: t4("openIDEndpointConfiguration")
  })), /* @__PURE__ */ react.createElement(StackItem, null, /* @__PURE__ */ react.createElement(FormattedLink, {
    href: `${baseUrl}realms/${realmName}/protocol/saml/descriptor`,
    title: t4("samlIdentityProviderMetadata")
  })))), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "primary",
    type: "submit",
    "data-testid": "general-tab-save",
    isDisabled: !isDirty
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: reset
  }, t4("common:revert"))))));
};

// build/realm-settings/KeysListTab.js
var KeysListTab = ({realmComponents}) => {
  const {t: t4} = useTranslation("roles");
  const history = useHistory();
  const {url} = useRouteMatch();
  const [key, setKey] = useState(0);
  const [publicKey, setPublicKey] = useState("");
  const [certificate, setCertificate] = useState("");
  const [filterDropdownOpen, setFilterDropdownOpen] = useState(false);
  const [filterType, setFilterType] = useState("Active keys");
  const refresh = () => {
    setKey(new Date().getTime());
  };
  const adminClient = useAdminClient();
  const {realm: realmName} = useRealm();
  const loader = async () => {
    const keysMetaData = await adminClient.realms.getKeys({
      realm: realmName
    });
    const keys2 = keysMetaData.keys;
    return keys2?.map((key2) => {
      const provider = realmComponents.find((component) => component.id === key2.providerId);
      return {...key2, provider: provider?.name};
    });
  };
  const activeKeysLoader = async () => {
    const keysMetaData = await adminClient.realms.getKeys({
      realm: realmName
    });
    const keys2 = keysMetaData.keys;
    const activeKeysCopy = keys2.filter((i3) => i3.status === "ACTIVE");
    return activeKeysCopy?.map((key2) => {
      const provider = realmComponents.find((component) => component.id === key2.providerId);
      return {...key2, provider: provider?.name};
    });
  };
  const passiveKeysLoader = async () => {
    const keysMetaData = await adminClient.realms.getKeys({
      realm: realmName
    });
    const keys2 = keysMetaData.keys;
    const passiveKeys = keys2.filter((i3) => i3.status === "PASSIVE");
    return passiveKeys?.map((key2) => {
      const provider = realmComponents.find((component) => component.id === key2.providerId);
      return {...key2, provider: provider?.name};
    });
  };
  const disabledKeysLoader = async () => {
    const keysMetaData = await adminClient.realms.getKeys({
      realm: realmName
    });
    const keys2 = keysMetaData.keys;
    const disabledKeys = keys2.filter((i3) => i3.status === "DISABLED");
    return disabledKeys?.map((key2) => {
      const provider = realmComponents.find((component) => component.id === key2.providerId);
      return {...key2, provider: provider?.name};
    });
  };
  const [togglePublicKeyDialog, PublicKeyDialog] = useConfirmDialog({
    titleKey: t4("realm-settings:publicKeys").slice(0, -1),
    messageKey: publicKey,
    continueButtonLabel: "common:close",
    continueButtonVariant: ButtonVariant.primary,
    onConfirm: () => Promise.resolve()
  });
  const [toggleCertificateDialog, CertificateDialog] = useConfirmDialog({
    titleKey: t4("realm-settings:certificate"),
    messageKey: certificate,
    continueButtonLabel: "common:close",
    continueButtonVariant: ButtonVariant.primary,
    onConfirm: () => Promise.resolve()
  });
  const goToCreate = () => history.push(`${url}/add-role`);
  const ProviderRenderer = ({provider}) => {
    return /* @__PURE__ */ react.createElement(react.Fragment, null, provider);
  };
  const ButtonRenderer = ({type, publicKey: publicKey2, certificate: certificate2}) => {
    if (type === "EC") {
      return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Button, {
        onClick: () => {
          togglePublicKeyDialog();
          setPublicKey(publicKey2);
        },
        variant: "secondary",
        id: "kc-public-key"
      }, t4("realm-settings:publicKeys").slice(0, -1)));
    } else if (type === "RSA") {
      return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement("div", {
        className: "button-wrapper"
      }, /* @__PURE__ */ react.createElement(Button, {
        onClick: () => {
          togglePublicKeyDialog();
          setPublicKey(publicKey2);
        },
        variant: "secondary",
        id: "kc-rsa-public-key"
      }, t4("realm-settings:publicKeys").slice(0, -1)), /* @__PURE__ */ react.createElement(Button, {
        onClick: () => {
          toggleCertificateDialog();
          setCertificate(certificate2);
        },
        variant: "secondary",
        id: "kc-certificate"
      }, t4("realm-settings:certificate"))));
    }
  };
  const options = [
    /* @__PURE__ */ react.createElement(SelectOption, {
      key: 1,
      "data-testid": "active-keys-option",
      value: t4("realm-settings:activeKeys"),
      isPlaceholder: true
    }),
    /* @__PURE__ */ react.createElement(SelectOption, {
      "data-testid": "passive-keys-option",
      key: 2,
      value: t4("realm-settings:passiveKeys")
    }),
    /* @__PURE__ */ react.createElement(SelectOption, {
      "data-testid": "disabled-keys-option",
      key: 3,
      value: t4("realm-settings:disabledKeys")
    })
  ];
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    padding: {default: "noPadding"}
  }, /* @__PURE__ */ react.createElement(PublicKeyDialog, null), /* @__PURE__ */ react.createElement(CertificateDialog, null), /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    isNotCompact: true,
    key,
    loader: filterType === "Active keys" ? activeKeysLoader : filterType === "Passive keys" ? passiveKeysLoader : filterType === "Disabled keys" ? disabledKeysLoader : loader,
    ariaLabelKey: "realm-settings:keysList",
    searchPlaceholderKey: "realm-settings:searchKey",
    searchTypeComponent: /* @__PURE__ */ react.createElement(Select, {
      width: 300,
      "data-testid": "filter-type-select",
      isOpen: filterDropdownOpen,
      className: "kc-filter-type-select",
      variant: SelectVariant.single,
      onToggle: () => setFilterDropdownOpen(!filterDropdownOpen),
      toggleIcon: /* @__PURE__ */ react.createElement(FilterIcon, null),
      onSelect: (_23, value) => {
        setFilterType(value);
        refresh();
        setFilterDropdownOpen(false);
      },
      selections: filterType
    }, options),
    canSelectAll: true,
    columns: [
      {
        name: "algorithm",
        displayKey: "realm-settings:algorithm",
        cellFormatters: [emptyFormatter()],
        transforms: [cellWidth(15)]
      },
      {
        name: "type",
        displayKey: "realm-settings:type",
        cellFormatters: [emptyFormatter()],
        transforms: [cellWidth(10)]
      },
      {
        name: "kid",
        displayKey: "realm-settings:kid",
        cellFormatters: [emptyFormatter()],
        transforms: [cellWidth(10)]
      },
      {
        name: "provider",
        displayKey: "realm-settings:provider",
        cellRenderer: ProviderRenderer,
        cellFormatters: [emptyFormatter()],
        transforms: [cellWidth(10)]
      },
      {
        name: "publicKeys",
        displayKey: "realm-settings:publicKeys",
        cellRenderer: ButtonRenderer,
        cellFormatters: [],
        transforms: [cellWidth(20)]
      }
    ],
    isSearching: !!filterType,
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      hasIcon: true,
      message: t4("realm-settings:noKeys"),
      instructions: t4(`realm-settings:noKeysDescription`) + `${filterType.toLocaleLowerCase()}.`,
      primaryActionText: t4("createRole"),
      onPrimaryAction: goToCreate
    })
  })));
};

// build/realm-settings/key-providers/aes-generated/AESGeneratedForm.js
var AESGeneratedForm = ({
  editMode,
  providerType,
  handleModalToggle,
  refresh
}) => {
  const {t: t4} = useTranslation("realm-settings");
  const serverInfo2 = useServerInfo();
  const [isKeySizeDropdownOpen, setIsKeySizeDropdownOpen] = useState(false);
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const {id: id3} = useParams();
  const providerId = useRouteMatch("/:providerType?")?.params.providerType;
  const save = async (component) => {
    try {
      if (id3) {
        await adminClient.components.update({id: id3}, {
          ...component,
          parentId: component.parentId,
          providerId: providerType,
          providerType: "org.keycloak.keys.KeyProvider"
        });
        addAlert(t4("saveProviderSuccess"), AlertVariant.success);
      } else {
        await adminClient.components.create({
          ...component,
          parentId: component.parentId,
          providerId: providerType,
          providerType: "org.keycloak.keys.KeyProvider"
        });
        handleModalToggle?.();
        addAlert(t4("saveProviderSuccess"), AlertVariant.success);
        refresh?.();
      }
    } catch (error2) {
      addError("realm-settings:saveProviderError", error2);
    }
  };
  const form2 = useForm({mode: "onChange"});
  const setupForm = (component) => {
    form2.reset();
    Object.entries(component).map(([key, value]) => {
      if (key === "config" && component.config?.secretSize && component.config?.active) {
        form2.setValue("config.secretSize", value.secretSize[0]);
        form2.setValue("config.active", value.active[0]);
        convertToFormValues(value, "config", form2.setValue);
      }
      form2.setValue(key, value);
    });
  };
  useFetch(async () => {
    if (editMode)
      return await adminClient.components.findOne({id: id3});
  }, (result) => {
    if (result) {
      setupForm(result);
    }
  }, []);
  const allComponentTypes = serverInfo2.componentTypes?.["org.keycloak.keys.KeyProvider"] ?? [];
  const aesSecretSizeOptions = allComponentTypes[0].properties[3].options;
  return /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    id: "add-provider",
    className: "pf-u-mt-lg",
    role: "manage-realm",
    onSubmit: form2.handleSubmit(save)
  }, editMode && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("providerId"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:mapperName",
      forLabel: t4("common:name"),
      forID: "name"
    }),
    fieldId: "id",
    isRequired: true,
    validated: form2.errors.name ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: form2.register(),
    id: "id",
    type: "text",
    name: "id",
    isReadOnly: editMode,
    "aria-label": t4("consoleDisplayName"),
    defaultValue: id3,
    "data-testid": "display-name-input"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:name"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:mapperName",
      forLabel: t4("common:name"),
      forID: "name"
    }),
    fieldId: "name",
    isRequired: true,
    validated: form2.errors.name ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, !editMode && /* @__PURE__ */ react.createElement(Controller, {
    name: "name",
    control: form2.control,
    defaultValue: providerType,
    render: ({onChange, value}) => {
      return /* @__PURE__ */ react.createElement(TextInput, {
        id: "name",
        type: "text",
        "aria-label": t4("consoleDisplayName"),
        defaultValue: providerType,
        value,
        onChange: (value2) => onChange(value2),
        "data-testid": "display-name-input"
      });
    }
  }), editMode && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(TextInput, {
    ref: form2.register(),
    type: "text",
    id: "name",
    name: "name",
    defaultValue: providerId,
    validated: form2.errors.name ? ValidatedOptions.error : ValidatedOptions.default
  }))), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:enabled"),
    fieldId: "kc-enabled",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: t4("realm-settings-help:enabled"),
      forLabel: t4("enabled"),
      forID: "kc-enabled"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.enabled",
    control: form2.control,
    defaultValue: ["true"],
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-enabled",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value[0] === "true",
      "data-testid": value[0] === "true" ? "internationalization-enabled" : "internationalization-disabled",
      onChange: (value2) => {
        onChange([value2.toString()]);
      }
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("active"),
    fieldId: "kc-active",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:active",
      forLabel: t4("active"),
      forID: "kc-active"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.active",
    control: form2.control,
    defaultValue: ["true"],
    render: ({onChange, value}) => {
      return /* @__PURE__ */ react.createElement(Switch, {
        id: "kc-active",
        label: t4("common:on"),
        labelOff: t4("common:off"),
        isChecked: value[0] === "true",
        "data-testid": value[0] === "true" ? "internationalization-enabled" : "internationalization-disabled",
        onChange: (value2) => {
          onChange([value2.toString()]);
        }
      });
    }
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("AESKeySize"),
    fieldId: "kc-aes-keysize",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:AESKeySize",
      forLabel: t4("AESKeySize"),
      forID: "kc-aes-key-size"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.secretSize",
    control: form2.control,
    defaultValue: ["16"],
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-aes-keysize",
      onToggle: () => setIsKeySizeDropdownOpen(!isKeySizeDropdownOpen),
      onSelect: (_23, value2) => {
        onChange([value2.toString()]);
        setIsKeySizeDropdownOpen(false);
      },
      selections: [value.toString()],
      isOpen: isKeySizeDropdownOpen,
      variant: SelectVariant.single,
      "aria-label": t4("aesKeySize"),
      "data-testid": "select-secret-size"
    }, aesSecretSizeOptions?.map((item) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: item === value,
      key: item,
      value: item
    })))
  })), /* @__PURE__ */ react.createElement(ActionGroup, {
    className: "kc-AESform-buttons"
  }, /* @__PURE__ */ react.createElement(Button, {
    className: "kc-AESform-save-button",
    "data-testid": "add-provider-button",
    variant: "primary",
    type: "submit"
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    className: "kc-AESform-cancel-button",
    onClick: !editMode && handleModalToggle || void 0,
    variant: "link"
  }, t4("common:cancel"))));
};
var AESGeneratedSettings = () => {
  const {t: t4} = useTranslation("realm-settings");
  const providerId = useRouteMatch("/:realm/realm-settings/keys/:id?/:providerType?/settings")?.params.providerType;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: t4("editProvider"),
    subKey: providerId
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(AESGeneratedForm, {
    providerType: providerId,
    editMode: true
  })));
};

// build/realm-settings/key-providers/aes-generated/AESGeneratedModal.js
var AESGeneratedModal = ({
  providerType,
  handleModalToggle,
  open: open2,
  refresh
}) => {
  const {t: t4} = useTranslation("realm-settings");
  return /* @__PURE__ */ react.createElement(Modal, {
    className: "add-provider-modal",
    variant: ModalVariant.medium,
    title: t4("addProvider"),
    isOpen: open2,
    onClose: handleModalToggle
  }, /* @__PURE__ */ react.createElement(AESGeneratedForm, {
    providerType,
    handleModalToggle,
    refresh
  }));
};

// build/realm-settings/key-providers/java-keystore/JavaKeystoreForm.js
var JavaKeystoreForm = ({
  editMode,
  providerType,
  handleModalToggle,
  refresh
}) => {
  const {t: t4} = useTranslation("realm-settings");
  const serverInfo2 = useServerInfo();
  const [isAlgorithmDropdownOpen, setIsAlgorithmDropdownOpen] = useState(false);
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const {id: id3} = useParams();
  const providerId = useRouteMatch("/:providerType?")?.params.providerType;
  const save = async (component) => {
    try {
      if (id3) {
        await adminClient.components.update({id: id3}, {
          ...component,
          parentId: component.parentId,
          providerId: providerType,
          providerType: "org.keycloak.keys.KeyProvider"
        });
        addAlert(t4("saveProviderSuccess"), AlertVariant.success);
      } else {
        await adminClient.components.create({
          ...component,
          parentId: component.parentId,
          providerId: providerType,
          providerType: "org.keycloak.keys.KeyProvider"
        });
        handleModalToggle?.();
        addAlert(t4("saveProviderSuccess"), AlertVariant.success);
        refresh?.();
      }
    } catch (error2) {
      addError("realm-settings:saveProviderError", error2);
    }
  };
  const form2 = useForm({mode: "onChange"});
  const setupForm = (component) => {
    form2.reset();
    Object.entries(component).map(([key, value]) => {
      if (key === "config" && component.config?.secretSize && component.config?.active && component.config?.algorithm && component.config?.keystore && component.config?.keystorePassword && component.config?.keyAlias && component.config?.keyPassword) {
        form2.setValue("config.secretSize", value.secretSize[0]);
        form2.setValue("config.active", value.active[0]);
        form2.setValue("config.algorithm", value.algorithm[0]);
        form2.setValue("config.keystore", value.keystore[0]);
        form2.setValue("config.keyAlias", value.keyAlias[0]);
        form2.setValue("config.keyPassword", value.keyPassword[0]);
        convertToFormValues(value, "config", form2.setValue);
      }
      form2.setValue(key, value);
    });
  };
  useFetch(async () => {
    if (editMode)
      return await adminClient.components.findOne({id: id3});
  }, (result) => {
    if (result) {
      setupForm(result);
    }
  }, []);
  const allComponentTypes = serverInfo2.componentTypes?.["org.keycloak.keys.KeyProvider"] ?? [];
  const javaKeystoreAlgorithmOptions = allComponentTypes[3].properties[3].options;
  return /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    id: "add-provider",
    className: "pf-u-mt-lg",
    role: "manage-realm",
    onSubmit: form2.handleSubmit(save)
  }, editMode && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("providerId"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:mapperName",
      forLabel: t4("common:name"),
      forID: t4("common:helpLabel", {label: t4("common:name")})
    }),
    fieldId: "id",
    isRequired: true,
    validated: form2.errors.name ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: form2.register(),
    id: "id",
    type: "text",
    name: "id",
    isReadOnly: editMode,
    "aria-label": t4("consoleDisplayName"),
    defaultValue: id3,
    "data-testid": "display-name-input"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:name"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:mapperName",
      forLabel: t4("common:name"),
      forID: t4("common:helpLabel", {label: t4("common:name")})
    }),
    fieldId: "name",
    isRequired: true,
    validated: form2.errors.name ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, !editMode && /* @__PURE__ */ react.createElement(Controller, {
    name: "name",
    control: form2.control,
    defaultValue: providerType,
    render: ({onChange, value}) => {
      return /* @__PURE__ */ react.createElement(TextInput, {
        id: "name",
        type: "text",
        "aria-label": t4("consoleDisplayName"),
        defaultValue: providerType,
        value,
        onChange: (value2) => onChange(value2),
        "data-testid": "display-name-input"
      });
    }
  }), editMode && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(TextInput, {
    ref: form2.register(),
    type: "text",
    id: "name",
    name: "name",
    defaultValue: providerId,
    validated: form2.errors.name ? ValidatedOptions.error : ValidatedOptions.default
  }))), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:enabled"),
    fieldId: "kc-enabled",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: t4("realm-settings-help:enabled"),
      forLabel: t4("enabled"),
      forID: t4("common:helpLabel", {label: t4("enabled")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.enabled",
    control: form2.control,
    defaultValue: ["true"],
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-enabled-switch",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value[0] === "true",
      "data-testid": value[0] === "true" ? "enabled" : "disabled",
      onChange: (value2) => {
        onChange([value2.toString()]);
      }
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("active"),
    fieldId: "kc-active",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:active",
      forLabel: t4("active"),
      forID: t4("common:helpLabel", {label: t4("active")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.active",
    control: form2.control,
    defaultValue: ["true"],
    render: ({onChange, value}) => {
      return /* @__PURE__ */ react.createElement(Switch, {
        id: "kc-active-switch",
        label: t4("common:on"),
        labelOff: t4("common:off"),
        isChecked: value[0] === "true",
        "data-testid": value[0] === "true" ? "active" : "passive",
        onChange: (value2) => {
          onChange([value2.toString()]);
        }
      });
    }
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("algorithm"),
    fieldId: "kc-algorithm",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:algorithm",
      forLabel: t4("algorithm"),
      forID: t4("common:helpLabel", {label: t4("algorithm")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.algorithm",
    control: form2.control,
    defaultValue: ["RS256"],
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-elliptic",
      onToggle: (isExpanded) => setIsAlgorithmDropdownOpen(isExpanded),
      onSelect: (_23, value2) => {
        onChange([value2.toString()]);
        setIsAlgorithmDropdownOpen(false);
      },
      selections: [value.toString()],
      variant: SelectVariant.single,
      "aria-label": t4("algorithm"),
      isOpen: isAlgorithmDropdownOpen,
      placeholderText: "Select one...",
      "data-testid": "select-algorithm"
    }, javaKeystoreAlgorithmOptions.map((p3, idx) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: p3 === value,
      key: `algorithm-${idx}`,
      value: p3
    })))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("keystore"),
    fieldId: "kc-keystore",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:keystore",
      forLabel: t4("keystore"),
      forID: "kc-keystore"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.keystore",
    control: form2.control,
    defaultValue: [],
    render: ({onChange}) => /* @__PURE__ */ react.createElement(TextInput, {
      "aria-label": t4("keystore"),
      onChange: (value) => {
        onChange([value.toString()]);
      },
      "data-testid": "select-display-name"
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("keystorePassword"),
    fieldId: "kc-keystore-password",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:keystorePassword",
      forLabel: t4("keystorePassword"),
      forID: t4("common:helpLabel", {label: t4("keystorePassword")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.keystorePassword",
    control: form2.control,
    defaultValue: [],
    render: ({onChange}) => /* @__PURE__ */ react.createElement(TextInput, {
      "aria-label": t4("consoleDisplayName"),
      onChange: (value) => {
        onChange([value.toString()]);
      },
      "data-testid": "select-display-name"
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("keyAlias"),
    fieldId: "kc-key-alias",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:keyAlias",
      forLabel: t4("keyAlias"),
      forID: t4("common:helpLabel", {label: t4("keyAlias")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.keyAlias",
    control: form2.control,
    defaultValue: [],
    render: ({onChange}) => /* @__PURE__ */ react.createElement(TextInput, {
      "aria-label": t4("keyAlias"),
      onChange: (value) => {
        onChange([value.toString()]);
      },
      "data-testid": "key-alias"
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("keyPassword"),
    fieldId: "kc-key-password",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:keyPassword",
      forLabel: t4("keyPassword"),
      forID: t4("common:helpLabel", {label: t4("keyPassword")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.keyPassword",
    control: form2.control,
    defaultValue: [],
    render: ({onChange}) => /* @__PURE__ */ react.createElement(TextInput, {
      "aria-label": t4("keyPassword"),
      onChange: (value) => {
        onChange([value.toString()]);
      },
      "data-testid": "key-password"
    })
  })), /* @__PURE__ */ react.createElement(ActionGroup, {
    className: "kc-java-keystore-form-buttons"
  }, /* @__PURE__ */ react.createElement(Button, {
    className: "kc-java-keystore-form-save-button",
    "data-testid": "add-provider-button",
    variant: "primary",
    type: "submit"
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    className: "kc-java-keystore-form-cancel-button",
    onClick: !editMode && handleModalToggle || void 0,
    variant: "link"
  }, t4("common:cancel"))));
};
var JavaKeystoreSettings = () => {
  const {t: t4} = useTranslation("realm-settings");
  const providerId = useRouteMatch("/:realm/realm-settings/keys/:id?/:providerType?/settings")?.params.providerType;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: t4("editProvider"),
    subKey: providerId
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(JavaKeystoreForm, {
    providerType: providerId,
    editMode: true
  })));
};

// build/realm-settings/key-providers/java-keystore/JavaKeystoreModal.js
var JavaKeystoreModal = ({
  providerType,
  handleModalToggle,
  open: open2,
  refresh
}) => {
  const {t: t4} = useTranslation("realm-settings");
  return /* @__PURE__ */ react.createElement(Modal, {
    className: "add-provider-modal",
    variant: ModalVariant.medium,
    title: t4("addProvider"),
    isOpen: open2,
    onClose: handleModalToggle
  }, /* @__PURE__ */ react.createElement(JavaKeystoreForm, {
    providerType,
    handleModalToggle,
    refresh
  }));
};

// build/realm-settings/key-providers/hmac-generated/HMACGeneratedForm.js
var HMACGeneratedForm = ({
  editMode,
  providerType,
  handleModalToggle,
  refresh
}) => {
  const {t: t4} = useTranslation("realm-settings");
  const serverInfo2 = useServerInfo();
  const [isKeySizeDropdownOpen, setIsKeySizeDropdownOpen] = useState(false);
  const [isEllipticCurveDropdownOpen, setIsEllipticCurveDropdownOpen] = useState(false);
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const {id: id3} = useParams();
  const providerId = useRouteMatch("/:providerType?")?.params.providerType;
  const save = async (component) => {
    try {
      if (id3) {
        await adminClient.components.update({id: id3}, {
          ...component,
          parentId: component.parentId,
          providerId: providerType,
          providerType: "org.keycloak.keys.KeyProvider"
        });
        addAlert(t4("saveProviderSuccess"), AlertVariant.success);
      } else {
        await adminClient.components.create({
          ...component,
          parentId: component.parentId,
          providerId: providerType,
          providerType: "org.keycloak.keys.KeyProvider"
        });
        handleModalToggle?.();
        addAlert(t4("saveProviderSuccess"), AlertVariant.success);
        refresh?.();
      }
    } catch (error2) {
      addError("realm-settings:saveProviderError", error2);
    }
  };
  const form2 = useForm({mode: "onChange"});
  const setupForm = (component) => {
    form2.reset();
    Object.entries(component).map(([key, value]) => {
      if (key === "config" && component.config?.secretSize && component.config?.active && component.config?.algorithm) {
        form2.setValue("config.secretSize", value.secretSize[0]);
        form2.setValue("config.active", value.active[0]);
        form2.setValue("config.algorithm", value.active[0]);
        convertToFormValues(value, "config", form2.setValue);
      }
      form2.setValue(key, value);
    });
  };
  useFetch(async () => {
    if (editMode)
      return await adminClient.components.findOne({id: id3});
  }, (result) => {
    if (result) {
      setupForm(result);
    }
  }, []);
  const allComponentTypes = serverInfo2.componentTypes?.["org.keycloak.keys.KeyProvider"] ?? [];
  const hmacSecretSizeOptions = allComponentTypes[2].properties[3].options;
  const hmacAlgorithmOptions = allComponentTypes[2].properties[4].options;
  return /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    id: "add-provider",
    className: "pf-u-mt-lg",
    role: "manage-realm",
    onSubmit: form2.handleSubmit(save)
  }, editMode && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("providerId"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:mapperName",
      forLabel: t4("common:name"),
      forID: t4("common:helpLabel", {label: t4("common:name")})
    }),
    fieldId: "id",
    isRequired: true,
    validated: form2.errors.name ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: form2.register(),
    id: "id",
    type: "text",
    name: "id",
    isReadOnly: editMode,
    "aria-label": t4("consoleDisplayName"),
    defaultValue: id3,
    "data-testid": "display-name-input"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:name"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:mapperName",
      forLabel: t4("common:name"),
      forID: t4("common:helpLabel", {label: t4("common:name")})
    }),
    fieldId: "name",
    isRequired: true,
    validated: form2.errors.name ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, !editMode && /* @__PURE__ */ react.createElement(Controller, {
    name: "name",
    control: form2.control,
    defaultValue: providerType,
    render: ({onChange, value}) => {
      return /* @__PURE__ */ react.createElement(TextInput, {
        id: "name",
        type: "text",
        "aria-label": t4("consoleDisplayName"),
        defaultValue: providerType,
        value,
        onChange: (value2) => onChange(value2),
        "data-testid": "display-name-input"
      });
    }
  }), editMode && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(TextInput, {
    ref: form2.register(),
    type: "text",
    id: "name",
    name: "name",
    defaultValue: providerId,
    validated: form2.errors.name ? ValidatedOptions.error : ValidatedOptions.default
  }))), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:enabled"),
    fieldId: "kc-enabled",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: t4("realm-settings-help:enabled"),
      forLabel: t4("enabled"),
      forID: t4("common:helpLabel", {label: t4("enabled")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.enabled",
    control: form2.control,
    defaultValue: ["true"],
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-enabled-switch",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value[0] === "true",
      "data-testid": value[0] === "true" ? "enabled" : "disabled",
      onChange: (value2) => {
        onChange([value2.toString()]);
      }
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("active"),
    fieldId: "kc-active",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:active",
      forLabel: t4("active"),
      forID: t4("common:helpLabel", {label: t4("active")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.active",
    control: form2.control,
    defaultValue: ["true"],
    render: ({onChange, value}) => {
      return /* @__PURE__ */ react.createElement(Switch, {
        id: "kc-active-switch",
        label: t4("common:on"),
        labelOff: t4("common:off"),
        isChecked: value[0] === "true",
        "data-testid": value[0] === "true" ? "active" : "passive",
        onChange: (value2) => {
          onChange([value2.toString()]);
        }
      });
    }
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("secretSize"),
    fieldId: "kc-hmac-keysize",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:secretSize",
      forLabel: t4("secretSize"),
      forID: t4("common:helpLabel", {label: t4("secretSize")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.secretSize",
    control: form2.control,
    defaultValue: ["64"],
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-hmac-keysize",
      onToggle: (isExpanded) => setIsKeySizeDropdownOpen(isExpanded),
      onSelect: (_23, value2) => {
        onChange([value2.toString()]);
        setIsKeySizeDropdownOpen(false);
      },
      selections: [value.toString()],
      isOpen: isKeySizeDropdownOpen,
      variant: SelectVariant.single,
      "aria-label": t4("hmacKeySize"),
      "data-testid": "select-secret-size"
    }, hmacSecretSizeOptions.map((item) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: item === value,
      key: item,
      value: item
    })))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("algorithm"),
    fieldId: "kc-algorithm",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:algorithm",
      forLabel: t4("algorithm"),
      forID: t4("common:helpLabel", {label: t4("algorithm")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.algorithm",
    control: form2.control,
    defaultValue: ["HS-256"],
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-elliptic",
      onToggle: (isExpanded) => setIsEllipticCurveDropdownOpen(isExpanded),
      onSelect: (_23, value2) => {
        onChange([value2.toString()]);
        setIsEllipticCurveDropdownOpen(false);
      },
      selections: [value.toString()],
      variant: SelectVariant.single,
      "aria-label": t4("emailTheme"),
      isOpen: isEllipticCurveDropdownOpen,
      placeholderText: "Select one...",
      "data-testid": "select-email-theme"
    }, hmacAlgorithmOptions.map((p3, idx) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: p3 === value,
      key: `email-theme-${idx}`,
      value: p3
    })))
  })), /* @__PURE__ */ react.createElement(ActionGroup, {
    className: "kc-hmac-form-buttons"
  }, /* @__PURE__ */ react.createElement(Button, {
    className: "kc-hmac-form-save-button",
    "data-testid": "add-provider-button",
    variant: "primary",
    type: "submit"
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    className: "kc-hmac-form-cancel-button",
    onClick: !editMode && handleModalToggle || void 0,
    variant: "link"
  }, t4("common:cancel"))));
};
var HMACGeneratedSettings = () => {
  const {t: t4} = useTranslation("realm-settings");
  const providerId = useRouteMatch("/:realm/realm-settings/keys/:id?/:providerType?/settings")?.params.providerType;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: t4("editProvider"),
    subKey: providerId
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(HMACGeneratedForm, {
    providerType: providerId,
    editMode: true
  })));
};

// build/realm-settings/key-providers/hmac-generated/HMACGeneratedModal.js
var HMACGeneratedModal = ({
  providerType,
  handleModalToggle,
  open: open2,
  refresh
}) => {
  const {t: t4} = useTranslation("realm-settings");
  return /* @__PURE__ */ react.createElement(Modal, {
    className: "add-provider-modal",
    variant: ModalVariant.medium,
    title: t4("addProvider"),
    isOpen: open2,
    onClose: handleModalToggle
  }, /* @__PURE__ */ react.createElement(HMACGeneratedForm, {
    providerType,
    handleModalToggle,
    refresh
  }));
};

// build/realm-settings/key-providers/ecdsa-generated/ECDSAGeneratedForm.js
var ECDSAGeneratedForm = ({
  editMode,
  providerType,
  handleModalToggle,
  refresh
}) => {
  const {t: t4} = useTranslation("realm-settings");
  const serverInfo2 = useServerInfo();
  const [isKeySizeDropdownOpen, setIsKeySizeDropdownOpen] = useState(false);
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const {id: id3} = useParams();
  const providerId = useRouteMatch("/:providerType?")?.params.providerType;
  const save = async (component) => {
    try {
      if (id3) {
        await adminClient.components.update({id: id3}, {
          ...component,
          parentId: component.parentId,
          providerId: providerType,
          providerType: "org.keycloak.keys.KeyProvider"
        });
        addAlert(t4("saveProviderSuccess"), AlertVariant.success);
      } else {
        await adminClient.components.create({
          ...component,
          parentId: component.parentId,
          providerId: providerType,
          providerType: "org.keycloak.keys.KeyProvider"
        });
        handleModalToggle?.();
        addAlert(t4("saveProviderSuccess"), AlertVariant.success);
        refresh?.();
      }
    } catch (error2) {
      addError("realm-settings:saveProviderError", error2);
    }
  };
  const form2 = useForm({mode: "onChange"});
  const setupForm = (component) => {
    form2.reset();
    Object.entries(component).map(([key, value]) => {
      if (key === "config" && component.config?.ecdsaEllipticCurveKey && component.config?.active) {
        form2.setValue("config.secretSize", value.ecdsaEllipticCurveKey[0]);
        form2.setValue("config.active", value.active[0]);
        convertToFormValues(value, "config", form2.setValue);
      }
      form2.setValue(key, value);
    });
  };
  useFetch(async () => {
    if (editMode)
      return await adminClient.components.findOne({id: id3});
  }, (result) => {
    if (result) {
      setupForm(result);
    }
  }, []);
  const allComponentTypes = serverInfo2.componentTypes?.["org.keycloak.keys.KeyProvider"] ?? [];
  const ecdsaEllipticCurveOptions = allComponentTypes[1].properties[3].options;
  return /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    id: "add-provider",
    className: "pf-u-mt-lg",
    role: "manage-realm",
    onSubmit: form2.handleSubmit(save)
  }, editMode && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("providerId"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:mapperName",
      forLabel: t4("common:name"),
      forID: t4("common:helpLabel", {label: t4("common:name")})
    }),
    fieldId: "id",
    isRequired: true,
    validated: form2.errors.name ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: form2.register(),
    id: "id",
    type: "text",
    name: "id",
    isReadOnly: editMode,
    "aria-label": t4("consoleDisplayName"),
    defaultValue: id3,
    "data-testid": "display-name-input"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:name"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:mapperName",
      forLabel: t4("common:name"),
      forID: t4("common:helpLabel", {label: t4("common:name")})
    }),
    fieldId: "name",
    isRequired: true,
    validated: form2.errors.name ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, !editMode && /* @__PURE__ */ react.createElement(Controller, {
    name: "name",
    control: form2.control,
    defaultValue: providerType,
    render: ({onChange, value}) => {
      return /* @__PURE__ */ react.createElement(TextInput, {
        id: "name",
        type: "text",
        "aria-label": t4("consoleDisplayName"),
        value,
        onChange: (value2) => onChange(value2),
        "data-testid": "display-name-input"
      });
    }
  }), editMode && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(TextInput, {
    ref: form2.register(),
    type: "text",
    id: "name",
    name: "name",
    defaultValue: providerId,
    validated: form2.errors.name ? ValidatedOptions.error : ValidatedOptions.default
  }))), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:enabled"),
    fieldId: "kc-enabled",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: t4("realm-settings-help:enabled"),
      forLabel: t4("enabled"),
      forID: t4("common:helpLabel", {label: t4("enabled")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.enabled",
    control: form2.control,
    defaultValue: ["true"],
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-enabled-switch",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value[0] === "true",
      "data-testid": value[0] === "true" ? "enabled" : "disabled",
      onChange: (value2) => {
        onChange([value2.toString()]);
      }
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("active"),
    fieldId: "kc-active",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:active",
      forLabel: t4("active"),
      forID: t4("common:helpLabel", {label: t4("active")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.active",
    control: form2.control,
    defaultValue: ["true"],
    render: ({onChange, value}) => {
      return /* @__PURE__ */ react.createElement(Switch, {
        id: "kc-active-switch",
        label: t4("common:on"),
        labelOff: t4("common:off"),
        isChecked: value[0] === "true",
        "data-testid": value[0] === "true" ? "active" : "passive",
        onChange: (value2) => {
          onChange([value2.toString()]);
        }
      });
    }
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("ellipticCurve"),
    fieldId: "kc-elliptic-curve",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:ellipticCurve",
      forLabel: t4("ellipticCurve"),
      forID: t4("common:helpLabel", {label: t4("ellipticCurve")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.ecdsaEllipticCurveKey",
    control: form2.control,
    defaultValue: ["P-256"],
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-ecdsa-elliptic-curve",
      onToggle: (isExpanded) => setIsKeySizeDropdownOpen(isExpanded),
      onSelect: (_23, value2) => {
        onChange([value2.toString()]);
        setIsKeySizeDropdownOpen(false);
      },
      selections: [value.toString()],
      isOpen: isKeySizeDropdownOpen,
      variant: SelectVariant.single,
      "aria-label": t4("ellipticCurve"),
      "data-testid": "select-elliptic-curve-size"
    }, ecdsaEllipticCurveOptions?.map((item) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: item === value,
      key: item,
      value: item
    })))
  })), /* @__PURE__ */ react.createElement(ActionGroup, {
    className: "kc-ecdsa-form-buttons"
  }, /* @__PURE__ */ react.createElement(Button, {
    className: "kc-ecdsa-form-save-button",
    "data-testid": "add-provider-button",
    variant: "primary",
    type: "submit"
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    className: "kc-ecdsa-form-cancel-button",
    onClick: !editMode && handleModalToggle || void 0,
    variant: "link"
  }, t4("common:cancel"))));
};
var ECDSAGeneratedSettings = () => {
  const {t: t4} = useTranslation("realm-settings");
  const providerId = useRouteMatch("/:realm/realm-settings/keys/:id?/:providerType?/settings")?.params.providerType;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: t4("editProvider"),
    subKey: providerId
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(ECDSAGeneratedForm, {
    providerType: providerId,
    editMode: true
  })));
};

// build/realm-settings/key-providers/ecdsa-generated/ECDSAGeneratedModal.js
var ECDSAGeneratedModal = ({
  providerType,
  handleModalToggle,
  open: open2,
  refresh
}) => {
  const {t: t4} = useTranslation("realm-settings");
  return /* @__PURE__ */ react.createElement(Modal, {
    className: "add-provider-modal",
    variant: ModalVariant.medium,
    title: t4("addProvider"),
    isOpen: open2,
    onClose: handleModalToggle
  }, /* @__PURE__ */ react.createElement(ECDSAGeneratedForm, {
    providerType,
    handleModalToggle,
    refresh
  }));
};

// build/realm-settings/RSAModal.js
var RSAModal = ({
  providerType,
  handleModalToggle,
  open: open2,
  refresh
}) => {
  const {t: t4} = useTranslation("realm-settings");
  const serverInfo2 = useServerInfo();
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const {handleSubmit, control} = useForm({});
  const [isRSAalgDropdownOpen, setIsRSAalgDropdownOpen] = useState(false);
  const {id: id3} = useParams();
  const [keyFileName, setKeyFileName] = useState("");
  const [certificateFileName, setCertificateFileName] = useState("");
  const allComponentTypes = serverInfo2.componentTypes?.["org.keycloak.keys.KeyProvider"] ?? [];
  const save = async (component) => {
    try {
      if (id3) {
        await adminClient.components.update({id: id3}, {
          ...component,
          parentId: component.parentId,
          providerId: providerType,
          providerType: "org.keycloak.keys.KeyProvider"
        });
        addAlert(t4("saveProviderSuccess"), AlertVariant.success);
      } else {
        await adminClient.components.create({
          ...component,
          parentId: component.parentId,
          providerId: providerType,
          providerType: "org.keycloak.keys.KeyProvider"
        });
        handleModalToggle();
        addAlert(t4("saveProviderSuccess"), AlertVariant.success);
        refresh();
      }
    } catch (error2) {
      addError("realm-settings:saveProviderError", error2);
    }
  };
  return /* @__PURE__ */ react.createElement(Modal, {
    className: "add-provider-modal",
    variant: ModalVariant.medium,
    title: t4("addProvider"),
    isOpen: open2,
    onClose: handleModalToggle,
    actions: [
      /* @__PURE__ */ react.createElement(Button, {
        "data-testid": "add-provider-button",
        key: "confirm",
        variant: "primary",
        type: "submit",
        form: "add-provider"
      }, t4("common:Add")),
      /* @__PURE__ */ react.createElement(Button, {
        id: "modal-cancel",
        key: "cancel",
        variant: ButtonVariant.link,
        onClick: () => {
          handleModalToggle();
        }
      }, t4("common:cancel"))
    ]
  }, /* @__PURE__ */ react.createElement(Form, {
    isHorizontal: true,
    id: "add-provider",
    className: "pf-u-mt-lg",
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("consoleDisplayName"),
    fieldId: "kc-console-display-name",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:displayName",
      forLabel: t4("loginTheme"),
      forID: "kc-console-display-name"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "name",
    control,
    defaultValue: providerType,
    render: ({onChange}) => /* @__PURE__ */ react.createElement(TextInput, {
      "aria-label": t4("consoleDisplayName"),
      defaultValue: providerType,
      onChange: (value) => {
        onChange(value);
      },
      "data-testid": "display-name-input"
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:enabled"),
    fieldId: "kc-enabled",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: t4("realm-settings-help:enabled"),
      forLabel: t4("enabled"),
      forID: "kc-enabled"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.enabled",
    control,
    defaultValue: ["true"],
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-enabled",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value[0] === "true",
      "data-testid": value[0] === "true" ? "internationalization-enabled" : "internationalization-disabled",
      onChange: (value2) => {
        onChange([value2 + ""]);
      }
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("active"),
    fieldId: "kc-active",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:active",
      forLabel: t4("active"),
      forID: "kc-active"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.active",
    control,
    defaultValue: ["true"],
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-active",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value[0] === "true",
      "data-testid": value[0] === "true" ? "internationalization-enabled" : "internationalization-disabled",
      onChange: (value2) => {
        onChange([value2 + ""]);
      }
    })
  })), providerType === "rsa" && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("algorithm"),
    fieldId: "kc-algorithm",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:algorithm",
      forLabel: t4("algorithm"),
      forID: "kc-algorithm"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "algorithm",
    defaultValue: "",
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-rsa-algorithm",
      onToggle: () => setIsRSAalgDropdownOpen(!isRSAalgDropdownOpen),
      onSelect: (_23, value2) => {
        onChange(value2);
        setIsRSAalgDropdownOpen(false);
      },
      selections: [value + ""],
      variant: SelectVariant.single,
      "aria-label": t4("algorithm"),
      isOpen: isRSAalgDropdownOpen,
      "data-testid": "select-rsa-algorithm"
    }, allComponentTypes[4].properties[3].options.map((p3, idx) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: p3 === value,
      key: `rsa-algorithm-${idx}`,
      value: p3
    })))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("privateRSAKey"),
    fieldId: "kc-private-rsa-key",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:privateRSAKey",
      forLabel: t4("privateRSAKey"),
      forID: "kc-rsa-key"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.privateKey",
    control,
    defaultValue: [],
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(FileUpload, {
      id: "importPrivateKey",
      type: "text",
      value: value[0],
      filenamePlaceholder: "Upload a PEM file or paste key below",
      filename: keyFileName,
      onChange: (value2, fileName) => {
        setKeyFileName(fileName);
        onChange([value2]);
      }
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("x509Certificate"),
    fieldId: "kc-aes-keysize",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:x509Certificate",
      forLabel: t4("x509Certificate"),
      forID: "kc-x509-certificatw"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.certificate",
    control,
    defaultValue: [],
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(FileUpload, {
      id: "importCertificate",
      type: "text",
      value: value[0],
      filenamePlaceholder: "Upload a PEM file or paste key below",
      filename: certificateFileName,
      onChange: (value2, fileName) => {
        setCertificateFileName(fileName);
        onChange([value2]);
      }
    })
  })))));
};

// build/realm-settings/key-providers/rsa-generated/RSAGeneratedForm.js
var RSAGeneratedForm = ({
  editMode,
  providerType,
  handleModalToggle,
  refresh
}) => {
  const {t: t4} = useTranslation("realm-settings");
  const serverInfo2 = useServerInfo();
  const [isKeySizeDropdownOpen, setIsKeySizeDropdownOpen] = useState(false);
  const [isEllipticCurveDropdownOpen, setIsEllipticCurveDropdownOpen] = useState(false);
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const {id: id3} = useParams();
  const providerId = useRouteMatch("/:providerType?")?.params.providerType;
  const save = async (component) => {
    try {
      if (id3) {
        await adminClient.components.update({id: id3}, {
          ...component,
          parentId: component.parentId,
          providerId: providerType,
          providerType: "org.keycloak.keys.KeyProvider"
        });
        addAlert(t4("saveProviderSuccess"), AlertVariant.success);
      } else {
        await adminClient.components.create({
          ...component,
          parentId: component.parentId,
          providerId: providerType,
          providerType: "org.keycloak.keys.KeyProvider"
        });
        handleModalToggle?.();
        addAlert(t4("saveProviderSuccess"), AlertVariant.success);
        refresh?.();
      }
    } catch (error2) {
      addError("realm-settings:saveProviderError", error2);
    }
  };
  const form2 = useForm({mode: "onChange"});
  const setupForm = (component) => {
    form2.reset();
    Object.entries(component).map(([key, value]) => {
      if (key === "config" && component.config?.secretSize && component.config?.active && component.config?.algorithm) {
        form2.setValue("config.secretSize", value.secretSize[0]);
        form2.setValue("config.active", value.active[0]);
        form2.setValue("config.algorithm", value.active[0]);
        convertToFormValues(value, "config", form2.setValue);
      }
      form2.setValue(key, value);
    });
  };
  useFetch(async () => {
    if (editMode)
      return await adminClient.components.findOne({id: id3});
  }, (result) => {
    if (result) {
      setupForm(result);
    }
  }, []);
  const allComponentTypes = serverInfo2.componentTypes?.["org.keycloak.keys.KeyProvider"] ?? [];
  const rsaGeneratedKeySizeOptions = allComponentTypes[5].properties[4].options;
  const rsaGeneratedAlgorithmOptions = allComponentTypes[5].properties[3].options;
  return /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    id: "add-provider",
    className: "pf-u-mt-lg",
    role: "manage-realm",
    onSubmit: form2.handleSubmit(save)
  }, editMode && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("providerId"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:mapperName",
      forLabel: t4("common:name"),
      forID: t4("common:helpLabel", {label: t4("common:name")})
    }),
    fieldId: "id",
    isRequired: true,
    validated: form2.errors.name ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: form2.register(),
    id: "id",
    type: "text",
    name: "id",
    isReadOnly: editMode,
    "aria-label": t4("consoleDisplayName"),
    defaultValue: id3,
    "data-testid": "display-name-input"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:name"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:mapperName",
      forLabel: t4("common:name"),
      forID: t4("common:helpLabel", {label: t4("common:name")})
    }),
    fieldId: "name",
    isRequired: true,
    validated: form2.errors.name ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, !editMode && /* @__PURE__ */ react.createElement(Controller, {
    name: "name",
    control: form2.control,
    defaultValue: providerType,
    render: ({onChange, value}) => {
      return /* @__PURE__ */ react.createElement(TextInput, {
        id: "name",
        type: "text",
        "aria-label": t4("consoleDisplayName"),
        value,
        onChange: (value2) => onChange(value2),
        "data-testid": "display-name-input"
      });
    }
  }), editMode && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(TextInput, {
    ref: form2.register(),
    type: "text",
    id: "name",
    name: "name",
    defaultValue: providerId,
    validated: form2.errors.name ? ValidatedOptions.error : ValidatedOptions.default
  }))), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:enabled"),
    fieldId: "kc-enabled",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: t4("realm-settings-help:enabled"),
      forLabel: t4("enabled"),
      forID: t4("common:helpLabel", {label: t4("enabled")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.enabled",
    control: form2.control,
    defaultValue: ["true"],
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-enabled-switch",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value[0] === "true",
      "data-testid": value[0] === "true" ? "enabled" : "disabled",
      onChange: (value2) => {
        onChange([value2.toString()]);
      }
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("active"),
    fieldId: "kc-active",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:active",
      forLabel: t4("active"),
      forID: t4("common:helpLabel", {label: t4("active")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.active",
    control: form2.control,
    defaultValue: ["true"],
    render: ({onChange, value}) => {
      return /* @__PURE__ */ react.createElement(Switch, {
        id: "kc-active-switch",
        label: t4("common:on"),
        labelOff: t4("common:off"),
        isChecked: value[0] === "true",
        "data-testid": value[0] === "true" ? "active" : "passive",
        onChange: (value2) => {
          onChange([value2.toString()]);
        }
      });
    }
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("secretSize"),
    fieldId: "kc-rsa-generated-keysize",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:secretSize",
      forLabel: t4("secretSize"),
      forID: t4("common:helpLabel", {label: t4("secretSize")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.secretSize",
    control: form2.control,
    defaultValue: ["2048"],
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-rsa-generated-keysize",
      onToggle: (isExpanded) => setIsKeySizeDropdownOpen(isExpanded),
      onSelect: (_23, value2) => {
        onChange([value2.toString()]);
        setIsKeySizeDropdownOpen(false);
      },
      selections: [value.toString()],
      isOpen: isKeySizeDropdownOpen,
      variant: SelectVariant.single,
      "aria-label": t4("KeySize"),
      "data-testid": "select-secret-size"
    }, rsaGeneratedKeySizeOptions.map((item) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: item === value,
      key: item,
      value: item
    })))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("algorithm"),
    fieldId: "kc-algorithm",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:algorithm",
      forLabel: t4("algorithm"),
      forID: t4("common:helpLabel", {label: t4("algorithm")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.algorithm",
    control: form2.control,
    defaultValue: ["RS256"],
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-elliptic",
      onToggle: (isExpanded) => setIsEllipticCurveDropdownOpen(isExpanded),
      onSelect: (_23, value2) => {
        onChange([value2.toString()]);
        setIsEllipticCurveDropdownOpen(false);
      },
      selections: [value.toString()],
      variant: SelectVariant.single,
      "aria-label": t4("emailTheme"),
      isOpen: isEllipticCurveDropdownOpen,
      placeholderText: "Select one...",
      "data-testid": "select-email-theme"
    }, rsaGeneratedAlgorithmOptions.map((p3, idx) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: p3 === value,
      key: `email-theme-${idx}`,
      value: p3
    })))
  })), /* @__PURE__ */ react.createElement(ActionGroup, {
    className: "kc-rsa-generated-form-buttons"
  }, /* @__PURE__ */ react.createElement(Button, {
    className: "kc-rsa-generated-form-save-button",
    "data-testid": "add-provider-button",
    variant: "primary",
    type: "submit"
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    className: "kc-rsa-generated-form-cancel-button",
    onClick: !editMode && handleModalToggle || void 0,
    variant: "link"
  }, t4("common:cancel"))));
};
var RSAGeneratedSettings = () => {
  const {t: t4} = useTranslation("realm-settings");
  const providerId = useRouteMatch("/:realm/realm-settings/keys/:id?/:providerType?/settings")?.params.providerType;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: t4("editProvider"),
    subKey: providerId
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(RSAGeneratedForm, {
    providerType: providerId,
    editMode: true
  })));
};

// build/realm-settings/key-providers/rsa-generated/RSAGeneratedModal.js
var RSAGeneratedModal = ({
  providerType,
  handleModalToggle,
  open: open2,
  refresh
}) => {
  const {t: t4} = useTranslation("realm-settings");
  return /* @__PURE__ */ react.createElement(Modal, {
    className: "add-provider-modal",
    variant: ModalVariant.medium,
    title: t4("addProvider"),
    isOpen: open2,
    onClose: handleModalToggle
  }, /* @__PURE__ */ react.createElement(RSAGeneratedForm, {
    providerType,
    handleModalToggle,
    refresh
  }));
};

// build/realm-settings/KeysProvidersTab.js
var KeysTabInner = ({components: components3, refresh}) => {
  const {t: t4} = useTranslation("realm-settings");
  const {addAlert, addError} = useAlerts();
  const adminClient = useAdminClient();
  const {realm: realm2} = useRealm();
  const {url} = useRouteMatch();
  const [id3, setId] = useState("");
  const [searchVal, setSearchVal] = useState("");
  const [filteredComponents, setFilteredComponents] = useState([]);
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
  const serverInfo2 = useServerInfo();
  const providerTypes = serverInfo2.componentTypes["org.keycloak.keys.KeyProvider"].map((item) => item.id);
  const itemIds = components3.map((_23, idx) => "data" + idx);
  const [itemOrder, setItemOrder] = useState([]);
  const [providerDropdownOpen, setProviderDropdownOpen] = useState(false);
  const [defaultConsoleDisplayName, setDefaultConsoleDisplayName] = useState("");
  const [selectedComponent, setSelectedComponent] = useState();
  const [liveText, setLiveText] = useState("");
  useEffect(() => {
    setItemOrder(["data", ...itemIds]);
  }, [components3, searchVal]);
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: "realm-settings:deleteProviderTitle",
    messageKey: t4("deleteProviderConfirm") + selectedComponent?.name + "?",
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        await adminClient.components.del({
          id: selectedComponent.id,
          realm: realm2
        });
        refresh();
        addAlert(t4("deleteProviderSuccess"), AlertVariant.success);
      } catch (error2) {
        addError("realm-settings:deleteProviderError", error2);
      }
    }
  });
  const onDragStart = (id22) => {
    setLiveText(t4("common:onDragStart", {item: id22}));
    setId(id22);
  };
  const onDragMove = () => {
    setLiveText(t4("common:onDragMove", {item: id3}));
  };
  const onDragCancel = () => {
    setLiveText(t4("common:onDragCancel"));
  };
  const onDragFinish = (itemOrder2) => {
    setItemOrder(["data", ...itemOrder2.filter((i3) => i3 !== "data")]);
    setLiveText(t4("common:onDragFinish"));
  };
  const onSearch = () => {
    if (searchVal !== "") {
      setSearchVal(searchVal);
      const x3 = components3.filter((v3) => {
        return v3.name?.includes(searchVal) || v3.providerId?.includes(searchVal);
      });
      setFilteredComponents(x3);
    } else {
      setSearchVal("");
      setFilteredComponents(components3);
    }
  };
  const handleKeyDown = (e3) => {
    if (e3.key === "Enter") {
      onSearch();
    }
  };
  const handleInputChange = (value) => {
    setSearchVal(value);
  };
  const handleModalToggle = () => {
    setIsCreateModalOpen(!isCreateModalOpen);
  };
  const [actionListOpen, setActionListOpen] = useState(components3.map(() => false));
  const toggleActionList = (index3) => {
    actionListOpen[index3] = !actionListOpen[index3];
    setActionListOpen([...actionListOpen]);
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, defaultConsoleDisplayName === "aes-generated" && /* @__PURE__ */ react.createElement(AESGeneratedModal, {
    handleModalToggle,
    providerType: defaultConsoleDisplayName,
    refresh,
    open: isCreateModalOpen
  }), defaultConsoleDisplayName === "ecdsa-generated" && /* @__PURE__ */ react.createElement(ECDSAGeneratedModal, {
    handleModalToggle,
    providerType: defaultConsoleDisplayName,
    refresh,
    open: isCreateModalOpen
  }), defaultConsoleDisplayName === "hmac-generated" && /* @__PURE__ */ react.createElement(HMACGeneratedModal, {
    handleModalToggle,
    providerType: defaultConsoleDisplayName,
    refresh,
    open: isCreateModalOpen
  }), defaultConsoleDisplayName === "java-keystore" && /* @__PURE__ */ react.createElement(JavaKeystoreModal, {
    handleModalToggle,
    providerType: defaultConsoleDisplayName,
    refresh,
    open: isCreateModalOpen
  }), defaultConsoleDisplayName === "rsa" && /* @__PURE__ */ react.createElement(RSAModal, {
    handleModalToggle,
    providerType: defaultConsoleDisplayName,
    refresh,
    open: isCreateModalOpen
  }), defaultConsoleDisplayName === "rsa-generated" && /* @__PURE__ */ react.createElement(RSAGeneratedModal, {
    handleModalToggle,
    providerType: defaultConsoleDisplayName,
    refresh,
    open: isCreateModalOpen
  }), /* @__PURE__ */ react.createElement(DeleteConfirm, null), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    padding: {default: "noPadding"}
  }, /* @__PURE__ */ react.createElement(Toolbar, null, /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ToolbarGroup, {
    className: "providers-toolbar"
  }, /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(InputGroup, null, /* @__PURE__ */ react.createElement(TextInput, {
    name: "inputGroupName",
    id: "inputGroupName",
    type: "search",
    "aria-label": t4("common:search"),
    placeholder: t4("common:search"),
    onChange: handleInputChange,
    onKeyDown: handleKeyDown
  }), /* @__PURE__ */ react.createElement(Button, {
    variant: ButtonVariant.control,
    "aria-label": t4("common:search")
  }, /* @__PURE__ */ react.createElement(SearchIcon, null)))), /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Dropdown, {
    "data-testid": "addProviderDropdown",
    className: "add-provider-dropdown",
    isOpen: providerDropdownOpen,
    toggle: /* @__PURE__ */ react.createElement(DropdownToggle, {
      onToggle: (val) => setProviderDropdownOpen(val),
      isPrimary: true
    }, t4("realm-settings:addProvider")),
    dropdownItems: [
      providerTypes.map((item) => /* @__PURE__ */ react.createElement(DropdownItem, {
        onClick: () => {
          handleModalToggle();
          setProviderDropdownOpen(false);
          setDefaultConsoleDisplayName(item);
        },
        "data-testid": `option-${item}`,
        key: item
      }, item))
    ]
  }))))), /* @__PURE__ */ react.createElement(DataList, {
    "aria-label": t4("groups"),
    onDragFinish,
    onDragStart,
    onDragMove,
    onDragCancel,
    itemOrder,
    isCompact: true
  }, /* @__PURE__ */ react.createElement(DataListItem, {
    "aria-labelledby": "aria",
    id: "data",
    key: "data"
  }, /* @__PURE__ */ react.createElement(DataListItemRow, {
    className: "test",
    "data-testid": "data-list-row"
  }, /* @__PURE__ */ react.createElement(DataListDragButton, {
    className: "header-drag-button",
    "aria-label": "Reorder",
    "aria-labelledby": "simple-item",
    "aria-describedby": "Press space or enter to begin dragging, and use the arrow keys to navigate up or down. Press enter to confirm the drag, or any other key to cancel the drag operation.",
    "aria-pressed": "false",
    isDisabled: true
  }), /* @__PURE__ */ react.createElement(DataListItemCells, {
    className: "data-list-cells",
    dataListCells: [
      /* @__PURE__ */ react.createElement(DataListCell, {
        className: "name",
        key: "1"
      }, /* @__PURE__ */ react.createElement(react.Fragment, null, t4("realm-settings:name"))),
      /* @__PURE__ */ react.createElement(DataListCell, {
        className: "provider",
        key: "2"
      }, /* @__PURE__ */ react.createElement(react.Fragment, null, t4("realm-settings:provider"))),
      /* @__PURE__ */ react.createElement(DataListCell, {
        className: "provider-description",
        key: "3"
      }, /* @__PURE__ */ react.createElement(react.Fragment, null, t4("realm-settings:providerDescription")))
    ]
  }))), (filteredComponents.length === 0 ? components3 : filteredComponents).map((component, idx) => /* @__PURE__ */ react.createElement(DataListItem, {
    draggable: true,
    "aria-labelledby": "aria",
    key: `data${idx}`,
    id: `data${idx}`
  }, /* @__PURE__ */ react.createElement(DataListItemRow, {
    key: idx,
    "data-testid": "data-list-row"
  }, /* @__PURE__ */ react.createElement(DataListControl, null, /* @__PURE__ */ react.createElement(DataListDragButton, {
    className: "row-drag-button",
    "aria-label": "Reorder",
    "aria-labelledby": "simple-item2",
    "aria-describedby": "Press space or enter to begin dragging, and use the arrow keys to navigate up or down. Press enter to confirm the drag, or any other key to cancel the drag operation.",
    "aria-pressed": "false"
  })), /* @__PURE__ */ react.createElement(DataListItemCells, {
    dataListCells: [
      /* @__PURE__ */ react.createElement(DataListCell, {
        "data-testid": "provider-name",
        key: `name-${idx}`
      }, /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Link, {
        key: component.name,
        "data-testid": "provider-name-link",
        to: `${url}/${component.id}/${component.providerId}/settings`
      }, component.name))),
      /* @__PURE__ */ react.createElement(DataListCell, {
        key: `providerId-${idx}`
      }, /* @__PURE__ */ react.createElement(react.Fragment, null, component.providerId)),
      /* @__PURE__ */ react.createElement(DataListCell, {
        key: `providerDescription-${idx}`
      }, /* @__PURE__ */ react.createElement(react.Fragment, null, component.providerDescription)),
      /* @__PURE__ */ react.createElement(DataListAction, {
        "aria-labelledby": "data-list-action",
        "aria-label": "Actions",
        isPlainButtonAction: true,
        key: `data-action-list-${idx}`,
        id: `data-action-list-${idx}`
      }, /* @__PURE__ */ react.createElement(Dropdown, {
        isPlain: true,
        position: DropdownPosition.right,
        isOpen: actionListOpen[idx],
        toggle: /* @__PURE__ */ react.createElement(KebabToggle, {
          "data-testid": "provider-action",
          onToggle: () => {
            toggleActionList(idx);
          }
        }),
        dropdownItems: [
          /* @__PURE__ */ react.createElement(DropdownItem, {
            key: "action",
            component: "button",
            "data-testid": "delete-action",
            onClick: () => {
              setSelectedComponent(component);
              toggleDeleteDialog();
              toggleActionList(idx);
            }
          }, t4("common:delete"))
        ]
      }))
    ]
  }))))), /* @__PURE__ */ react.createElement("div", {
    className: "pf-screen-reader",
    "aria-live": "assertive"
  }, liveText)));
};
var KeysProvidersTab = ({
  keyProviderComponentTypes,
  realmComponents,
  refresh,
  ...props
}) => {
  return /* @__PURE__ */ react.createElement(KeysTabInner, {
    components: realmComponents?.map((component) => {
      const provider = keyProviderComponentTypes.find((componentType) => component.providerId === componentType.id);
      return {
        ...component,
        providerDescription: provider?.helpText
      };
    }),
    keyProviderComponentTypes,
    refresh,
    realmComponents,
    ...props
  });
};

// build/realm-settings/LoginTab.js
var RealmSettingsLoginTab = ({
  save,
  realm: realm2
}) => {
  const {t: t4} = useTranslation("realm-settings");
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(FormPanel, {
    className: "kc-login-screen",
    title: "Login screen customization"
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-realm"
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("userRegistration"),
    fieldId: "kc-user-reg",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: t4("userRegistrationHelpText"),
      forLabel: t4("userRegistration"),
      forID: t4(`common:helpLabel`, {
        label: t4("userRegistration")
      })
    }),
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Switch, {
    id: "kc-user-reg-switch",
    "data-testid": "user-reg-switch",
    name: "registrationAllowed",
    label: t4("common:on"),
    labelOff: t4("common:off"),
    isChecked: realm2?.registrationAllowed,
    onChange: (value) => {
      save({...realm2, registrationAllowed: value});
    }
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("forgotPassword"),
    fieldId: "kc-forgot-pw",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: t4("forgotPasswordHelpText"),
      forLabel: t4("forgotPassword"),
      forID: t4(`common:helpLabel`, {label: t4("forgotPassword")})
    }),
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Switch, {
    id: "kc-forgot-pw-switch",
    "data-testid": "forgot-pw-switch",
    name: "resetPasswordAllowed",
    label: t4("common:on"),
    labelOff: t4("common:off"),
    isChecked: realm2?.resetPasswordAllowed,
    onChange: (value) => {
      save({...realm2, resetPasswordAllowed: value});
    }
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("rememberMe"),
    fieldId: "kc-remember-me",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: t4("rememberMeHelpText"),
      forLabel: t4("rememberMe"),
      forID: t4(`common:helpLabel`, {label: t4("rememberMe")})
    }),
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Switch, {
    id: "kc-remember-me-switch",
    "data-testid": "remember-me-switch",
    name: "rememberMe",
    label: t4("common:on"),
    labelOff: t4("common:off"),
    isChecked: realm2?.rememberMe,
    onChange: (value) => {
      save({...realm2, rememberMe: value});
    }
  })))), /* @__PURE__ */ react.createElement(FormPanel, {
    className: "kc-email-settings",
    title: "Email settings"
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-realm"
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("emailAsUsername"),
    fieldId: "kc-email-as-username",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: t4("emailAsUsernameHelpText"),
      forLabel: t4("emailAsUsername"),
      forID: t4(`common:helpLabel`, {label: t4("emailAsUsername")})
    }),
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Switch, {
    id: "kc-email-as-username-switch",
    "data-testid": "email-as-username-switch",
    name: "registrationEmailAsUsername",
    label: t4("common:on"),
    labelOff: t4("common:off"),
    isChecked: realm2?.registrationEmailAsUsername,
    onChange: (value) => {
      save({...realm2, registrationEmailAsUsername: value});
    }
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("loginWithEmail"),
    fieldId: "kc-login-with-email",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: t4("loginWithEmailHelpText"),
      forLabel: t4("loginWithEmail"),
      forID: t4(`common:helpLabel`, {label: t4("loginWithEmail")})
    }),
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Switch, {
    id: "kc-login-with-email-switch",
    "data-testid": "login-with-email-switch",
    name: "loginWithEmailAllowed",
    label: t4("common:on"),
    labelOff: t4("common:off"),
    isChecked: realm2?.loginWithEmailAllowed,
    onChange: (value) => {
      save({...realm2, loginWithEmailAllowed: value});
    }
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("duplicateEmails"),
    fieldId: "kc-duplicate-emails",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: t4("duplicateEmailsHelpText"),
      forLabel: t4("duplicateEmails"),
      forID: t4(`common:helpLabel`, {label: t4("duplicateEmails")})
    }),
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Switch, {
    id: "kc-duplicate-emails-switch",
    "data-testid": "duplicate-emails-switch",
    label: t4("common:on"),
    labelOff: t4("common:off"),
    name: "duplicateEmailsAllowed",
    isChecked: realm2?.duplicateEmailsAllowed && !realm2?.loginWithEmailAllowed && !realm2?.registrationEmailAsUsername,
    onChange: (value) => {
      save({...realm2, duplicateEmailsAllowed: value});
    },
    isDisabled: realm2?.loginWithEmailAllowed || realm2?.registrationEmailAsUsername
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("verifyEmail"),
    fieldId: "kc-verify-email",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: t4("verifyEmailHelpText"),
      forLabel: t4("verifyEmail"),
      forID: t4(`common:helpLabel`, {label: t4("verifyEmail")})
    }),
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Switch, {
    id: "kc-verify-email-switch",
    "data-testid": "verify-email-switch",
    name: "verifyEmail",
    label: t4("common:on"),
    labelOff: t4("common:off"),
    isChecked: realm2?.verifyEmail,
    onChange: (value) => {
      save({...realm2, verifyEmail: value});
    }
  }))))));
};

// build/realm-settings/PartialImport.js
var PartialImportDialog = (props) => {
  const tRealm = useTranslation("realm-settings").t;
  const {t: t4} = useTranslation("partial-import");
  const [isFileSelected, setIsFileSelected] = useState(false);
  const [isMultiRealm, setIsMultiRealm] = useState(false);
  const [importedFile, setImportedFile] = useState([]);
  const [isRealmSelectOpen, setIsRealmSelectOpen] = useState(false);
  const [isCollisionSelectOpen, setIsCollisionSelectOpen] = useState(false);
  const [collisionOption, setCollisionOption] = useState("FAIL");
  const [targetRealm, setTargetRealm] = useState({});
  const allResourcesUnChecked = {
    users: false,
    clients: false,
    groups: false,
    identityProviders: false,
    realmRoles: false,
    clientRoles: false
  };
  const [resourcesToImport, setResourcesToImport] = useState(lodash.cloneDeep(allResourcesUnChecked));
  const [isAnyResourceChecked, setIsAnyResourceChecked] = useState(false);
  const resetResourcesToImport = () => {
    setResourcesToImport(lodash.cloneDeep(allResourcesUnChecked));
    setIsAnyResourceChecked(false);
  };
  const resetInputState = () => {
    setIsMultiRealm(false);
    setImportedFile([]);
    setTargetRealm({});
    setCollisionOption("FAIL");
    resetResourcesToImport();
  };
  useEffect(() => {
    setIsFileSelected(false);
    resetInputState();
  }, [props.open]);
  const handleFileChange = (value) => {
    setIsFileSelected(!!value);
    resetInputState();
    setImportedFile(value);
    if (value instanceof Array && value.length > 0) {
      setIsMultiRealm(value.length > 1);
      setTargetRealm(value[0] || {});
    } else {
      setIsMultiRealm(false);
      setTargetRealm(value || {});
    }
  };
  const handleRealmSelect = (event, realm2) => {
    setTargetRealm(realm2);
    setIsRealmSelectOpen(false);
    resetResourcesToImport();
  };
  const handleResourceCheckBox = (checked, event) => {
    const resource2 = event.currentTarget.name;
    const copyOfResourcesToImport = lodash.cloneDeep(resourcesToImport);
    copyOfResourcesToImport[resource2] = checked;
    setResourcesToImport(copyOfResourcesToImport);
    setIsAnyResourceChecked(resourcesChecked(copyOfResourcesToImport));
  };
  const realmSelectOptions = () => {
    if (!isMultiRealm)
      return [];
    const mapper = (realm2) => {
      return /* @__PURE__ */ react.createElement(SelectOption, {
        key: realm2.id,
        value: realm2,
        "data-testid": realm2.id + "-select-option"
      }, realm2.realm || realm2.id);
    };
    return importedFile.map(mapper);
  };
  const handleCollisionSelect = (event, option) => {
    setCollisionOption(option);
    setIsCollisionSelectOpen(false);
  };
  const collisionOptions = () => {
    return [
      /* @__PURE__ */ react.createElement(SelectOption, {
        key: "fail",
        value: "FAIL"
      }, t4("FAIL")),
      /* @__PURE__ */ react.createElement(SelectOption, {
        key: "skip",
        value: "SKIP"
      }, t4("SKIP")),
      /* @__PURE__ */ react.createElement(SelectOption, {
        key: "overwrite",
        value: "OVERWRITE"
      }, t4("OVERWRITE"))
    ];
  };
  const targetHasResources = () => {
    return targetHasResource("users") || targetHasResource("groups") || targetHasResource("clients") || targetHasResource("identityProviders") || targetHasRealmRoles() || targetHasClientRoles();
  };
  const targetHasResource = (resource2) => {
    return targetRealm && targetRealm[resource2] instanceof Array && targetRealm[resource2].length > 0;
  };
  const targetHasRoles = () => {
    return targetRealm && Object.prototype.hasOwnProperty.call(targetRealm, "roles");
  };
  const targetHasRealmRoles = () => {
    return targetHasRoles() && targetRealm.roles.realm instanceof Array && targetRealm.roles.realm.length > 0;
  };
  const targetHasClientRoles = () => {
    return targetHasRoles() && Object.prototype.hasOwnProperty.call(targetRealm.roles, "client") && Object.keys(targetRealm.roles.client).length > 0;
  };
  const itemCount = (resource2) => {
    if (!isFileSelected)
      return 0;
    if (targetHasRealmRoles() && resource2 === "realmRoles")
      return targetRealm.roles.realm.length;
    if (targetHasClientRoles() && resource2 == "clientRoles")
      return clientRolesCount(targetRealm.roles.client);
    if (!targetRealm[resource2])
      return 0;
    return targetRealm[resource2].length;
  };
  const clientRolesCount = (clientRoles) => {
    let total = 0;
    for (const clientName in clientRoles) {
      total += clientRoles[clientName].length;
    }
    return total;
  };
  const resourcesChecked = (resources) => {
    let resource2;
    for (resource2 in resources) {
      if (resources[resource2])
        return true;
    }
    return false;
  };
  const resourceDataListItem = (resource2, resourceDisplayName) => {
    return /* @__PURE__ */ react.createElement(DataListItem, {
      "aria-labelledby": `${resource2}-list-item`
    }, /* @__PURE__ */ react.createElement(DataListItemRow, null, /* @__PURE__ */ react.createElement(DataListCheck, {
      "aria-labelledby": `${resource2}-checkbox`,
      name: resource2,
      isChecked: resourcesToImport[resource2],
      onChange: handleResourceCheckBox,
      "data-testid": resource2 + "-checkbox"
    }), /* @__PURE__ */ react.createElement(DataListItemCells, {
      dataListCells: [
        /* @__PURE__ */ react.createElement(DataListCell, {
          key: resource2
        }, /* @__PURE__ */ react.createElement("span", {
          "data-testid": resource2 + "-count"
        }, itemCount(resource2), " ", resourceDisplayName))
      ]
    })));
  };
  return /* @__PURE__ */ react.createElement(Modal, {
    variant: ModalVariant.medium,
    title: tRealm("partialImport"),
    isOpen: props.open,
    onClose: props.toggleDialog,
    actions: [
      /* @__PURE__ */ react.createElement(Button, {
        id: "modal-import",
        "data-testid": "import-button",
        key: "import",
        isDisabled: !isAnyResourceChecked,
        onClick: () => {
          props.toggleDialog();
        }
      }, t4("import")),
      /* @__PURE__ */ react.createElement(Button, {
        id: "modal-cancel",
        "data-testid": "cancel-button",
        key: "cancel",
        variant: ButtonVariant.link,
        onClick: () => {
          props.toggleDialog();
        }
      }, t4("common:cancel"))
    ]
  }, /* @__PURE__ */ react.createElement(Stack, {
    hasGutter: true
  }, /* @__PURE__ */ react.createElement(StackItem, null, /* @__PURE__ */ react.createElement(TextContent, null, /* @__PURE__ */ react.createElement(Text, null, t4("partialImportHeaderText")))), /* @__PURE__ */ react.createElement(StackItem, null, /* @__PURE__ */ react.createElement(JsonFileUpload, {
    id: "partial-import-file",
    onChange: handleFileChange
  })), isFileSelected && targetHasResources() && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(StackItem, null, /* @__PURE__ */ react.createElement(Divider, null)), isMultiRealm && /* @__PURE__ */ react.createElement(StackItem, null, /* @__PURE__ */ react.createElement(Text, null, t4("selectRealm"), ":"), /* @__PURE__ */ react.createElement(Select, {
    toggleId: "realm-selector",
    isOpen: isRealmSelectOpen,
    onToggle: () => setIsRealmSelectOpen(!isRealmSelectOpen),
    onSelect: handleRealmSelect,
    placeholderText: targetRealm.realm || targetRealm.id
  }, realmSelectOptions())), /* @__PURE__ */ react.createElement(StackItem, null, /* @__PURE__ */ react.createElement(Text, null, t4("chooseResources"), ":"), /* @__PURE__ */ react.createElement(DataList, {
    "aria-label": "Resources to import",
    isCompact: true
  }, targetHasResource("users") && resourceDataListItem("users", "users"), targetHasResource("groups") && resourceDataListItem("groups", "groups"), targetHasResource("clients") && resourceDataListItem("clients", "clients"), targetHasResource("identityProviders") && resourceDataListItem("identityProviders", "identity providers"), targetHasRealmRoles() && resourceDataListItem("realmRoles", "realm roles"), targetHasClientRoles() && resourceDataListItem("clientRoles", "client roles"))), /* @__PURE__ */ react.createElement(StackItem, null, /* @__PURE__ */ react.createElement(Text, null, t4("selectIfResourceExists"), ":"), /* @__PURE__ */ react.createElement(Select, {
    isOpen: isCollisionSelectOpen,
    direction: "up",
    onToggle: () => {
      setIsCollisionSelectOpen(!isCollisionSelectOpen);
    },
    onSelect: handleCollisionSelect,
    placeholderText: t4(collisionOption)
  }, collisionOptions())))));
};

// build/realm-settings/security-defences/HelpLinkTextInput.js
var HelpLinkTextInput = ({
  fieldName,
  url
}) => {
  const {t: t4} = useTranslation("realm-settings");
  const {register} = useFormContext();
  const name = fieldName.substr(fieldName.indexOf(".") + 1);
  return /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4(name),
    fieldId: name,
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: /* @__PURE__ */ react.createElement(Trans, {
        i18nKey: `realm-settings-help:${name}`
      }, "Default value prevents pages from being included", /* @__PURE__ */ react.createElement(FormattedLink, {
        href: url,
        title: t4("common:learnMore")
      })),
      forLabel: t4(name),
      forID: name
    })
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: name,
    name: fieldName,
    ref: register
  }));
};

// build/realm-settings/security-defences/HeadersForm.js
var HeadersForm = ({save, reset}) => {
  const {t: t4} = useTranslation();
  const {
    formState: {isDirty},
    handleSubmit
  } = useFormContext();
  return /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-realm",
    className: "keycloak__security-defences__form",
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(HelpLinkTextInput, {
    fieldName: "browserSecurityHeaders.xFrameOptions",
    url: "http://tools.ietf.org/html/rfc7034"
  }), /* @__PURE__ */ react.createElement(HelpLinkTextInput, {
    fieldName: "browserSecurityHeaders.contentSecurityPolicy",
    url: "http://www.w3.org/TR/CSP/"
  }), /* @__PURE__ */ react.createElement(HelpLinkTextInput, {
    fieldName: "browserSecurityHeaders.contentSecurityPolicyReportOnly",
    url: "http://www.w3.org/TR/CSP/"
  }), /* @__PURE__ */ react.createElement(HelpLinkTextInput, {
    fieldName: "browserSecurityHeaders.xContentTypeOptions",
    url: "https://www.owasp.org/index.php/List_of_useful_HTTP_headers"
  }), /* @__PURE__ */ react.createElement(HelpLinkTextInput, {
    fieldName: "browserSecurityHeaders.xRobotsTag",
    url: "https://developers.google.com/webmasters/control-crawl-index/docs/robots_meta_tag"
  }), /* @__PURE__ */ react.createElement(HelpLinkTextInput, {
    fieldName: "browserSecurityHeaders.xXSSProtection",
    url: "https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#xxxsp"
  }), /* @__PURE__ */ react.createElement(HelpLinkTextInput, {
    fieldName: "browserSecurityHeaders.strictTransportSecurity",
    url: "https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#hsts"
  }), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "primary",
    type: "submit",
    "data-testid": "headers-form-tab-save",
    isDisabled: !isDirty
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: reset
  }, t4("common:revert"))));
};

// build/realm-settings/security-defences/Time.js
var Time = ({name}) => {
  const {t: t4} = useTranslation("realm-settings");
  const {control, errors} = useFormContext();
  return /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4(name),
    fieldId: name,
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: `realm-settings-help:${name}`,
      forLabel: t4(name),
      forID: name
    }),
    validated: errors[name] ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(Controller, {
    name,
    defaultValue: "",
    control,
    rules: {required: true},
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      value,
      onChange,
      validated: errors[name] ? ValidatedOptions.error : ValidatedOptions.default
    })
  }));
};

// build/realm-settings/security-defences/BruteForceDetection.js
var BruteForceDetection = ({
  save,
  reset
}) => {
  const {t: t4} = useTranslation("realm-settings");
  const {
    handleSubmit,
    control,
    formState: {isDirty}
  } = useFormContext();
  const enable = useWatch({
    control,
    name: "bruteForceProtected"
  });
  const permanentLockout = useWatch({
    control,
    name: "permanentLockout"
  });
  return /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-realm",
    isHorizontal: true,
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:enabled"),
    fieldId: "bruteForceProtected",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "bruteForceProtected",
    defaultValue: false,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "bruteForceProtected",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value,
      onChange
    })
  })), enable && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("failureFactor"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:failureFactor",
      forLabel: t4("failureFactor"),
      forID: "failureFactor"
    }),
    fieldId: "failureFactor"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "failureFactor",
    defaultValue: 0,
    control,
    rules: {required: true},
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(NumberInput, {
      type: "text",
      id: "failureFactor",
      value,
      onPlus: () => onChange(value + 1),
      onMinus: () => onChange(value - 1),
      onChange: (event) => onChange(Number(event.target.value))
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("permanentLockout"),
    fieldId: "permanentLockout",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "permanentLockout",
    defaultValue: false,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "permanentLockout",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value,
      onChange
    })
  })), permanentLockout && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Time, {
    name: "waitIncrement"
  }), /* @__PURE__ */ react.createElement(Time, {
    name: "maxFailureWait"
  }), /* @__PURE__ */ react.createElement(Time, {
    name: "maxDeltaTime"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("quickLoginCheckMilliSeconds"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:quickLoginCheckMilliSeconds",
      forLabel: t4("quickLoginCheckMilliSeconds"),
      forID: "quickLoginCheckMilliSeconds"
    }),
    fieldId: "quickLoginCheckMilliSeconds"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "quickLoginCheckMilliSeconds",
    defaultValue: 0,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(NumberInput, {
      type: "text",
      id: "quickLoginCheckMilliSeconds",
      value,
      onPlus: () => onChange(value + 1),
      onMinus: () => onChange(value - 1),
      onChange: (event) => onChange(Number(event.target.value))
    })
  })), /* @__PURE__ */ react.createElement(Time, {
    name: "minimumQuickLoginWaitSeconds"
  })), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "primary",
    type: "submit",
    "data-testid": "brute-force-tab-save",
    isDisabled: !isDirty
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: reset
  }, t4("common:revert"))));
};

// build/realm-settings/security-defences/SecurityDefences.js
var SecurityDefences = ({save, reset}) => {
  const {t: t4} = useTranslation("realm-settings");
  const [activeTab, setActiveTab] = useState(10);
  return /* @__PURE__ */ react.createElement(Tabs, {
    activeKey: activeTab,
    onSelect: (_23, key) => setActiveTab(key)
  }, /* @__PURE__ */ react.createElement(Tab, {
    id: "headers",
    eventKey: 10,
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("headers"))
  }, /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(HeadersForm, {
    save,
    reset
  }))), /* @__PURE__ */ react.createElement(Tab, {
    id: "bruteForce",
    eventKey: 20,
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("bruteForceDetection"))
  }, /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(BruteForceDetection, {
    save,
    reset
  }))));
};

// build/realm-settings/SessionsTab.js
var RealmSettingsSessionsTab = ({
  realm: initialRealm
}) => {
  const {t: t4} = useTranslation("realm-settings");
  const adminClient = useAdminClient();
  const {realm: realmName} = useRealm();
  const {addAlert, addError} = useAlerts();
  const [realm2, setRealm] = useState(initialRealm);
  const {
    control,
    handleSubmit,
    reset: resetForm,
    formState
  } = useForm();
  const offlineSessionMaxEnabled = useWatch({
    control,
    name: "offlineSessionMaxLifespanEnabled",
    defaultValue: realm2?.offlineSessionMaxLifespanEnabled
  });
  useEffect(() => resetForm(realm2), [realm2]);
  const save = async (form2) => {
    try {
      const savedRealm = {...realm2, ...form2};
      await adminClient.realms.update({realm: realmName}, savedRealm);
      setRealm(savedRealm);
      addAlert(t4("saveSuccess"), AlertVariant.success);
    } catch (error2) {
      addError("realm-settings:saveError", error2);
    }
  };
  const reset = () => {
    if (realm2) {
      resetForm(realm2);
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(FormPanel, {
    title: t4("SSOSessionSettings"),
    className: "kc-sso-session-template"
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-realm",
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("SSOSessionIdle"),
    fieldId: "SSOSessionIdle",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:ssoSessionIdle",
      forLabel: t4("SSOSessionIdle"),
      forID: "SSOSessionIdle",
      id: "SSOSessionIdle"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "ssoSessionIdleTimeout",
    defaultValue: realm2?.ssoSessionIdleTimeout,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      className: "kc-sso-session-idle",
      "data-testid": "sso-session-idle-input",
      "aria-label": "sso-session-idle-input",
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("SSOSessionMax"),
    fieldId: "SSOSessionMax",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:ssoSessionMax",
      forLabel: t4("SSOSessionMax"),
      forID: "SSOSessionMax",
      id: "SSOSessionMax"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "ssoSessionMaxLifespan",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      className: "kc-sso-session-max",
      "data-testid": "sso-session-max-input",
      "aria-label": "sso-session-max-input",
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("SSOSessionIdleRememberMe"),
    fieldId: "SSOSessionIdleRememberMe",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:ssoSessionIdleRememberMe",
      forLabel: t4("SSOSessionIdleRememberMe"),
      forID: "SSOSessionIdleRememberMe",
      id: "SSOSessionIdleRememberMe"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "ssoSessionIdleTimeoutRememberMe",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      className: "kc-sso-session-idle-remember-me",
      "data-testid": "sso-session-idle-remember-me-input",
      "aria-label": "sso-session-idle-remember-me-input",
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("SSOSessionMaxRememberMe"),
    fieldId: "SSOSessionMaxRememberMe",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:ssoSessionMaxRememberMe",
      forLabel: t4("SSOSessionMaxRememberMe"),
      forID: "SSOSessionMaxRememberMe",
      id: "SSOSessionMaxRememberMe"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "ssoSessionMaxLifespanRememberMe",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      className: "kc-sso-session-max-remember-me",
      "aria-label": "sso-session-max-remember-me-input",
      "data-testid": "sso-session-max-remember-me-input",
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  })))), /* @__PURE__ */ react.createElement(FormPanel, {
    title: t4("clientSessionSettings"),
    className: "kc-client-session-template"
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-realm",
    className: "pf-u-mt-lg",
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("clientSessionIdle"),
    fieldId: "clientSessionIdle",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:clientSessionIdle",
      forLabel: t4("clientSessionIdle"),
      forID: "clientSessionIdle",
      id: "clientSessionIdle"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "clientSessionIdleTimeout",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      className: "kc-client-session-idle",
      "data-testid": "client-session-idle-input",
      "aria-label": "client-session-idle-input",
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("clientSessionMax"),
    fieldId: "clientSessionMax",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:clientSessionMax",
      forLabel: t4("clientSessionMax"),
      forID: "clientSessionMax",
      id: "clientSessionMax"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "clientSessionMaxLifespan",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      className: "kc-client-session-max",
      "data-testid": "client-session-max-input",
      "aria-label": "client-session-max-input",
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  })))), /* @__PURE__ */ react.createElement(FormPanel, {
    title: t4("offlineSessionSettings"),
    className: "kc-offline-session-template"
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-realm",
    className: "pf-u-mt-lg",
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("offlineSessionIdle"),
    fieldId: "offlineSessionIdle",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:offlineSessionIdle",
      forLabel: t4("offlineSessionIdle"),
      forID: "offlineSessionIdle",
      id: "offlineSessionIdle"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "offlineSessionIdleTimeout",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      className: "kc-offline-session-idle",
      "data-testid": "offline-session-idle-input",
      "aria-label": "offline-session-idle-input",
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    hasNoPaddingTop: true,
    label: t4("offlineSessionMaxLimited"),
    fieldId: "kc-offlineSessionMaxLimited",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:offlineSessionMaxLimited",
      forLabel: t4("offlineSessionMaxLimited"),
      forID: "offlineSessionMaxLimited",
      id: "offlineSessionMaxLimited"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "offlineSessionMaxLifespanEnabled",
    control,
    defaultValue: false,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-offline-session-max",
      "data-testid": "offline-session-max-switch",
      "aria-label": "offline-session-max-switch",
      label: t4("common:enabled"),
      labelOff: t4("common:disabled"),
      isChecked: value,
      onChange: (value2) => onChange(value2.toString())
    })
  })), offlineSessionMaxEnabled && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("offlineSessionMax"),
    fieldId: "offlineSessionMax",
    id: "offline-session-max-label",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:offlineSessionMax",
      forLabel: t4("offlineSessionMax"),
      forID: "offlineSessionMax",
      id: "offlineSessionMax"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "offlineSessionMaxLifespan",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      className: "kc-offline-session-max",
      "data-testid": "offline-session-max-input",
      "aria-label": "offline-session-max-input",
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  })))), /* @__PURE__ */ react.createElement(FormPanel, {
    className: "kc-login-settings-template",
    title: t4("loginSettings")
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-realm",
    className: "pf-u-mt-lg",
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("loginTimeout"),
    id: "kc-login-timeout-label",
    fieldId: "offlineSessionIdle",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:loginTimeout",
      forLabel: t4("loginTimeout"),
      forID: "loginTimeout",
      id: "loginTimeout"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "accessCodeLifespanLogin",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      className: "kc-login-timeout",
      "data-testid": "login-timeout-input",
      "aria-label": "login-timeout-input",
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("loginActionTimeout"),
    fieldId: "loginActionTimeout",
    id: "login-action-timeout-label",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:loginActionTimeout",
      forLabel: t4("loginActionTimeout"),
      forID: "loginActionTimeout",
      id: "loginActionTimeout"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "accessCodeLifespanUserAction",
    defaultValue: "",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      className: "kc-login-action-timeout",
      "data-testid": "login-action-timeout-input",
      "aria-label": "login-action-timeout-input",
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  })), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "primary",
    type: "submit",
    "data-testid": "sessions-tab-save",
    isDisabled: !formState.isDirty
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: reset
  }, t4("common:revert")))))));
};

// build/realm-settings/ThemesTab.js
var RealmSettingsThemesTab = ({
  save,
  reset,
  realm: realm2
}) => {
  const {t: t4} = useTranslation("realm-settings");
  const [loginThemeOpen, setLoginThemeOpen] = useState(false);
  const [accountThemeOpen, setAccountThemeOpen] = useState(false);
  const [adminConsoleThemeOpen, setAdminConsoleThemeOpen] = useState(false);
  const [emailThemeOpen, setEmailThemeOpen] = useState(false);
  const [supportedLocalesOpen, setSupportedLocalesOpen] = useState(false);
  const [defaultLocaleOpen, setDefaultLocaleOpen] = useState(false);
  const {control, handleSubmit} = useFormContext();
  const themeTypes = useServerInfo().themes;
  const watchSupportedLocales = useWatch({
    control,
    name: "supportedLocales",
    defaultValue: themeTypes?.account[0].locales
  });
  const internationalizationEnabled = useWatch({
    control,
    name: "internationalizationEnabled",
    defaultValue: realm2?.internationalizationEnabled
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-realm",
    className: "pf-u-mt-lg",
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("loginTheme"),
    fieldId: "kc-login-theme",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:loginTheme",
      forLabel: t4("loginTheme"),
      forID: "kc-login-theme"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "loginTheme",
    control,
    defaultValue: "",
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-login-theme",
      onToggle: () => setLoginThemeOpen(!loginThemeOpen),
      onSelect: (_23, value2) => {
        onChange(value2);
        setLoginThemeOpen(false);
      },
      selections: value,
      variant: SelectVariant.single,
      "aria-label": t4("loginTheme"),
      isOpen: loginThemeOpen,
      placeholderText: "Select a theme",
      "data-testid": "select-login-theme"
    }, themeTypes.login.map((theme, idx) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: theme.name === value,
      key: `login-theme-${idx}`,
      value: theme.name
    }, t4(`${theme.name}`))))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("accountTheme"),
    fieldId: "kc-account-theme",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:accountTheme",
      forLabel: t4("accountTheme"),
      forID: "kc-account-theme"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "accountTheme",
    control,
    defaultValue: "",
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-account-theme",
      onToggle: () => setAccountThemeOpen(!accountThemeOpen),
      onSelect: (_23, value2) => {
        onChange(value2);
        setAccountThemeOpen(false);
      },
      selections: value,
      variant: SelectVariant.single,
      "aria-label": t4("accountTheme"),
      isOpen: accountThemeOpen,
      placeholderText: "Select a theme",
      "data-testid": "select-account-theme"
    }, themeTypes.account.map((theme, idx) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: theme.name === value,
      key: `account-theme-${idx}`,
      value: theme.name
    }, t4(`${theme.name}`))))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("adminTheme"),
    fieldId: "kc-admin-console-theme",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:adminConsoleTheme",
      forLabel: t4("adminTheme"),
      forID: "kc-admin-console-theme"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "adminTheme",
    control,
    defaultValue: "",
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-admin-console-theme",
      onToggle: () => setAdminConsoleThemeOpen(!adminConsoleThemeOpen),
      onSelect: (_23, value2) => {
        onChange(value2);
        setAdminConsoleThemeOpen(false);
      },
      selections: value,
      variant: SelectVariant.single,
      "aria-label": t4("adminConsoleTheme"),
      isOpen: adminConsoleThemeOpen,
      placeholderText: "Select a theme",
      "data-testid": "select-admin-theme"
    }, themeTypes.admin.map((theme, idx) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: theme.name === value,
      key: `admin-theme-${idx}`,
      value: theme.name
    }, t4(`${theme.name}`))))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("emailTheme"),
    fieldId: "kc-email-theme",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:emailTheme",
      forLabel: t4("emailTheme"),
      forID: "kc-email-theme"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "emailTheme",
    control,
    defaultValue: "",
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-email-theme",
      onToggle: () => setEmailThemeOpen(!emailThemeOpen),
      onSelect: (_23, value2) => {
        onChange(value2);
        setEmailThemeOpen(false);
      },
      selections: value,
      variant: SelectVariant.single,
      "aria-label": t4("emailTheme"),
      isOpen: emailThemeOpen,
      placeholderText: "Select a theme",
      "data-testid": "select-email-theme"
    }, themeTypes.email.map((theme, idx) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: theme.name === value,
      key: `email-theme-${idx}`,
      value: theme.name
    }, t4(`${theme.name}`))))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("internationalization"),
    fieldId: "kc-internationalization"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "internationalizationEnabled",
    control,
    defaultValue: false,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-t-internationalization",
      label: t4("common:enabled"),
      labelOff: t4("common:disabled"),
      isChecked: value,
      "data-testid": value ? "internationalization-enabled" : "internationalization-disabled",
      onChange
    })
  })), internationalizationEnabled && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("supportedLocales"),
    fieldId: "kc-t-supported-locales"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "supportedLocales",
    control,
    defaultValue: themeTypes?.account[0].locales,
    render: ({value, onChange}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-t-supported-locales",
      onToggle: () => {
        setSupportedLocalesOpen(!supportedLocalesOpen);
      },
      onSelect: (_23, v3) => {
        const option = v3;
        if (!value) {
          onChange([option]);
        } else if (value.includes(option)) {
          onChange(value.filter((item) => item !== option));
        } else {
          onChange([...value, option]);
        }
      },
      onClear: () => {
        onChange([]);
      },
      selections: value,
      variant: SelectVariant.typeaheadMulti,
      "aria-label": t4("supportedLocales"),
      isOpen: supportedLocalesOpen,
      placeholderText: "Select locales"
    }, themeTypes?.login[0].locales.map((locale, idx) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: true,
      key: `locale-${idx}`,
      value: locale
    }, t4(`allSupportedLocales.${locale}`))))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("defaultLocale"),
    fieldId: "kc-default-locale"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "defaultLocale",
    control,
    defaultValue: "",
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-t-default-locale",
      onToggle: () => setDefaultLocaleOpen(!defaultLocaleOpen),
      onSelect: (_23, value2) => {
        onChange(value2);
        setDefaultLocaleOpen(false);
      },
      selections: value && t4(`allSupportedLocales.${value}`),
      variant: SelectVariant.single,
      "aria-label": t4("defaultLocale"),
      isOpen: defaultLocaleOpen,
      placeholderText: "Select one",
      "data-testid": "select-default-locale"
    }, watchSupportedLocales.map((locale, idx) => /* @__PURE__ */ react.createElement(SelectOption, {
      key: `default-locale-${idx}`,
      value: locale
    }, t4(`allSupportedLocales.${locale}`))))
  }))), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "primary",
    type: "submit",
    "data-testid": "themes-tab-save"
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: reset
  }, t4("common:revert"))))));
};

// build/realm-settings/TokensTab.js
var RealmSettingsTokensTab = ({
  realm: initialRealm,
  reset
}) => {
  const {t: t4} = useTranslation("realm-settings");
  const adminClient = useAdminClient();
  const {realm: realmName} = useRealm();
  const {addAlert, addError} = useAlerts();
  const serverInfo2 = useServerInfo();
  const [realm2, setRealm] = useState(initialRealm);
  const [defaultSigAlgDrpdwnIsOpen, setDefaultSigAlgDrpdwnOpen] = useState(false);
  const allComponentTypes = serverInfo2.componentTypes?.["org.keycloak.keys.KeyProvider"] ?? [];
  const esOptions = ["ES256", "ES384", "ES512"];
  const hmacAlgorithmOptions = allComponentTypes[2].properties[4].options;
  const javaKeystoreAlgOptions = allComponentTypes[3].properties[3].options;
  const defaultSigAlgOptions = esOptions.concat(hmacAlgorithmOptions, javaKeystoreAlgOptions);
  const form2 = useForm();
  const {control} = useFormContext();
  const offlineSessionMaxEnabled = useWatch({
    control,
    name: "offlineSessionMaxLifespanEnabled",
    defaultValue: realm2?.offlineSessionMaxLifespanEnabled
  });
  const setupForm = (realm22) => {
    const {...formValues} = realm22;
    form2.reset(formValues);
    Object.entries(realm22).map((entry) => {
      if (entry[0] === "attributes") {
        convertToFormValues(entry[1], "attributes", form2.setValue);
      } else {
        form2.setValue(entry[0], entry[1]);
      }
    });
  };
  useFetch(() => adminClient.realms.findOne({realm: realmName}), (realm22) => {
    setRealm(realm22);
    setupForm(realm22);
  }, [realmName]);
  const save = async () => {
    const firstInstanceOnly = true;
    const flattenedAttributes = convertFormValuesToObject(flatten2(form2.getValues()["attributes"]), firstInstanceOnly);
    const attributes = {...flattenedAttributes, ...realm2?.attributes};
    try {
      const newRealm = {
        ...realm2,
        ...form2.getValues(),
        attributes
      };
      await adminClient.realms.update({realm: realmName}, newRealm);
      setupForm(newRealm);
      setRealm(newRealm);
      addAlert(t4("saveSuccess"), AlertVariant.success);
    } catch (error2) {
      addError("realm-settings:saveError", error2);
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(FormPanel, {
    title: t4("realm-settings:general"),
    className: "kc-sso-session-template"
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-realm",
    onSubmit: form2.handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("defaultSigAlg"),
    fieldId: "kc-default-signature-algorithm",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:defaultSigAlg",
      forLabel: t4("defaultSigAlg"),
      forID: t4("common:helpLabel", {label: t4("algorithm")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "defaultSignatureAlgorithm",
    defaultValue: "RS256",
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-default-sig-alg",
      onToggle: () => setDefaultSigAlgDrpdwnOpen(!defaultSigAlgDrpdwnIsOpen),
      onSelect: (_23, value2) => {
        onChange(value2.toString());
        setDefaultSigAlgDrpdwnOpen(false);
      },
      selections: [value.toString()],
      variant: SelectVariant.single,
      "aria-label": t4("defaultSigAlg"),
      isOpen: defaultSigAlgDrpdwnIsOpen,
      "data-testid": "select-default-sig-alg"
    }, defaultSigAlgOptions.map((p3, idx) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: p3 === value,
      key: `default-sig-alg-${idx}`,
      value: p3
    })))
  })))), /* @__PURE__ */ react.createElement(FormPanel, {
    title: t4("realm-settings:refreshTokens"),
    className: "kc-client-session-template"
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-realm",
    className: "pf-u-mt-lg",
    onSubmit: form2.handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    hasNoPaddingTop: true,
    label: t4("revokeRefreshToken"),
    fieldId: "kc-revoke-refresh-token",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:revokeRefreshToken",
      forLabel: t4("revokeRefreshToken"),
      forID: "revokeRefreshToken",
      id: "revokeRefreshToken"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "revokeRefreshToken",
    control: form2.control,
    defaultValue: false,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-revoke-refresh-token",
      "data-testid": "revoke-refresh-token-switch",
      "aria-label": "revoke-refresh-token-switch",
      label: t4("common:enabled"),
      labelOff: t4("common:disabled"),
      isChecked: value,
      onChange
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("refreshTokenMaxReuse"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:refreshTokenMaxReuse",
      forLabel: t4("refreshTokenMaxReuse"),
      forID: "refreshTokenMaxReuse"
    }),
    fieldId: "refreshTokenMaxReuse"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "refreshTokenMaxReuse",
    defaultValue: 0,
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(NumberInput, {
      type: "text",
      id: "refreshTokenMaxReuseMs",
      value,
      onPlus: () => onChange(value + 1),
      onMinus: () => onChange(value - 1),
      onChange: (event) => onChange(Number(event.target.value))
    })
  })))), /* @__PURE__ */ react.createElement(FormPanel, {
    title: t4("realm-settings:accessTokens"),
    className: "kc-offline-session-template"
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-realm",
    className: "pf-u-mt-lg",
    onSubmit: form2.handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("accessTokenLifespan"),
    fieldId: "accessTokenLifespan",
    helperText: `It is recommended for this value to be shorter than the SSO session idle timeout: ${interpolateTimespan(forHumans(realm2?.ssoSessionIdleTimeout))}`,
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:accessTokenLifespan",
      forLabel: t4("accessTokenLifespan"),
      forID: "accessTokenLifespan",
      id: "accessTokenLifespan"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "accessTokenLifespan",
    defaultValue: "",
    helperTextInvalid: t4("common:required"),
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      validated: value > realm2?.ssoSessionIdleTimeout ? "warning" : "default",
      className: "kc-access-token-lifespan",
      "data-testid": "access-token-lifespan-input",
      "aria-label": "access-token-lifespan",
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("accessTokenLifespanImplicitFlow"),
    fieldId: "accessTokenLifespanImplicitFlow",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:accessTokenLifespanImplicitFlow",
      forLabel: t4("accessTokenLifespanImplicitFlow"),
      forID: "accessTokenLifespanImplicitFlow",
      id: "accessTokenLifespanImplicitFlow"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "accessTokenLifespanForImplicitFlow",
    defaultValue: "",
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      className: "kc-access-token-lifespan-implicit",
      "data-testid": "access-token-lifespan-implicit-input",
      "aria-label": "access-token-lifespan-implicit",
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("clientLoginTimeout"),
    fieldId: "clientLoginTimeout",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:clientLoginTimeout",
      forLabel: t4("clientLoginTimeout"),
      forID: "clientLoginTimeout",
      id: "clientLoginTimeout"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "accessCodeLifespan",
    defaultValue: "",
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      className: "kc-client-login-timeout",
      "data-testid": "client-login-timeout-input",
      "aria-label": "client-login-timeout",
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  })), offlineSessionMaxEnabled && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("offlineSessionMax"),
    fieldId: "offlineSessionMax",
    id: "offline-session-max-label",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:offlineSessionMax",
      forLabel: t4("offlineSessionMax"),
      forID: "offlineSessionMax",
      id: "offlineSessionMax"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "offlineSessionMaxLifespan",
    defaultValue: "",
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      className: "kc-offline-session-max",
      "data-testid": "offline-session-max-input",
      "aria-label": "offline-session-max-input",
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  })))), /* @__PURE__ */ react.createElement(FormPanel, {
    className: "kc-login-settings-template",
    title: t4("actionTokens")
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    role: "manage-realm",
    className: "pf-u-mt-lg",
    onSubmit: form2.handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("userInitiatedActionLifespan"),
    id: "kc-user-initiated-action-lifespan",
    fieldId: "userInitiatedActionLifespan",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:userInitiatedActionLifespan",
      forLabel: t4("userInitiatedActionLifespan"),
      forID: "userInitiatedActionLifespan",
      id: "userInitiatedActionLifespan"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "actionTokenGeneratedByUserLifespan",
    defaultValue: "",
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      className: "kc-user-initiated-action-lifespan",
      "data-testid": "user-initiated-action-lifespan",
      "aria-label": "user-initiated-action-lifespan",
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("defaultAdminInitiated"),
    fieldId: "defaultAdminInitiated",
    id: "default-admin-initiated-label",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:defaultAdminInitiatedActionLifespan",
      forLabel: t4("defaultAdminInitiated"),
      forID: "defaultAdminInitiated",
      id: "defaultAdminInitiated"
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "actionTokenGeneratedByAdminLifespan",
    defaultValue: "",
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      className: "kc-default-admin-initiated",
      "data-testid": "default-admin-initated-input",
      "aria-label": "default-admin-initated-input",
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  })), /* @__PURE__ */ react.createElement(Text, {
    className: "kc-override-action-tokens-subtitle",
    component: TextVariants.h1
  }, t4("overrideActionTokens")), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("emailVerification"),
    fieldId: "emailVerification",
    id: "email-verification"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.actionTokenGeneratedByUserLifespan-verify-email",
    defaultValue: "",
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      className: "kc-email-verification",
      "data-testid": "email-verification-input",
      "aria-label": "email-verification-input",
      value,
      onChange: (value2) => onChange(value2.toString()),
      units: ["minutes", "hours", "days"]
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("idpAccountEmailVerification"),
    fieldId: "idpAccountEmailVerification",
    id: "idp-acct-label"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.actionTokenGeneratedByUserLifespan-idp-verify-account-via-email",
    defaultValue: "",
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      className: "kc-idp-email-verification",
      "data-testid": "idp-email-verification-input",
      "aria-label": "idp-email-verification",
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("forgotPassword"),
    fieldId: "forgotPassword",
    id: "forgot-password-label"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.actionTokenGeneratedByUserLifespan-reset-credentials",
    defaultValue: "",
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      className: "kc-forgot-pw",
      "data-testid": "forgot-pw-input",
      "aria-label": "forgot-pw-input",
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("executeActions"),
    fieldId: "executeActions",
    id: "execute-actions"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "attributes.actionTokenGeneratedByUserLifespan-execute-actions",
    defaultValue: "",
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(TimeSelector, {
      className: "kc-execute-actions",
      "data-testid": "execute-actions-input",
      "aria-label": "execute-actions-input",
      value,
      onChange,
      units: ["minutes", "hours", "days"]
    })
  })), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    variant: "primary",
    type: "submit",
    "data-testid": "tokens-tab-save",
    isDisabled: !form2.formState.isDirty
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: reset
  }, t4("common:revert")))))));
};

// build/realm-settings/RealmSettingsSection.js
var EditProviderCrumb = () => {
  const {t: t4} = useTranslation("realm-settings");
  const {realm: realm2} = useRealm();
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Breadcrumb, null, /* @__PURE__ */ react.createElement(BreadcrumbItem, {
    render: (props) => /* @__PURE__ */ react.createElement(Link, {
      ...props,
      to: toRealmSettings({realm: realm2, tab: "keys"})
    }, t4("keys"))
  }), /* @__PURE__ */ react.createElement(BreadcrumbItem, null, t4("providers")), /* @__PURE__ */ react.createElement(BreadcrumbItem, {
    isActive: true
  }, t4("editProvider"))));
};
var RealmSettingsHeader = ({
  save,
  onChange,
  value,
  realmName
}) => {
  const {t: t4} = useTranslation("realm-settings");
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const history = useHistory();
  const {refresh} = useRealm();
  const [partialImportOpen, setPartialImportOpen] = useState(false);
  const [toggleDisableDialog, DisableConfirm] = useConfirmDialog({
    titleKey: "realm-settings:disableConfirmTitle",
    messageKey: "realm-settings:disableConfirm",
    continueButtonLabel: "common:disable",
    onConfirm: () => {
      onChange(!value);
      save();
    }
  });
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: "realm-settings:deleteConfirmTitle",
    messageKey: "realm-settings:deleteConfirm",
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        await adminClient.realms.del({realm: realmName});
        addAlert(t4("deletedSuccess"), AlertVariant.success);
        history.push("/master/");
        refresh();
      } catch (error2) {
        addError("realm-settings:deleteError", error2);
      }
    }
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DisableConfirm, null), /* @__PURE__ */ react.createElement(DeleteConfirm, null), /* @__PURE__ */ react.createElement(PartialImportDialog, {
    open: partialImportOpen,
    toggleDialog: () => setPartialImportOpen(!partialImportOpen)
  }), /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: toUpperCase(realmName),
    divider: false,
    dropdownItems: [
      /* @__PURE__ */ react.createElement(DropdownItem, {
        key: "import",
        "data-testid": "openPartialImportModal",
        onClick: () => {
          setPartialImportOpen(true);
        }
      }, t4("partialImport")),
      /* @__PURE__ */ react.createElement(DropdownItem, {
        key: "export"
      }, t4("partialExport")),
      /* @__PURE__ */ react.createElement(DropdownSeparator, {
        key: "separator"
      }),
      /* @__PURE__ */ react.createElement(DropdownItem, {
        key: "delete",
        onClick: toggleDeleteDialog
      }, t4("common:delete"))
    ],
    isEnabled: value,
    onToggle: (value2) => {
      if (!value2) {
        toggleDisableDialog();
      } else {
        onChange(value2);
        save();
      }
    }
  }));
};
var RealmSettingsSection = () => {
  const {t: t4} = useTranslation("realm-settings");
  const adminClient = useAdminClient();
  const {realm: realmName} = useRealm();
  const {addAlert, addError} = useAlerts();
  const form2 = useForm({mode: "onChange"});
  const {control, getValues, setValue, reset: resetForm} = form2;
  const [key, setKey] = useState(0);
  const [realm2, setRealm] = useState();
  const [activeTab, setActiveTab] = useState(0);
  const [realmComponents, setRealmComponents] = useState();
  const [currentUser, setCurrentUser] = useState();
  const {whoAmI: whoAmI2} = useWhoAmI();
  const kpComponentTypes = useServerInfo().componentTypes["org.keycloak.keys.KeyProvider"];
  useFetch(async () => {
    const realm22 = await adminClient.realms.findOne({realm: realmName});
    const realmComponents2 = await adminClient.components.find({
      type: "org.keycloak.keys.KeyProvider",
      realm: realmName
    });
    const user = await adminClient.users.findOne({id: whoAmI2.getUserId()});
    return {user, realm: realm22, realmComponents: realmComponents2};
  }, ({user, realm: realm22, realmComponents: realmComponents2}) => {
    setRealmComponents(realmComponents2);
    setCurrentUser(user);
    setRealm(realm22);
  }, [key]);
  const refresh = () => {
    setKey(new Date().getTime());
  };
  useEffect(() => {
    if (realm2) {
      Object.entries(realm2).map((entry) => setValue(entry[0], entry[1]));
      resetForm({...realm2});
    }
  }, [realm2, resetForm]);
  const save = async (realm22) => {
    try {
      await adminClient.realms.update({realm: realmName}, realm22);
      setRealm(realm22);
      addAlert(t4("saveSuccess"), AlertVariant.success);
    } catch (error2) {
      addError("realm-settings:saveError", error2);
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Controller, {
    name: "enabled",
    control,
    defaultValue: true,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(RealmSettingsHeader, {
      value,
      onChange,
      realmName,
      save: () => save(getValues())
    })
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    className: "pf-u-p-0"
  }, /* @__PURE__ */ react.createElement(FormProvider, {
    ...form2
  }, /* @__PURE__ */ react.createElement(KeycloakTabs, {
    isBox: true
  }, /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "general",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("general")),
    "data-testid": "rs-general-tab",
    "aria-label": "general-tab"
  }, /* @__PURE__ */ react.createElement(RealmSettingsGeneralTab, {
    save,
    reset: () => resetForm(realm2)
  })), /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "login",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("login")),
    "data-testid": "rs-login-tab",
    "aria-label": "login-tab"
  }, /* @__PURE__ */ react.createElement(RealmSettingsLoginTab, {
    save,
    realm: realm2
  })), /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "email",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("email")),
    "data-testid": "rs-email-tab",
    "aria-label": "email-tab"
  }, realm2 && /* @__PURE__ */ react.createElement(RealmSettingsEmailTab, {
    user: currentUser,
    realm: realm2
  })), /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "themes",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("themes")),
    "data-testid": "rs-themes-tab",
    "aria-label": "themes-tab"
  }, /* @__PURE__ */ react.createElement(RealmSettingsThemesTab, {
    save,
    reset: () => resetForm(realm2),
    realm: realm2
  })), /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "keys",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("realm-settings:keys")),
    "data-testid": "rs-keys-tab",
    "aria-label": "keys-tab"
  }, realmComponents && /* @__PURE__ */ react.createElement(Tabs, {
    activeKey: activeTab,
    onSelect: (_23, key2) => setActiveTab(key2)
  }, /* @__PURE__ */ react.createElement(Tab, {
    id: "keysList",
    eventKey: 0,
    "data-testid": "rs-keys-list-tab",
    "aria-label": "keys-list-subtab",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("keysList"))
  }, /* @__PURE__ */ react.createElement(KeysListTab, {
    realmComponents
  })), /* @__PURE__ */ react.createElement(Tab, {
    id: "providers",
    "data-testid": "rs-providers-tab",
    "aria-label": "rs-providers-tab",
    eventKey: 1,
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("providers"))
  }, /* @__PURE__ */ react.createElement(KeysProvidersTab, {
    realmComponents,
    keyProviderComponentTypes: kpComponentTypes,
    refresh
  })))), /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "events",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("events")),
    "data-testid": "rs-realm-events-tab",
    "aria-label": "realm-events-tab"
  }, /* @__PURE__ */ react.createElement(EventsTab, null)), /* @__PURE__ */ react.createElement(Tab, {
    id: "localization",
    eventKey: "localization",
    "data-testid": "rs-localization-tab",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("localization"))
  }, realm2 && /* @__PURE__ */ react.createElement(LocalizationTab, {
    key,
    refresh,
    save,
    reset: () => resetForm(realm2),
    realm: realm2
  })), /* @__PURE__ */ react.createElement(Tab, {
    id: "securityDefences",
    eventKey: "securityDefences",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("securityDefences"))
  }, realm2 && /* @__PURE__ */ react.createElement(SecurityDefences, {
    save,
    reset: () => resetForm(realm2)
  })), /* @__PURE__ */ react.createElement(Tab, {
    id: "sessions",
    eventKey: "sessions",
    "data-testid": "rs-sessions-tab",
    "aria-label": "sessions-tab",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("realm-settings:sessions"))
  }, realm2 && /* @__PURE__ */ react.createElement(RealmSettingsSessionsTab, {
    key,
    realm: realm2
  })), /* @__PURE__ */ react.createElement(Tab, {
    id: "tokens",
    eventKey: "tokens",
    "data-testid": "rs-tokens-tab",
    "aria-label": "tokens-tab",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("realm-settings:tokens"))
  }, /* @__PURE__ */ react.createElement(RealmSettingsTokensTab, {
    reset: () => resetForm(realm2)
  }))))));
};

// build/realm-settings/routes/RealmSettings.js
var RealmSettingsRoute = {
  path: "/:realm/realm-settings/:tab?",
  component: RealmSettingsSection,
  breadcrumb: (t4) => t4("realmSettings"),
  access: "view-realm"
};
var toRealmSettings = (params) => ({
  pathname: generatePath(RealmSettingsRoute.path, params)
});

// build/user/UserForm.js
var import_moment3 = __toModule(require_moment());

// build/components/group/GroupPath.js
var MAX_LENGTH = 20;
var PART = 10;
var truncatePath = (path) => {
  if (path && path.length >= MAX_LENGTH) {
    return path.substr(0, PART) + "..." + path.substr(path.length - PART, path.length);
  }
  return path;
};
var GroupPath = ({
  group: {path},
  onMouseEnter: onMouseEnterProp,
  ...props
}) => {
  const [tooltip2, setTooltip] = react.useState("");
  const onMouseEnter = (event) => {
    setTooltip(path);
    onMouseEnterProp?.(event);
  };
  const text = /* @__PURE__ */ react.createElement("span", {
    onMouseEnter,
    ...props
  }, truncatePath(path));
  return tooltip2 !== "" ? /* @__PURE__ */ react.createElement(Tooltip, {
    content: tooltip2,
    isVisible: true
  }, text) : text;
};

// build/components/group/GroupPickerDialog.js
var GroupPickerDialog = ({
  id: id3,
  type,
  filterGroups,
  text,
  onClose,
  onConfirm
}) => {
  const {t: t4} = useTranslation();
  const adminClient = useAdminClient();
  const [selectedRows, setSelectedRows] = useState([]);
  const [navigation, setNavigation] = useState([]);
  const [groups2, setGroups] = useState([]);
  const [filter3, setFilter] = useState("");
  const [joinedGroups, setJoinedGroups] = useState([]);
  const [groupId, setGroupId] = useState();
  const [max2, setMax] = useState(10);
  const [first, setFirst] = useState(0);
  const currentGroup = () => navigation[navigation.length - 1];
  useFetch(async () => {
    let group;
    let groups22;
    let existingUserGroups;
    if (!groupId) {
      groups22 = await adminClient.groups.find({
        first,
        max: max2 + 1,
        search: filter3
      });
    } else {
      group = await adminClient.groups.findOne({id: groupId});
      groups22 = group.subGroups;
    }
    if (id3) {
      existingUserGroups = await adminClient.users.listGroups({
        id: id3
      });
    }
    return {group, groups: groups22, existingUserGroups};
  }, async ({group: selectedGroup, groups: groups22, existingUserGroups}) => {
    setJoinedGroups(existingUserGroups || []);
    if (selectedGroup) {
      setNavigation([...navigation, selectedGroup]);
    }
    groups22.forEach((group) => {
      group.checked = !!selectedRows.find((r4) => r4.id === group.id);
    });
    setGroups(groups22);
  }, [groupId, filter3, first, max2]);
  const isRowDisabled = (row) => {
    return !![...joinedGroups, ...filterGroups || []].find((group) => group.id === row?.id);
  };
  const hasSubgroups = (group) => {
    return group.subGroups.length !== 0;
  };
  const findSubGroup = (group, name) => {
    if (group.name?.includes(name)) {
      return group;
    }
    if (group.subGroups) {
      for (const g3 of group.subGroups) {
        const found = findSubGroup(g3, name);
        return found;
      }
    }
    return group;
  };
  return /* @__PURE__ */ react.createElement(Modal, {
    variant: ModalVariant.small,
    title: t4(text.title, {
      group1: filterGroups?.[0]?.name,
      group2: currentGroup() ? currentGroup().name : t4("root")
    }),
    isOpen: true,
    onClose,
    actions: [
      /* @__PURE__ */ react.createElement(Button, {
        "data-testid": `${text.ok}-button`,
        key: "confirm",
        variant: "primary",
        form: "group-form",
        onClick: () => {
          onConfirm(type === "selectMany" ? selectedRows : [currentGroup()]);
        },
        isDisabled: type === "selectMany" && selectedRows.length === 0
      }, t4(text.ok))
    ]
  }, /* @__PURE__ */ react.createElement(PaginatingTableToolbar, {
    count: groups2.length,
    first,
    max: max2,
    onNextClick: setFirst,
    onPreviousClick: setFirst,
    onPerPageSelect: (first2, max22) => {
      setFirst(first2);
      setMax(max22);
    },
    inputGroupName: "common:search",
    inputGroupOnEnter: (search) => {
      setFilter(search);
      setFirst(0);
      setMax(10);
      setNavigation([]);
    },
    inputGroupPlaceholder: t4("users:searchForGroups")
  }, /* @__PURE__ */ react.createElement(Breadcrumb, null, navigation.length > 0 && /* @__PURE__ */ react.createElement(BreadcrumbItem, {
    key: "home"
  }, /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: () => {
      setGroupId(void 0);
      setNavigation([]);
    }
  }, t4("groups"))), navigation.map((group, i3) => /* @__PURE__ */ react.createElement(BreadcrumbItem, {
    key: i3
  }, navigation.length - 1 !== i3 && /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: () => {
      setGroupId(group.id);
      setNavigation([...navigation].slice(0, i3));
    }
  }, group.name), navigation.length - 1 === i3 && /* @__PURE__ */ react.createElement(react.Fragment, null, group.name)))), /* @__PURE__ */ react.createElement(DataList, {
    "aria-label": t4("groups"),
    isCompact: true
  }, groups2.slice(0, max2).map((group) => /* @__PURE__ */ react.createElement(DataListItem, {
    className: `join-group-dialog-row-${isRowDisabled(group) ? "disabled" : ""}`,
    "aria-labelledby": group.name,
    key: group.id,
    id: group.id,
    onClick: (e3) => {
      const g3 = filter3 !== "" ? findSubGroup(group, filter3) : group;
      if (isRowDisabled(g3))
        return;
      if (type === "selectOne") {
        setGroupId(g3.id);
      } else if (hasSubgroups(group) && filter3 === "" && e3.target.type !== "checkbox") {
        setGroupId(group.id);
      }
    }
  }, /* @__PURE__ */ react.createElement(DataListItemRow, {
    className: `join-group-dialog-row-${isRowDisabled(group) ? "m-disabled" : ""}`,
    "data-testid": group.name
  }, type === "selectMany" && /* @__PURE__ */ react.createElement(DataListCheck, {
    className: "join-group-modal-check",
    "data-testid": `${group.name}-check`,
    checked: group.checked,
    isDisabled: isRowDisabled(group),
    onChange: (checked) => {
      group.checked = checked;
      let newSelectedRows = [];
      if (!group.checked) {
        newSelectedRows = selectedRows.filter((r4) => r4.id !== group.id);
      } else if (group.checked) {
        newSelectedRows = [
          ...selectedRows,
          filter3 === "" ? group : findSubGroup(group, filter3)
        ];
      }
      setSelectedRows(newSelectedRows);
    },
    "aria-labelledby": "data-list-check"
  }), /* @__PURE__ */ react.createElement(DataListItemCells, {
    dataListCells: [
      /* @__PURE__ */ react.createElement(DataListCell, {
        key: `name-${group.id}`
      }, filter3 === "" ? /* @__PURE__ */ react.createElement(react.Fragment, null, group.name) : /* @__PURE__ */ react.createElement(GroupPath, {
        group: findSubGroup(group, filter3)
      }))
    ]
  }), /* @__PURE__ */ react.createElement(DataListAction, {
    "aria-labelledby": `select-${group.name}`,
    id: `select-${group.name}`,
    "aria-label": t4("groupName"),
    isPlainButtonAction: true
  }, (hasSubgroups(group) && filter3 === "" || type === "selectOne") && /* @__PURE__ */ react.createElement(Button, {
    isDisabled: true,
    variant: "link"
  }, /* @__PURE__ */ react.createElement(AngleRightIcon, null)))))), groups2.length === 0 && filter3 === "" && /* @__PURE__ */ react.createElement(ListEmptyState, {
    hasIcon: false,
    message: t4("groups:moveGroupEmpty"),
    instructions: t4("groups:moveGroupEmptyInstructions")
  }), groups2.length === 0 && filter3 !== "" && /* @__PURE__ */ react.createElement(ListEmptyState, {
    message: t4("common:noSearchResults"),
    instructions: t4("common:noSearchResultsInstructions")
  }))));
};

// build/user/UserForm.js
var UserForm = ({
  form: {handleSubmit, register, errors, watch, control, setValue, reset},
  save,
  editMode,
  onGroupsUpdate
}) => {
  const {t: t4} = useTranslation("users");
  const {realm: realm2} = useRealm();
  const [
    isRequiredUserActionsDropdownOpen,
    setRequiredUserActionsDropdownOpen
  ] = useState(false);
  const history = useHistory();
  const adminClient = useAdminClient();
  const {id: id3} = useParams();
  const watchUsernameInput = watch("username");
  const [user, setUser] = useState();
  const [selectedGroups, setSelectedGroups] = useState([]);
  const {addAlert, addError} = useAlerts();
  const [open2, setOpen] = useState(false);
  useFetch(async () => {
    if (editMode)
      return await adminClient.users.findOne({id: id3});
  }, (user2) => {
    if (user2) {
      setupForm(user2);
      setUser(user2);
    }
  }, [selectedGroups]);
  const setupForm = (user2) => {
    reset();
    Object.entries(user2).map((entry) => {
      setValue(entry[0], entry[1]);
    });
  };
  const requiredUserActionsOptions = [
    /* @__PURE__ */ react.createElement(SelectOption, {
      key: 0,
      value: "CONFIGURE_TOTP"
    }, t4("configureOTP")),
    /* @__PURE__ */ react.createElement(SelectOption, {
      key: 1,
      value: "UPDATE_PASSWORD"
    }, t4("updatePassword")),
    /* @__PURE__ */ react.createElement(SelectOption, {
      key: 2,
      value: "UPDATE_PROFILE"
    }, t4("updateProfile")),
    /* @__PURE__ */ react.createElement(SelectOption, {
      key: 3,
      value: "VERIFY_EMAIL"
    }, t4("verifyEmail"))
  ];
  const clearSelection = () => {
    setRequiredUserActionsDropdownOpen(false);
  };
  const deleteItem = (id22) => {
    setSelectedGroups(selectedGroups.filter((item) => item.name !== id22));
    onGroupsUpdate(selectedGroups);
  };
  const addChips = async (groups2) => {
    setSelectedGroups([...selectedGroups, ...groups2]);
    onGroupsUpdate([...selectedGroups, ...groups2]);
  };
  const addGroups = async (groups2) => {
    const newGroups = groups2;
    newGroups.forEach(async (group) => {
      try {
        await adminClient.users.addToGroup({
          id: id3,
          groupId: group.id
        });
        addAlert(t4("users:addedGroupMembership"), AlertVariant.success);
      } catch (error2) {
        addError("users:addedGroupMembershipError", error2);
      }
    });
  };
  const toggleModal = () => {
    setOpen(!open2);
  };
  return /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    onSubmit: handleSubmit(save),
    role: "manage-users",
    className: "pf-u-mt-lg"
  }, open2 && /* @__PURE__ */ react.createElement(GroupPickerDialog, {
    type: "selectMany",
    text: {
      title: "users:selectGroups",
      ok: "users:join"
    },
    onConfirm: (groups2) => {
      editMode ? addGroups(groups2) : addChips(groups2);
      setOpen(false);
    },
    onClose: () => setOpen(false),
    filterGroups: selectedGroups
  }), editMode && user ? /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:id"),
    fieldId: "kc-id",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    id: user.id,
    value: user.id,
    type: "text",
    isReadOnly: true
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("createdAt"),
    fieldId: "kc-created-at",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    value: (0, import_moment3.default)(user.createdTimestamp).format("MM/DD/YY hh:MM:ss A"),
    type: "text",
    id: "kc-created-at",
    name: "createdTimestamp",
    isReadOnly: true
  }))) : /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("username"),
    fieldId: "kc-username",
    isRequired: true,
    validated: errors.username ? "error" : "default",
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register(),
    type: "text",
    id: "kc-username",
    name: "username",
    isReadOnly: editMode
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("email"),
    fieldId: "kc-description",
    validated: errors.email ? "error" : "default",
    helperTextInvalid: t4("users:emailInvalid")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register({
      pattern: emailRegexPattern
    }),
    type: "email",
    id: "kc-email",
    name: "email",
    "data-testid": "email-input",
    "aria-label": t4("emailInput")
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("emailVerified"),
    fieldId: "kc-email-verified",
    helperTextInvalid: t4("common:required"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "users-help:emailVerified",
      forLabel: t4("emailVerified"),
      forID: t4(`common:helpLabel`, {label: t4("emailVerified")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "emailVerified",
    defaultValue: false,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      "data-testid": "email-verified-switch",
      id: "kc-user-email-verified",
      isDisabled: false,
      onChange: (value2) => onChange(value2),
      isChecked: value,
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("firstName"),
    fieldId: "kc-firstname",
    validated: errors.firstName ? "error" : "default",
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register(),
    "data-testid": "firstName-input",
    type: "text",
    id: "kc-firstname",
    name: "firstName"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("lastName"),
    fieldId: "kc-name",
    validated: errors.lastName ? "error" : "default"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: register(),
    "data-testid": "lastName-input",
    type: "text",
    id: "kc-lastname",
    name: "lastName",
    "aria-label": t4("lastName")
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:enabled"),
    fieldId: "kc-enabled",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "users-help:disabled",
      forLabel: t4("enabled"),
      forID: t4(`common:helpLabel`, {label: t4("enabled")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "enabled",
    defaultValue: true,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      "data-testid": "user-enabled-switch",
      id: "kc-user-enabled",
      onChange: (value2) => onChange(value2),
      isChecked: value,
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("requiredUserActions"),
    fieldId: "kc-required-user-actions",
    validated: errors.requiredActions ? "error" : "default",
    helperTextInvalid: t4("common:required"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "users-help:requiredUserActions",
      forLabel: t4("requiredUserActions"),
      forID: t4(`common:helpLabel`, {label: t4("requiredUserActions")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "requiredActions",
    defaultValue: [],
    typeAheadAriaLabel: "Select an action",
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      "data-testid": "required-actions-select",
      placeholderText: "Select action",
      toggleId: "kc-required-user-actions",
      onToggle: () => setRequiredUserActionsDropdownOpen(!isRequiredUserActionsDropdownOpen),
      isOpen: isRequiredUserActionsDropdownOpen,
      selections: value,
      onSelect: (_23, v3) => {
        const option = v3;
        if (value.includes(option)) {
          onChange(value.filter((item) => item !== option));
        } else {
          onChange([...value, option]);
        }
      },
      onClear: clearSelection,
      variant: "typeaheadmulti"
    }, requiredUserActionsOptions)
  })), !editMode && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:groups"),
    fieldId: "kc-groups",
    validated: errors.requiredActions ? "error" : "default",
    helperTextInvalid: t4("common:required"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "users-help:groups",
      forLabel: t4("common:groups"),
      forID: t4(`common:helpLabel`, {label: t4("common:groups")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "groups",
    defaultValue: [],
    typeAheadAriaLabel: "Select an action",
    control,
    render: () => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(InputGroup, null, /* @__PURE__ */ react.createElement(ChipGroup, {
      categoryName: " "
    }, selectedGroups.map((currentChip) => /* @__PURE__ */ react.createElement(Chip, {
      key: currentChip.id,
      onClick: () => deleteItem(currentChip.name)
    }, currentChip.path))), /* @__PURE__ */ react.createElement(Button, {
      id: "kc-join-groups-button",
      onClick: toggleModal,
      variant: "secondary",
      "data-testid": "join-groups-button"
    }, t4("users:joinGroups"))))
  })), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    "data-testid": !editMode ? "create-user" : "save-user",
    isDisabled: !editMode && !watchUsernameInput,
    variant: "primary",
    type: "submit"
  }, editMode ? t4("common:save") : t4("common:create")), /* @__PURE__ */ react.createElement(Button, {
    "data-testid": "cancel-create-user",
    onClick: () => editMode ? setupForm(user) : history.push(`/${realm2}/users`),
    variant: "link"
  }, editMode ? t4("common:revert") : t4("common:cancel"))));
};

// build/user/UserGroups.js
var UserGroups = () => {
  const {t: t4} = useTranslation("users");
  const {addAlert, addError} = useAlerts();
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const [selectedGroup, setSelectedGroup] = useState();
  const [list3, setList] = useState(false);
  const [listGroups, setListGroups] = useState(true);
  const [search, setSearch] = useState("");
  const [username, setUsername] = useState("");
  const [isDirectMembership, setDirectMembership] = useState(true);
  const [directMembershipList, setDirectMembershipList] = useState([]);
  const [open2, setOpen] = useState(false);
  const {enabled} = useHelp();
  const adminClient = useAdminClient();
  const {id: id3} = useParams();
  const alphabetize = (groupsList) => {
    return lodash.sortBy(groupsList, (group) => group.path?.toUpperCase());
  };
  const loader = async (first, max2, search2) => {
    const params = {
      first,
      max: max2
    };
    const user = await adminClient.users.findOne({id: id3});
    setUsername(user.username);
    const searchParam = search2 || "";
    if (searchParam) {
      params.search = searchParam;
      setSearch(searchParam);
    }
    if (!searchParam && !listGroups && !list3) {
      return [];
    }
    const joinedUserGroups = await adminClient.users.listGroups({
      ...params,
      id: id3
    });
    const allCreatedGroups = await adminClient.groups.find();
    const getAllPaths = joinedUserGroups.reduce((acc, cur) => (cur.path && acc.push(cur.path), acc), []);
    const parentGroupNames = [];
    const allGroupMembership = [];
    const slicedGroups = [];
    const rootLevelGroups = [...allCreatedGroups];
    let allPaths = [];
    const getAllSubgroupPaths = (o, f3, context2) => {
      f3(o, context2);
      if (typeof o !== "object")
        return context2;
      if (Array.isArray(o))
        return o.forEach((e3) => getAllSubgroupPaths(e3, f3, context2)), context2;
      for (const prop in o)
        getAllSubgroupPaths(o[prop], f3, context2);
      return context2;
    };
    const arr = getAllSubgroupPaths(rootLevelGroups, (x3, context2) => {
      if (x3 !== void 0 && x3.subGroups)
        context2.push(x3.subGroups);
    }, []);
    const allSubgroups = [].concat(...arr);
    allPaths = [...rootLevelGroups, ...allSubgroups];
    getAllPaths.forEach((item) => {
      const paths = item.split("/");
      const groups2 = [];
      paths.reduce((acc, value) => {
        const path = acc + "/" + value;
        groups2.push(path);
        return path;
      }, "");
      for (let i3 = 1; i3 < groups2.length; i3++) {
        slicedGroups.push(groups2[i3].substring(1));
      }
    });
    allGroupMembership.push(...slicedGroups);
    allPaths.forEach((item) => {
      if (item.subGroups.length !== 0) {
        allPaths.push(...item.subGroups);
      }
    });
    allPaths = allPaths.filter((group) => allGroupMembership.includes(group.path));
    const topLevelGroups = allCreatedGroups.filter((value) => parentGroupNames.includes(value.name));
    const subgroupArray = [];
    topLevelGroups.forEach((group) => subgroupArray.push(group.subGroups));
    const directMembership = joinedUserGroups.filter((value) => !topLevelGroups.includes(value));
    setDirectMembershipList(directMembership);
    const filterDupesfromGroups = allPaths.filter((thing, index3, self2) => index3 === self2.findIndex((t22) => t22.name === thing.name));
    if (!isDirectMembership) {
      return alphabetize(filterDupesfromGroups);
    }
    return alphabetize(directMembership);
  };
  useFetch(() => adminClient.users.listGroups({id: id3}), (response) => {
    setListGroups(!!(response && response.length > 0));
  }, []);
  useEffect(() => {
    refresh();
  }, [isDirectMembership]);
  const AliasRenderer = (group) => {
    return /* @__PURE__ */ react.createElement(react.Fragment, null, group.name);
  };
  const toggleModal = () => {
    setOpen(!open2);
  };
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: t4("leaveGroup", {
      name: selectedGroup?.name
    }),
    messageKey: t4("leaveGroupConfirmDialog", {
      groupname: selectedGroup?.name,
      username
    }),
    continueButtonLabel: "leave",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        await adminClient.users.delFromGroup({
          id: id3,
          groupId: selectedGroup.id
        });
        refresh();
        addAlert(t4("removedGroupMembership"), AlertVariant.success);
      } catch (error2) {
        addError("users:removedGroupMembershipError", error2);
      }
    }
  });
  const leave = (group) => {
    setSelectedGroup(group);
    toggleDeleteDialog();
  };
  const LeaveButtonRenderer = (group) => {
    const canLeaveGroup = directMembershipList.some((item) => item.id === group.id) || directMembershipList.length === 0 || isDirectMembership;
    return /* @__PURE__ */ react.createElement(react.Fragment, null, canLeaveGroup && /* @__PURE__ */ react.createElement(Button, {
      "data-testid": `leave-${group.name}`,
      onClick: () => leave(group),
      variant: "link"
    }, t4("leave")));
  };
  const addGroups = async (groups2) => {
    const newGroups = groups2;
    newGroups.forEach(async (group) => {
      try {
        await adminClient.users.addToGroup({
          id: id3,
          groupId: group.id
        });
        setList(true);
        refresh();
        addAlert(t4("addedGroupMembership"), AlertVariant.success);
      } catch (error2) {
        addError("users:addedGroupMembershipError", error2);
      }
    });
  };
  const Path = (group) => /* @__PURE__ */ react.createElement(GroupPath, {
    group
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DeleteConfirm, null), open2 && /* @__PURE__ */ react.createElement(GroupPickerDialog, {
    id: id3,
    type: "selectMany",
    text: {
      title: t4("joinGroupsFor", {username}),
      ok: "users:join"
    },
    onClose: () => setOpen(false),
    onConfirm: (groups2) => {
      addGroups(groups2);
      setOpen(false);
    }
  }), /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    loader,
    className: "keycloak_user-section_groups-table",
    isPaginated: true,
    ariaLabelKey: "roles:roleList",
    searchPlaceholderKey: "groups:searchGroup",
    canSelectAll: true,
    toolbarItem: /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Button, {
      className: "kc-join-group-button",
      key: "join-group-button",
      onClick: toggleModal,
      "data-testid": "add-group-button"
    }, t4("joinGroup")), /* @__PURE__ */ react.createElement(Checkbox, {
      label: t4("directMembership"),
      key: "direct-membership-check",
      id: "kc-direct-membership-checkbox",
      onChange: () => setDirectMembership(!isDirectMembership),
      isChecked: isDirectMembership,
      className: "direct-membership-check"
    }), enabled && /* @__PURE__ */ react.createElement(Popover, {
      "aria-label": "Basic popover",
      position: "bottom",
      bodyContent: /* @__PURE__ */ react.createElement("div", null, t4("whoWillAppearPopoverText"))
    }, /* @__PURE__ */ react.createElement(Button, {
      variant: "link",
      className: "kc-who-will-appear-button",
      key: "who-will-appear-button",
      icon: /* @__PURE__ */ react.createElement(QuestionCircleIcon, null)
    }, t4("whoWillAppearLinkText")))),
    columns: [
      {
        name: "groupMembership",
        displayKey: "users:groupMembership",
        cellRenderer: AliasRenderer,
        cellFormatters: [emptyFormatter()],
        transforms: [cellWidth(40)]
      },
      {
        name: "path",
        displayKey: "users:path",
        cellRenderer: Path,
        transforms: [cellWidth(45)]
      },
      {
        name: "",
        cellRenderer: LeaveButtonRenderer,
        cellFormatters: [emptyFormatter()],
        transforms: [cellWidth(20)]
      }
    ],
    emptyState: !search ? /* @__PURE__ */ react.createElement(ListEmptyState, {
      hasIcon: true,
      message: t4("noGroups"),
      instructions: t4("noGroupsText"),
      primaryActionText: t4("joinGroup"),
      onPrimaryAction: toggleModal
    }) : ""
  }));
};

// build/user/UserConsents.js
var import_moment4 = __toModule(require_moment());
var UserConsents = () => {
  const [selectedClient, setSelectedClient] = useState();
  const {t: t4} = useTranslation("roles");
  const {addAlert, addError} = useAlerts();
  const [key, setKey] = useState(0);
  const adminClient = useAdminClient();
  const {id: id3} = useParams();
  const alphabetize = (consentsList) => {
    return lodash.sortBy(consentsList, (client2) => client2.clientId?.toUpperCase());
  };
  const refresh = () => setKey(new Date().getTime());
  const loader = async () => {
    const getConsents = await adminClient.users.listConsents({id: id3});
    return alphabetize(getConsents);
  };
  const clientScopesRenderer = ({
    grantedClientScopes
  }) => {
    return /* @__PURE__ */ react.createElement(ChipGroup, {
      className: "kc-consents-chip-group"
    }, grantedClientScopes.map((currentChip) => /* @__PURE__ */ react.createElement(Chip, {
      key: currentChip,
      isReadOnly: true,
      className: "kc-consents-chip",
      id: "consents-chip-text"
    }, currentChip)));
  };
  const createdRenderer = ({createDate}) => {
    return /* @__PURE__ */ react.createElement(react.Fragment, null, (0, import_moment4.default)(createDate).format("MM/DD/YY hh:MM A"));
  };
  const lastUpdatedRenderer = ({
    lastUpdatedDate
  }) => {
    return /* @__PURE__ */ react.createElement(react.Fragment, null, (0, import_moment4.default)(lastUpdatedDate).format("MM/DD/YY hh:MM A"));
  };
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: "users:revokeClientScopesTitle",
    messageKey: t4("users:revokeClientScopes", {
      clientId: selectedClient?.clientId
    }),
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        await adminClient.users.revokeConsent({
          id: id3,
          clientId: selectedClient.clientId
        });
        refresh();
        addAlert(t4("deleteGrantsSuccess"), AlertVariant.success);
      } catch (error2) {
        addError("roles:deleteGrantsError", error2);
      }
    }
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DeleteConfirm, null), /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    loader,
    key,
    ariaLabelKey: "roles:roleList",
    searchPlaceholderKey: " ",
    columns: [
      {
        name: "clientId",
        displayKey: "clients:Client",
        cellFormatters: [emptyFormatter()],
        transforms: [cellWidth(20)]
      },
      {
        name: "grantedClientScopes",
        displayKey: "client-scopes:grantedClientScopes",
        cellFormatters: [emptyFormatter()],
        cellRenderer: clientScopesRenderer,
        transforms: [cellWidth(30)]
      },
      {
        name: "createdDate",
        displayKey: "clients:created",
        cellFormatters: [emptyFormatter()],
        cellRenderer: createdRenderer,
        transforms: [cellWidth(20)]
      },
      {
        name: "lastUpdatedDate",
        displayKey: "clients:lastUpdated",
        cellFormatters: [emptyFormatter()],
        cellRenderer: lastUpdatedRenderer,
        transforms: [cellWidth(10)]
      }
    ],
    actions: [
      {
        title: t4("users:revoke"),
        onRowClick: (client2) => {
          setSelectedClient(client2);
          toggleDeleteDialog();
        }
      }
    ],
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      hasIcon: true,
      icon: CubesIcon,
      message: t4("users:noConsents"),
      instructions: t4("users:noConsentsText")
    })
  }));
};

// build/user/UsersTabs.js
var UsersTabs = () => {
  const {t: t4} = useTranslation("roles");
  const {addAlert, addError} = useAlerts();
  const history = useHistory();
  const {realm: realm2} = useRealm();
  const adminClient = useAdminClient();
  const userForm = useForm({mode: "onChange"});
  const {id: id3} = useParams();
  const [user, setUser] = useState("");
  const [addedGroups, setAddedGroups] = useState([]);
  useEffect(() => {
    const update = async () => {
      if (id3) {
        const fetchedUser = await adminClient.users.findOne({id: id3});
        setUser(fetchedUser.username);
      }
    };
    setTimeout(update, 100);
  }, []);
  const updateGroups = (groups2) => {
    setAddedGroups(groups2);
  };
  const save = async (user2) => {
    try {
      if (id3) {
        await adminClient.users.update({id: id3}, user2);
        addAlert(t4("users:userSaved"), AlertVariant.success);
      } else {
        const createdUser = await adminClient.users.create(user2);
        addedGroups.forEach(async (group) => {
          await adminClient.users.addToGroup({
            id: createdUser.id,
            groupId: group.id
          });
        });
        addAlert(t4("users:userCreated"), AlertVariant.success);
        history.push(`/${realm2}/users/${createdUser.id}/settings`);
      }
    } catch (error2) {
      addError("users:userCreateError", error2);
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: user || t4("users:createUser"),
    divider: !id3
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    className: "pf-u-p-0"
  }, id3 && /* @__PURE__ */ react.createElement(KeycloakTabs, {
    isBox: true
  }, /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "settings",
    "data-testid": "user-details-tab",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("details"))
  }, /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(UserForm, {
    onGroupsUpdate: updateGroups,
    form: userForm,
    save,
    editMode: true
  }))), /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "groups",
    "data-testid": "user-groups-tab",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("groups"))
  }, /* @__PURE__ */ react.createElement(UserGroups, null)), /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "consents",
    "data-testid": "user-consents-tab",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("users:consents"))
  }, /* @__PURE__ */ react.createElement(UserConsents, null))), !id3 && /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(UserForm, {
    onGroupsUpdate: updateGroups,
    form: userForm,
    save,
    editMode: false
  }))));
};

// build/user/routes/User.js
var UserRoute = {
  path: "/:realm/users/:id/:tab",
  component: UsersTabs,
  breadcrumb: (t4) => t4("users:userDetails"),
  access: "manage-users"
};
var toUser = (params) => ({
  pathname: generatePath(UserRoute.path, params)
});

// build/events/AdminEvents.js
var import_moment5 = __toModule(require_moment());
var DisplayDialog = ({
  titleKey,
  onClose,
  children: children2
}) => {
  const {t: t4} = useTranslation("events");
  return /* @__PURE__ */ react.createElement(Modal, {
    variant: ModalVariant.medium,
    title: t4(titleKey),
    isOpen: true,
    onClose
  }, children2);
};
var MAX_TEXT_LENGTH = 38;
var Truncate = ({
  text,
  children: children2
}) => {
  const definedText = text || "";
  const needsTruncation = definedText.length > MAX_TEXT_LENGTH;
  const truncatedText = definedText.substr(0, MAX_TEXT_LENGTH);
  return /* @__PURE__ */ react.createElement(react.Fragment, null, needsTruncation && /* @__PURE__ */ react.createElement(Tooltip, {
    content: text
  }, children2(truncatedText + "...")), !needsTruncation && /* @__PURE__ */ react.createElement(react.Fragment, null, children2(definedText)));
};
var AdminEvents = () => {
  const {t: t4} = useTranslation("events");
  const adminClient = useAdminClient();
  const {realm: realm2} = useRealm();
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const [authEvent, setAuthEvent] = useState();
  const [representationEvent, setRepresentationEvent] = useState();
  const loader = async (first, max2, search) => {
    const params = {
      first,
      max: max2,
      realm: realm2
    };
    if (search) {
      console.log("how to search?", search);
    }
    return await adminClient.realms.findAdminEvents({...params});
  };
  const LinkResource = (row) => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Truncate, {
    text: row.resourcePath
  }, (text) => /* @__PURE__ */ react.createElement(react.Fragment, null, row.resourceType !== "COMPONENT" && /* @__PURE__ */ react.createElement(Link, {
    to: `/${realm2}/${row.resourcePath}${row.resourceType !== "GROUP" ? "/settings" : ""}`
  }, text), row.resourceType === "COMPONENT" && /* @__PURE__ */ react.createElement("span", null, text))));
  return /* @__PURE__ */ react.createElement(react.Fragment, null, authEvent && /* @__PURE__ */ react.createElement(DisplayDialog, {
    titleKey: "auth",
    onClose: () => setAuthEvent(void 0)
  }, /* @__PURE__ */ react.createElement(Table, {
    "aria-label": "authData",
    variant: TableVariant.compact,
    cells: [t4("attribute"), t4("value")],
    rows: Object.entries(authEvent.authDetails)
  }, /* @__PURE__ */ react.createElement(TableHeader, null), /* @__PURE__ */ react.createElement(TableBody, null))), representationEvent && /* @__PURE__ */ react.createElement(DisplayDialog, {
    titleKey: "representation",
    onClose: () => setRepresentationEvent(void 0)
  }, "some json from the changed values"), /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    loader,
    isPaginated: true,
    ariaLabelKey: "events:adminEvents",
    searchPlaceholderKey: "events:searchForEvent",
    toolbarItem: /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      onClick: refresh
    }, t4("refresh")))),
    actions: [
      {
        title: t4("auth"),
        onRowClick: (event) => setAuthEvent(event)
      },
      {
        title: t4("representation"),
        onRowClick: (event) => setRepresentationEvent(event)
      }
    ],
    columns: [
      {
        name: "time",
        displayKey: "events:time",
        cellRenderer: (row) => (0, import_moment5.default)(row.time).format("LLL")
      },
      {
        name: "resourcePath",
        displayKey: "events:resourcePath",
        cellRenderer: LinkResource
      },
      {
        name: "resourceType",
        displayKey: "events:resourceType"
      },
      {
        name: "operationType",
        displayKey: "events:operationType",
        transforms: [cellWidth(10)]
      },
      {
        name: "",
        displayKey: "events:user",
        cellRenderer: (event) => event.authDetails?.userId
      }
    ],
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      message: t4("emptyEvents"),
      instructions: t4("emptyEventsInstructions")
    })
  }));
};

// build/events/EventsSection.js
var EventsSection = () => {
  const {t: t4} = useTranslation("events");
  const adminClient = useAdminClient();
  const {realm: realm2} = useRealm();
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const loader = async (first, max2, search) => {
    const params = {
      first,
      max: max2,
      realm: realm2
    };
    if (search) {
      console.log("how to search?", search);
    }
    return await adminClient.realms.findEvents({...params});
  };
  const StatusRow = (event) => /* @__PURE__ */ react.createElement(react.Fragment, null, !event.error && /* @__PURE__ */ react.createElement("span", {
    key: `status-${event.time}-${event.type}`
  }, /* @__PURE__ */ react.createElement(CheckCircleIcon, {
    color: "green",
    key: `circle-${event.time}-${event.type}`
  }), " ", event.type), event.error && /* @__PURE__ */ react.createElement(Tooltip, {
    content: event.error,
    key: `tooltip-${event.time}-${event.type}`
  }, /* @__PURE__ */ react.createElement("span", {
    key: `label-${event.time}-${event.type}`
  }, /* @__PURE__ */ react.createElement(WarningTriangleIcon, {
    color: "orange",
    key: `triangle-${event.time}-${event.type}`
  }), " ", event.type)));
  const UserDetailLink = (event) => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Link, {
    key: `link-${event.time}-${event.type}`,
    to: toUser({realm: realm2, id: event.userId, tab: "settings"})
  }, event.userId));
  const DetailCell = (event) => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DescriptionList, {
    isHorizontal: true,
    className: "keycloak_eventsection_details"
  }, Object.keys(event.details).map((k3) => /* @__PURE__ */ react.createElement(DescriptionListGroup, {
    key: `detail-${event.time}-${event.type}`
  }, /* @__PURE__ */ react.createElement(DescriptionListTerm, null, k3), /* @__PURE__ */ react.createElement(DescriptionListDescription, null, event.details[k3])))));
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: "events:title",
    subKey: /* @__PURE__ */ react.createElement(Trans, {
      i18nKey: "events:eventExplain"
    }, "If you want to configure user events, Admin events or Event listeners, please enter", /* @__PURE__ */ react.createElement(Link, {
      to: toRealmSettings({realm: realm2, tab: "events"})
    }, t4("eventConfig")), "page realm settings to configure."),
    divider: false
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    className: "pf-u-p-0"
  }, /* @__PURE__ */ react.createElement(KeycloakTabs, {
    isBox: true
  }, /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "userEvents",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("userEvents"))
  }, /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    loader,
    detailColumns: [
      {
        name: "details",
        enabled: (event) => event.details !== void 0,
        cellRenderer: DetailCell
      }
    ],
    isPaginated: true,
    ariaLabelKey: "events:title",
    searchPlaceholderKey: "events:searchForEvent",
    toolbarItem: /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      onClick: refresh
    }, t4("refresh")))),
    columns: [
      {
        name: "time",
        displayKey: "events:time",
        cellRenderer: (row) => (0, import_moment6.default)(row.time).format("LLL"),
        cellFormatters: [expandable]
      },
      {
        name: "userId",
        displayKey: "events:user",
        cellRenderer: UserDetailLink
      },
      {
        name: "type",
        displayKey: "events:eventType",
        cellRenderer: StatusRow
      },
      {
        name: "ipAddress",
        displayKey: "events:ipAddress",
        transforms: [cellWidth(10)]
      },
      {
        name: "clientId",
        displayKey: "events:client"
      }
    ],
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      message: t4("emptyEvents"),
      instructions: t4("emptyEventsInstructions")
    })
  })), /* @__PURE__ */ react.createElement(Tab, {
    eventKey: "adminEvents",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("adminEvents"))
  }, /* @__PURE__ */ react.createElement(AdminEvents, null)))));
};

// build/events/routes/Events.js
var EventsRoute = {
  path: "/:realm/events/:tab?",
  component: EventsSection,
  breadcrumb: (t4) => t4("events:title"),
  access: "view-events"
};

// build/events/routes.js
var routes5 = [EventsRoute];
var routes_default5 = routes5;

// build/groups/SubGroupsContext.js
var SubGroupContext = createContext(void 0);
var SubGroups = ({children: children2}) => {
  const [subGroups, setSubGroups] = useState([]);
  const clear = () => setSubGroups([]);
  const remove3 = (group) => setSubGroups(subGroups.slice(0, subGroups.findIndex((g3) => g3.id === group.id) + 1));
  const currentGroup = () => subGroups[subGroups.length - 1];
  return /* @__PURE__ */ react.createElement(SubGroupContext.Provider, {
    value: {subGroups, setSubGroups, clear, remove: remove3, currentGroup}
  }, children2);
};
var useSubGroups = () => useRequiredContext(SubGroupContext);

// build/groups/GroupsModal.js
var GroupsModal = ({
  id: id3,
  rename,
  handleModalToggle,
  refresh
}) => {
  const {t: t4} = useTranslation("groups");
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const {register, errors, handleSubmit} = useForm({
    defaultValues: {name: rename}
  });
  const submitForm = async (group) => {
    try {
      if (!id3) {
        await adminClient.groups.create(group);
      } else if (rename) {
        await adminClient.groups.update({id: id3}, group);
      } else {
        await adminClient.groups.setOrCreateChild({id: id3}, group);
      }
      refresh(rename ? group : void 0);
      handleModalToggle();
      addAlert(t4(rename ? "groupUpdated" : "groupCreated"), AlertVariant.success);
    } catch (error2) {
      addError("groups:couldNotCreateGroup", error2);
    }
  };
  return /* @__PURE__ */ react.createElement(Modal, {
    variant: ModalVariant.small,
    title: t4(rename ? "renameAGroup" : "createAGroup"),
    isOpen: true,
    onClose: handleModalToggle,
    actions: [
      /* @__PURE__ */ react.createElement(Button, {
        "data-testid": `${rename ? "rename" : "create"}Group`,
        key: "confirm",
        variant: "primary",
        type: "submit",
        form: "group-form"
      }, t4(rename ? "rename" : "create")),
      /* @__PURE__ */ react.createElement(Button, {
        id: "modal-cancel",
        key: "cancel",
        variant: ButtonVariant.link,
        onClick: () => {
          handleModalToggle();
        }
      }, t4("common:cancel"))
    ]
  }, /* @__PURE__ */ react.createElement(Form, {
    id: "group-form",
    isHorizontal: true,
    onSubmit: handleSubmit(submitForm)
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    name: "create-modal-group",
    label: t4("common:name"),
    fieldId: "group-id",
    helperTextInvalid: t4("common:required"),
    validated: errors.name ? ValidatedOptions.error : ValidatedOptions.default,
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    "data-testid": "groupNameInput",
    "aria-label": "group name input",
    ref: register({required: true}),
    autoFocus: true,
    type: "text",
    id: "create-group-name",
    name: "name",
    validated: errors.name ? ValidatedOptions.error : ValidatedOptions.default
  }))));
};

// build/groups/groupIdUtils.js
var getId = (pathname) => {
  const pathParts = pathname.substr(1).split("/");
  return pathParts.length > 1 ? pathParts.splice(2) : void 0;
};
var getLastId = (pathname) => {
  const pathParts = getId(pathname);
  return pathParts ? pathParts[pathParts.length - 1] : void 0;
};

// build/groups/GroupTable.js
var GroupTable = () => {
  const {t: t4} = useTranslation("groups");
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const {realm: realm2} = useRealm();
  const [isKebabOpen, setIsKebabOpen] = useState(false);
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
  const [selectedRows, setSelectedRows] = useState([]);
  const [move, setMove] = useState();
  const {subGroups, setSubGroups} = useSubGroups();
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const history = useHistory();
  const location2 = useLocation();
  const id3 = getLastId(location2.pathname);
  const loader = async () => {
    const groupsData = id3 ? (await adminClient.groups.findOne({id: id3})).subGroups : await adminClient.groups.find({
      briefRepresentation: false
    });
    if (!groupsData) {
      history.push(`/${realm2}/groups`);
    }
    return groupsData || [];
  };
  const multiDelete = async () => {
    try {
      for (const group of selectedRows) {
        await adminClient.groups.del({
          id: group.id
        });
      }
      addAlert(t4("groupDeleted", {count: selectedRows.length}), AlertVariant.success);
      setSelectedRows([]);
    } catch (error2) {
      addError("groups:groupDeleteError", error2);
    }
    refresh();
  };
  const GroupNameCell = (group) => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Link, {
    key: group.id,
    to: `${location2.pathname}/${group.id}`,
    onClick: () => {
      setSubGroups([...subGroups, group]);
    }
  }, group.name));
  const handleModalToggle = () => {
    setIsCreateModalOpen(!isCreateModalOpen);
  };
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: t4("deleteConfirmTitle", {count: selectedRows.length}),
    messageKey: t4("deleteConfirm", {count: selectedRows.length}),
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: multiDelete
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DeleteConfirm, null), /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key: `${id3}${key}`,
    onSelect: (rows) => setSelectedRows([...rows]),
    canSelectAll: false,
    loader,
    ariaLabelKey: "groups:groups",
    searchPlaceholderKey: "groups:searchForGroups",
    toolbarItem: /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      "data-testid": "openCreateGroupModal",
      variant: "primary",
      onClick: handleModalToggle
    }, t4("createGroup"))), /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Dropdown, {
      toggle: /* @__PURE__ */ react.createElement(KebabToggle, {
        onToggle: () => setIsKebabOpen(!isKebabOpen),
        isDisabled: selectedRows.length === 0
      }),
      isOpen: isKebabOpen,
      isPlain: true,
      dropdownItems: [
        /* @__PURE__ */ react.createElement(DropdownItem, {
          key: "action",
          component: "button",
          onClick: () => {
            toggleDeleteDialog();
            setIsKebabOpen(false);
          }
        }, t4("common:delete"))
      ]
    }))),
    actions: [
      {
        title: t4("moveTo"),
        onRowClick: async (group) => {
          setMove(group);
          return false;
        }
      },
      {
        title: t4("common:delete"),
        onRowClick: async (group) => {
          setSelectedRows([group]);
          toggleDeleteDialog();
          return true;
        }
      }
    ],
    columns: [
      {
        name: "name",
        displayKey: "groups:groupName",
        cellRenderer: GroupNameCell,
        transforms: [cellWidth(90)]
      }
    ],
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      hasIcon: true,
      message: t4(`noGroupsInThis${id3 ? "SubGroup" : "Realm"}`),
      instructions: t4(`noGroupsInThis${id3 ? "SubGroup" : "Realm"}Instructions`),
      primaryActionText: t4("createGroup"),
      onPrimaryAction: handleModalToggle
    })
  }), isCreateModalOpen && /* @__PURE__ */ react.createElement(GroupsModal, {
    id: id3,
    handleModalToggle,
    refresh
  }), move && /* @__PURE__ */ react.createElement(GroupPickerDialog, {
    type: "selectOne",
    filterGroups: [move],
    text: {
      title: "groups:moveToGroup",
      ok: "groups:moveHere"
    },
    onClose: () => setMove(void 0),
    onConfirm: async (group) => {
      try {
        try {
          if (group[0].id) {
            await adminClient.groups.setOrCreateChild({id: group[0].id}, move);
          } else {
            await adminClient.groups.create(move);
          }
        } catch (error2) {
          if (error2.response) {
            throw error2;
          }
        }
        setMove(void 0);
        refresh();
        addAlert(t4("moveGroupSuccess"), AlertVariant.success);
      } catch (error2) {
        addError("groups:moveGroupError", error2);
      }
    }
  }));
};

// build/groups/MembersModal.js
var MemberModal = ({groupId, onClose}) => {
  const {t: t4} = useTranslation("groups");
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const [selectedRows, setSelectedRows] = useState([]);
  const history = useHistory();
  const {realm: realm2} = useRealm();
  const goToCreate = () => history.push(`/${realm2}/users/add-user`);
  const loader = async (first, max2, search) => {
    const members = await adminClient.groups.listMembers({id: groupId});
    const params = {
      first,
      max: max2 + members.length,
      search: search || ""
    };
    try {
      const users2 = await adminClient.users.find({...params});
      return lodash.differenceBy(users2, members, "id").slice(0, max2);
    } catch (error2) {
      addError("groups:noUsersFoundError", error2);
      return [];
    }
  };
  return /* @__PURE__ */ react.createElement(Modal, {
    variant: ModalVariant.large,
    title: t4("addMember"),
    isOpen: true,
    onClose,
    actions: [
      /* @__PURE__ */ react.createElement(Button, {
        "data-testid": "add",
        key: "confirm",
        variant: "primary",
        onClick: async () => {
          try {
            await Promise.all(selectedRows.map((user) => adminClient.users.addToGroup({id: user.id, groupId})));
            onClose();
            addAlert(t4("usersAdded", {count: selectedRows.length}), AlertVariant.success);
          } catch (error2) {
            addError("groups:usersAddedError", error2);
          }
        }
      }, t4("common:add")),
      /* @__PURE__ */ react.createElement(Button, {
        "data-testid": "cancel",
        key: "cancel",
        variant: "link",
        onClick: onClose
      }, t4("common:cancel"))
    ]
  }, /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    loader,
    isPaginated: true,
    ariaLabelKey: "users:title",
    searchPlaceholderKey: "users:searchForUser",
    canSelectAll: true,
    onSelect: (rows) => setSelectedRows([...rows]),
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      message: t4("users:noUsersFound"),
      instructions: t4("users:emptyInstructions"),
      primaryActionText: t4("users:createNewUser"),
      onPrimaryAction: goToCreate
    }),
    columns: [
      {
        name: "username",
        displayKey: "users:username"
      },
      {
        name: "email",
        displayKey: "users:email"
      },
      {
        name: "lastName",
        displayKey: "users:lastName",
        cellFormatters: [emptyFormatter()]
      },
      {
        name: "firstName",
        displayKey: "users:firstName",
        cellFormatters: [emptyFormatter()]
      }
    ]
  }));
};

// build/groups/Members.js
var Members = () => {
  const {t: t4} = useTranslation("groups");
  const adminClient = useAdminClient();
  const {realm: realm2} = useRealm();
  const {addAlert, addError} = useAlerts();
  const location2 = useLocation();
  const id3 = getLastId(location2.pathname);
  const [includeSubGroup, setIncludeSubGroup] = useState(false);
  const {currentGroup} = useSubGroups();
  const [addMembers, setAddMembers] = useState(false);
  const [isKebabOpen, setIsKebabOpen] = useState(false);
  const [selectedRows, setSelectedRows] = useState([]);
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const getMembership = async (id22) => await adminClient.users.listGroups({id: id22});
  const getSubGroups = (groups2) => {
    let subGroups = [];
    for (const group of groups2) {
      subGroups.push(group);
      const subs = getSubGroups(group.subGroups);
      subGroups = subGroups.concat(subs);
    }
    return subGroups;
  };
  const loader = async (first, max2) => {
    let members = await adminClient.groups.listMembers({
      id: id3,
      first,
      max: max2
    });
    if (includeSubGroup) {
      const subGroups = getSubGroups(currentGroup().subGroups);
      for (const group of subGroups) {
        members = members.concat(await adminClient.groups.listMembers({id: group.id}));
      }
      members = lodash.uniqBy(members, (member) => member.username);
    }
    const memberOfPromises = await Promise.all(members.map((member) => getMembership(member.id)));
    return members.map((member, i3) => {
      return {...member, membership: memberOfPromises[i3]};
    });
  };
  const MemberOfRenderer = (member) => {
    return /* @__PURE__ */ react.createElement(react.Fragment, null, member.membership.map((group, index3) => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(GroupPath, {
      key: group.id,
      group
    }), member.membership[index3 + 1] ? ", " : "")));
  };
  const UserDetailLink = (user) => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Link, {
    key: user.id,
    to: toUser({realm: realm2, id: user.id, tab: "settings"})
  }, user.username));
  return /* @__PURE__ */ react.createElement(react.Fragment, null, addMembers && /* @__PURE__ */ react.createElement(MemberModal, {
    groupId: id3,
    onClose: () => {
      setAddMembers(false);
      refresh();
    }
  }), /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key: `${id3}${key}${includeSubGroup}`,
    loader,
    ariaLabelKey: "groups:members",
    isPaginated: true,
    canSelectAll: true,
    onSelect: (rows) => setSelectedRows([...rows]),
    toolbarItem: /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      "data-testid": "addMember",
      variant: "primary",
      onClick: () => setAddMembers(true)
    }, t4("addMember"))), /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Checkbox, {
      "data-testid": "includeSubGroupsCheck",
      label: t4("includeSubGroups"),
      id: "kc-include-sub-groups",
      isChecked: includeSubGroup,
      onChange: () => setIncludeSubGroup(!includeSubGroup)
    })), /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Dropdown, {
      toggle: /* @__PURE__ */ react.createElement(KebabToggle, {
        onToggle: () => setIsKebabOpen(!isKebabOpen),
        isDisabled: selectedRows.length === 0
      }),
      isOpen: isKebabOpen,
      isPlain: true,
      dropdownItems: [
        /* @__PURE__ */ react.createElement(DropdownItem, {
          key: "action",
          component: "button",
          onClick: async () => {
            try {
              await Promise.all(selectedRows.map((user) => adminClient.users.delFromGroup({
                id: user.id,
                groupId: id3
              })));
              setIsKebabOpen(false);
              addAlert(t4("usersLeft", {count: selectedRows.length}), AlertVariant.success);
            } catch (error2) {
              addError("groups:usersLeftError", error2);
            }
            refresh();
          }
        }, t4("leave"))
      ]
    }))),
    actions: [
      {
        title: t4("leave"),
        onRowClick: async (user) => {
          try {
            await adminClient.users.delFromGroup({
              id: user.id,
              groupId: id3
            });
            addAlert(t4("usersLeft", {count: 1}), AlertVariant.success);
          } catch (error2) {
            addError("groups:usersLeftError", error2);
          }
          return true;
        }
      }
    ],
    columns: [
      {
        name: "username",
        displayKey: "common:name",
        cellRenderer: UserDetailLink
      },
      {
        name: "email",
        displayKey: "groups:email",
        cellFormatters: [emptyFormatter()]
      },
      {
        name: "firstName",
        displayKey: "groups:firstName",
        cellFormatters: [emptyFormatter()]
      },
      {
        name: "lastName",
        displayKey: "groups:lastName",
        cellFormatters: [emptyFormatter()]
      },
      {
        name: "membership",
        displayKey: "groups:membership",
        cellRenderer: MemberOfRenderer
      }
    ],
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      message: t4("users:noUsersFound"),
      instructions: t4("users:emptyInstructions"),
      primaryActionText: t4("addMember"),
      onPrimaryAction: () => setAddMembers(true)
    })
  }));
};

// build/groups/GroupAttributes.js
var GroupAttributes = () => {
  const {t: t4} = useTranslation("groups");
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const form2 = useForm({mode: "onChange"});
  const {fields, append, remove: remove3} = useFieldArray({
    control: form2.control,
    name: "attributes"
  });
  const location2 = useLocation();
  const id3 = getLastId(location2.pathname);
  const {currentGroup, subGroups, setSubGroups} = useSubGroups();
  const convertAttributes = (attr2) => {
    const attributes = attributesToArray(attr2 || currentGroup().attributes);
    attributes.push({key: "", value: ""});
    return attributes;
  };
  useEffect(() => {
    form2.setValue("attributes", convertAttributes());
  }, [subGroups]);
  const save = async (attributeForm) => {
    try {
      const group = currentGroup();
      const attributes = arrayToAttributes(attributeForm.attributes);
      await adminClient.groups.update({id: id3}, {...group, attributes});
      setSubGroups([
        ...subGroups.slice(0, subGroups.length - 1),
        {...group, attributes}
      ]);
      form2.setValue("attributes", convertAttributes(attributes));
      addAlert(t4("groupUpdated"), AlertVariant.success);
    } catch (error2) {
      addError("groups:groupUpdateError", error2);
    }
  };
  return /* @__PURE__ */ react.createElement(PageSection, {
    variant: PageSectionVariants.light
  }, /* @__PURE__ */ react.createElement(AttributesForm, {
    form: form2,
    save,
    array: {fields, append, remove: remove3},
    reset: () => form2.reset({
      attributes: convertAttributes()
    })
  }));
};

// build/groups/GroupsSection.js
var GroupsSection = () => {
  const {t: t4} = useTranslation("groups");
  const [activeTab, setActiveTab] = useState(0);
  const adminClient = useAdminClient();
  const {subGroups, setSubGroups, currentGroup} = useSubGroups();
  const {addAlert, addError} = useAlerts();
  const {realm: realm2} = useRealm();
  const [rename, setRename] = useState();
  const history = useHistory();
  const location2 = useLocation();
  const id3 = getLastId(location2.pathname);
  const deleteGroup = async (group) => {
    try {
      await adminClient.groups.del({
        id: group.id
      });
      addAlert(t4("groupDelete"), AlertVariant.success);
    } catch (error2) {
      addError("groups:groupDeleteError", error2);
    }
    return true;
  };
  useFetch(async () => {
    const ids = getId(location2.pathname);
    const isNavigationStateInValid = ids && ids.length > subGroups.length;
    if (isNavigationStateInValid) {
      const groups2 = [];
      for (const i3 of ids) {
        const group = await adminClient.groups.findOne({id: i3});
        if (group)
          groups2.push(group);
      }
      return groups2;
    }
    return [];
  }, (groups2) => {
    if (groups2.length)
      setSubGroups(groups2);
  }, [id3]);
  const SearchDropdown = /* @__PURE__ */ react.createElement(DropdownItem, {
    "data-testid": "searchGroup",
    key: "searchGroup",
    onClick: () => history.push(`/${realm2}/groups/search`)
  }, t4("searchGroup"));
  return /* @__PURE__ */ react.createElement(react.Fragment, null, rename && /* @__PURE__ */ react.createElement(GroupsModal, {
    id: id3,
    rename,
    refresh: (group) => setSubGroups([...subGroups.slice(0, subGroups.length - 1), group]),
    handleModalToggle: () => setRename(void 0)
  }), /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: !id3 ? "groups:groups" : currentGroup()?.name,
    subKey: !id3 ? "groups:groupsDescription" : "",
    divider: !id3,
    dropdownItems: id3 ? [
      SearchDropdown,
      /* @__PURE__ */ react.createElement(DropdownItem, {
        "data-testid": "renameGroupAction",
        key: "renameGroup",
        onClick: () => setRename(currentGroup().name)
      }, t4("renameGroup")),
      /* @__PURE__ */ react.createElement(DropdownItem, {
        "data-testid": "deleteGroup",
        key: "deleteGroup",
        onClick: () => {
          deleteGroup({id: id3});
          history.push(location2.pathname.substr(0, location2.pathname.lastIndexOf("/")));
        }
      }, t4("deleteGroup"))
    ] : [SearchDropdown]
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: PageSectionVariants.light,
    className: "pf-u-p-0"
  }, subGroups.length > 0 && /* @__PURE__ */ react.createElement(Tabs, {
    inset: {
      default: "insetNone",
      md: "insetSm",
      xl: "inset2xl",
      "2xl": "insetLg"
    },
    activeKey: activeTab,
    onSelect: (_23, key) => setActiveTab(key),
    isBox: true
  }, /* @__PURE__ */ react.createElement(Tab, {
    "data-testid": "groups",
    eventKey: 0,
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("childGroups"))
  }, /* @__PURE__ */ react.createElement(GroupTable, null)), /* @__PURE__ */ react.createElement(Tab, {
    "data-testid": "members",
    eventKey: 1,
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("members"))
  }, /* @__PURE__ */ react.createElement(Members, null)), /* @__PURE__ */ react.createElement(Tab, {
    "data-testid": "attributes",
    eventKey: 2,
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("common:attributes"))
  }, /* @__PURE__ */ react.createElement(GroupAttributes, null))), subGroups.length === 0 && /* @__PURE__ */ react.createElement(GroupTable, null)));
};

// build/groups/routes/Groups.js
var GroupsRoute = {
  path: "/:realm/groups",
  component: GroupsSection,
  access: "query-groups",
  matchOptions: {
    exact: false
  }
};

// build/groups/SearchGroups.js
var SearchGroups = () => {
  const {t: t4} = useTranslation("groups");
  const adminClient = useAdminClient();
  const {realm: realm2} = useRealm();
  const [searchTerm, setSearchTerm] = useState("");
  const [searchTerms, setSearchTerms] = useState([]);
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const {setSubGroups} = useSubGroups();
  useEffect(() => setSubGroups([{name: t4("searchGroups")}]), []);
  const deleteTerm = (id3) => {
    const index3 = searchTerms.indexOf(id3);
    searchTerms.splice(index3, 1);
    setSearchTerms([...searchTerms]);
    refresh();
  };
  const addTerm = () => {
    setSearchTerms([...searchTerms, searchTerm]);
    setSearchTerm("");
    refresh();
  };
  const GroupNameCell = (group) => {
    setSubGroups([{name: t4("searchGroups"), id: "search"}, group]);
    return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Link, {
      key: group.id,
      to: `/${realm2}/groups/search/${group.link}`
    }, group.name));
  };
  const flatten4 = (groups2, id3) => {
    let result = [];
    for (const group of groups2) {
      const link = `${id3 || ""}${id3 ? "/" : ""}${group.id}`;
      result.push({...group, link});
      if (group.subGroups) {
        result = [...result, ...flatten4(group.subGroups, link)];
      }
    }
    return result;
  };
  const loader = async (first, max2) => {
    const params = {
      first,
      max: max2
    };
    let result = [];
    if (searchTerms[0]) {
      result = await adminClient.groups.find({
        ...params,
        search: searchTerms[0]
      });
      result = flatten4(result);
      for (const searchTerm2 of searchTerms) {
        result = result.filter((group) => group.name?.includes(searchTerm2));
      }
    }
    return result;
  };
  const Path = (group) => /* @__PURE__ */ react.createElement(GroupPath, {
    group
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(PageSection, {
    variant: PageSectionVariants.light
  }, /* @__PURE__ */ react.createElement(TextContent, {
    className: "pf-u-mr-sm"
  }, /* @__PURE__ */ react.createElement(Text, {
    component: "h1"
  }, t4("searchForGroups"))), /* @__PURE__ */ react.createElement(Form, {
    className: "pf-u-mt-sm keycloak__form",
    onSubmit: (e3) => {
      e3.preventDefault();
      addTerm();
    }
  }, /* @__PURE__ */ react.createElement(InputGroup, null, /* @__PURE__ */ react.createElement(TextInput, {
    name: "search",
    "data-testid": "group-search",
    type: "search",
    "aria-label": t4("search"),
    placeholder: t4("searchGroups"),
    value: searchTerm,
    onChange: (value) => setSearchTerm(value)
  }), /* @__PURE__ */ react.createElement(Button, {
    "data-testid": "search-button",
    variant: ButtonVariant.control,
    "aria-label": t4("search"),
    onClick: addTerm
  }, /* @__PURE__ */ react.createElement(SearchIcon, null))), /* @__PURE__ */ react.createElement(ChipGroup, null, searchTerms.map((term) => /* @__PURE__ */ react.createElement(Chip, {
    key: term,
    onClick: () => deleteTerm(term)
  }, term)))), /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    ariaLabelKey: "groups:groups",
    isPaginated: true,
    loader,
    columns: [
      {
        name: "name",
        displayKey: "groups:groupName",
        cellRenderer: GroupNameCell
      },
      {
        name: "path",
        displayKey: "groups:path",
        cellRenderer: Path
      }
    ],
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      message: t4("noSearchResults"),
      instructions: t4("noSearchResultsInstructions"),
      hasIcon: false
    })
  })));
};

// build/groups/routes/GroupsSearch.js
var GroupsSearchRoute = {
  path: "/:realm/groups/search",
  component: SearchGroups,
  breadcrumb: (t4) => t4("groups:searchGroups"),
  access: "query-groups"
};

// build/groups/routes.js
var routes6 = [GroupsSearchRoute, GroupsRoute];
var routes_default6 = routes6;

// build/identity-providers/component/RedirectUrl.js
var RedirectUrl = ({id: id3}) => {
  const {t: t4} = useTranslation("identity-providers");
  const {t: th2} = useTranslation("identity-providers-help");
  const adminClient = useAdminClient();
  const {realm: realm2} = useRealm();
  const callbackUrl = `${getBaseUrl(adminClient)}realms/${realm2}/broker`;
  return /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("redirectURI"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: th2("redirectURI"),
      forLabel: t4("redirectURI"),
      forID: "kc-redirect-uri"
    }),
    fieldId: "kc-redirect-uri"
  }, /* @__PURE__ */ react.createElement(ClipboardCopy, {
    isReadOnly: true
  }, `${callbackUrl}/${id3}/endpoint`));
};

// build/identity-providers/component/ClientIdSecret.js
var ClientIdSecret = ({
  secretRequired = true,
  create: create3 = true
}) => {
  const {t: t4} = useTranslation("identity-providers");
  const {t: th2} = useTranslation("identity-providers-help");
  const {register, errors} = useFormContext();
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("clientId"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: th2("clientId"),
      forLabel: t4("clientId"),
      forID: "kc-client-id"
    }),
    fieldId: "kc-client-id",
    isRequired: true,
    validated: errors.config && errors.config.clientId ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-client-id",
    "data-testid": "clientId",
    name: "config.clientId",
    ref: register({required: true})
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("clientSecret"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: th2("clientSecret"),
      forLabel: t4("clientSecret"),
      forID: "kc-client-secret"
    }),
    fieldId: "kc-client-secret",
    isRequired: secretRequired,
    validated: errors.config && errors.config.clientSecret ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, create3 && /* @__PURE__ */ react.createElement(PasswordInput, {
    isRequired: secretRequired,
    id: "kc-client-secret",
    "data-testid": "clientSecret",
    name: "config.clientSecret",
    ref: register({required: secretRequired})
  }), !create3 && /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: secretRequired,
    type: "password",
    id: "kc-client-secret",
    "data-testid": "clientSecret",
    name: "config.clientSecret",
    ref: register({required: secretRequired})
  })));
};

// build/identity-providers/component/DisplayOrder.js
var DisplayOrder = () => {
  const {t: t4} = useTranslation("identity-providers");
  const {t: th2} = useTranslation("identity-providers-help");
  const {control} = useFormContext();
  return /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("displayOrder"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: th2("displayOrder"),
      forLabel: t4("displayOrder"),
      forID: "kc-display-order"
    }),
    fieldId: "kc-display-order"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.guiOrder",
    control,
    defaultValue: 0,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(NumberInput, {
      value,
      "data-testid": "displayOrder",
      min: 0,
      onMinus: () => onChange(Number.parseInt(value) - 1),
      onChange,
      onPlus: () => onChange(Number.parseInt(value) + 1),
      inputName: "input",
      inputAriaLabel: t4("displayOrder"),
      minusBtnAriaLabel: t4("common:minus"),
      plusBtnAriaLabel: t4("common:plus")
    })
  }));
};

// build/identity-providers/add/GeneralSettings.js
var GeneralSettings2 = ({
  create: create3 = true,
  id: id3
}) => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(RedirectUrl, {
  id: id3
}), /* @__PURE__ */ react.createElement(ClientIdSecret, {
  create: create3
}), /* @__PURE__ */ react.createElement(DisplayOrder, null));

// build/identity-providers/add/AddIdentityProvider.js
var IdentityProviderCrumb = ({match, location: location2}) => {
  const {t: t4} = useTranslation();
  const {
    params: {id: id3}
  } = match;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, t4(`identity-providers:${location2.pathname.endsWith("settings") ? "provider" : "addIdentityProvider"}`, {
    provider: toUpperCase(id3)
  }));
};
var AddIdentityProvider = () => {
  const {t: t4} = useTranslation("identity-providers");
  const {id: id3} = useParams();
  const form2 = useForm();
  const {
    handleSubmit,
    formState: {isDirty}
  } = form2;
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const history = useHistory();
  const {realm: realm2} = useRealm();
  const save = async (provider) => {
    try {
      await adminClient.identityProviders.create({
        ...provider,
        providerId: id3,
        alias: id3
      });
      addAlert(t4("createSuccess"), AlertVariant.success);
      history.push(`/${realm2}/identity-providers/${id3}/settings`);
    } catch (error2) {
      addError("identity-providers:createError", error2);
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: t4("addIdentityProvider", {provider: toUpperCase(id3)})
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-identity-providers",
    isHorizontal: true,
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(FormProvider, {
    ...form2
  }, /* @__PURE__ */ react.createElement(GeneralSettings2, {
    id: id3
  })), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    isDisabled: !isDirty,
    variant: "primary",
    type: "submit",
    "data-testid": "createProvider"
  }, t4("common:add")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    "data-testid": "cancel",
    onClick: () => history.push(`/${realm2}/identity-providers`)
  }, t4("common:cancel"))))));
};

// build/identity-providers/routes/IdentityProvider.js
var IdentityProviderRoute = {
  path: "/:realm/identity-providers/:id",
  component: AddIdentityProvider,
  breadcrumb: () => IdentityProviderCrumb,
  access: "manage-identity-providers"
};

// build/identity-providers/component/FormGroupField.js
var FormGroupField = ({
  label: label2,
  children: children2
}) => {
  const {t: t4} = useTranslation("identity-providers");
  return /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4(label2),
    fieldId: label2,
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: `identity-providers-help:${label2}`,
      forLabel: t4(label2),
      forID: label2
    })
  }, children2);
};

// build/identity-providers/component/TextField.js
var TextField = ({label: label2, field, isReadOnly = false}) => {
  const {register} = useFormContext();
  return /* @__PURE__ */ react.createElement(FormGroupField, {
    label: label2
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: label2,
    "data-testid": label2,
    name: field,
    ref: register,
    isReadOnly
  }));
};

// build/identity-providers/add/OIDCGeneralSettings.js
var OIDCGeneralSettings = ({id: id3}) => {
  const {t: t4} = useTranslation("identity-providers");
  const {t: th2} = useTranslation("identity-providers-help");
  const {register, errors} = useFormContext();
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(RedirectUrl, {
    id: id3
  }), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("alias"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: th2("alias"),
      forLabel: t4("alias"),
      forID: "alias"
    }),
    fieldId: "alias",
    isRequired: true,
    validated: errors.alias ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "alias",
    "data-testid": "alias",
    name: "alias",
    validated: errors.alias ? ValidatedOptions.error : ValidatedOptions.default,
    ref: register({required: true})
  })), /* @__PURE__ */ react.createElement(TextField, {
    field: "displayName",
    label: "displayName"
  }), /* @__PURE__ */ react.createElement(DisplayOrder, null));
};

// build/identity-providers/component/SwitchField.js
var SwitchField = ({
  label: label2,
  field,
  fieldType = "string",
  isReadOnly = false
}) => {
  const {t: t4} = useTranslation("identity-providers");
  const {control} = useFormContext();
  return /* @__PURE__ */ react.createElement(FormGroupField, {
    label: label2
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: field,
    defaultValue: fieldType === "string" ? "false" : false,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: label2,
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: fieldType === "string" ? value === "true" : value,
      onChange: (value2) => onChange(fieldType === "string" ? "" + value2 : value2),
      isDisabled: isReadOnly
    })
  }));
};

// build/identity-providers/add/DiscoverySettings.js
var Fields = ({readOnly}) => {
  const {t: t4} = useTranslation("identity-providers");
  const {register, control, errors} = useFormContext();
  const validateSignature = useWatch({
    control,
    name: "config.validateSignature"
  });
  const useJwks = useWatch({
    control,
    name: "config.useJwksUrl"
  });
  return /* @__PURE__ */ react.createElement("div", {
    className: "pf-c-form pf-m-horizontal"
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("authorizationUrl"),
    fieldId: "kc-authorization-url",
    isRequired: true,
    validated: errors.config && errors.config.authorizationUrl ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    "data-testid": "authorizationUrl",
    id: "kc-authorization-url",
    name: "config.authorizationUrl",
    ref: register({required: true}),
    validated: errors.config && errors.config.authorizationUrl ? ValidatedOptions.error : ValidatedOptions.default,
    isReadOnly: readOnly
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("tokenUrl"),
    fieldId: "tokenUrl",
    isRequired: true,
    validated: errors.config && errors.config.tokenUrl ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "tokenUrl",
    name: "config.tokenUrl",
    ref: register({required: true}),
    validated: errors.config && errors.config.tokenUrl ? ValidatedOptions.error : ValidatedOptions.default,
    isReadOnly: readOnly
  })), /* @__PURE__ */ react.createElement(TextField, {
    field: "config.logoutUrl",
    label: "logoutUrl",
    isReadOnly: readOnly
  }), /* @__PURE__ */ react.createElement(TextField, {
    field: "config.userInfoUrl",
    label: "userInfoUrl",
    isReadOnly: readOnly
  }), /* @__PURE__ */ react.createElement(TextField, {
    field: "config.issuer",
    label: "issuer",
    isReadOnly: readOnly
  }), /* @__PURE__ */ react.createElement(SwitchField, {
    field: "config.validateSignature",
    label: "validateSignature",
    isReadOnly: readOnly
  }), validateSignature === "true" && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(SwitchField, {
    field: "config.useJwksUrl",
    label: "useJwksUrl",
    isReadOnly: readOnly
  }), useJwks === "true" && /* @__PURE__ */ react.createElement(TextField, {
    field: "config.jwksUrl",
    label: "jwksUrl",
    isReadOnly: readOnly
  })));
};
var DiscoverySettings = ({readOnly}) => {
  const {t: t4} = useTranslation("identity-providers");
  const [isExpanded, setIsExpanded] = useState(false);
  return /* @__PURE__ */ react.createElement(react.Fragment, null, readOnly && /* @__PURE__ */ react.createElement(ExpandableSection, {
    className: "keycloak__discovery-settings__metadata",
    toggleText: isExpanded ? t4("hideMetaData") : t4("showMetaData"),
    onToggle: () => setIsExpanded(!isExpanded),
    isExpanded
  }, /* @__PURE__ */ react.createElement(Fields, {
    readOnly
  })), !readOnly && /* @__PURE__ */ react.createElement(Fields, {
    readOnly
  }));
};

// build/identity-providers/add/OpenIdConnectSettings.js
var OpenIdConnectSettings = () => {
  const {t: t4} = useTranslation("identity-providers");
  const id3 = "oidc";
  const adminClient = useAdminClient();
  const {realm: realm2} = useRealm();
  const {setValue, register, errors} = useFormContext();
  const [discovery, setDiscovery] = useState(true);
  const [discoveryUrl, setDiscoveryUrl] = useState("");
  const [discovering, setDiscovering] = useState(false);
  const [discoveryResult, setDiscoveryResult] = useState();
  const setupForm = (result) => {
    Object.keys(result).map((k3) => setValue(`config.${k3}`, result[k3]));
  };
  useEffect(() => {
    if (discovering) {
      setDiscovering(!!discoveryUrl);
      if (discoveryUrl)
        (async () => {
          let result;
          try {
            result = await adminClient.identityProviders.importFromUrl({
              providerId: id3,
              fromUrl: discoveryUrl
            });
          } catch (error2) {
            result = {error: error2};
          }
          setDiscoveryResult(result);
          setupForm(result);
          setDiscovering(false);
        })();
    }
  }, [discovering]);
  const fileUpload2 = async (obj) => {
    if (obj) {
      const formData = new FormData();
      formData.append("providerId", id3);
      formData.append("file", new Blob([JSON.stringify(obj)]));
      try {
        const response = await fetch(`${getBaseUrl(adminClient)}admin/realms/${realm2}/identity-provider/import-config`, {
          method: "POST",
          body: formData,
          headers: {
            Authorization: `bearer ${await adminClient.getAccessToken()}`
          }
        });
        const result = await response.json();
        setupForm(result);
      } catch (error2) {
        setDiscoveryResult({error: error2});
      }
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Title, {
    headingLevel: "h4",
    size: "xl",
    className: "kc-form-panel__title"
  }, t4("OpenID Connect settings")), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("useDiscoveryEndpoint"),
    fieldId: "kc-discovery-endpoint-switch",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "identity-providers-help:useDiscoveryEndpoint",
      forLabel: t4("useDiscoveryEndpoint"),
      forID: "kc-discovery-endpoint-switch"
    })
  }, /* @__PURE__ */ react.createElement(Switch, {
    id: "kc-discovery-endpoint-switch",
    label: t4("common:on"),
    labelOff: t4("common:off"),
    isChecked: discovery,
    onChange: setDiscovery
  })), discovery && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("discoveryEndpoint"),
    fieldId: "kc-discovery-endpoint",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "identity-providers-help:discoveryEndpoint",
      forLabel: t4("discoveryEndpoint"),
      forID: "kc-discovery-endpoint"
    }),
    validated: discoveryResult && discoveryResult.error || errors.discoveryEndpoint ? "error" : !discoveryResult ? "default" : "success",
    helperTextInvalid: errors.discoveryEndpoint ? t4("common:required") : t4("noValidMetaDataFound"),
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    name: "discoveryEndpoint",
    "data-testid": "discoveryEndpoint",
    id: "kc-discovery-endpoint",
    placeholder: "https://hostname/.well-known/openid-configuration",
    value: discoveryUrl,
    onChange: setDiscoveryUrl,
    onBlur: () => setDiscovering(!discovering),
    validated: discoveryResult && discoveryResult.error || errors.discoveryEndpoint ? "error" : !discoveryResult ? "default" : "success",
    customIconUrl: discovering ? 'data:image/svg+xml;charset=utf8,%3Csvg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid"%3E%3Ccircle cx="50" cy="50" fill="none" stroke="%230066cc" stroke-width="10" r="35" stroke-dasharray="164.93361431346415 56.97787143782138"%3E%3CanimateTransform attributeName="transform" type="rotate" repeatCount="indefinite" dur="1s" values="0 50 50;360 50 50" keyTimes="0;1"%3E%3C/animateTransform%3E%3C/circle%3E%3C/svg%3E' : "",
    ref: register({required: true})
  })), !discovery && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("importConfig"),
    fieldId: "kc-import-config",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "identity-providers-help:importConfig",
      forLabel: t4("importConfig"),
      forID: "kc-import-config"
    }),
    validated: discoveryResult && discoveryResult.error ? "error" : "default",
    helperTextInvalid: discoveryResult?.error?.toString()
  }, /* @__PURE__ */ react.createElement(JsonFileUpload, {
    id: "kc-import-config",
    helpText: "identity=providers-help:jsonFileUpload",
    hideDefaultPreview: true,
    unWrap: true,
    validated: discoveryResult && discoveryResult.error ? "error" : "default",
    onChange: (value) => fileUpload2(value)
  })), discovery && discoveryResult && !discoveryResult.error && /* @__PURE__ */ react.createElement(DiscoverySettings, {
    readOnly: true
  }), !discovery && /* @__PURE__ */ react.createElement(DiscoverySettings, {
    readOnly: false
  }));
};

// build/identity-providers/add/OIDCAuthentication.js
var clientAuthenticationTypes = [
  "clientAuth_post",
  "clientAuth_basic",
  "clientAuth_secret_jwt",
  "clientAuth_privatekey_jwt"
];
var OIDCAuthentication = ({create: create3 = true}) => {
  const {t: t4} = useTranslation("identity-providers");
  const {t: th2} = useTranslation("identity-providers-help");
  const {control} = useFormContext();
  const [openClientAuth, setOpenClientAuth] = useState(false);
  const clientAuthMethod = useWatch({
    control,
    name: "config.clientAuthMethod"
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("clientAuthentication"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: th2("clientAuthentication"),
      forLabel: t4("clientAuthentication"),
      forID: "clientAuthentication"
    }),
    fieldId: "clientAuthentication"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.clientAuthMethod",
    defaultValue: clientAuthenticationTypes[0],
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "clientAuthMethod",
      required: true,
      onToggle: () => setOpenClientAuth(!openClientAuth),
      onSelect: (_23, value2) => {
        onChange(value2);
        setOpenClientAuth(false);
      },
      selections: value,
      variant: SelectVariant.single,
      "aria-label": t4("prompt"),
      isOpen: openClientAuth
    }, clientAuthenticationTypes.map((option) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: option === value,
      key: option,
      value: option
    }, t4(`clientAuthentications.${option}`))))
  })), /* @__PURE__ */ react.createElement(ClientIdSecret, {
    secretRequired: clientAuthMethod !== "clientAuth_privatekey_jwt",
    create: create3
  }));
};

// build/identity-providers/add/AddOpenIdConnect.js
var AddOpenIdConnect = () => {
  const {t: t4} = useTranslation("identity-providers");
  const history = useHistory();
  const {url} = useRouteMatch();
  const isKeycloak = url.endsWith("keycloak-oidc");
  const id3 = `${isKeycloak ? "keycloak-" : ""}oidc`;
  const form2 = useForm({
    defaultValues: {alias: id3}
  });
  const {
    handleSubmit,
    formState: {isDirty}
  } = form2;
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const {realm: realm2} = useRealm();
  const save = async (provider) => {
    delete provider.discoveryEndpoint;
    try {
      await adminClient.identityProviders.create({
        ...provider,
        providerId: id3
      });
      addAlert(t4("createSuccess"), AlertVariant.success);
      history.push(`/${realm2}/identity-providers/${id3}/settings`);
    } catch (error2) {
      addError("identity-providers:createError", error2);
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: t4(isKeycloak ? "addKeycloakOpenIdProvider" : "addOpenIdProvider")
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(FormProvider, {
    ...form2
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-identity-providers",
    isHorizontal: true,
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(OIDCGeneralSettings, {
    id: id3
  }), /* @__PURE__ */ react.createElement(OpenIdConnectSettings, null), /* @__PURE__ */ react.createElement(OIDCAuthentication, null), /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    isDisabled: !isDirty,
    variant: "primary",
    type: "submit",
    "data-testid": "createProvider"
  }, t4("common:add")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    "data-testid": "cancel",
    onClick: () => history.push(`/${realm2}/identity-providers`)
  }, t4("common:cancel")))))));
};

// build/identity-providers/routes/IdentityProviderKeycloakOidc.js
var IdentityProviderKeycloakOidcRoute = {
  path: "/:realm/identity-providers/keycloak-oidc",
  component: AddOpenIdConnect,
  breadcrumb: (t4) => t4("identity-providers:addKeycloakOpenIdProvider"),
  access: "manage-identity-providers"
};

// build/identity-providers/routes/IdentityProviderOidc.js
var IdentityProviderOidcRoute = {
  path: "/:realm/identity-providers/oidc",
  component: AddOpenIdConnect,
  breadcrumb: (t4) => t4("identity-providers:addOpenIdProvider"),
  access: "manage-identity-providers"
};

// build/identity-providers/icons/FontAwesomeIcon.js
var FontAwesomeIcon = ({icon}) => {
  const styles4 = {style: {height: "2em", width: "2em"}};
  switch (icon) {
    case "bitbucket":
      return /* @__PURE__ */ react.createElement("img", {
        src: environment_default.resourceUrl + "./bitbucket-brands.svg",
        ...styles4,
        "aria-label": "bitbucket icon"
      });
    case "microsoft":
      return /* @__PURE__ */ react.createElement("img", {
        src: environment_default.resourceUrl + "./microsoft-brands.svg",
        ...styles4,
        "aria-label": "microsoft icon"
      });
    case "instagram":
      return /* @__PURE__ */ react.createElement("img", {
        src: environment_default.resourceUrl + "./instagram-brands.svg",
        ...styles4,
        "aria-label": "instagram icon"
      });
    case "paypal":
      return /* @__PURE__ */ react.createElement("img", {
        src: environment_default.resourceUrl + "./paypal-brands.svg",
        ...styles4,
        "aria-label": "paypal icon"
      });
    default:
      return /* @__PURE__ */ react.createElement(react.Fragment, null);
  }
};

// build/identity-providers/ProviderIconMapper.js
var ProviderIconMapper = ({provider}) => {
  const defaultProps = {size: "lg"};
  switch (provider.id) {
    case "github":
      return /* @__PURE__ */ react.createElement(GithubIcon, {
        ...defaultProps
      });
    case "facebook":
      return /* @__PURE__ */ react.createElement(FacebookSquareIcon, {
        ...defaultProps
      });
    case "gitlab":
      return /* @__PURE__ */ react.createElement(GitlabIcon, {
        ...defaultProps
      });
    case "google":
      return /* @__PURE__ */ react.createElement(GoogleIcon, {
        ...defaultProps
      });
    case "linkedin":
      return /* @__PURE__ */ react.createElement(LinkedinIcon, {
        ...defaultProps
      });
    case "openshift-v3":
    case "openshift-v4":
      return /* @__PURE__ */ react.createElement(OpenshiftIcon, {
        ...defaultProps
      });
    case "stackoverflow":
      return /* @__PURE__ */ react.createElement(StackOverflowIcon, {
        ...defaultProps
      });
    case "twitter":
      return /* @__PURE__ */ react.createElement(TwitterIcon, {
        ...defaultProps
      });
    case "microsoft":
    case "bitbucket":
    case "instagram":
    case "paypal":
      return /* @__PURE__ */ react.createElement(FontAwesomeIcon, {
        icon: provider.id
      });
    default:
      return /* @__PURE__ */ react.createElement(CubeIcon, {
        ...defaultProps
      });
  }
};

// build/identity-providers/ManageOrderDialog.js
var ManageOderDialog = ({
  providers,
  onClose
}) => {
  const {t: t4} = useTranslation("identity-providers");
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const [alias, setAlias] = useState("");
  const [liveText, setLiveText] = useState("");
  const [order3, setOrder] = useState(providers.map((provider) => provider.alias));
  const onDragStart = (id3) => {
    setAlias(id3);
    setLiveText(t4("common:onDragStart", {item: id3}));
  };
  const onDragMove = () => {
    setLiveText(t4("common:onDragMove", {item: alias}));
  };
  const onDragCancel = () => {
    setLiveText(t4("common:onDragCancel"));
  };
  const onDragFinish = (providerOrder) => {
    setLiveText(t4("common:onDragFinish", {list: providerOrder}));
    setOrder(providerOrder);
  };
  return /* @__PURE__ */ react.createElement(Modal, {
    variant: ModalVariant.small,
    title: t4("manageDisplayOrder"),
    isOpen: true,
    onClose,
    actions: [
      /* @__PURE__ */ react.createElement(Button, {
        id: "modal-confirm",
        key: "confirm",
        onClick: () => {
          order3.map(async (alias2, index3) => {
            const provider = providers.find((p3) => p3.alias === alias2);
            provider.config.guiOrder = index3;
            try {
              await adminClient.identityProviders.update({alias: alias2}, provider);
              addAlert(t4("orderChangeSuccess"), AlertVariant.success);
            } catch (error2) {
              addError("identity-providers:orderChangeError", error2);
            }
          });
          onClose();
        }
      }, t4("common:save")),
      /* @__PURE__ */ react.createElement(Button, {
        id: "modal-cancel",
        key: "cancel",
        variant: ButtonVariant.link,
        onClick: onClose
      }, t4("common:cancel"))
    ]
  }, /* @__PURE__ */ react.createElement(TextContent, {
    className: "pf-u-pb-lg"
  }, /* @__PURE__ */ react.createElement(Text, null, t4("oderDialogIntro"))), /* @__PURE__ */ react.createElement(DataList, {
    "aria-label": t4("manageOrderTableAria"),
    "data-testid": "manageOrderDataList",
    isCompact: true,
    onDragFinish,
    onDragStart,
    onDragMove,
    onDragCancel,
    itemOrder: order3
  }, lodash.sortBy(providers, "config.guiOrder").map((provider) => /* @__PURE__ */ react.createElement(DataListItem, {
    "aria-labelledby": provider.alias,
    id: provider.alias,
    key: provider.alias
  }, /* @__PURE__ */ react.createElement(DataListItemRow, null, /* @__PURE__ */ react.createElement(DataListControl, null, /* @__PURE__ */ react.createElement(DataListDragButton, {
    "aria-label": "Reorder",
    "aria-labelledby": provider.alias,
    "aria-describedby": t4("manageOrderItemAria"),
    "aria-pressed": "false"
  })), /* @__PURE__ */ react.createElement(DataListItemCells, {
    dataListCells: [
      /* @__PURE__ */ react.createElement(DataListCell, {
        key: `${provider.alias}-cell`,
        "data-testid": provider.alias
      }, /* @__PURE__ */ react.createElement("span", {
        id: provider.alias
      }, provider.alias))
    ]
  }))))), /* @__PURE__ */ react.createElement("div", {
    className: "pf-screen-reader",
    "aria-live": "assertive"
  }, liveText));
};

// build/identity-providers/IdentityProvidersSection.js
var IdentityProvidersSection = () => {
  const {t: t4} = useTranslation("identity-providers");
  const identityProviders2 = lodash.groupBy(useServerInfo().identityProviders, "groupName");
  const {realm: realm2} = useRealm();
  const {url} = useRouteMatch();
  const history = useHistory();
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const [addProviderOpen, setAddProviderOpen] = useState(false);
  const [manageDisplayDialog, setManageDisplayDialog] = useState(false);
  const [providers, setProviders] = useState([]);
  const [selectedProvider, setSelectedProvider] = useState();
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  useFetch(async () => (await adminClient.realms.findOne({realm: realm2})).identityProviders, (providers2) => {
    setProviders(providers2);
  }, []);
  const loader = () => Promise.resolve(lodash.sortBy(providers, "alias"));
  const DetailLink = (identityProvider) => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Link, {
    key: identityProvider.providerId,
    to: `/${realm2}/identity-providers/${identityProvider.providerId}/settings`
  }, identityProvider.alias, !identityProvider.enabled && /* @__PURE__ */ react.createElement(Badge, {
    key: `${identityProvider.providerId}-disabled`,
    isRead: true,
    className: "pf-u-ml-sm"
  }, t4("common:disabled"))));
  const navigateToCreate = (providerId) => history.push(`${url}/${providerId}`);
  const identityProviderOptions = () => Object.keys(identityProviders2).map((group) => /* @__PURE__ */ react.createElement(DropdownGroup, {
    key: group,
    label: group
  }, lodash.sortBy(identityProviders2[group], "name").map((provider) => /* @__PURE__ */ react.createElement(DropdownItem, {
    key: provider.id,
    value: provider.id,
    "data-testid": provider.id,
    onClick: () => navigateToCreate(provider.id)
  }, provider.name))));
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: "identity-providers:deleteProvider",
    messageKey: t4("deleteConfirm", {provider: selectedProvider?.alias}),
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        await adminClient.identityProviders.del({
          alias: selectedProvider.alias
        });
        setProviders([
          ...providers.filter((p3) => p3.alias !== selectedProvider?.alias)
        ]);
        refresh();
        addAlert(t4("deletedSuccess"), AlertVariant.success);
      } catch (error2) {
        addError("identity-providers:deleteError", error2);
      }
    }
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DeleteConfirm, null), manageDisplayDialog && /* @__PURE__ */ react.createElement(ManageOderDialog, {
    onClose: () => setManageDisplayDialog(false),
    providers: providers?.filter((p3) => p3.enabled)
  }), /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: "common:identityProviders",
    subKey: "identity-providers:listExplain"
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: providers.length === 0 ? "default" : "light",
    className: providers.length === 0 ? "" : "pf-u-p-0"
  }, providers.length === 0 && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(TextContent, null, /* @__PURE__ */ react.createElement(Text, {
    component: TextVariants.p
  }, t4("getStarted"))), Object.keys(identityProviders2).map((group) => /* @__PURE__ */ react.createElement(Fragment, {
    key: group
  }, /* @__PURE__ */ react.createElement(TextContent, null, /* @__PURE__ */ react.createElement(Text, {
    className: "pf-u-mt-lg",
    component: TextVariants.h2
  }, group, ":")), /* @__PURE__ */ react.createElement("hr", {
    className: "pf-u-mb-lg"
  }), /* @__PURE__ */ react.createElement(Gallery, {
    hasGutter: true
  }, lodash.sortBy(identityProviders2[group], "name").map((provider) => /* @__PURE__ */ react.createElement(Card, {
    className: "keycloak-empty-state-card",
    key: provider.id,
    isHoverable: true,
    "data-testid": `${provider.id}-card`,
    onClick: () => navigateToCreate(provider.id)
  }, /* @__PURE__ */ react.createElement(CardTitle, null, /* @__PURE__ */ react.createElement(Split, {
    hasGutter: true
  }, /* @__PURE__ */ react.createElement(SplitItem, null, /* @__PURE__ */ react.createElement(ProviderIconMapper, {
    provider
  })), /* @__PURE__ */ react.createElement(SplitItem, {
    isFilled: true
  }, provider.name))))))))), providers.length !== 0 && /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    loader,
    ariaLabelKey: "common:identityProviders",
    searchPlaceholderKey: "identity-providers:searchForProvider",
    toolbarItem: /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Dropdown, {
      "data-testid": "addProviderDropdown",
      toggle: /* @__PURE__ */ react.createElement(DropdownToggle, {
        onToggle: () => setAddProviderOpen(!addProviderOpen),
        isPrimary: true
      }, t4("addProvider")),
      isOpen: addProviderOpen,
      dropdownItems: identityProviderOptions()
    })), /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      "data-testid": "manageDisplayOrder",
      variant: "link",
      onClick: () => setManageDisplayDialog(true)
    }, t4("manageDisplayOrder")))),
    actions: [
      {
        title: t4("common:delete"),
        onRowClick: (provider) => {
          setSelectedProvider(provider);
          toggleDeleteDialog();
        }
      }
    ],
    columns: [
      {
        name: "alias",
        displayKey: "common:name",
        cellRenderer: DetailLink
      },
      {
        name: "providerId",
        displayKey: "identity-providers:provider",
        cellFormatters: [upperCaseFormatter()]
      }
    ]
  })));
};

// build/identity-providers/routes/IdentityProviders.js
var IdentityProvidersRoute = {
  path: "/:realm/identity-providers",
  component: IdentityProvidersSection,
  breadcrumb: (t4) => t4("identityProviders"),
  access: "view-identity-providers"
};

// build/identity-providers/add/AdvancedSettings.js
var LoginFlow = ({
  field,
  label: label2,
  defaultValue
}) => {
  const {t: t4} = useTranslation("identity-providers");
  const {control} = useFormContext();
  const adminClient = useAdminClient();
  const [flows, setFlows] = useState();
  const [open2, setOpen] = useState(false);
  useFetch(() => adminClient.authenticationManagement.getFlows(), (flows2) => setFlows(flows2?.filter((flow) => flow.providerId === "basic-flow")), []);
  return /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4(label2),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: `identity-providers-help:${label2}`,
      forLabel: t4(label2),
      forID: label2
    }),
    fieldId: label2
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: field,
    defaultValue,
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: label2,
      required: true,
      onToggle: () => setOpen(!open2),
      onSelect: (_23, value2) => {
        onChange(value2);
        setOpen(false);
      },
      selections: value || t4("common:none"),
      variant: SelectVariant.single,
      "aria-label": t4(label2),
      isOpen: open2
    }, /* @__PURE__ */ react.createElement(react.Fragment, null, defaultValue === "" && /* @__PURE__ */ react.createElement(SelectOption, {
      key: "empty",
      value: defaultValue
    }, t4("common:none"))), /* @__PURE__ */ react.createElement(react.Fragment, null, flows && flows.map((option) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: option.alias === value,
      key: option.id,
      value: option.alias
    }, option.alias))))
  }));
};
var syncModes = ["import", "legacy", "force"];
var AdvancedSettings2 = ({isOIDC}) => {
  const {t: t4} = useTranslation("identity-providers");
  const {control} = useFormContext();
  const [syncModeOpen, setSyncModeOpen] = useState(false);
  return /* @__PURE__ */ react.createElement(react.Fragment, null, !isOIDC && /* @__PURE__ */ react.createElement(TextField, {
    field: "config.defaultScope",
    label: "scopes"
  }), /* @__PURE__ */ react.createElement(SwitchField, {
    field: "storeToken",
    label: "storeTokens",
    fieldType: "boolean"
  }), !isOIDC && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(SwitchField, {
    field: "config.acceptsPromptNoneForwardFromClient",
    label: "acceptsPromptNone"
  }), /* @__PURE__ */ react.createElement(SwitchField, {
    field: "config.disableUserInfo",
    label: "disableUserInfo"
  })), /* @__PURE__ */ react.createElement(SwitchField, {
    field: "trustEmail",
    label: "trustEmail",
    fieldType: "boolean"
  }), /* @__PURE__ */ react.createElement(SwitchField, {
    field: "linkOnly",
    label: "accountLinkingOnly",
    fieldType: "boolean"
  }), /* @__PURE__ */ react.createElement(SwitchField, {
    field: "config.hideOnLoginPage",
    label: "hideOnLoginPage"
  }), /* @__PURE__ */ react.createElement(LoginFlow, {
    field: "firstBrokerLoginFlowAlias",
    label: "firstBrokerLoginFlowAlias",
    defaultValue: "fist broker login"
  }), /* @__PURE__ */ react.createElement(LoginFlow, {
    field: "postBrokerLoginFlowAlias",
    label: "postBrokerLoginFlowAlias",
    defaultValue: ""
  }), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("syncMode"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "identity-providers-help:syncMode",
      forLabel: t4("syncMode"),
      forID: "syncMode"
    }),
    fieldId: "syncMode"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.syncMode",
    defaultValue: syncModes[0],
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "syncMode",
      required: true,
      direction: "up",
      onToggle: () => setSyncModeOpen(!syncModeOpen),
      onSelect: (_23, value2) => {
        onChange(value2);
        setSyncModeOpen(false);
      },
      selections: t4(`syncModes.${value.toLowerCase()}`),
      variant: SelectVariant.single,
      "aria-label": t4("syncMode"),
      isOpen: syncModeOpen
    }, syncModes.map((option) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: option === value,
      key: option,
      value: option.toUpperCase()
    }, t4(`syncModes.${option}`))))
  })));
};

// build/identity-providers/add/ExtendedNonDiscoverySettings.js
var promptOptions = [
  "unspecified",
  "none",
  "consent",
  "login",
  "select_account"
];
var ExtendedNonDiscoverySettings = () => {
  const {t: t4} = useTranslation("identity-providers");
  const {control} = useFormContext();
  const [isExpanded, setIsExpanded] = useState(false);
  const [promptOpen, setPromptOpen] = useState(false);
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ExpandableSection, {
    toggleText: t4("advanced"),
    onToggle: () => setIsExpanded(!isExpanded),
    isExpanded
  }, /* @__PURE__ */ react.createElement(Form, {
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(SwitchField, {
    label: "passLoginHint",
    field: "config.loginHint"
  }), /* @__PURE__ */ react.createElement(SwitchField, {
    label: "passCurrentLocale",
    field: "config.uiLocales"
  }), /* @__PURE__ */ react.createElement(SwitchField, {
    field: "config.backchannelSupported",
    label: "backchannelLogout"
  }), /* @__PURE__ */ react.createElement(SwitchField, {
    field: "config.disableUserInfo",
    label: "disableUserInfo"
  }), /* @__PURE__ */ react.createElement(TextField, {
    field: "config.defaultScope",
    label: "scopes"
  }), /* @__PURE__ */ react.createElement(FormGroupField, {
    label: "prompt"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.prompt",
    defaultValue: promptOptions[0],
    control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "prompt",
      required: true,
      onToggle: () => setPromptOpen(!promptOpen),
      onSelect: (_23, value2) => {
        onChange(value2);
        setPromptOpen(false);
      },
      selections: value,
      variant: SelectVariant.single,
      "aria-label": t4("prompt"),
      isOpen: promptOpen
    }, promptOptions.map((option) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: option === value,
      key: option,
      value: option
    }, t4(`prompts.${option}`))))
  })), /* @__PURE__ */ react.createElement(SwitchField, {
    field: "config.acceptsPromptNoneForwardFromClient",
    label: "acceptsPromptNone"
  }), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("allowedClockSkew"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "identity-providers-help:allowedClockSkew",
      forLabel: t4("allowedClockSkew"),
      forID: "allowedClockSkew"
    }),
    fieldId: "allowedClockSkew"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.allowedClockSkew",
    control,
    defaultValue: 0,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(NumberInput, {
      value,
      "data-testid": "allowedClockSkew",
      onMinus: () => onChange(value - 1),
      onChange,
      onPlus: () => onChange(value + 1),
      inputName: "input",
      inputAriaLabel: t4("allowedClockSkew"),
      minusBtnAriaLabel: t4("common:minus"),
      plusBtnAriaLabel: t4("common:plus"),
      min: 0,
      unit: t4("common:times.seconds")
    })
  })), /* @__PURE__ */ react.createElement(TextField, {
    field: "config.forwardParameters",
    label: "forwardParameters"
  }))));
};

// build/identity-providers/add/DetailSettings.js
var Header3 = ({onChange, value, save, toggleDeleteDialog}) => {
  const {t: t4} = useTranslation("identity-providers");
  const {id: id3} = useParams();
  const [toggleDisableDialog, DisableConfirm] = useConfirmDialog({
    titleKey: "identity-providers:disableProvider",
    messageKey: t4("disableConfirm", {provider: id3}),
    continueButtonLabel: "common:disable",
    onConfirm: () => {
      onChange(!value);
      save();
    }
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DisableConfirm, null), /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: toUpperCase(id3),
    divider: false,
    dropdownItems: [
      /* @__PURE__ */ react.createElement(DropdownItem, {
        key: "delete",
        onClick: () => toggleDeleteDialog()
      }, t4("common:delete"))
    ],
    isEnabled: value,
    onToggle: (value2) => {
      if (!value2) {
        toggleDisableDialog();
      } else {
        onChange(value2);
        save();
      }
    }
  }));
};
var DetailSettings = () => {
  const {t: t4} = useTranslation("identity-providers");
  const {id: id3} = useParams();
  const [provider, setProvider] = useState();
  const form2 = useForm();
  const {handleSubmit, setValue, getValues, reset} = form2;
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const history = useHistory();
  const {realm: realm2} = useRealm();
  useFetch(() => adminClient.identityProviders.findOne({alias: id3}), (provider2) => {
    if (provider2) {
      setProvider(provider2);
      Object.entries(provider2).map((entry) => setValue(entry[0], entry[1]));
    }
  }, []);
  const save = async (provider2) => {
    const p3 = provider2 || getValues();
    try {
      await adminClient.identityProviders.update({alias: id3}, {...p3, alias: id3, providerId: id3});
      setProvider(p3);
      addAlert(t4("updateSuccess"), AlertVariant.success);
    } catch (error2) {
      addError("identity-providers:updateError", error2);
    }
  };
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: "identity-providers:deleteProvider",
    messageKey: t4("identity-providers:deleteConfirm", {provider: id3}),
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        await adminClient.identityProviders.del({alias: id3});
        addAlert(t4("deletedSuccess"), AlertVariant.success);
        history.push(`/${realm2}/identity-providers`);
      } catch (error2) {
        addError("identity-providers:deleteErrorError", error2);
      }
    }
  });
  const sections2 = [t4("generalSettings"), t4("advancedSettings")];
  const isOIDC = id3.indexOf("oidc") !== -1;
  if (isOIDC) {
    sections2.splice(1, 0, t4("oidcSettings"));
  }
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DeleteConfirm, null), /* @__PURE__ */ react.createElement(Controller, {
    name: "enabled",
    control: form2.control,
    defaultValue: true,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Header3, {
      value,
      onChange,
      save,
      toggleDeleteDialog
    })
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    className: "pf-u-p-0"
  }, /* @__PURE__ */ react.createElement(FormProvider, {
    ...form2
  }, /* @__PURE__ */ react.createElement(KeycloakTabs, {
    isBox: true
  }, /* @__PURE__ */ react.createElement(Tab, {
    id: "settings",
    eventKey: "settings",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("common:settings"))
  }, /* @__PURE__ */ react.createElement(ScrollForm, {
    className: "pf-u-px-lg",
    sections: sections2
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-identity-providers",
    isHorizontal: true,
    onSubmit: handleSubmit(save)
  }, !isOIDC && /* @__PURE__ */ react.createElement(GeneralSettings2, {
    create: false,
    id: id3
  }), isOIDC && /* @__PURE__ */ react.createElement(OIDCGeneralSettings, {
    id: id3
  })), isOIDC && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DiscoverySettings, {
    readOnly: false
  }), /* @__PURE__ */ react.createElement(Form, {
    isHorizontal: true,
    className: "pf-u-py-lg"
  }, /* @__PURE__ */ react.createElement(Divider, null), /* @__PURE__ */ react.createElement(OIDCAuthentication, {
    create: false
  })), /* @__PURE__ */ react.createElement(ExtendedNonDiscoverySettings, null)), /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-identity-providers",
    isHorizontal: true,
    onSubmit: handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(AdvancedSettings2, {
    isOIDC
  }), /* @__PURE__ */ react.createElement(ActionGroup, {
    className: "keycloak__form_actions"
  }, /* @__PURE__ */ react.createElement(Button, {
    "data-testid": "save",
    type: "submit"
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    "data-testid": "revert",
    variant: "link",
    onClick: () => {
      reset(provider);
    }
  }, t4("common:revert"))))))))));
};

// build/identity-providers/routes/IdentityProviderTab.js
var IdentityProviderTabRoute = {
  path: "/:realm/identity-providers/:id/:tab?",
  component: DetailSettings,
  access: "manage-identity-providers"
};

// build/identity-providers/routes.js
var routes7 = [
  IdentityProvidersRoute,
  IdentityProviderOidcRoute,
  IdentityProviderKeycloakOidcRoute,
  IdentityProviderRoute,
  IdentityProviderTabRoute
];
var routes_default7 = routes7;

// build/PageNotFoundSection.js
var PageNotFoundSection = () => {
  return /* @__PURE__ */ react.createElement(react.Fragment, null, "Page Not Found");
};

// build/realm-roles/routes/AddRole.js
var AddRoleRoute = {
  path: "/:realm/roles/add-role",
  component: RealmRoleTabs,
  breadcrumb: (t4) => t4("roles:createRole"),
  access: "manage-realm"
};

// build/realm-roles/routes/AddRoleToClient.js
var AddRoleToClientRoute = {
  path: "/:realm/clients/:clientId/roles/add-role",
  component: RealmRoleTabs,
  breadcrumb: (t4) => t4("roles:createRole"),
  access: "manage-realm"
};

// build/realm-roles/routes/ClientRole.js
var ClientRoleRoute = {
  path: "/:realm/clients/:clientId/roles/:id/:tab?",
  component: RealmRoleTabs,
  breadcrumb: (t4) => t4("roles:roleDetails"),
  access: "view-realm"
};

// build/realm-roles/RealmRolesSection.js
var RealmRolesSection = () => {
  const adminClient = useAdminClient();
  const loader = (first, max2, search) => {
    const params = {
      first,
      max: max2
    };
    const searchParam = search || "";
    if (searchParam) {
      params.search = searchParam;
    }
    return adminClient.roles.find(params);
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: "roles:title",
    subKey: "roles:roleExplain"
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    padding: {default: "noPadding"}
  }, /* @__PURE__ */ react.createElement(RolesList, {
    loader
  })));
};

// build/realm-roles/routes/RealmRoles.js
var RealmRolesRoute = {
  path: "/:realm/roles",
  component: RealmRolesSection,
  breadcrumb: (t4) => t4("roles:roleList"),
  access: "view-realm"
};

// build/realm-roles/routes.js
var routes8 = [
  AddRoleToClientRoute,
  ClientRoleRoute,
  RealmRolesRoute,
  AddRoleRoute,
  RealmRoleRoute
];
var routes_default8 = routes8;

// build/realm-settings/routes/AesGeneratedSettings.js
var AesGeneratedSettingsRoute = {
  path: "/:realm/realm-settings/keys/:id/aes-generated/settings",
  component: AESGeneratedSettings,
  breadcrumb: () => EditProviderCrumb,
  access: "view-realm"
};

// build/realm-settings/routes/EcdsaGeneratedSettings.js
var EcdsaGeneratedSettingsRoute = {
  path: "/:realm/realm-settings/keys/:id/ecdsa-generated/settings",
  component: ECDSAGeneratedSettings,
  breadcrumb: () => EditProviderCrumb,
  access: "view-realm"
};

// build/realm-settings/routes/HmacGeneratedSettings.js
var HmacGeneratedSettingsRoute = {
  path: "/:realm/realm-settings/keys/:id/hmac-generated/settings",
  component: HMACGeneratedSettings,
  breadcrumb: () => EditProviderCrumb,
  access: "view-realm"
};

// build/realm-settings/routes/JavaKeystoreSettings.js
var JavaKeystoreSettingsRoute = {
  path: "/:realm/realm-settings/keys/:id/java-keystore/settings",
  component: JavaKeystoreSettings,
  breadcrumb: () => EditProviderCrumb,
  access: "view-realm"
};

// build/realm-settings/routes/RsaGeneratedSettings.js
var RsaGeneratedSettingsRoute = {
  path: "/:realm/realm-settings/keys/:id/rsa-generated/settings",
  component: RSAGeneratedSettings,
  breadcrumb: () => EditProviderCrumb,
  access: "view-realm"
};

// build/realm-settings/key-providers/rsa/RSAForm.js
var RSAForm = ({
  editMode,
  providerType,
  handleModalToggle,
  refresh
}) => {
  const {t: t4} = useTranslation("realm-settings");
  const serverInfo2 = useServerInfo();
  const [component, setComponent] = useState();
  const [isRSAalgDropdownOpen, setIsRSAalgDropdownOpen] = useState(false);
  const [keyFileName, setKeyFileName] = useState("");
  const [certificateFileName, setCertificateFileName] = useState("");
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const {id: id3} = useParams();
  const providerId = useRouteMatch("/:providerType?")?.params.providerType;
  const save = async (component2) => {
    try {
      if (id3) {
        await adminClient.components.update({id: id3}, {
          ...component2,
          parentId: component2.parentId,
          providerId: providerType,
          providerType: "org.keycloak.keys.KeyProvider"
        });
        addAlert(t4("saveProviderSuccess"), AlertVariant.success);
      } else {
        await adminClient.components.create({
          ...component2,
          parentId: component2.parentId,
          providerId: providerType,
          providerType: "org.keycloak.keys.KeyProvider"
        });
        handleModalToggle?.();
        addAlert(t4("saveProviderSuccess"), AlertVariant.success);
        refresh?.();
      }
    } catch (error2) {
      addError("realm-settings:saveProviderError", error2);
    }
  };
  const form2 = useForm({mode: "onChange"});
  const setupForm = (component2) => {
    form2.reset();
    Object.entries(component2).map(([key, value]) => {
      if (key === "config" && component2.config?.secretSize && component2.config?.active && component2.config?.algorithm && component2.config?.privateKey && component2.config?.certificate) {
        form2.setValue("config.secretSize", value.secretSize[0]);
        form2.setValue("config.active", value.active[0]);
        form2.setValue("config.algorithm", value.algorithm[0]);
        form2.setValue("config.privateKey", value.privateKey[0]);
        form2.setValue("config.certificate", value.certificate[0]);
        convertToFormValues(value, "config", form2.setValue);
      }
      form2.setValue(key, value);
    });
  };
  useFetch(async () => {
    if (editMode)
      return await adminClient.components.findOne({id: id3});
  }, (result) => {
    if (result) {
      setupForm(result);
      setComponent(result);
    }
  }, []);
  const allComponentTypes = serverInfo2.componentTypes?.["org.keycloak.keys.KeyProvider"] ?? [];
  const rsaAlgOptions = allComponentTypes[4].properties[3].options;
  return /* @__PURE__ */ react.createElement(FormAccess, {
    isHorizontal: true,
    id: "add-provider",
    className: "pf-u-mt-lg",
    role: "manage-realm",
    onSubmit: form2.handleSubmit(save)
  }, editMode && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("providerId"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:mapperName",
      forLabel: t4("common:name"),
      forID: t4("common:helpLabel", {label: t4("common:name")})
    }),
    fieldId: "id",
    isRequired: true,
    validated: form2.errors.name ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, /* @__PURE__ */ react.createElement(TextInput, {
    ref: form2.register(),
    id: "id",
    type: "text",
    name: "id",
    isReadOnly: editMode,
    "aria-label": t4("consoleDisplayName"),
    defaultValue: id3,
    "data-testid": "display-name-input"
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:name"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "client-scopes-help:mapperName",
      forLabel: t4("common:name"),
      forID: t4("common:helpLabel", {label: t4("common:name")})
    }),
    fieldId: "name",
    isRequired: true,
    validated: form2.errors.name ? ValidatedOptions.error : ValidatedOptions.default,
    helperTextInvalid: t4("common:required")
  }, !editMode && /* @__PURE__ */ react.createElement(Controller, {
    name: "name",
    control: form2.control,
    defaultValue: providerType,
    render: ({onChange, value}) => {
      return /* @__PURE__ */ react.createElement(TextInput, {
        id: "name",
        type: "text",
        "aria-label": t4("consoleDisplayName"),
        defaultValue: providerType,
        value,
        onChange: (value2) => onChange(value2),
        "data-testid": "display-name-input"
      });
    }
  }), editMode && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(TextInput, {
    ref: form2.register(),
    type: "text",
    id: "name",
    name: "name",
    defaultValue: providerId,
    validated: form2.errors.name ? ValidatedOptions.error : ValidatedOptions.default
  }))), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:enabled"),
    fieldId: "kc-enabled",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: t4("realm-settings-help:enabled"),
      forLabel: t4("enabled"),
      forID: t4("common:helpLabel", {label: t4("enabled")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.enabled",
    control: form2.control,
    defaultValue: ["true"],
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-enabled-switch",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      isChecked: value[0] === "true",
      "data-testid": value[0] === "true" ? "enabled" : "disabled",
      onChange: (value2) => {
        onChange([value2.toString()]);
      }
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("active"),
    fieldId: "kc-active",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:active",
      forLabel: t4("active"),
      forID: t4("common:helpLabel", {label: t4("active")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.active",
    control: form2.control,
    defaultValue: ["true"],
    render: ({onChange, value}) => {
      return /* @__PURE__ */ react.createElement(Switch, {
        id: "kc-active-switch",
        label: t4("common:on"),
        labelOff: t4("common:off"),
        isChecked: value[0] === "true",
        "data-testid": value[0] === "true" ? "active" : "passive",
        onChange: (value2) => {
          onChange([value2.toString()]);
        }
      });
    }
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("algorithm"),
    fieldId: "kc-algorithm",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:algorithm",
      forLabel: t4("algorithm"),
      forID: t4("common:helpLabel", {label: t4("algorithm")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.algorithm",
    defaultValue: ["RS256"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-rsa-algorithm",
      onToggle: () => setIsRSAalgDropdownOpen(!isRSAalgDropdownOpen),
      onSelect: (_23, value2) => {
        onChange([value2.toString()]);
        setIsRSAalgDropdownOpen(false);
      },
      selections: [value.toString()],
      variant: SelectVariant.single,
      "aria-label": t4("algorithm"),
      isOpen: isRSAalgDropdownOpen,
      "data-testid": "select-rsa-algorithm"
    }, rsaAlgOptions.map((p3, idx) => /* @__PURE__ */ react.createElement(SelectOption, {
      selected: p3 === value,
      key: `rsa-algorithm-${idx}`,
      value: p3
    })))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("privateRSAKey"),
    fieldId: "kc-private-rsa-key",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:privateRSAKey",
      forLabel: t4("privateRSAKey"),
      forID: t4("common:helpLabel", {label: t4("privateRSAKey")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.privateKey",
    control: form2.control,
    defaultValue: [],
    render: ({onChange}) => /* @__PURE__ */ react.createElement(FileUpload, {
      id: "importPrivateKey",
      type: "text",
      value: component?.config?.privateKey[0],
      filenamePlaceholder: "Upload a PEM file or paste key below",
      filename: keyFileName,
      onChange: (value, fileName) => {
        setKeyFileName(fileName);
        onChange([value]);
      }
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("x509Certificate"),
    fieldId: "kc-aes-keysize",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: "realm-settings-help:x509Certificate",
      forLabel: t4("x509Certificate"),
      forID: t4("common:helpLabel", {label: t4("x509Certificate")})
    })
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.certificate",
    control: form2.control,
    defaultValue: [],
    render: ({onChange}) => /* @__PURE__ */ react.createElement(FileUpload, {
      id: "importCertificate",
      type: "text",
      value: component?.config?.certificate[0],
      filenamePlaceholder: "Upload a PEM file or paste key below",
      filename: certificateFileName,
      onChange: (value, fileName) => {
        setCertificateFileName(fileName);
        onChange([value]);
      }
    })
  })), /* @__PURE__ */ react.createElement(ActionGroup, {
    className: "kc-hmac-form-buttons"
  }, /* @__PURE__ */ react.createElement(Button, {
    className: "kc-hmac-form-save-button",
    "data-testid": "add-provider-button",
    variant: "primary",
    type: "submit"
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    className: "kc-hmac-form-cancel-button",
    onClick: !editMode && handleModalToggle || void 0,
    variant: "link"
  }, t4("common:cancel"))));
};
var RSASettings = () => {
  const {t: t4} = useTranslation("realm-settings");
  const providerId = useRouteMatch("/:realm/realm-settings/keys/:id?/:providerType?/settings")?.params.providerType;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: t4("editProvider"),
    subKey: providerId
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(RSAForm, {
    providerType: providerId,
    editMode: true
  })));
};

// build/realm-settings/routes/RsaSettings.js
var RsaSettingsRoute = {
  path: "/:realm/realm-settings/keys/:id/rsa/settings",
  component: RSASettings,
  breadcrumb: () => EditProviderCrumb,
  access: "view-realm"
};

// build/realm-settings/routes.js
var routes9 = [
  RealmSettingsRoute,
  AesGeneratedSettingsRoute,
  EcdsaGeneratedSettingsRoute,
  HmacGeneratedSettingsRoute,
  JavaKeystoreSettingsRoute,
  RsaGeneratedSettingsRoute,
  RsaSettingsRoute
];
var routes_default9 = routes9;

// build/realm/routes.js
var routes10 = [AddRealmRoute];
var routes_default10 = routes10;

// build/sessions/SessionsSection.js
var import_moment7 = __toModule(require_moment());
var Clients = (row) => {
  return /* @__PURE__ */ react.createElement(react.Fragment, null, Object.values(row.clients).map((client2) => /* @__PURE__ */ react.createElement(Link, {
    key: client2,
    to: "",
    className: "pf-u-mx-sm"
  }, client2)));
};
var SessionsSection = () => {
  const {t: t4} = useTranslation("sessions");
  const adminClient = useAdminClient();
  const [filterDropdownOpen, setFilterDropdownOpen] = useState(false);
  const [filterType, setFilterType] = useState(t4("sessionsType.allSessions").toString());
  const [key, setKey] = useState(0);
  const refresh = () => {
    setKey(new Date().getTime());
  };
  const loader = async () => {
    const activeClients = await adminClient.sessions.find();
    const clientSessions = (await Promise.all(activeClients.map((client2) => adminClient.clients.listSessions({id: client2.id})))).flat();
    const userIds = Array.from(new Set(clientSessions.map((session) => session.userId)));
    const userSessions = (await Promise.all(userIds.map((userId) => adminClient.users.listSessions({id: userId})))).flat();
    return userSessions;
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: "sessions:title",
    subKey: "sessions:sessionExplain"
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    className: "pf-u-p-0"
  }, /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    loader,
    ariaLabelKey: "session:title",
    searchPlaceholderKey: "sessions:searchForSession",
    searchTypeComponent: /* @__PURE__ */ react.createElement(Select, {
      "data-testid": "filter-session-type-select",
      isOpen: filterDropdownOpen,
      className: "kc-filter-session-type-select",
      variant: SelectVariant.single,
      onToggle: (isExpanded) => setFilterDropdownOpen(isExpanded),
      toggleIcon: /* @__PURE__ */ react.createElement(FilterIcon, null),
      onSelect: (_23, value) => {
        setFilterType(value.toString());
        refresh();
        setFilterDropdownOpen(false);
      },
      selections: filterType
    }, /* @__PURE__ */ react.createElement(SelectOption, {
      "data-testid": "all-sessions-option",
      value: t4("sessionsType.allSessions"),
      isPlaceholder: true
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      "data-testid": "regular-sso-option",
      value: t4("sessionsType.regularSSO")
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      "data-testid": "offline-option",
      value: t4("sessionsType.offline")
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      "data-testid": "direct-grant-option",
      value: t4("sessionsType.directGrant")
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      "data-testid": "service-account-option",
      value: t4("sessionsType.serviceAccount")
    })),
    columns: [
      {
        name: "username",
        displayKey: "sessions:subject"
      },
      {
        name: "lastAccess",
        displayKey: "sessions:lastAccess",
        cellRenderer: (row) => (0, import_moment7.default)(row.lastAccess).fromNow()
      },
      {
        name: "start",
        displayKey: "sessions:startDate",
        cellRenderer: (row) => (0, import_moment7.default)(row.lastAccess).format("LLL")
      },
      {
        name: "clients",
        displayKey: "sessions:accessedClients",
        cellRenderer: Clients
      }
    ],
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      message: t4("emptyTitle"),
      instructions: t4("emptyInstructions")
    })
  })));
};

// build/sessions/routes/Sessions.js
var SessionsRoute = {
  path: "/:realm/sessions",
  component: SessionsSection,
  breadcrumb: (t4) => t4("sessions:title"),
  access: "view-realm"
};

// build/sessions/routes.js
var routes11 = [SessionsRoute];
var routes_default11 = routes11;

// build/components/wizard-section-header/WizardSectionHeader.js
var WizardSectionHeader = ({
  title: title3,
  description,
  showDescription = false
}) => {
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Title, {
    size: "xl",
    headingLevel: "h2",
    className: showDescription ? "kc-wizard-section-header__title--has-description" : "kc-wizard-section-header__title"
  }, title3), showDescription && /* @__PURE__ */ react.createElement(TextContent, {
    className: "kc-wizard-section-header__description"
  }, /* @__PURE__ */ react.createElement(Text, null, description)));
};

// build/user-federation/kerberos/KerberosSettingsRequired.js
var KerberosSettingsRequired = ({
  form: form2,
  showSectionHeading = false,
  showSectionDescription = false
}) => {
  const {t: t4} = useTranslation("user-federation");
  const helpText = useTranslation("user-federation-help").t;
  const {realm: realm2} = useRealm();
  const [isEditModeDropdownOpen, setIsEditModeDropdownOpen] = useState(false);
  const allowPassAuth = useWatch({
    control: form2.control,
    name: "config.allowPasswordAuthentication"
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, showSectionHeading && /* @__PURE__ */ react.createElement(WizardSectionHeader, {
    title: t4("requiredSettings"),
    description: helpText("kerberosRequiredSettingsDescription"),
    showDescription: showSectionDescription
  }), /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-realm",
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("consoleDisplayName"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("consoleDisplayNameHelp"),
      forLabel: t4("consoleDisplayName"),
      forID: "kc-console-display-name"
    }),
    fieldId: "kc-console-display-name",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    hidden: true,
    type: "text",
    id: "kc-console-providerId",
    name: "providerId",
    defaultValue: "kerberos",
    ref: form2.register
  }), /* @__PURE__ */ react.createElement(TextInput, {
    hidden: true,
    type: "text",
    id: "kc-console-providerType",
    name: "providerType",
    defaultValue: "org.keycloak.storage.UserStorageProvider",
    ref: form2.register
  }), /* @__PURE__ */ react.createElement(TextInput, {
    hidden: true,
    type: "text",
    id: "kc-console-parentId",
    name: "parentId",
    defaultValue: realm2,
    ref: form2.register
  }), /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-console-name",
    name: "name",
    ref: form2.register({
      required: {
        value: true,
        message: `${t4("validateName")}`
      }
    }),
    "data-testid": "kerberos-name"
  }), form2.errors.name && /* @__PURE__ */ react.createElement("div", {
    className: "error"
  }, form2.errors.name.message)), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("kerberosRealm"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("kerberosRealmHelp"),
      forLabel: t4("kerberosRealm"),
      forID: "kc-kerberos-realm"
    }),
    fieldId: "kc-kerberos-realm",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-kerberos-realm",
    name: "config.kerberosRealm[0]",
    ref: form2.register({
      required: {
        value: true,
        message: `${t4("validateRealm")}`
      }
    }),
    "data-testid": "kerberos-realm"
  }), form2.errors.config && form2.errors.config.kerberosRealm && form2.errors.config.kerberosRealm[0] && /* @__PURE__ */ react.createElement("div", {
    className: "error"
  }, form2.errors.config.kerberosRealm[0].message)), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("serverPrincipal"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("serverPrincipalHelp"),
      forLabel: t4("serverPrincipal"),
      forID: "kc-server-principal"
    }),
    fieldId: "kc-server-principal",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-server-principal",
    name: "config.serverPrincipal[0]",
    ref: form2.register({
      required: {
        value: true,
        message: `${t4("validateServerPrincipal")}`
      }
    }),
    "data-testid": "kerberos-principal"
  }), form2.errors.config && form2.errors.config.serverPrincipal && form2.errors.config.serverPrincipal[0] && /* @__PURE__ */ react.createElement("div", {
    className: "error"
  }, form2.errors.config.serverPrincipal[0].message)), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("keyTab"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("keyTabHelp"),
      forLabel: t4("keyTab"),
      forID: "kc-key-tab"
    }),
    fieldId: "kc-key-tab",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-key-tab",
    name: "config.keyTab[0]",
    ref: form2.register({
      required: {
        value: true,
        message: `${t4("validateKeyTab")}`
      }
    }),
    "data-testid": "kerberos-keytab"
  }), form2.errors.config && form2.errors.config.keyTab && form2.errors.config.keyTab[0] && /* @__PURE__ */ react.createElement("div", {
    className: "error"
  }, form2.errors.config.keyTab[0].message)), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("debug"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("debugHelp"),
      forLabel: t4("debug"),
      forID: "kc-debug"
    }),
    fieldId: "kc-debug",
    hasNoPaddingTop: true
  }, " ", /* @__PURE__ */ react.createElement(Controller, {
    name: "config.debug",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-debug",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("allowPasswordAuthentication"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("allowPasswordAuthenticationHelp"),
      forLabel: t4("allowPasswordAuthentication"),
      forID: "kc-allow-password-authentication"
    }),
    fieldId: "kc-allow-password-authentication",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.allowPasswordAuthentication",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-allow-password-authentication",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  })), lodash.isEqual(allowPassAuth, ["true"]) ? /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("editMode"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("editModeKerberosHelp"),
      forLabel: t4("editMode"),
      forID: "kc-edit-mode"
    }),
    isRequired: true,
    fieldId: "kc-edit-mode"
  }, " ", /* @__PURE__ */ react.createElement(Controller, {
    name: "config.editMode[0]",
    defaultValue: "READ_ONLY",
    control: form2.control,
    rules: {required: true},
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-edit-mode",
      required: true,
      onToggle: () => setIsEditModeDropdownOpen(!isEditModeDropdownOpen),
      isOpen: isEditModeDropdownOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setIsEditModeDropdownOpen(false);
      },
      selections: value,
      variant: SelectVariant.single
    }, /* @__PURE__ */ react.createElement(SelectOption, {
      key: 0,
      value: "READ_ONLY",
      isPlaceholder: true
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 1,
      value: "UNSYNCED"
    }))
  })) : /* @__PURE__ */ react.createElement(react.Fragment, null), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("updateFirstLogin"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("updateFirstLoginHelp"),
      forLabel: t4("updateFirstLogin"),
      forID: "kc-update-first-login"
    }),
    fieldId: "kc-update-first-login",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.updateProfileFirstLogin",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-update-first-login",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  }))));
};

// build/user-federation/shared/SettingsCache.js
var SettingsCache = ({
  form: form2,
  showSectionHeading = false,
  showSectionDescription = false
}) => {
  const {t: t4} = useTranslation("user-federation");
  const helpText = useTranslation("user-federation-help").t;
  const [isCachePolicyDropdownOpen, setIsCachePolicyDropdownOpen] = useState(false);
  const [isEvictionHourDropdownOpen, setIsEvictionHourDropdownOpen] = useState(false);
  const cachePolicyType = useWatch({
    control: form2.control,
    name: "config.cachePolicy"
  });
  const [isEvictionMinuteDropdownOpen, setIsEvictionMinuteDropdownOpen] = useState(false);
  const [isEvictionDayDropdownOpen, setIsEvictionDayDropdownOpen] = useState(false);
  const hourOptions = [
    /* @__PURE__ */ react.createElement(SelectOption, {
      key: 0,
      value: [`${0}`],
      isPlaceholder: true
    }, [`0${0}`])
  ];
  let hourDisplay = "";
  for (let index3 = 1; index3 < 24; index3++) {
    if (index3 < 10) {
      hourDisplay = `0${index3}`;
    } else {
      hourDisplay = `${index3}`;
    }
    hourOptions.push(/* @__PURE__ */ react.createElement(SelectOption, {
      key: index3,
      value: [`${index3}`]
    }, hourDisplay));
  }
  const minuteOptions = [
    /* @__PURE__ */ react.createElement(SelectOption, {
      key: 0,
      value: [`${0}`],
      isPlaceholder: true
    }, [`0${0}`])
  ];
  let minuteDisplay = "";
  for (let index3 = 1; index3 < 60; index3++) {
    if (index3 < 10) {
      minuteDisplay = `0${index3}`;
    } else {
      minuteDisplay = `${index3}`;
    }
    minuteOptions.push(/* @__PURE__ */ react.createElement(SelectOption, {
      key: index3,
      value: [`${index3}`]
    }, minuteDisplay));
  }
  return /* @__PURE__ */ react.createElement(react.Fragment, null, showSectionHeading && /* @__PURE__ */ react.createElement(WizardSectionHeader, {
    title: t4("cacheSettings"),
    description: helpText("cacheSettingsDescription"),
    showDescription: showSectionDescription
  }), /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-realm",
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("cachePolicy"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("cachePolicyHelp"),
      forLabel: t4("cachePolicy"),
      forID: "kc-cache-policy"
    }),
    fieldId: "kc-cache-policy"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.cachePolicy",
    defaultValue: ["DEFAULT"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-cache-policy",
      required: true,
      onToggle: () => setIsCachePolicyDropdownOpen(!isCachePolicyDropdownOpen),
      isOpen: isCachePolicyDropdownOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setIsCachePolicyDropdownOpen(false);
      },
      selections: value,
      variant: SelectVariant.single,
      "data-testid": "kerberos-cache-policy"
    }, /* @__PURE__ */ react.createElement(SelectOption, {
      key: 0,
      value: ["DEFAULT"],
      isPlaceholder: true
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 1,
      value: ["EVICT_DAILY"]
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 2,
      value: ["EVICT_WEEKLY"]
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 3,
      value: ["MAX_LIFESPAN"]
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 4,
      value: ["NO_CACHE"]
    }))
  })), lodash.isEqual(cachePolicyType, ["EVICT_WEEKLY"]) ? /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("evictionDay"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("evictionDayHelp"),
      forLabel: t4("evictionDay"),
      forID: "kc-eviction-day"
    }),
    isRequired: true,
    fieldId: "kc-eviction-day"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.evictionDay[0]",
    defaultValue: "1",
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      "data-testid": "cache-day",
      toggleId: "kc-eviction-day",
      required: true,
      onToggle: () => setIsEvictionDayDropdownOpen(!isEvictionDayDropdownOpen),
      isOpen: isEvictionDayDropdownOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setIsEvictionDayDropdownOpen(false);
      },
      selections: value,
      variant: SelectVariant.single
    }, /* @__PURE__ */ react.createElement(SelectOption, {
      key: 0,
      value: "1",
      isPlaceholder: true
    }, t4("common:Sunday")), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 1,
      value: "2"
    }, t4("common:Monday")), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 2,
      value: "3"
    }, t4("common:Tuesday")), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 3,
      value: "4"
    }, t4("common:Wednesday")), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 4,
      value: "5"
    }, t4("common:Thursday")), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 5,
      value: "6"
    }, t4("common:Friday")), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 6,
      value: "7"
    }, t4("common:Saturday")))
  })) : /* @__PURE__ */ react.createElement(react.Fragment, null), lodash.isEqual(cachePolicyType, ["EVICT_DAILY"]) || lodash.isEqual(cachePolicyType, ["EVICT_WEEKLY"]) ? /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("evictionHour"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("evictionHourHelp"),
      forLabel: t4("evictionHour"),
      forID: "kc-eviction-hour"
    }),
    isRequired: true,
    fieldId: "kc-eviction-hour"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.evictionHour",
    defaultValue: ["0"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-eviction-hour",
      onToggle: () => setIsEvictionHourDropdownOpen(!isEvictionHourDropdownOpen),
      isOpen: isEvictionHourDropdownOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setIsEvictionHourDropdownOpen(false);
      },
      selections: value,
      variant: SelectVariant.single
    }, hourOptions)
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("evictionMinute"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("evictionMinuteHelp"),
      forLabel: t4("evictionMinute"),
      forID: "kc-eviction-minute"
    }),
    isRequired: true,
    fieldId: "kc-eviction-minute"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.evictionMinute",
    defaultValue: ["0"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-eviction-minute",
      onToggle: () => setIsEvictionMinuteDropdownOpen(!isEvictionMinuteDropdownOpen),
      isOpen: isEvictionMinuteDropdownOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setIsEvictionMinuteDropdownOpen(false);
      },
      selections: value,
      variant: SelectVariant.single
    }, minuteOptions)
  }))) : /* @__PURE__ */ react.createElement(react.Fragment, null), lodash.isEqual(cachePolicyType, ["MAX_LIFESPAN"]) ? /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("maxLifespan"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("maxLifespanHelp"),
      forLabel: t4("maxLifespan"),
      forID: "kc-max-lifespan"
    }),
    fieldId: "kc-max-lifespan"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-max-lifespan",
    name: "config.maxLifespan[0]",
    ref: form2.register,
    "data-testid": "kerberos-cache-lifespan"
  })) : /* @__PURE__ */ react.createElement(react.Fragment, null)));
};

// build/user-federation/UserFederationKerberosSettings.js
var KerberosSettingsHeader = ({
  onChange,
  value,
  save,
  toggleDeleteDialog
}) => {
  const {t: t4} = useTranslation("user-federation");
  const {id: id3} = useParams();
  const [toggleDisableDialog, DisableConfirm] = useConfirmDialog({
    titleKey: "user-federation:userFedDisableConfirmTitle",
    messageKey: "user-federation:userFedDisableConfirm",
    continueButtonLabel: "common:disable",
    onConfirm: () => {
      onChange("false");
      save();
    }
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DisableConfirm, null), id3 === "new" ? /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: "Kerberos"
  }) : /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: "Kerberos",
    dropdownItems: [
      /* @__PURE__ */ react.createElement(DropdownItem, {
        key: "delete",
        onClick: () => toggleDeleteDialog(),
        "data-testid": "delete-kerberos-cmd"
      }, t4("deleteProvider"))
    ],
    isEnabled: value === "true",
    onToggle: (value2) => {
      if (!value2) {
        toggleDisableDialog();
      } else {
        onChange("" + value2);
        save();
      }
    }
  }));
};
var UserFederationKerberosSettings = () => {
  const {t: t4} = useTranslation("user-federation");
  const form2 = useForm({mode: "onChange"});
  const history = useHistory();
  const adminClient = useAdminClient();
  const {realm: realm2} = useRealm();
  const {id: id3} = useParams();
  const {addAlert, addError} = useAlerts();
  useEffect(() => {
    (async () => {
      if (id3 !== "new") {
        const fetchedComponent = await adminClient.components.findOne({id: id3});
        if (fetchedComponent) {
          setupForm(fetchedComponent);
        }
      }
    })();
  }, []);
  const setupForm = (component) => {
    form2.reset();
    Object.entries(component).map((entry) => {
      form2.setValue("config.allowPasswordAuthentication", component.config?.allowPasswordAuthentication);
      if (entry[0] === "config") {
        convertToFormValues(entry[1], "config", form2.setValue);
      }
      form2.setValue(entry[0], entry[1]);
    });
  };
  const save = async (component) => {
    try {
      if (id3) {
        if (id3 === "new") {
          await adminClient.components.create(component);
          history.push(`/${realm2}/user-federation`);
        } else {
          await adminClient.components.update({id: id3}, component);
        }
      }
      setupForm(component);
      addAlert(t4(id3 === "new" ? "createSuccess" : "saveSuccess"), AlertVariant.success);
    } catch (error2) {
      addError(`user-federation:${id3 === "new" ? "createError" : "saveError"}`, error2);
    }
  };
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: "user-federation:userFedDeleteConfirmTitle",
    messageKey: "user-federation:userFedDeleteConfirm",
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        await adminClient.components.del({id: id3});
        addAlert(t4("userFedDeletedSuccess"), AlertVariant.success);
        history.replace(`/${realm2}/user-federation`);
      } catch (error2) {
        addAlert("user-federation:userFedDeleteError", error2);
      }
    }
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DeleteConfirm, null), /* @__PURE__ */ react.createElement(Controller, {
    name: "config.enabled[0]",
    defaultValue: ["true"][0],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(KerberosSettingsHeader, {
      value,
      onChange,
      save: () => save(form2.getValues()),
      toggleDeleteDialog
    })
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light"
  }, /* @__PURE__ */ react.createElement(KerberosSettingsRequired, {
    form: form2,
    showSectionHeading: true
  })), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    isFilled: true
  }, /* @__PURE__ */ react.createElement(SettingsCache, {
    form: form2,
    showSectionHeading: true
  }), /* @__PURE__ */ react.createElement(Form, {
    onSubmit: form2.handleSubmit(save)
  }, /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    isDisabled: !form2.formState.isDirty,
    variant: "primary",
    type: "submit",
    "data-testid": "kerberos-save"
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: () => history.push(`/${realm2}/user-federation`),
    "data-testid": "kerberos-cancel"
  }, t4("common:cancel"))))));
};

// build/user-federation/routes/NewKerberosUserFederation.js
var NewKerberosUserFederationRoute = {
  path: "/:realm/user-federation/kerberos/new",
  component: UserFederationKerberosSettings,
  breadcrumb: (t4) => t4("common:settings"),
  access: "view-realm"
};

// build/user-federation/ldap/LdapSettingsAdvanced.js
var LdapSettingsAdvanced = ({
  form: form2,
  showSectionHeading = false,
  showSectionDescription = false
}) => {
  const {t: t4} = useTranslation("user-federation");
  const helpText = useTranslation("user-federation-help").t;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, showSectionHeading && /* @__PURE__ */ react.createElement(WizardSectionHeader, {
    title: t4("advancedSettings"),
    description: helpText("ldapAdvancedSettingsDescription"),
    showDescription: showSectionDescription
  }), /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-realm",
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("enableLdapv3Password"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("enableLdapv3PasswordHelp"),
      forLabel: t4("enableLdapv3Password"),
      forID: "kc-enable-ldapv3-password"
    }),
    fieldId: "kc-enable-ldapv3-password",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.usePasswordModifyExtendedOp",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-enable-ldapv3-password",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("validatePasswordPolicy"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("validatePasswordPolicyHelp"),
      forLabel: t4("validatePasswordPolicy"),
      forID: "kc-validate-password-policy"
    }),
    fieldId: "kc-validate-password-policy",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.validatePasswordPolicy",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-validate-password-policy",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("trustEmail"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("trustEmailHelp"),
      forLabel: t4("trustEmail"),
      forID: "kc-trust-email"
    }),
    fieldId: "kc-trust-email",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.trustEmail",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-trust-email",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  }))));
};

// build/user-federation/ldap/LdapSettingsKerberosIntegration.js
var LdapSettingsKerberosIntegration = ({
  form: form2,
  showSectionHeading = false,
  showSectionDescription = false
}) => {
  const {t: t4} = useTranslation("user-federation");
  const helpText = useTranslation("user-federation-help").t;
  const allowKerberosAuth = useWatch({
    control: form2.control,
    name: "config.allowKerberosAuthentication",
    defaultValue: ["false"]
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, showSectionHeading && /* @__PURE__ */ react.createElement(WizardSectionHeader, {
    title: t4("kerberosIntegration"),
    description: helpText("ldapKerberosSettingsDescription"),
    showDescription: showSectionDescription
  }), /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-realm",
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("allowKerberosAuthentication"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("allowKerberosAuthenticationHelp"),
      forLabel: t4("allowKerberosAuthentication"),
      forID: "kc-allow-kerberos-authentication"
    }),
    fieldId: "kc-allow-kerberos-authentication",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.allowKerberosAuthentication",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-allow-kerberos-authentication",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  })), allowKerberosAuth[0] === "true" && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("kerberosRealm"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("kerberosRealmHelp"),
      forLabel: t4("kerberosRealm"),
      forID: "kc-kerberos-realm"
    }),
    fieldId: "kc-kerberos-realm",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-kerberos-realm",
    name: "config.kerberosRealm[0]",
    ref: form2.register({
      required: {
        value: true,
        message: `${t4("validateRealm")}`
      }
    }),
    "data-testid": "kerberos-realm"
  }), form2.errors.config && form2.errors.config.kerberosRealm && form2.errors.config.kerberosRealm[0] && /* @__PURE__ */ react.createElement("div", {
    className: "error"
  }, form2.errors.config.kerberosRealm[0].message)), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("serverPrincipal"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("serverPrincipalHelp"),
      forLabel: t4("serverPrincipal"),
      forID: "kc-server-principal"
    }),
    fieldId: "kc-server-principal",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-server-principal",
    name: "config.serverPrincipal[0]",
    ref: form2.register({
      required: {
        value: true,
        message: `${t4("validateServerPrincipal")}`
      }
    }),
    "data-testid": "kerberos-principal"
  }), form2.errors.config && form2.errors.config.serverPrincipal && form2.errors.config.serverPrincipal[0] && /* @__PURE__ */ react.createElement("div", {
    className: "error"
  }, form2.errors.config.serverPrincipal[0].message)), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("keyTab"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("keyTabHelp"),
      forLabel: t4("keyTab"),
      forID: "kc-key-tab"
    }),
    fieldId: "kc-key-tab",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-key-tab",
    name: "config.keyTab[0]",
    ref: form2.register({
      required: {
        value: true,
        message: `${t4("validateKeyTab")}`
      }
    }),
    "data-testid": "kerberos-keytab"
  }), form2.errors.config && form2.errors.config.keyTab && form2.errors.config.keyTab[0] && /* @__PURE__ */ react.createElement("div", {
    className: "error"
  }, form2.errors.config.keyTab[0].message)), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("debug"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("debugHelp"),
      forLabel: t4("debug"),
      forID: "kc-debug"
    }),
    fieldId: "kc-debug",
    hasNoPaddingTop: true
  }, " ", /* @__PURE__ */ react.createElement(Controller, {
    name: "config.debug",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-debug",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  }))), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("useKerberosForPasswordAuthentication"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("useKerberosForPasswordAuthenticationHelp"),
      forLabel: t4("useKerberosForPasswordAuthentication"),
      forID: "kc-use-kerberos-password-authentication"
    }),
    fieldId: "kc-use-kerberos-password-authentication",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.useKerberosForPasswordAuthentication",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-use-kerberos-password-authentication",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  }))));
};

// build/user-federation/ldap/LdapSettingsSynchronization.js
var LdapSettingsSynchronization = ({
  form: form2,
  showSectionHeading = false,
  showSectionDescription = false
}) => {
  const {t: t4} = useTranslation("user-federation");
  const helpText = useTranslation("user-federation-help").t;
  const watchPeriodicSync = form2.watch("config.periodicFullSync", false);
  const watchChangedSync = form2.watch("config.periodicChangedUsersSync", false);
  return /* @__PURE__ */ react.createElement(react.Fragment, null, showSectionHeading && /* @__PURE__ */ react.createElement(WizardSectionHeader, {
    title: t4("synchronizationSettings"),
    description: helpText("ldapSynchronizationSettingsDescription"),
    showDescription: showSectionDescription
  }), /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-realm",
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    hasNoPaddingTop: true,
    label: t4("importUsers"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("importUsersHelp"),
      forLabel: t4("importUsers"),
      forID: "kc-import-users"
    }),
    fieldId: "kc-import-users"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.importEnabled",
    defaultValue: ["true"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-import-users",
      name: "importEnabled",
      label: t4("common:on"),
      labelOff: t4("common:off"),
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      isDisabled: false
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("batchSize"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("batchSizeHelp"),
      forLabel: t4("batchSize"),
      forID: "kc-batch-size"
    }),
    fieldId: "kc-batch-size"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "number",
    min: 0,
    id: "kc-batch-size",
    name: "config.batchSizeForSync[0]",
    ref: form2.register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: "Periodic full sync",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("periodicFullSyncHelp"),
      forLabel: "periodicFullSync",
      forID: "kc-periodic-full-sync"
    }),
    fieldId: "kc-periodic-full-sync",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.periodicFullSync",
    defaultValue: false,
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-periodic-full-sync",
      isDisabled: false,
      onChange: (value2) => onChange(value2),
      isChecked: value === true,
      label: t4("common:on"),
      labelOff: t4("common:off"),
      ref: form2.register
    })
  })), watchPeriodicSync && /* @__PURE__ */ react.createElement(FormGroup, {
    hasNoPaddingTop: true,
    label: t4("fullSyncPeriod"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("fullSyncPeriodHelp"),
      forLabel: t4("fullSyncPeriod"),
      forID: "kc-full-sync-period"
    }),
    fieldId: "kc-full-sync-period"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "number",
    min: -1,
    defaultValue: 604800,
    id: "kc-full-sync-period",
    name: "config.fullSyncPeriod[0]",
    ref: form2.register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: "Periodic Changed Users Sync",
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("periodicChangedUsersSyncHelp"),
      forLabel: "periodicChangedUsersSync",
      forID: "kc-periodic-changed-users-sync"
    }),
    fieldId: "kc-periodic-changed-users-sync",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.periodicChangedUsersSync",
    defaultValue: false,
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-periodic-changed-users-sync",
      isDisabled: false,
      onChange: (value2) => onChange(value2),
      isChecked: value === true,
      label: t4("common:on"),
      labelOff: t4("common:off"),
      ref: form2.register
    })
  })), watchChangedSync && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("changedUsersSyncPeriod"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("changedUsersSyncHelp"),
      forLabel: t4("changedUsersSyncPeriod"),
      forID: "kc-changed-users-sync-period"
    }),
    fieldId: "kc-changed-users-sync-period",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "number",
    min: -1,
    defaultValue: 86400,
    id: "kc-changed-users-sync-period",
    name: "config.changedSyncPeriod[0]",
    ref: form2.register
  }))));
};

// build/user-federation/ldap/LdapSettingsGeneral.js
var LdapSettingsGeneral = ({
  form: form2,
  showSectionHeading = false,
  showSectionDescription = false
}) => {
  const {t: t4} = useTranslation("user-federation");
  const helpText = useTranslation("user-federation-help").t;
  const {realm: realm2} = useRealm();
  const [isVendorDropdownOpen, setIsVendorDropdownOpen] = useState(false);
  const setVendorDefaultValues = () => {
    switch (form2.getValues("config.vendor[0]")) {
      case "ad":
        form2.setValue("config.usernameLDAPAttribute[0]", "cn");
        form2.setValue("config.rdnLDAPAttribute[0]", "cn");
        form2.setValue("config.uuidLDAPAttribute[0]", "objectGUID");
        form2.setValue("config.userObjectClasses[0]", "person, organizationalPerson, user");
        break;
      case "rhds":
        form2.setValue("config.usernameLDAPAttribute[0]", "uid");
        form2.setValue("config.rdnLDAPAttribute[0]", "uid");
        form2.setValue("config.uuidLDAPAttribute[0]", "nsuniqueid");
        form2.setValue("config.userObjectClasses[0]", "inetOrgPerson, organizationalPerson");
        break;
      case "tivoli":
        form2.setValue("config.usernameLDAPAttribute[0]", "uid");
        form2.setValue("config.rdnLDAPAttribute[0]", "uid");
        form2.setValue("config.uuidLDAPAttribute[0]", "uniqueidentifier");
        form2.setValue("config.userObjectClasses[0]", "inetOrgPerson, organizationalPerson");
        break;
      case "edirectory":
        form2.setValue("config.usernameLDAPAttribute[0]", "uid");
        form2.setValue("config.rdnLDAPAttribute[0]", "uid");
        form2.setValue("config.uuidLDAPAttribute[0]", "guid");
        form2.setValue("config.userObjectClasses[0]", "inetOrgPerson, organizationalPerson");
        break;
      case "other":
        form2.setValue("config.usernameLDAPAttribute[0]", "uid");
        form2.setValue("config.rdnLDAPAttribute[0]", "uid");
        form2.setValue("config.uuidLDAPAttribute[0]", "entryUUID");
        form2.setValue("config.userObjectClasses[0]", "inetOrgPerson, organizationalPerson");
        break;
      default:
        return "";
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, showSectionHeading && /* @__PURE__ */ react.createElement(WizardSectionHeader, {
    title: t4("generalOptions"),
    description: helpText("ldapGeneralOptionsSettingsDescription"),
    showDescription: showSectionDescription
  }), /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-realm",
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("consoleDisplayName"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("consoleDisplayNameHelp"),
      forLabel: t4("consoleDisplayName"),
      forID: "kc-console-display-name"
    }),
    fieldId: "kc-console-display-name",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    hidden: true,
    type: "text",
    id: "kc-console-provider-id",
    name: "providerId",
    defaultValue: "ldap",
    ref: form2.register
  }), /* @__PURE__ */ react.createElement(TextInput, {
    hidden: true,
    type: "text",
    id: "kc-console-provider-type",
    name: "providerType",
    defaultValue: "org.keycloak.storage.UserStorageProvider",
    ref: form2.register
  }), /* @__PURE__ */ react.createElement(TextInput, {
    hidden: true,
    type: "text",
    id: "kc-console-parentId",
    name: "parentId",
    defaultValue: realm2,
    ref: form2.register
  }), /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-console-display-name",
    name: "name",
    defaultValue: "ldap",
    ref: form2.register({
      required: {
        value: true,
        message: `${t4("validateName")}`
      }
    }),
    "data-testid": "ldap-name"
  }), form2.errors.name && /* @__PURE__ */ react.createElement("div", {
    className: "error"
  }, form2.errors.name.message)), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("vendor"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("vendorHelp"),
      forLabel: t4("vendor"),
      forID: "kc-vendor"
    }),
    fieldId: "kc-vendor",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.vendor[0]",
    defaultValue: "ad",
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-vendor",
      required: true,
      onToggle: () => setIsVendorDropdownOpen(!isVendorDropdownOpen),
      isOpen: isVendorDropdownOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setIsVendorDropdownOpen(false);
        setVendorDefaultValues();
      },
      selections: value,
      variant: SelectVariant.single
    }, /* @__PURE__ */ react.createElement(SelectOption, {
      key: 0,
      value: "ad",
      isPlaceholder: true
    }, "Active Directory"), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 1,
      value: "rhds"
    }, "Red Hat Directory Server"), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 2,
      value: "tivoli"
    }, "Tivoli"), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 3,
      value: "edirectory"
    }, "Novell eDirectory"), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 4,
      value: "other"
    }, "Other"))
  }))));
};

// build/user-federation/ldap/LdapSettingsConnection.js
var testLdapProperties = [
  "connectionUrl",
  "bindDn",
  "bindCredential",
  "useTruststoreSpi",
  "connectionTimeout",
  "startTls",
  "authType"
];
var LdapSettingsConnection = ({
  form: form2,
  showSectionHeading = false,
  showSectionDescription = false
}) => {
  const {t: t4} = useTranslation("user-federation");
  const {t: helpText} = useTranslation("user-federation-help");
  const adminClient = useAdminClient();
  const {realm: realm2} = useRealm();
  const {addAlert, addError} = useAlerts();
  const testLdap = async () => {
    try {
      const settings = {};
      testLdapProperties.forEach((key) => {
        const value = lodash.get(form2.getValues(), `config.${key}`);
        settings[key] = lodash.isArray(value) ? value[0] : "";
      });
      await adminClient.realms.testLDAPConnection({realm: realm2}, {...settings, action: "testConnection"});
      addAlert(t4("testSuccess"), AlertVariant.success);
    } catch (error2) {
      addError("user-federation:testError", error2);
    }
  };
  const [isTruststoreSpiDropdownOpen, setIsTruststoreSpiDropdownOpen] = useState(false);
  const [isBindTypeDropdownOpen, setIsBindTypeDropdownOpen] = useState(false);
  const ldapBindType = useWatch({
    control: form2.control,
    name: "config.authType",
    defaultValue: ["simple"]
  });
  return /* @__PURE__ */ react.createElement(react.Fragment, null, showSectionHeading && /* @__PURE__ */ react.createElement(WizardSectionHeader, {
    title: t4("connectionAndAuthenticationSettings"),
    description: helpText("ldapConnectionAndAuthorizationSettingsDescription"),
    showDescription: showSectionDescription
  }), /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-realm",
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("connectionURL"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("consoleDisplayConnectionUrlHelp"),
      forLabel: t4("connectionURL"),
      forID: "kc-console-connection-url"
    }),
    fieldId: "kc-console-connection-url",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-console-connection-url",
    "data-testid": "ldap-connection-url",
    name: "config.connectionUrl[0]",
    ref: form2.register({
      required: {
        value: true,
        message: `${t4("validateConnectionUrl")}`
      }
    })
  }), form2.errors.config && form2.errors.config.connectionUrl && form2.errors.config.connectionUrl[0] && /* @__PURE__ */ react.createElement("div", {
    className: "error"
  }, form2.errors.config.connectionUrl[0].message)), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("enableStartTls"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("enableStartTlsHelp"),
      forLabel: t4("enableStartTls"),
      forID: "kc-enable-start-tls"
    }),
    fieldId: "kc-enable-start-tls",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.startTls",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-enable-start-tls",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("useTruststoreSpi"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("useTruststoreSpiHelp"),
      forLabel: t4("useTruststoreSpi"),
      forID: "kc-use-truststore-spi"
    }),
    fieldId: "kc-use-truststore-spi"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.useTruststoreSpi[0]",
    control: form2.control,
    defaultValue: "ldapsOnly",
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-use-truststore-spi",
      onToggle: () => setIsTruststoreSpiDropdownOpen(!isTruststoreSpiDropdownOpen),
      isOpen: isTruststoreSpiDropdownOpen,
      onSelect: (_23, value2) => {
        onChange(value2.toString());
        setIsTruststoreSpiDropdownOpen(false);
      },
      selections: value
    }, /* @__PURE__ */ react.createElement(SelectOption, {
      value: "always"
    }, t4("always")), /* @__PURE__ */ react.createElement(SelectOption, {
      value: "ldapsOnly"
    }, t4("onlyLdaps")), /* @__PURE__ */ react.createElement(SelectOption, {
      value: "never"
    }, t4("never")))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("connectionPooling"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("connectionPoolingHelp"),
      forLabel: t4("connectionPooling"),
      forID: "kc-connection-pooling"
    }),
    fieldId: "kc-connection-pooling",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.connectionPooling",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-connection-pooling",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("connectionTimeout"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("connectionTimeoutHelp"),
      forLabel: t4("connectionTimeout"),
      forID: "kc-console-connection-timeout"
    }),
    fieldId: "kc-console-connection-timeout"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "number",
    min: 0,
    id: "kc-console-connection-timeout",
    name: "config.connectionTimeout[0]",
    ref: form2.register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("bindType"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("bindTypeHelp"),
      forLabel: t4("bindType"),
      forID: "kc-bind-type"
    }),
    fieldId: "kc-bind-type",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.authType[0]",
    defaultValue: "simple",
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-bind-type",
      required: true,
      onToggle: () => setIsBindTypeDropdownOpen(!isBindTypeDropdownOpen),
      isOpen: isBindTypeDropdownOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setIsBindTypeDropdownOpen(false);
      },
      selections: value,
      variant: SelectVariant.single,
      "data-testid": "ldap-bind-type"
    }, /* @__PURE__ */ react.createElement(SelectOption, {
      value: "simple"
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      value: "none"
    }))
  })), lodash.isEqual(ldapBindType, ["simple"]) && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("bindDn"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("bindDnHelp"),
      forLabel: t4("bindDn"),
      forID: "kc-console-bind-dn"
    }),
    fieldId: "kc-console-bind-dn",
    helperTextInvalid: t4("validateBindDn"),
    validated: form2.errors.config?.bindDn ? ValidatedOptions.error : ValidatedOptions.default,
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-console-bind-dn",
    "data-testid": "ldap-bind-dn",
    name: "config.bindDn[0]",
    ref: form2.register({required: true})
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("bindCredentials"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("bindCredentialsHelp"),
      forLabel: t4("bindCredentials"),
      forID: "kc-console-bind-credentials"
    }),
    fieldId: "kc-console-bind-credentials",
    helperTextInvalid: t4("validateBindCredentials"),
    validated: form2.errors.config?.bindCredential ? ValidatedOptions.error : ValidatedOptions.default,
    isRequired: true
  }, /* @__PURE__ */ react.createElement(PasswordInput, {
    isRequired: true,
    id: "kc-console-bind-credentials",
    "data-testid": "ldap-bind-credentials",
    name: "config.bindCredential[0]",
    ref: form2.register({
      required: true
    })
  }))), /* @__PURE__ */ react.createElement(FormGroup, {
    fieldId: "kc-test-button"
  }, /* @__PURE__ */ react.createElement(Button, {
    variant: "secondary",
    id: "kc-test-button",
    onClick: () => testLdap()
  }, t4("common:test")))));
};

// build/user-federation/ldap/LdapSettingsSearching.js
var LdapSettingsSearching = ({
  form: form2,
  showSectionHeading = false,
  showSectionDescription = false
}) => {
  const {t: t4} = useTranslation("user-federation");
  const helpText = useTranslation("user-federation-help").t;
  const [isSearchScopeDropdownOpen, setIsSearchScopeDropdownOpen] = useState(false);
  const [isEditModeDropdownOpen, setIsEditModeDropdownOpen] = useState(false);
  return /* @__PURE__ */ react.createElement(react.Fragment, null, showSectionHeading && /* @__PURE__ */ react.createElement(WizardSectionHeader, {
    title: t4("ldapSearchingAndUpdatingSettings"),
    description: helpText("ldapSearchingAndUpdatingSettingsDescription"),
    showDescription: showSectionDescription
  }), /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-realm",
    isHorizontal: true
  }, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("editMode"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("editModeLdapHelp"),
      forLabel: t4("editMode"),
      forID: "kc-edit-mode"
    }),
    fieldId: "kc-edit-mode"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.editMode[0]",
    defaultValue: "",
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-edit-mode",
      required: true,
      onToggle: () => setIsEditModeDropdownOpen(!isEditModeDropdownOpen),
      isOpen: isEditModeDropdownOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setIsEditModeDropdownOpen(false);
      },
      selections: value,
      variant: SelectVariant.single
    }, /* @__PURE__ */ react.createElement(SelectOption, {
      key: 0,
      value: "",
      isPlaceholder: true
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 1,
      value: "READ_ONLY"
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 2,
      value: "WRITABLE"
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 3,
      value: "UNSYNCED"
    }))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("usersDN"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("usersDNHelp"),
      forLabel: t4("usersDN"),
      forID: "kc-console-users-dn"
    }),
    fieldId: "kc-console-users-dn",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    defaultValue: "",
    id: "kc-console-users-dn",
    "data-testid": "ldap-users-dn",
    name: "config.usersDn[0]",
    ref: form2.register({
      required: {
        value: true,
        message: `${t4("validateUsersDn")}`
      }
    })
  }), form2.errors.config && form2.errors.config.usersDn && form2.errors.config.usersDn[0] && /* @__PURE__ */ react.createElement("div", {
    className: "error"
  }, form2.errors.config.usersDn[0].message)), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("usernameLdapAttribute"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("usernameLdapAttributeHelp"),
      forLabel: t4("usernameLdapAttribute"),
      forID: "kc-username-ldap-attribute"
    }),
    fieldId: "kc-username-ldap-attribute",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    defaultValue: "cn",
    id: "kc-username-ldap-attribute",
    "data-testid": "ldap-username-attribute",
    name: "config.usernameLDAPAttribute[0]",
    ref: form2.register({
      required: {
        value: true,
        message: `${t4("validateUsernameLDAPAttribute")}`
      }
    })
  }), form2.errors.config && form2.errors.config.usernameLDAPAttribute && form2.errors.config.usernameLDAPAttribute[0] && /* @__PURE__ */ react.createElement("div", {
    className: "error"
  }, form2.errors.config.usernameLDAPAttribute[0].message)), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("rdnLdapAttribute"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("rdnLdapAttributeHelp"),
      forLabel: t4("rdnLdapAttribute"),
      forID: "kc-rdn-ldap-attribute"
    }),
    fieldId: "kc-rdn-ldap-attribute",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    defaultValue: "cn",
    id: "kc-rdn-ldap-attribute",
    "data-testid": "ldap-rdn-attribute",
    name: "config.rdnLDAPAttribute[0]",
    ref: form2.register({
      required: {
        value: true,
        message: `${t4("validateRdnLdapAttribute")}`
      }
    })
  }), form2.errors.config && form2.errors.config.rdnLDAPAttribute && form2.errors.config.rdnLDAPAttribute[0] && /* @__PURE__ */ react.createElement("div", {
    className: "error"
  }, form2.errors.config.rdnLDAPAttribute[0].message)), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("uuidLdapAttribute"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("uuidLdapAttributeHelp"),
      forLabel: t4("uuidLdapAttribute"),
      forID: "kc-uuid-ldap-attribute"
    }),
    fieldId: "kc-uuid-ldap-attribute",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    defaultValue: "objectGUID",
    id: "kc-uuid-ldap-attribute",
    "data-testid": "ldap-uuid-attribute",
    name: "config.uuidLDAPAttribute[0]",
    ref: form2.register({
      required: {
        value: true,
        message: `${t4("validateUuidLDAPAttribute")}`
      }
    })
  }), form2.errors.config && form2.errors.config.uuidLDAPAttribute && form2.errors.config.uuidLDAPAttribute[0] && /* @__PURE__ */ react.createElement("div", {
    className: "error"
  }, form2.errors.config.uuidLDAPAttribute[0].message)), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("userObjectClasses"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("userObjectClassesHelp"),
      forLabel: t4("userObjectClasses"),
      forID: "kc-user-object-classes"
    }),
    fieldId: "kc-user-object-classes",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    defaultValue: "person, organizationalPerson, user",
    id: "kc-user-object-classes",
    "data-testid": "ldap-user-object-classes",
    name: "config.userObjectClasses[0]",
    ref: form2.register({
      required: {
        value: true,
        message: `${t4("validateUserObjectClasses")}`
      }
    })
  }), form2.errors.config && form2.errors.config.userObjectClasses && form2.errors.config.userObjectClasses[0] && /* @__PURE__ */ react.createElement("div", {
    className: "error"
  }, form2.errors.config.userObjectClasses[0].message)), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("userLdapFilter"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("userLdapFilterHelp"),
      forLabel: t4("userLdapFilter"),
      forID: "kc-user-ldap-filter"
    }),
    fieldId: "kc-user-ldap-filter"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-user-ldap-filter",
    name: "config.customUserSearchFilter[0]",
    ref: form2.register({
      pattern: {
        value: /(\(.*\))$/,
        message: `${t4("validateCustomUserSearchFilter")}`
      }
    })
  }), form2.errors.config && form2.errors.config.customUserSearchFilter && form2.errors.config.customUserSearchFilter[0] && /* @__PURE__ */ react.createElement("div", {
    className: "error"
  }, form2.errors.config.customUserSearchFilter[0].message)), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("searchScope"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("searchScopeHelp"),
      forLabel: t4("searchScope"),
      forID: "kc-search-scope"
    }),
    fieldId: "kc-search-scope"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.searchScope[0]",
    defaultValue: "",
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-search-scope",
      required: true,
      onToggle: () => setIsSearchScopeDropdownOpen(!isSearchScopeDropdownOpen),
      isOpen: isSearchScopeDropdownOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setIsSearchScopeDropdownOpen(false);
      },
      selections: value,
      variant: SelectVariant.single
    }, /* @__PURE__ */ react.createElement(SelectOption, {
      key: 0,
      value: "1",
      isPlaceholder: true
    }, t4("oneLevel")), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 1,
      value: "2"
    }, t4("subtree")))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("readTimeout"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("readTimeoutHelp"),
      forLabel: t4("readTimeout"),
      forID: "kc-read-timeout"
    }),
    fieldId: "kc-read-timeout"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "number",
    min: 0,
    id: "kc-read-timeout",
    name: "config.readTimeout[0]",
    ref: form2.register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("pagination"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("paginationHelp"),
      forLabel: t4("pagination"),
      forID: "kc-console-pagination"
    }),
    fieldId: "kc-console-pagination",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.pagination",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-console-pagination",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  }))));
};

// build/user-federation/ldap/mappers/LdapMapperList.js
var LdapMapperList = () => {
  const history = useHistory();
  const {t: t4} = useTranslation("user-federation");
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const {url} = useRouteMatch();
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const {id: id3} = useParams();
  const [selectedMapper, setSelectedMapper] = useState();
  const loader = async () => {
    const testParams = {
      parent: id3,
      type: "org.keycloak.storage.ldap.mappers.LDAPStorageMapper"
    };
    const mappersList = (await adminClient.components.find(testParams)).map((mapper) => {
      return {
        ...mapper,
        name: mapper.name,
        type: mapper.providerId
      };
    });
    return mappersList;
  };
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: t4("common:deleteMappingTitle", {mapperId: selectedMapper?.id}),
    messageKey: "common:deleteMappingConfirm",
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        await adminClient.components.del({
          id: selectedMapper.id
        });
        refresh();
        addAlert(t4("common:mappingDeletedSuccess"), AlertVariant.success);
        setSelectedMapper(void 0);
      } catch (error2) {
        addError("common:mappingDeletedError", error2);
      }
    }
  });
  const getUrl = (url2) => {
    if (url2.indexOf("/mappers") === -1) {
      return `${url2}/mappers`;
    }
    return `${url2}`;
  };
  const MapperLink = (mapper) => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Link, {
    to: `${getUrl(url)}/${mapper.id}`
  }, mapper.name));
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DeleteConfirm, null), /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    loader,
    ariaLabelKey: "ldapMappersList",
    searchPlaceholderKey: "common:searchForMapper",
    toolbarItem: /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      "data-testid": "add-mapper-btn",
      variant: "primary",
      onClick: () => history.push(`${url}/new`)
    }, t4("common:addMapper"))),
    actions: [
      {
        title: t4("common:delete"),
        onRowClick: (mapper) => {
          setSelectedMapper(mapper);
          toggleDeleteDialog();
        }
      }
    ],
    columns: [
      {
        name: "name",
        cellRenderer: MapperLink
      },
      {
        name: "type"
      }
    ],
    emptyState: /* @__PURE__ */ react.createElement(ListEmptyState, {
      message: t4("common:emptyMappers"),
      instructions: t4("common:emptyMappersInstructions"),
      primaryActionText: t4("common:emptyPrimaryAction"),
      onPrimaryAction: () => history.push(`${url}/new`)
    })
  }));
};

// build/user-federation/UserFederationLdapSettings.js
var LdapSettingsHeader = ({
  onChange,
  value,
  save,
  toggleDeleteDialog,
  toggleRemoveUsersDialog
}) => {
  const {t: t4} = useTranslation("user-federation");
  const {id: id3} = useParams();
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const [toggleDisableDialog, DisableConfirm] = useConfirmDialog({
    titleKey: "user-federation:userFedDisableConfirmTitle",
    messageKey: "user-federation:userFedDisableConfirm",
    continueButtonLabel: "common:disable",
    onConfirm: () => {
      onChange("false");
      save();
    }
  });
  const syncChangedUsers = async () => {
    try {
      if (id3) {
        const response = await adminClient.userStorageProvider.sync({
          id: id3,
          action: "triggerChangedUsersSync"
        });
        if (response.ignored) {
          addAlert(`${response.status}.`, AlertVariant.warning);
        } else {
          addAlert(t4("syncUsersSuccess") + `${response.added} users added, ${response.updated} users updated, ${response.removed} users removed, ${response.failed} users failed.`, AlertVariant.success);
        }
      }
    } catch (error2) {
      addError("user-federation:syncUsersError", error2);
    }
  };
  const syncAllUsers = async () => {
    try {
      if (id3) {
        const response = await adminClient.userStorageProvider.sync({
          id: id3,
          action: "triggerFullSync"
        });
        if (response.ignored) {
          addAlert(`${response.status}.`, AlertVariant.warning);
        } else {
          addAlert(t4("syncUsersSuccess") + `${response.added} users added, ${response.updated} users updated, ${response.removed} users removed, ${response.failed} users failed.`, AlertVariant.success);
        }
      }
    } catch (error2) {
      addError("user-federation:syncUsersError", error2);
    }
  };
  const unlinkUsers = async () => {
    try {
      if (id3) {
        await adminClient.userStorageProvider.unlinkUsers({id: id3});
      }
      addAlert(t4("unlinkUsersSuccess"), AlertVariant.success);
    } catch (error2) {
      addError("user-federation:unlinkUsersError", error2);
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DisableConfirm, null), !id3 ? /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: t4("addOneLdap")
  }) : /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: "LDAP",
    dropdownItems: [
      /* @__PURE__ */ react.createElement(DropdownItem, {
        key: "sync",
        onClick: syncChangedUsers
      }, t4("syncChangedUsers")),
      /* @__PURE__ */ react.createElement(DropdownItem, {
        key: "syncall",
        onClick: syncAllUsers
      }, t4("syncAllUsers")),
      /* @__PURE__ */ react.createElement(DropdownItem, {
        key: "unlink",
        onClick: unlinkUsers
      }, t4("unlinkUsers")),
      /* @__PURE__ */ react.createElement(DropdownItem, {
        key: "remove",
        onClick: toggleRemoveUsersDialog
      }, t4("removeImported")),
      /* @__PURE__ */ react.createElement(DropdownSeparator, {
        key: "separator"
      }),
      /* @__PURE__ */ react.createElement(DropdownItem, {
        key: "delete",
        onClick: toggleDeleteDialog,
        "data-testid": "delete-ldap-cmd"
      }, t4("deleteProvider"))
    ],
    isEnabled: value === "true",
    onToggle: (value2) => {
      if (!value2) {
        toggleDisableDialog();
      } else {
        onChange("" + value2);
        save();
      }
    }
  }));
};
var UserFederationLdapSettings = () => {
  const {t: t4} = useTranslation("user-federation");
  const form2 = useForm({mode: "onChange"});
  const history = useHistory();
  const adminClient = useAdminClient();
  const {realm: realm2} = useRealm();
  const {id: id3} = useParams();
  const {addAlert, addError} = useAlerts();
  useFetch(async () => {
    if (id3) {
      return await adminClient.components.findOne({id: id3});
    }
    return void 0;
  }, (fetchedComponent) => {
    if (fetchedComponent) {
      setupForm(fetchedComponent);
    }
  }, []);
  const setupForm = (component) => {
    Object.entries(component).map((entry) => {
      if (entry[0] === "config") {
        form2.setValue("config.periodicChangedUsersSync", entry[1].changedSyncPeriod[0] !== "-1");
        form2.setValue("config.periodicFullSync", entry[1].fullSyncPeriod[0] !== "-1");
        convertToFormValues(entry[1], "config", form2.setValue);
      }
      form2.setValue(entry[0], entry[1]);
    });
  };
  const removeImportedUsers = async () => {
    try {
      if (id3) {
        await adminClient.userStorageProvider.removeImportedUsers({id: id3});
      }
      addAlert(t4("removeImportedUsersSuccess"), AlertVariant.success);
    } catch (error2) {
      addError("user-federation:removeImportedUsersError", error2);
    }
  };
  const save = async (component) => {
    if (component?.config?.periodicChangedUsersSync !== null) {
      if (component?.config?.periodicChangedUsersSync === false) {
        component.config.changedSyncPeriod = ["-1"];
      }
      delete component?.config?.periodicChangedUsersSync;
    }
    if (component?.config?.periodicFullSync !== null) {
      if (component?.config?.periodicFullSync === false) {
        component.config.fullSyncPeriod = ["-1"];
      }
      delete component?.config?.periodicFullSync;
    }
    try {
      if (!id3) {
        await adminClient.components.create(component);
        history.push(`/${realm2}/user-federation`);
      } else {
        await adminClient.components.update({id: id3}, component);
      }
      addAlert(t4(id3 ? "saveSuccess" : "createSuccess"), AlertVariant.success);
    } catch (error2) {
      addError(`user-federation:${id3 ? "saveError" : "createError"}`, error2);
    }
  };
  const [toggleRemoveUsersDialog, RemoveUsersConfirm] = useConfirmDialog({
    titleKey: t4("removeImportedUsers"),
    messageKey: t4("removeImportedUsersMessage"),
    continueButtonLabel: "common:remove",
    onConfirm: async () => {
      try {
        removeImportedUsers();
        addAlert(t4("removeImportedUsersSuccess"), AlertVariant.success);
      } catch (error2) {
        addError("user-federation:removeImportedUsersError", error2);
      }
    }
  });
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: "user-federation:userFedDeleteConfirmTitle",
    messageKey: "user-federation:userFedDeleteConfirm",
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        await adminClient.components.del({id: id3});
        addAlert(t4("userFedDeletedSuccess"), AlertVariant.success);
        history.replace(`/${realm2}/user-federation`);
      } catch (error2) {
        addError("user-federation:userFedDeleteError", error2);
      }
    }
  });
  const addLdapFormContent = () => {
    return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ScrollForm, {
      sections: [
        t4("generalOptions"),
        t4("connectionAndAuthenticationSettings"),
        t4("ldapSearchingAndUpdatingSettings"),
        t4("synchronizationSettings"),
        t4("kerberosIntegration"),
        t4("cacheSettings"),
        t4("advancedSettings")
      ]
    }, /* @__PURE__ */ react.createElement(LdapSettingsGeneral, {
      form: form2
    }), /* @__PURE__ */ react.createElement(LdapSettingsConnection, {
      form: form2
    }), /* @__PURE__ */ react.createElement(LdapSettingsSearching, {
      form: form2
    }), /* @__PURE__ */ react.createElement(LdapSettingsSynchronization, {
      form: form2
    }), /* @__PURE__ */ react.createElement(LdapSettingsKerberosIntegration, {
      form: form2
    }), /* @__PURE__ */ react.createElement(SettingsCache, {
      form: form2
    }), /* @__PURE__ */ react.createElement(LdapSettingsAdvanced, {
      form: form2
    })), /* @__PURE__ */ react.createElement(Form, {
      onSubmit: form2.handleSubmit(save)
    }, /* @__PURE__ */ react.createElement(ActionGroup, {
      className: "keycloak__form_actions"
    }, /* @__PURE__ */ react.createElement(Button, {
      isDisabled: !form2.formState.isDirty,
      variant: "primary",
      type: "submit",
      "data-testid": "ldap-save"
    }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
      variant: "link",
      onClick: () => history.push(`/${realm2}/user-federation`),
      "data-testid": "ldap-cancel"
    }, t4("common:cancel")))));
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DeleteConfirm, null), /* @__PURE__ */ react.createElement(RemoveUsersConfirm, null), /* @__PURE__ */ react.createElement(Controller, {
    name: "config.enabled[0]",
    defaultValue: ["true"][0],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(LdapSettingsHeader, {
      value,
      save: () => save(form2.getValues()),
      onChange,
      toggleDeleteDialog,
      toggleRemoveUsersDialog
    })
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    isFilled: true
  }, id3 ? /* @__PURE__ */ react.createElement(KeycloakTabs, {
    isBox: true
  }, /* @__PURE__ */ react.createElement(Tab, {
    id: "settings",
    eventKey: "settings",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("common:settings"))
  }, addLdapFormContent()), /* @__PURE__ */ react.createElement(Tab, {
    id: "mappers",
    eventKey: "mappers",
    title: /* @__PURE__ */ react.createElement(TabTitleText, null, t4("common:mappers")),
    "data-testid": "ldap-mappers-tab"
  }, /* @__PURE__ */ react.createElement(LdapMapperList, null))) : addLdapFormContent()));
};

// build/user-federation/routes/NewLdapUserFederation.js
var NewLdapUserFederationRoute = {
  path: "/:realm/user-federation/ldap/new",
  component: UserFederationLdapSettings,
  breadcrumb: (t4) => t4("user-federation:addOneLdap"),
  access: "view-realm"
};

// build/components/keycloak-card/KeycloakCard.js
var KeycloakCard = ({
  id: id3,
  title: title3,
  dropdownItems,
  labelText,
  labelColor,
  footerText,
  providerId
}) => {
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const history = useHistory();
  const {url} = useRouteMatch();
  const onDropdownToggle = () => {
    setIsDropdownOpen(!isDropdownOpen);
  };
  const handleCardMenuClick = (e3) => {
    e3.stopPropagation();
  };
  const openSettings = () => {
    history.push(`${url}/${providerId}/${id3}`);
  };
  return /* @__PURE__ */ react.createElement(Card, {
    isSelectable: true,
    onClick: openSettings
  }, /* @__PURE__ */ react.createElement(CardHeader, null, /* @__PURE__ */ react.createElement(CardActions, null, dropdownItems && /* @__PURE__ */ react.createElement(Dropdown, {
    "data-testid": `${title3}-dropdown`,
    isPlain: true,
    position: "right",
    toggle: /* @__PURE__ */ react.createElement(KebabToggle, {
      onToggle: onDropdownToggle
    }),
    onClick: (e3) => handleCardMenuClick(e3),
    isOpen: isDropdownOpen,
    dropdownItems
  })), /* @__PURE__ */ react.createElement(CardTitle, {
    "data-testid": "keycloak-card-title"
  }, title3)), /* @__PURE__ */ react.createElement(CardBody, null), /* @__PURE__ */ react.createElement(CardFooter, null, /* @__PURE__ */ react.createElement(Flex, null, /* @__PURE__ */ react.createElement(FlexItem, {
    className: "keycloak--keycloak-card__footer"
  }, footerText && footerText), /* @__PURE__ */ react.createElement(FlexItem, null, labelText && /* @__PURE__ */ react.createElement(Label, {
    color: labelColor || "gray"
  }, labelText)))));
};

// build/user-federation/UserFederationSection.js
var UserFederationSection = () => {
  const [userFederations, setUserFederations] = useState();
  const {addAlert, addError} = useAlerts();
  const {t: t4} = useTranslation("user-federation");
  const {realm: realm2} = useRealm();
  const adminClient = useAdminClient();
  const [key, setKey] = useState(0);
  const refresh = () => setKey(new Date().getTime());
  const {url} = useRouteMatch();
  const history = useHistory();
  useFetch(() => {
    const testParams = {
      parentId: realm2,
      type: "org.keycloak.storage.UserStorageProvider"
    };
    return adminClient.components.find(testParams);
  }, (userFederations2) => {
    setUserFederations(userFederations2);
  }, [key]);
  const ufAddProviderDropdownItems = [
    /* @__PURE__ */ react.createElement(DropdownItem, {
      key: "itemLDAP",
      onClick: () => history.push(`${url}/ldap/new`)
    }, "LDAP"),
    /* @__PURE__ */ react.createElement(DropdownItem, {
      key: "itemKerberos",
      onClick: () => history.push(`${url}/kerberos/new`)
    }, "Kerberos")
  ];
  const learnMoreLinkProps = {
    title: t4("common:learnMore"),
    href: "https://www.keycloak.org/docs/latest/server_admin/index.html#_user-storage-federation"
  };
  let cards;
  const [currentCard, setCurrentCard] = useState("");
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: t4("userFedDeleteConfirmTitle"),
    messageKey: t4("userFedDeleteConfirm"),
    continueButtonLabel: "common:delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        await adminClient.components.del({id: currentCard});
        refresh();
        addAlert(t4("userFedDeletedSuccess"), AlertVariant.success);
      } catch (error2) {
        addError("user-federation:userFedDeleteError", error2);
      }
    }
  });
  const toggleDeleteForCard = (id3) => {
    setCurrentCard(id3);
    toggleDeleteDialog();
  };
  if (userFederations) {
    cards = userFederations.map((userFederation, index3) => {
      const ufCardDropdownItems = [
        /* @__PURE__ */ react.createElement(DropdownItem, {
          key: `${index3}-cardDelete`,
          onClick: () => {
            toggleDeleteForCard(userFederation.id);
          },
          "data-testid": "card-delete"
        }, t4("common:delete"))
      ];
      return /* @__PURE__ */ react.createElement(GalleryItem, {
        key: index3,
        className: "keycloak-admin--user-federation__gallery-item"
      }, /* @__PURE__ */ react.createElement(KeycloakCard, {
        id: userFederation.id,
        dropdownItems: ufCardDropdownItems,
        providerId: userFederation.providerId,
        title: userFederation.name,
        footerText: userFederation.providerId === "ldap" ? "LDAP" : "Kerberos",
        labelText: userFederation.config["enabled"][0] !== "false" ? `${t4("common:enabled")}` : `${t4("common:disabled")}`,
        labelColor: userFederation.config["enabled"][0] !== "false" ? "blue" : "gray"
      }));
    });
  }
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: "userFederation",
    subKey: "user-federation:userFederationExplanation",
    subKeyLinkProps: learnMoreLinkProps,
    ...userFederations && userFederations.length > 0 ? {
      lowerDropdownItems: ufAddProviderDropdownItems,
      lowerDropdownMenuTitle: "user-federation:addNewProvider"
    } : {}
  }), /* @__PURE__ */ react.createElement(PageSection, null, userFederations && userFederations.length > 0 ? /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DeleteConfirm, null), /* @__PURE__ */ react.createElement(Gallery, {
    hasGutter: true
  }, cards)) : /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(TextContent, null, /* @__PURE__ */ react.createElement(Text, {
    component: TextVariants.p
  }, t4("getStarted"))), /* @__PURE__ */ react.createElement(TextContent, null, /* @__PURE__ */ react.createElement(Text, {
    className: "pf-u-mt-lg",
    component: TextVariants.h2
  }, t4("providers"))), /* @__PURE__ */ react.createElement("hr", {
    className: "pf-u-mb-lg"
  }), /* @__PURE__ */ react.createElement(Gallery, {
    hasGutter: true
  }, /* @__PURE__ */ react.createElement(Card, {
    className: "keycloak-empty-state-card",
    isHoverable: true,
    onClick: () => history.push(`${url}/kerberos/new`),
    "data-testid": "kerberos-card"
  }, /* @__PURE__ */ react.createElement(CardTitle, null, /* @__PURE__ */ react.createElement(Split, {
    hasGutter: true
  }, /* @__PURE__ */ react.createElement(SplitItem, null, /* @__PURE__ */ react.createElement(DatabaseIcon, {
    size: "lg"
  })), /* @__PURE__ */ react.createElement(SplitItem, {
    isFilled: true
  }, t4("addKerberos"))))), /* @__PURE__ */ react.createElement(Card, {
    className: "keycloak-empty-state-card",
    isHoverable: true,
    onClick: () => history.push(`${url}/ldap/new`),
    "data-testid": "ldap-card"
  }, /* @__PURE__ */ react.createElement(CardTitle, null, /* @__PURE__ */ react.createElement(Split, {
    hasGutter: true
  }, /* @__PURE__ */ react.createElement(SplitItem, null, /* @__PURE__ */ react.createElement(DatabaseIcon, {
    size: "lg"
  })), /* @__PURE__ */ react.createElement(SplitItem, {
    isFilled: true
  }, t4("addLdap")))))))));
};

// build/user-federation/routes/UserFederation.js
var UserFederationRoute = {
  path: "/:realm/user-federation",
  component: UserFederationSection,
  breadcrumb: (t4) => t4("userFederation"),
  access: "view-realm"
};

// build/user-federation/routes/UserFederationKerberos.js
var UserFederationKerberosRoute = {
  path: "/:realm/user-federation/kerberos/:id",
  component: UserFederationKerberosSettings,
  breadcrumb: (t4) => t4("common:settings"),
  access: "view-realm"
};

// build/user-federation/routes/UserFederationLdap.js
var UserFederationLdapRoute = {
  path: "/:realm/user-federation/ldap/:id/:tab?",
  component: UserFederationLdapSettings,
  breadcrumb: (t4) => t4("common:settings"),
  access: "view-realm"
};

// build/user-federation/ldap/mappers/LdapMapperUserAttribute.js
var LdapMapperUserAttribute = ({
  form: form2,
  mapperType
}) => {
  const {t: t4} = useTranslation("user-federation");
  const helpText = useTranslation("user-federation-help").t;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("userModelAttribute"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("userModelAttributeHelp"),
      forLabel: t4("userModelAttribute"),
      forID: "kc-user-model-attribute"
    }),
    fieldId: "kc-user-model-attribute",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-user-model-attribute",
    "data-testid": "mapper-userModelAttribute-fld",
    name: "config.user-model-attribute[0]",
    ref: form2.register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("ldapAttribute"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("ldapAttributeHelp"),
      forLabel: t4("ldapAttribute"),
      forID: "kc-ldap-attribute"
    }),
    fieldId: "kc-ldap-attribute",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-ldap-attribute",
    "data-testid": "mapper-ldapAttribute-fld",
    name: "config.ldap-attribute[0]",
    ref: form2.register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("readOnly"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("readOnlyHelp"),
      forLabel: t4("readOnly"),
      forID: "kc-read-only"
    }),
    fieldId: "kc-read-only",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.read-only",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-read-only",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("alwaysReadValueFromLdap"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("alwaysReadValueFromLdapHelp"),
      forLabel: t4("alwaysReadValueFromLdap"),
      forID: "kc-always-read-value"
    }),
    fieldId: "kc-always-read-value",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.always-read-value-from-ldap",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-always-read-value",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("isMandatoryInLdap"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("isMandatoryInLdapHelp"),
      forLabel: t4("isMandatoryInLdap"),
      forID: "kc-is-mandatory"
    }),
    fieldId: "kc-is-mandatory",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.is-mandatory-in-ldap",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-is-mandatory",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("isBinaryAttribute"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("isBinaryAttributeHelp"),
      forLabel: t4("isBinaryAttribute"),
      forID: "kc-is-binary"
    }),
    fieldId: "kc-is-binary",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.is-binary-attribute",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-is-binary",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  })), mapperType === "certificate-ldap-mapper" ? /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("derFormatted"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("derFormattedHelp"),
      forLabel: t4("derFormatted"),
      forID: "kc-der-formatted"
    }),
    fieldId: "kc-der-formatted",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.is-der-formatted",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-der-formatted",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  }))) : /* @__PURE__ */ react.createElement(react.Fragment, null));
};

// build/user-federation/ldap/mappers/LdapMapperMsadUserAccount.js
var LdapMapperMsadUserAccount = ({
  form: form2
}) => {
  const {t: t4} = useTranslation("user-federation");
  const helpText = useTranslation("user-federation-help").t;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("passwordPolicyHintsEnabled"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("passwordPolicyHintsEnabledHelp"),
      forLabel: t4("passwordPolicyHintsEnabled"),
      forID: "kc-pw-policy-hints-enabled"
    }),
    fieldId: "kc-der-formatted",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.ldap-password-policy-hints-enabled",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-pw-policy-hints-enabled",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  })));
};

// build/user-federation/ldap/mappers/LdapMapperFullNameAttribute.js
var LdapMapperFullNameAttribute = ({
  form: form2
}) => {
  const {t: t4} = useTranslation("user-federation");
  const helpText = useTranslation("user-federation-help").t;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("ldapFullNameAttribute"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("ldapFullNameAttributeHelp"),
      forLabel: t4("ldapFullNameAttribute"),
      forID: "kc-full-name-attribute"
    }),
    fieldId: "kc-full-name-attribute",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-full-name-attribute",
    "data-testid": "mapper-fullNameAttribute-fld",
    name: "config.ldap-full-name-attribute[0]",
    ref: form2.register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("readOnly"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("readOnlyHelp"),
      forLabel: t4("readOnly"),
      forID: "kc-read-only"
    }),
    fieldId: "kc-read-only",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.read-only",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-read-only",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("writeOnly"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("writeOnlyHelp"),
      forLabel: t4("writeOnly"),
      forID: "kc-write-only"
    }),
    fieldId: "kc-read-only",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.write-only",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-write-only",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  })));
};

// build/user-federation/ldap/mappers/LdapMapperHardcodedLdapRole.js
var LdapMapperHardcodedLdapRole = ({
  form: form2
}) => {
  const {t: t4} = useTranslation("user-federation");
  const helpText = useTranslation("user-federation-help").t;
  const [showAssign, setShowAssign] = useState(false);
  const selectRoles = async (rows) => {
    if (rows[0].client) {
      form2.setValue("config.role[0]", `${rows[0].client.clientId}.${rows[0].role.name}`);
    } else {
      form2.setValue("config.role[0]", `${rows[0].role.name}`);
    }
  };
  return /* @__PURE__ */ react.createElement(react.Fragment, null, showAssign && /* @__PURE__ */ react.createElement(AddRoleMappingModal, {
    id: "",
    type: "user-fed",
    onAssign: selectRoles,
    isRadio: true,
    onClose: () => setShowAssign(false)
  }), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:role"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("roleHelp"),
      forLabel: t4("common:role"),
      forID: "kc-role"
    }),
    fieldId: "kc-role",
    isRequired: true
  }, /* @__PURE__ */ react.createElement("div", {
    className: "keycloak__user-federation__assign-role"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-role",
    "data-testid": "role",
    name: "config.role[0]",
    ref: form2.register({required: true}),
    validated: form2.errors.config && form2.errors.config.role ? ValidatedOptions.error : ValidatedOptions.default
  }), /* @__PURE__ */ react.createElement(Button, {
    className: "keycloak__user-federation__assign-role-btn",
    "data-testid": "selectRole",
    onClick: () => setShowAssign(true)
  }, t4("selectRole")))));
};

// build/user-federation/ldap/mappers/LdapMapperHardcodedLdapGroup.js
var LdapMapperHardcodedLdapGroup = ({
  form: form2
}) => {
  const {t: t4} = useTranslation("user-federation");
  const helpText = useTranslation("user-federation-help").t;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("group"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("groupHelp"),
      forLabel: t4("group"),
      forID: "kc-group"
    }),
    fieldId: "kc-group",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-group",
    "data-testid": "mapper-group-fld",
    name: "config.group[0]",
    ref: form2.register({required: true}),
    validated: form2.errors.config && form2.errors.config.group ? ValidatedOptions.error : ValidatedOptions.default
  })));
};

// build/user-federation/ldap/mappers/LdapMapperHardcodedLdapAttribute.js
var LdapMapperHardcodedLdapAttribute = ({
  form: form2
}) => {
  const {t: t4} = useTranslation("user-federation");
  const helpText = useTranslation("user-federation-help").t;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("ldapAttributeName"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("ldapAttributeNameHelp"),
      forLabel: t4("ldapAttributeName"),
      forID: "kc-ldap-attribute-name"
    }),
    fieldId: "kc-ldap-attribute-name",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-ldap-attribute-name",
    "data-testid": "mapper-ldapAttributeName-fld",
    name: "config.ldap-attribute-name[0]",
    ref: form2.register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("ldapAttributeValue"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("ldapAttributeValueHelp"),
      forLabel: t4("ldapAttributeValue"),
      forID: "kc-ldap-attribute-value"
    }),
    fieldId: "kc-ldap-attribute-value",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-ldap-attribute-value",
    "data-testid": "mapper-ldapAttributeValue-fld",
    name: "config.ldap-attribute-value[0]",
    ref: form2.register
  })));
};

// build/user-federation/ldap/mappers/LdapMapperHardcodedAttribute.js
var LdapMapperHardcodedAttribute = ({
  form: form2
}) => {
  const {t: t4} = useTranslation("user-federation");
  const helpText = useTranslation("user-federation-help").t;
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("userModelAttributeName"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("userModelAttributeNameHelp"),
      forLabel: t4("userModelAttributeName"),
      forID: "kc-user-model-attribute"
    }),
    fieldId: "kc-user-model-attribute",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-user-model-attribute",
    "data-testid": "mapper-userModelAttributeName-fld",
    name: "config.user-model-attribute[0]",
    ref: form2.register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("attributeValue"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("attributeValueHelp"),
      forLabel: t4("attributeValue"),
      forID: "kc-attribute-value"
    }),
    fieldId: "kc-attribute-value",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-attribute-value",
    "data-testid": "mapper-attributeValue-fld",
    name: "config.attribute-value[0]",
    ref: form2.register
  })));
};

// build/user-federation/ldap/mappers/LdapMapperRoleGroup.js
var LdapMapperRoleGroup = ({
  form: form2,
  type
}) => {
  const {t: t4} = useTranslation("user-federation");
  const helpText = useTranslation("user-federation-help").t;
  const adminClient = useAdminClient();
  const [isMbAttTypeDropdownOpen, setIsMbAttTypeDropdownOpen] = useState(false);
  const [isModeDropdownOpen, setIsModeDropdownOpen] = useState(false);
  const [isRetrieveStratDropdownOpen, setIsRetrieveStratDropdownOpen] = useState(false);
  const [isClientIdDropdownOpen, setIsClientIdDropdownOpen] = useState(false);
  const [clients2, setClients] = useState([]);
  let isRole = true;
  const groupMapper = "group-ldap-mapper";
  if (type === groupMapper) {
    isRole = false;
  }
  useFetch(async () => {
    const clients22 = await adminClient.clients.find();
    if (clients22) {
      setClients(clients22);
    }
    return clients22;
  }, (clients22) => setClients(clients22), []);
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: isRole ? t4("ldapRolesDn") : t4("ldapGroupsDn"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: isRole ? helpText("ldapRolesDnHelp") : helpText("ldapGroupsDnHelp"),
      forLabel: isRole ? t4("ldapRolesDN") : t4("ldapGroupsDN"),
      forID: "kc-ldap-dn"
    }),
    fieldId: "kc-ldap-dn",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-ldap-dn",
    "data-testid": "ldap-dn",
    name: isRole ? "config.roles-dn[0]" : "config.groups-dn[0]",
    ref: form2.register({required: true}),
    validated: isRole ? form2.errors.config && form2.errors.config["roles-dn"] ? ValidatedOptions.error : ValidatedOptions.default : form2.errors.config && form2.errors.config["groups-dn"] ? ValidatedOptions.error : ValidatedOptions.default
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: isRole ? t4("roleNameLdapAttribute") : t4("groupNameLdapAttribute"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: isRole ? helpText("roleNameLdapAttributeHelp") : helpText("groupNameLdapAttributeHelp"),
      forLabel: isRole ? t4("roleNameLdapAttribute") : t4("groupNameLdapAttribute"),
      forID: "kc-name-attribute"
    }),
    fieldId: "kc-name-attribute",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-name-attribute",
    "data-testid": "name-attribute",
    defaultValue: "cn",
    name: isRole ? "config.role-name-ldap-attribute[0]" : "config.group-name-ldap-attribute[0]",
    ref: form2.register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: isRole ? t4("roleObjectClasses") : t4("groupObjectClasses"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: isRole ? helpText("roleObjectClassesHelp") : helpText("groupObjectClassesHelp"),
      forLabel: isRole ? t4("roleObjectClasses") : t4("groupObjectClasses"),
      forID: "kc-object-classes"
    }),
    fieldId: "kc-object-classes",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-object-classes",
    "data-testid": "object-classes",
    defaultValue: "group",
    name: isRole ? "config.role-object-classes[0]" : "config.group-object-classes[0]",
    ref: form2.register
  })), !isRole && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("preserveGroupInheritance"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("preserveGroupInheritanceHelp"),
      forLabel: t4("preserveGroupInheritance"),
      forID: "kc-preserve-inheritance"
    }),
    fieldId: "kc-preserve-inheritance",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.preserve-group-inheritance",
    defaultValue: ["true"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-preserve-inheritance",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("ignoreMissingGroups"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("ignoreMissingGroupsHelp"),
      forLabel: t4("ignoreMissingGroups"),
      forID: "kc-ignore-missing"
    }),
    fieldId: "kc-ignore-missing",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.ignore-missing-groups",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-ignore-missing",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  }))), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("membershipLdapAttribute"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("membershipLdapAttributeHelp"),
      forLabel: t4("membershipLdapAttribute"),
      forID: "kc-membership-ldap-attribute"
    }),
    fieldId: "kc-membership-ldap-attribute",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    defaultValue: "member",
    id: "kc-membership-ldap-attribute",
    "data-testid": "membership-ldap-attribute",
    name: "config.membership-ldap-attribute[0]",
    ref: form2.register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("membershipAttributeType"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("membershipAttributeTypeHelp"),
      forLabel: t4("membershipAttributeType"),
      forID: "kc-membership-attribute-type"
    }),
    fieldId: "kc-membership-attribute-type"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.membership-attribute-type[0]",
    defaultValue: "DN",
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-membership-attribute-type",
      onToggle: () => setIsMbAttTypeDropdownOpen(!isMbAttTypeDropdownOpen),
      isOpen: isMbAttTypeDropdownOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setIsMbAttTypeDropdownOpen(false);
      },
      selections: value,
      variant: SelectVariant.single
    }, /* @__PURE__ */ react.createElement(SelectOption, {
      key: 0,
      value: "DN"
    }, "DN"), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 1,
      value: "UID"
    }, "UID"))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("membershipUserLdapAttribute"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("membershipUserLdapAttributeHelp"),
      forLabel: t4("membershipUserLdapAttribute"),
      forID: "kc-membership-user-ldap-attribute"
    }),
    fieldId: "kc-membership-user-ldap-attribute",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-membership-user-ldap-attribute",
    "data-testid": "membership-user-ldap-attribute",
    defaultValue: "cn",
    name: "config.membership-user-ldap-attribute[0]",
    ref: form2.register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("ldapFilter"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("ldapFilterHelp"),
      forLabel: t4("ldapFilter"),
      forID: "kc-ldap-filter"
    }),
    fieldId: "kc-ldap-filter"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-ldap-filter",
    "data-testid": "ldap-filter",
    name: isRole ? "config.roles-ldap-filter[0]" : "config.groups-ldap-filter[0]",
    ref: form2.register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("mode"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("modeHelp"),
      forLabel: t4("mode"),
      forID: "kc-mode"
    }),
    fieldId: "kc-mode"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.mode[0]",
    defaultValue: "READ_ONLY",
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-mode",
      onToggle: () => setIsModeDropdownOpen(!isModeDropdownOpen),
      isOpen: isModeDropdownOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setIsModeDropdownOpen(false);
      },
      selections: value,
      variant: SelectVariant.single
    }, /* @__PURE__ */ react.createElement(SelectOption, {
      key: 0,
      value: "READ_ONLY"
    }, "READ_ONLY"), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 1,
      value: "LDAP_ONLY"
    }, "LDAP_ONLY"), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 2,
      value: "IMPORT"
    }, "IMPORT"))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: isRole ? t4("userRolesRetrieveStrategy") : t4("userGroupsRetrieveStrategy"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: isRole ? helpText("userRolesRetrieveStrategyHelp") : helpText("userGroupsRetrieveStrategyHelp"),
      forLabel: isRole ? t4("userRolesRetrieveStrategy") : t4("userGroupsRetrieveStrategy"),
      forID: "kc-user-retrieve-strategy"
    }),
    fieldId: "kc-user-retrieve-strategy"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: isRole ? "config.user-roles-retrieve-strategy[0]" : "config.user-groups-retrieve-strategy[0]",
    defaultValue: "LOAD_ROLES_BY_MEMBER_ATTRIBUTE",
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-user-retrieve-strategy",
      onToggle: () => setIsRetrieveStratDropdownOpen(!isRetrieveStratDropdownOpen),
      isOpen: isRetrieveStratDropdownOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setIsRetrieveStratDropdownOpen(false);
      },
      selections: value,
      variant: SelectVariant.single
    }, /* @__PURE__ */ react.createElement(SelectOption, {
      key: 0,
      value: "LOAD_ROLES_BY_MEMBER_ATTRIBUTE"
    }, "LOAD_ROLES_BY_MEMBER_ATTRIBUTE"), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 1,
      value: "GET_ROLES_FROM_USER_MEMBEROF_ATTRIBUTE"
    }, "GET_ROLES_FROM_USER_MEMBEROF_ATTRIBUTE"), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 2,
      value: "LOAD_ROLES_BY_MEMBER_ATTRIBUTE_RECURSIVELY"
    }, "LOAD_ROLES_BY_MEMBER_ATTRIBUTE_RECURSIVELY"))
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("memberofLdapAttribute"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("memberofLdapAttributeHelp"),
      forLabel: t4("memberofLdapAttribute"),
      forID: "kc-member-of-attribute"
    }),
    fieldId: "kc-member-of-attribute",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-member-of-attribute",
    defaultValue: "memberOf",
    "data-testid": "member-of-attribute",
    name: "config.memberof-ldap-attribute[0]",
    ref: form2.register
  })), isRole && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("useRealmRolesMapping"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("useRealmRolesMappingHelp"),
      forLabel: t4("useRealmRolesMapping"),
      forID: "kc-use-realm-roles"
    }),
    fieldId: "kc-use-realm-roles",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.use-realm-roles-mapping",
    defaultValue: ["true"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-use-realm-roles",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:clientId"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("clientIdHelp"),
      forLabel: t4("common:clientId"),
      forID: "kc-client-id"
    }),
    fieldId: "kc-client-id"
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.client-id[0]",
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-client-id",
      onToggle: () => setIsClientIdDropdownOpen(!isClientIdDropdownOpen),
      isOpen: isClientIdDropdownOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setIsClientIdDropdownOpen(false);
      },
      selections: value,
      variant: SelectVariant.single
    }, clients2.map((client2) => /* @__PURE__ */ react.createElement(SelectOption, {
      key: client2.id,
      value: client2.id
    }, client2.clientId)))
  }))), !isRole && /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("mappedGroupAttributes"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("mappedGroupAttributesHelp"),
      forLabel: t4("mappedGroupAttributes"),
      forID: "kc-mapped-attributes"
    }),
    fieldId: "kc-mapped-attributes"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-mapped-attributes",
    "data-testid": "mapped-attributes",
    name: "config.mapped-group-attributes[0]",
    ref: form2.register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("dropNonexistingGroupsDuringSync"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("dropNonexistingGroupsDuringSyncHelp"),
      forLabel: t4("dropNonexistingGroupsDuringSync"),
      forID: "kc-drop-nonexisting"
    }),
    fieldId: "kc-drop-nonexisting",
    hasNoPaddingTop: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "config.drop-non-existing-groups-during-sync",
    defaultValue: ["false"],
    control: form2.control,
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Switch, {
      id: "kc-drop-nonexisting",
      isDisabled: false,
      onChange: (value2) => onChange([`${value2}`]),
      isChecked: value[0] === "true",
      label: t4("common:on"),
      labelOff: t4("common:off")
    })
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("groupsPath"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("groupsPathHelp"),
      forLabel: t4("groupsPath"),
      forID: "kc-path"
    }),
    fieldId: "kc-path",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isRequired: true,
    type: "text",
    id: "kc-path",
    "data-testid": "path",
    defaultValue: "/",
    name: "config.groups-path[0]",
    ref: form2.register({required: true}),
    validated: form2.errors.config && form2.errors.config["groups-path"] ? ValidatedOptions.error : ValidatedOptions.default
  }))));
};

// build/user-federation/ldap/mappers/LdapMapperDetails.js
var LdapMapperDetails = () => {
  const form2 = useForm();
  const [mapping, setMapping] = useState();
  const adminClient = useAdminClient();
  const {id: id3, mapperId} = useParams();
  const history = useHistory();
  const {realm: realm2} = useRealm();
  const {t: t4} = useTranslation("user-federation");
  const helpText = useTranslation("user-federation-help").t;
  const {addAlert, addError} = useAlerts();
  const [isMapperDropdownOpen, setIsMapperDropdownOpen] = useState(false);
  useEffect(() => {
    (async () => {
      if (mapperId !== "new") {
        if (mapperId) {
          const fetchedMapper = await adminClient.components.findOne({
            id: mapperId
          });
          if (fetchedMapper) {
            setMapping(fetchedMapper);
            setupForm(fetchedMapper);
          }
        }
      }
    })();
  }, []);
  const setupForm = (mapper) => {
    Object.entries(mapper).map((entry) => {
      if (entry[0] === "config") {
        convertToFormValues(entry[1], "config", form2.setValue);
      } else {
        form2.setValue(entry[0], entry[1]);
      }
    });
  };
  const save = async (mapper) => {
    let config2 = {};
    if (mapper.config !== void 0) {
      config2 = convertFormValuesToObject(mapper.config);
    }
    const map3 = {...mapper, config: config2};
    try {
      if (mapperId) {
        if (mapperId === "new") {
          await adminClient.components.create(map3);
          history.push(`/${realm2}/user-federation/ldap/${mapper.parentId}/mappers`);
        } else {
          await adminClient.components.update({id: mapperId}, map3);
        }
      }
      setupForm(map3);
      addAlert(t4(mapperId === "new" ? "common:mappingCreatedSuccess" : "common:mappingUpdatedSuccess"), AlertVariant.success);
    } catch (error2) {
      addError(`user-federation:${mapperId === "new" ? "common:mappingCreatedError" : "common:mappingUpdatedError"}`, error2);
    }
  };
  const mapperType = useWatch({
    control: form2.control,
    name: "providerId"
  });
  const isNew = mapperId === "new";
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: mapping ? mapping.name : t4("common:createNewMapper")
  }), /* @__PURE__ */ react.createElement(PageSection, {
    variant: "light",
    isFilled: true
  }, /* @__PURE__ */ react.createElement(FormAccess, {
    role: "manage-realm",
    isHorizontal: true
  }, !isNew && /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:id"),
    fieldId: "kc-ldap-mapper-id"
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isDisabled: true,
    type: "text",
    id: "kc-ldap-mapper-id",
    "data-testid": "ldap-mapper-id",
    name: "id",
    ref: form2.register
  })), /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:name"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("nameHelp"),
      forLabel: t4("common:name"),
      forID: "kc-ldap-mapper-name"
    }),
    fieldId: "kc-ldap-mapper-name",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isDisabled: !isNew,
    isRequired: true,
    type: "text",
    id: "kc-ldap-mapper-name",
    "data-testid": "ldap-mapper-name",
    name: "name",
    ref: form2.register({required: true}),
    validated: form2.errors.name ? ValidatedOptions.error : ValidatedOptions.default
  }), /* @__PURE__ */ react.createElement(TextInput, {
    hidden: true,
    defaultValue: isNew ? id3 : mapping ? mapping.parentId : "",
    type: "text",
    id: "kc-ldap-parentId",
    "data-testid": "ldap-mapper-parentId",
    name: "parentId",
    ref: form2.register
  }), /* @__PURE__ */ react.createElement(TextInput, {
    hidden: true,
    defaultValue: "org.keycloak.storage.ldap.mappers.LDAPStorageMapper",
    type: "text",
    id: "kc-ldap-provider-type",
    "data-testid": "ldap-mapper-provider-type",
    name: "providerType",
    ref: form2.register
  })), !isNew ? /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:mapperType"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("mapperTypeHelp"),
      forLabel: t4("common:mapperType"),
      forID: "kc-ldap-mapper-type"
    }),
    fieldId: "kc-ldap-mapper-type",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(TextInput, {
    isDisabled: !isNew,
    isRequired: true,
    type: "text",
    id: "kc-ldap-mapper-type",
    "data-testid": "ldap-mapper-type-fld",
    name: "providerId",
    ref: form2.register
  })) : /* @__PURE__ */ react.createElement(FormGroup, {
    label: t4("common:mapperType"),
    labelIcon: /* @__PURE__ */ react.createElement(HelpItem, {
      helpText: helpText("mapperTypeHelp"),
      forLabel: t4("common:mapperType"),
      forID: "kc-providerId"
    }),
    fieldId: "kc-providerId",
    isRequired: true
  }, /* @__PURE__ */ react.createElement(Controller, {
    name: "providerId",
    defaultValue: "",
    control: form2.control,
    "data-testid": "ldap-mapper-type-select",
    render: ({onChange, value}) => /* @__PURE__ */ react.createElement(Select, {
      toggleId: "kc-providerId",
      required: true,
      onToggle: () => setIsMapperDropdownOpen(!isMapperDropdownOpen),
      isOpen: isMapperDropdownOpen,
      onSelect: (_23, value2) => {
        onChange(value2);
        setIsMapperDropdownOpen(false);
      },
      selections: value,
      variant: SelectVariant.typeahead
    }, /* @__PURE__ */ react.createElement(SelectOption, {
      key: 0,
      value: "msad-user-account-control-mapper"
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 1,
      value: "msad-lds-user-account-control-mapper"
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 2,
      value: "group-ldap-mapper"
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 3,
      value: "user-attribute-ldap-mapper"
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 4,
      value: "role-ldap-mapper"
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 5,
      value: "hardcoded-attribute-mapper"
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 6,
      value: "hardcoded-ldap-role-mapper"
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 7,
      value: "certificate-ldap-mapper"
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 8,
      value: "full-name-ldap-mapper"
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 9,
      value: "hardcoded-ldap-group-mapper"
    }), /* @__PURE__ */ react.createElement(SelectOption, {
      key: 10,
      value: "hardcoded-ldap-attribute-mapper"
    }))
  })), mapping ? (mapping.providerId === "certificate-ldap-mapper" || mapping.providerId === "user-attribute-ldap-mapper") && /* @__PURE__ */ react.createElement(LdapMapperUserAttribute, {
    form: form2,
    mapperType: mapping?.providerId
  }) : "", mapping ? mapping.providerId === "msad-user-account-control-mapper" && /* @__PURE__ */ react.createElement(LdapMapperMsadUserAccount, {
    form: form2
  }) : "", mapping ? mapping.providerId === "full-name-ldap-mapper" && /* @__PURE__ */ react.createElement(LdapMapperFullNameAttribute, {
    form: form2
  }) : "", mapping ? mapping.providerId === "hardcoded-ldap-role-mapper" && /* @__PURE__ */ react.createElement(LdapMapperHardcodedLdapRole, {
    form: form2
  }) : "", mapping ? mapping.providerId === "hardcoded-ldap-group-mapper" && /* @__PURE__ */ react.createElement(LdapMapperHardcodedLdapGroup, {
    form: form2
  }) : "", mapping ? mapping.providerId === "hardcoded-ldap-attribute-mapper" && /* @__PURE__ */ react.createElement(LdapMapperHardcodedLdapAttribute, {
    form: form2
  }) : "", mapping ? mapping.providerId === "hardcoded-attribute-mapper" && /* @__PURE__ */ react.createElement(LdapMapperHardcodedAttribute, {
    form: form2
  }) : "", mapping ? (mapping.providerId === "role-ldap-mapper" || mapping.providerId === "group-ldap-mapper") && /* @__PURE__ */ react.createElement(LdapMapperRoleGroup, {
    form: form2,
    type: mapping.providerId
  }) : "", isNew && mapperType ? mapperType === "certificate-ldap-mapper" && /* @__PURE__ */ react.createElement(LdapMapperUserAttribute, {
    form: form2,
    mapperType
  }) : "", isNew && mapperType ? mapperType === "user-attribute-ldap-mapper" && /* @__PURE__ */ react.createElement(LdapMapperUserAttribute, {
    form: form2,
    mapperType
  }) : "", isNew && mapperType ? mapperType === "msad-user-account-control-mapper" && /* @__PURE__ */ react.createElement(LdapMapperMsadUserAccount, {
    form: form2
  }) : "", isNew && mapperType ? mapperType === "full-name-ldap-mapper" && /* @__PURE__ */ react.createElement(LdapMapperFullNameAttribute, {
    form: form2
  }) : "", isNew && mapperType ? mapperType === "hardcoded-ldap-role-mapper" && /* @__PURE__ */ react.createElement(LdapMapperHardcodedLdapRole, {
    form: form2
  }) : "", isNew && mapperType ? mapperType === "hardcoded-ldap-group-mapper" && /* @__PURE__ */ react.createElement(LdapMapperHardcodedLdapGroup, {
    form: form2
  }) : "", isNew && mapperType ? mapperType === "hardcoded-ldap-attribute-mapper" && /* @__PURE__ */ react.createElement(LdapMapperHardcodedLdapAttribute, {
    form: form2
  }) : "", isNew && mapperType ? mapperType === "hardcoded-attribute-mapper" && /* @__PURE__ */ react.createElement(LdapMapperHardcodedAttribute, {
    form: form2
  }) : "", isNew && mapperType ? mapperType === "role-ldap-mapper" && /* @__PURE__ */ react.createElement(LdapMapperRoleGroup, {
    form: form2,
    type: mapperType
  }) : "", isNew && mapperType ? mapperType === "group-ldap-mapper" && /* @__PURE__ */ react.createElement(LdapMapperRoleGroup, {
    form: form2,
    type: mapperType
  }) : ""), /* @__PURE__ */ react.createElement(Form, {
    onSubmit: form2.handleSubmit(() => save(form2.getValues()))
  }, /* @__PURE__ */ react.createElement(ActionGroup, null, /* @__PURE__ */ react.createElement(Button, {
    isDisabled: !form2.formState.isDirty,
    variant: "primary",
    type: "submit",
    "data-testid": "ldap-mapper-save"
  }, t4("common:save")), /* @__PURE__ */ react.createElement(Button, {
    variant: "link",
    onClick: () => isNew ? history.goBack() : history.push(`/${realm2}/user-federation/ldap/${mapping.parentId}/mappers`),
    "data-testid": "ldap-mapper-cancel"
  }, t4("common:cancel"))))));
};

// build/user-federation/routes/UserFederationLdapMapper.js
var UserFederationLdapMapperRoute = {
  path: "/:realm/user-federation/ldap/:id/:tab/:mapperId",
  component: LdapMapperDetails,
  breadcrumb: (t4) => t4("common:mappingDetails"),
  access: "view-realm"
};

// build/user-federation/routes/UserFederationsKerberos.js
var UserFederationsKerberosRoute = {
  path: "/:realm/user-federation/kerberos",
  component: UserFederationSection,
  access: "view-realm"
};

// build/user-federation/routes/UserFederationsLdap.js
var UserFederationsLdapRoute = {
  path: "/:realm/user-federation/ldap",
  component: UserFederationSection,
  access: "view-realm"
};

// build/user-federation/routes.js
var routes12 = [
  UserFederationRoute,
  UserFederationsKerberosRoute,
  UserFederationKerberosRoute,
  NewKerberosUserFederationRoute,
  UserFederationsLdapRoute,
  NewLdapUserFederationRoute,
  UserFederationLdapRoute,
  UserFederationLdapMapperRoute
];
var routes_default12 = routes12;

// build/user/routes/AddUser.js
var AddUserRoute = {
  path: "/:realm/users/add-user",
  component: UsersTabs,
  breadcrumb: (t4) => t4("users:createUser"),
  access: "manage-users"
};

// build/user/SearchUser.js
var SearchUser = ({onSearch}) => {
  const {t: t4} = useTranslation("users");
  const {register, handleSubmit} = useForm();
  const {url} = useRouteMatch();
  const history = useHistory();
  const goToCreate = () => history.push(`${url}/add-user`);
  return /* @__PURE__ */ react.createElement(EmptyState, null, /* @__PURE__ */ react.createElement(Title, {
    "data-testid": "search-users-title",
    headingLevel: "h4",
    size: "lg"
  }, t4("startBySearchingAUser")), /* @__PURE__ */ react.createElement(EmptyStateBody, null, /* @__PURE__ */ react.createElement(Form, {
    onSubmit: handleSubmit((form2) => onSearch(form2.search))
  }, /* @__PURE__ */ react.createElement(InputGroup, null, /* @__PURE__ */ react.createElement(TextInput, {
    type: "text",
    id: "kc-user-search",
    name: "search",
    ref: register()
  }), /* @__PURE__ */ react.createElement(Button, {
    variant: ButtonVariant.control,
    "aria-label": t4("common:search"),
    type: "submit"
  }, /* @__PURE__ */ react.createElement(SearchIcon, null))))), /* @__PURE__ */ react.createElement(Button, {
    "data-testid": "create-new-user",
    variant: "link",
    onClick: goToCreate
  }, t4("createNewUser")));
};

// build/user/UsersSection.js
var UsersSection = () => {
  const {t: t4} = useTranslation("users");
  const adminClient = useAdminClient();
  const {addAlert, addError} = useAlerts();
  const {realm: realmName} = useRealm();
  const history = useHistory();
  const {url} = useRouteMatch();
  const [listUsers, setListUsers] = useState(false);
  const [initialSearch, setInitialSearch] = useState("");
  const [selectedRows, setSelectedRows] = useState([]);
  const [search, setSearch] = useState("");
  const [key, setKey] = useState("");
  const refresh = () => setKey(`${new Date().getTime()}`);
  useFetch(() => {
    const testParams = {
      type: "org.keycloak.storage.UserStorageProvider"
    };
    return Promise.all([
      adminClient.components.find(testParams),
      adminClient.users.count()
    ]);
  }, (response) => {
    setListUsers(!(response[0] && response[0].length > 0 || response[1] > 100));
  }, []);
  const UserDetailLink = (user) => /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(Link, {
    key: user.username,
    to: toUser({realm: realmName, id: user.id, tab: "settings"})
  }, user.username));
  const loader = async (first, max2, search2) => {
    const params = {
      first,
      max: max2
    };
    const searchParam = search2 || initialSearch || "";
    if (searchParam) {
      params.search = searchParam;
      setSearch(searchParam);
    }
    if (!listUsers && !searchParam) {
      return [];
    }
    try {
      const users2 = await adminClient.users.find({...params});
      const realm2 = await adminClient.realms.findOne({realm: realmName});
      if (realm2?.bruteForceProtected) {
        const brutes = await Promise.all(users2.map((user) => adminClient.attackDetection.findOne({
          id: user.id
        })));
        for (let index3 = 0; index3 < users2.length; index3++) {
          const user = users2[index3];
          user.brute = brutes[index3];
        }
      }
      return users2;
    } catch (error2) {
      addError("users:noUsersFoundError", error2);
      return [];
    }
  };
  const [toggleDeleteDialog, DeleteConfirm] = useConfirmDialog({
    titleKey: "users:deleteConfirm",
    messageKey: t4("deleteConfirmDialog", {count: selectedRows.length}),
    continueButtonLabel: "delete",
    continueButtonVariant: ButtonVariant.danger,
    onConfirm: async () => {
      try {
        for (const user of selectedRows) {
          await adminClient.users.del({id: user.id});
        }
        setSelectedRows([]);
        refresh();
        addAlert(t4("userDeletedSuccess"), AlertVariant.success);
      } catch (error2) {
        addError("users:userDeletedError", error2);
      }
    }
  });
  const StatusRow = (user) => {
    return /* @__PURE__ */ react.createElement(react.Fragment, null, !user.enabled && /* @__PURE__ */ react.createElement(Label, {
      key: user.id,
      color: "red",
      icon: /* @__PURE__ */ react.createElement(InfoCircleIcon, null)
    }, t4("disabled")), user.brute?.disabled && /* @__PURE__ */ react.createElement(Label, {
      key: user.id,
      color: "orange",
      icon: /* @__PURE__ */ react.createElement(WarningTriangleIcon, null)
    }, t4("temporaryDisabled")), user.enabled && !user.brute?.disabled && "");
  };
  const ValidatedEmail = (user) => {
    return /* @__PURE__ */ react.createElement(react.Fragment, null, !user.emailVerified && /* @__PURE__ */ react.createElement(Tooltip, {
      key: `email-verified-${user.id}`,
      content: /* @__PURE__ */ react.createElement(react.Fragment, null, t4("notVerified"))
    }, /* @__PURE__ */ react.createElement(ExclamationCircleIcon, {
      className: "keycloak__user-section__email-verified"
    })), " ", emptyFormatter()(user.email));
  };
  const goToCreate = () => history.push(`${url}/add-user`);
  return /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(DeleteConfirm, null), /* @__PURE__ */ react.createElement(ViewHeader, {
    titleKey: "users:title"
  }), /* @__PURE__ */ react.createElement(PageSection, {
    "data-testid": "users-page",
    variant: "light",
    className: "pf-u-p-0"
  }, !listUsers && !initialSearch && /* @__PURE__ */ react.createElement(SearchUser, {
    onSearch: (search2) => {
      setInitialSearch(search2);
    }
  }), (listUsers || initialSearch) && /* @__PURE__ */ react.createElement(KeycloakDataTable, {
    key,
    loader,
    isPaginated: true,
    ariaLabelKey: "users:title",
    searchPlaceholderKey: "users:searchForUser",
    canSelectAll: true,
    onSelect: (rows) => setSelectedRows([...rows]),
    emptyState: !search ? /* @__PURE__ */ react.createElement(ListEmptyState, {
      message: t4("noUsersFound"),
      instructions: t4("emptyInstructions"),
      primaryActionText: t4("createNewUser"),
      onPrimaryAction: goToCreate
    }) : "",
    toolbarItem: /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      "data-testid": "add-user",
      onClick: goToCreate
    }, t4("addUser"))), /* @__PURE__ */ react.createElement(ToolbarItem, null, /* @__PURE__ */ react.createElement(Button, {
      variant: ButtonVariant.plain,
      onClick: toggleDeleteDialog
    }, t4("deleteUser")))),
    actions: [
      {
        title: t4("common:delete"),
        onRowClick: (user) => {
          setSelectedRows([user]);
          toggleDeleteDialog();
        }
      }
    ],
    columns: [
      {
        name: "username",
        displayKey: "users:username",
        cellRenderer: UserDetailLink
      },
      {
        name: "email",
        displayKey: "users:email",
        cellRenderer: ValidatedEmail
      },
      {
        name: "lastName",
        displayKey: "users:lastName",
        cellFormatters: [emptyFormatter()]
      },
      {
        name: "firstName",
        displayKey: "users:firstName",
        cellFormatters: [emptyFormatter()]
      },
      {
        name: "status",
        displayKey: "users:status",
        cellRenderer: StatusRow
      }
    ]
  })));
};

// build/user/routes/Users.js
var UsersRoute = {
  path: "/:realm/users",
  component: UsersSection,
  breadcrumb: (t4) => t4("users:title"),
  access: "query-users"
};

// build/user/routes.js
var routes13 = [UsersRoute, AddUserRoute, UserRoute];
var routes_default13 = routes13;

// build/route-config.js
var NotFoundRoute = {
  path: "*",
  component: PageNotFoundSection,
  access: "anyone"
};
var routes14 = [
  ...routes_default,
  ...routes_default3,
  ...routes_default2,
  ...routes_default5,
  ...routes_default7,
  ...routes_default8,
  ...routes_default10,
  ...routes_default9,
  ...routes_default11,
  ...routes_default12,
  ...routes_default13,
  ...routes_default4,
  ...routes_default6,
  NotFoundRoute
];

// build/PageNav.js
var PageNav = () => {
  const {t: t4} = useTranslation("common");
  const {hasAccess, hasSomeAccess} = useAccess();
  const {realm: realm2} = useRealm();
  const history = useHistory();
  const onSelect = (item) => {
    history.push(item.to);
    item.event.preventDefault();
  };
  const LeftNav = ({title: title3, path}) => {
    const route = routes14.find((route2) => route2.path.replace(/\/:.+?(\?|(?:(?!\/).)*|$)/g, "") === path);
    const accessAllowed = route && (route.access instanceof Array ? hasAccess(...route.access) : hasAccess(route.access));
    if (!accessAllowed) {
      return null;
    }
    const activeItem = history.location.pathname.substr(realm2.length + 1);
    return /* @__PURE__ */ react.createElement(NavItem, {
      id: "nav-item" + path.replace("/", "-"),
      to: `/${realm2}${path}`,
      isActive: path === activeItem || path !== "/" && activeItem.startsWith(path)
    }, t4(title3));
  };
  const showManage = hasSomeAccess("view-realm", "query-groups", "query-users", "query-clients", "view-events");
  const showConfigure = hasSomeAccess("view-realm", "query-clients", "view-identity-providers");
  const isOnAddRealm = !!useRouteMatch(AddRealmRoute.path);
  return /* @__PURE__ */ react.createElement(PageSidebar, {
    nav: /* @__PURE__ */ react.createElement(Nav, {
      onSelect
    }, /* @__PURE__ */ react.createElement(NavList, null, /* @__PURE__ */ react.createElement(NavItem, {
      className: "keycloak__page_nav__nav_item__realm-selector"
    }, /* @__PURE__ */ react.createElement(RealmSelector, null))), !isOnAddRealm && /* @__PURE__ */ react.createElement(NavGroup, {
      title: ""
    }, /* @__PURE__ */ react.createElement(LeftNav, {
      title: "home",
      path: "/"
    })), showManage && !isOnAddRealm && /* @__PURE__ */ react.createElement(NavGroup, {
      title: t4("manage")
    }, /* @__PURE__ */ react.createElement(LeftNav, {
      title: "clients",
      path: "/clients"
    }), /* @__PURE__ */ react.createElement(LeftNav, {
      title: "clientScopes",
      path: "/client-scopes"
    }), /* @__PURE__ */ react.createElement(LeftNav, {
      title: "realmRoles",
      path: "/roles"
    }), /* @__PURE__ */ react.createElement(LeftNav, {
      title: "users",
      path: "/users"
    }), /* @__PURE__ */ react.createElement(LeftNav, {
      title: "groups",
      path: "/groups"
    }), /* @__PURE__ */ react.createElement(LeftNav, {
      title: "sessions",
      path: "/sessions"
    }), /* @__PURE__ */ react.createElement(LeftNav, {
      title: "events",
      path: "/events"
    })), showConfigure && !isOnAddRealm && /* @__PURE__ */ react.createElement(NavGroup, {
      title: t4("configure")
    }, /* @__PURE__ */ react.createElement(LeftNav, {
      title: "realmSettings",
      path: "/realm-settings"
    }), /* @__PURE__ */ react.createElement(LeftNav, {
      title: "authentication",
      path: "/authentication"
    }), /* @__PURE__ */ react.createElement(LeftNav, {
      title: "identityProviders",
      path: "/identity-providers"
    }), /* @__PURE__ */ react.createElement(LeftNav, {
      title: "userFederation",
      path: "/user-federation"
    })))
  });
};

// build/_snowpack/pkg/use-react-router-breadcrumbs.js
var arrayWithoutHoles = createCommonjsModule(function(module2) {
  function _arrayWithoutHoles2(arr) {
    if (Array.isArray(arr))
      return arrayLikeToArray(arr);
  }
  module2.exports = _arrayWithoutHoles2;
  module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
});
var iterableToArray = createCommonjsModule(function(module2) {
  function _iterableToArray2(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
      return Array.from(iter);
  }
  module2.exports = _iterableToArray2;
  module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
});
var nonIterableSpread = createCommonjsModule(function(module2) {
  function _nonIterableSpread2() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  module2.exports = _nonIterableSpread2;
  module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
});
var toConsumableArray = createCommonjsModule(function(module2) {
  function _toConsumableArray4(arr) {
    return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
  }
  module2.exports = _toConsumableArray4;
  module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
});
var _toConsumableArray3 = /* @__PURE__ */ getDefaultExportFromCjs(toConsumableArray);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __rest3(s2, e3) {
  var t4 = {};
  for (var p3 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p3) && e3.indexOf(p3) < 0)
      t4[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s2); i3 < p3.length; i3++) {
      if (e3.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i3]))
        t4[p3[i3]] = s2[p3[i3]];
    }
  return t4;
}
var DEFAULT_MATCH_OPTIONS = {
  exact: true
};
var NO_BREADCRUMB = "NO_BREADCRUMB";
var humanize = function humanize2(str) {
  return str.replace(/^[\s_]+|[\s_]+$/g, "").replace(/[_\s]+/g, " ").replace(/^[a-z]/, function(m3) {
    return m3.toUpperCase();
  });
};
var render2 = function render3(_ref) {
  var Breadcrumb2 = _ref.breadcrumb, match = _ref.match, location2 = _ref.location, props = _ref.props;
  var componentProps = Object.assign({
    match,
    location: location2,
    key: match.url
  }, props || {});
  return Object.assign(Object.assign({}, componentProps), {
    breadcrumb: typeof Breadcrumb2 === "string" ? /* @__PURE__ */ react.createElement("span", {
      key: componentProps.key
    }, Breadcrumb2) : /* @__PURE__ */ react.createElement(Breadcrumb2, Object.assign({}, componentProps))
  });
};
var getDefaultBreadcrumb = function getDefaultBreadcrumb2(_ref2) {
  var currentSection = _ref2.currentSection, location2 = _ref2.location, pathSection = _ref2.pathSection;
  var match = matchPath(pathSection, Object.assign(Object.assign({}, DEFAULT_MATCH_OPTIONS), {
    path: pathSection
  })) || {
    url: "not-found"
  };
  return render2({
    breadcrumb: humanize(currentSection),
    match,
    location: location2
  });
};
var getBreadcrumbMatch = function getBreadcrumbMatch2(_ref3) {
  var currentSection = _ref3.currentSection, disableDefaults = _ref3.disableDefaults, excludePaths = _ref3.excludePaths, location2 = _ref3.location, pathSection = _ref3.pathSection, routes15 = _ref3.routes;
  var breadcrumb2;
  var getIsPathExcluded = function getIsPathExcluded2(path) {
    return matchPath(pathSection, {
      path,
      exact: true,
      strict: false
    }) != null;
  };
  if (excludePaths && excludePaths.some(getIsPathExcluded)) {
    return NO_BREADCRUMB;
  }
  routes15.some(function(_a) {
    var userProvidedBreadcrumb = _a.breadcrumb, matchOptions = _a.matchOptions, path = _a.path, rest = __rest3(_a, ["breadcrumb", "matchOptions", "path"]);
    if (!path) {
      throw new Error("useBreadcrumbs: `path` must be provided in every route object");
    }
    var match = matchPath(pathSection, Object.assign(Object.assign({}, matchOptions || DEFAULT_MATCH_OPTIONS), {
      path
    }));
    if (match && userProvidedBreadcrumb === null || !match && matchOptions) {
      breadcrumb2 = NO_BREADCRUMB;
      return true;
    }
    if (match) {
      if (!userProvidedBreadcrumb && disableDefaults) {
        breadcrumb2 = NO_BREADCRUMB;
        return true;
      }
      breadcrumb2 = render2(Object.assign({
        breadcrumb: userProvidedBreadcrumb || humanize(currentSection),
        match,
        location: location2
      }, rest));
      return true;
    }
    return false;
  });
  if (breadcrumb2) {
    return breadcrumb2;
  }
  if (disableDefaults) {
    return NO_BREADCRUMB;
  }
  return getDefaultBreadcrumb({
    pathSection,
    currentSection: pathSection === "/" ? "Home" : currentSection,
    location: location2
  });
};
var getBreadcrumbs = function getBreadcrumbs2(_ref4) {
  var routes15 = _ref4.routes, location2 = _ref4.location, _ref4$options = _ref4.options, options = _ref4$options === void 0 ? {} : _ref4$options;
  var matches2 = [];
  var pathname = location2.pathname;
  pathname.split("?")[0].split("/").reduce(function(previousSection, currentSection, index3) {
    var pathSection = !currentSection ? "/" : "".concat(previousSection, "/").concat(currentSection);
    if (pathSection === "/" && index3 !== 0) {
      return "";
    }
    var breadcrumb2 = getBreadcrumbMatch(Object.assign({
      currentSection,
      location: location2,
      pathSection,
      routes: routes15
    }, options));
    if (breadcrumb2 !== NO_BREADCRUMB) {
      matches2.push(breadcrumb2);
    }
    return pathSection === "/" ? "" : pathSection;
  }, "");
  return matches2;
};
var flattenRoutes = function flattenRoutes2(routes15) {
  return routes15.reduce(function(arr, route) {
    if (route.routes) {
      return arr.concat([route].concat(_toConsumableArray3(flattenRoutes2(route.routes))));
    }
    return arr.concat(route);
  }, []);
};
var useReactRouterBreadcrumbs = function useReactRouterBreadcrumbs2(routes15, options) {
  return getBreadcrumbs({
    routes: flattenRoutes(routes15 || []),
    location: useLocation(),
    options
  });
};
var use_react_router_breadcrumbs_default = useReactRouterBreadcrumbs;

// build/components/bread-crumb/GroupBreadCrumbs.js
var GroupBreadCrumbs = () => {
  const {t: t4} = useTranslation();
  const {clear, remove: remove3, subGroups} = useSubGroups();
  const {realm: realm2} = useRealm();
  const history = useHistory();
  const location2 = useLocation();
  useEffect(() => {
    return history.listen(({pathname}) => {
      if (pathname.indexOf("/groups") === -1 || pathname.endsWith("/groups")) {
        clear();
      }
    });
  }, [history]);
  return /* @__PURE__ */ react.createElement(react.Fragment, null, subGroups.length !== 0 && /* @__PURE__ */ react.createElement(Breadcrumb, null, /* @__PURE__ */ react.createElement(BreadcrumbItem, {
    key: "home"
  }, /* @__PURE__ */ react.createElement(Link, {
    to: `/${realm2}/groups`
  }, t4("groups"))), subGroups.map((group, i3) => /* @__PURE__ */ react.createElement(BreadcrumbItem, {
    key: i3,
    isActive: subGroups.length - 1 === i3
  }, subGroups.length - 1 !== i3 && /* @__PURE__ */ react.createElement(Link, {
    to: location2.pathname.substr(0, location2.pathname.indexOf(group.id) + group.id.length),
    onClick: () => remove3(group)
  }, group.name), subGroups.length - 1 === i3 && /* @__PURE__ */ react.createElement(react.Fragment, null, t4("groups:groupDetails"))))));
};

// build/components/bread-crumb/PageBreadCrumbs.js
var PageBreadCrumbs = () => {
  const {t: t4} = useTranslation();
  const {realm: realm2} = useRealm();
  const elementText = (crumb) => isValidElement(crumb.breadcrumb) && crumb.breadcrumb.props.children;
  const routesWithCrumbs = routes14.map((route) => ({
    ...route,
    breadcrumb: route.breadcrumb?.(t4)
  }));
  const crumbs = lodash.uniqBy(use_react_router_breadcrumbs_default(routesWithCrumbs, {
    disableDefaults: true,
    excludePaths: ["/", `/${realm2}`]
  }), elementText);
  return /* @__PURE__ */ react.createElement(react.Fragment, null, crumbs.length > 1 && /* @__PURE__ */ react.createElement(Breadcrumb, null, crumbs.map(({match, breadcrumb: crumb}, i3) => /* @__PURE__ */ react.createElement(BreadcrumbItem, {
    key: i3,
    isActive: crumbs.length - 1 === i3
  }, crumbs.length - 1 !== i3 && /* @__PURE__ */ react.createElement(Link, {
    to: match.url
  }, crumb), crumbs.length - 1 === i3 && /* @__PURE__ */ react.createElement(react.Fragment, null, crumb)))), /* @__PURE__ */ react.createElement(GroupBreadCrumbs, null));
};

// build/ForbiddenSection.js
var ForbiddenSection = () => {
  return /* @__PURE__ */ react.createElement(react.Fragment, null, "Forbidden");
};

// build/components/error/ErrorRenderer.js
var ErrorRenderer = ({error: error2, resetErrorBoundary}) => {
  const {t: t4} = useTranslation();
  return /* @__PURE__ */ react.createElement(PageSection, null, /* @__PURE__ */ react.createElement(Alert, {
    isInline: true,
    variant: AlertVariant.danger,
    title: error2.message,
    actionClose: /* @__PURE__ */ react.createElement(AlertActionCloseButton, {
      title: error2.message,
      onClose: resetErrorBoundary
    }),
    actionLinks: /* @__PURE__ */ react.createElement(react.Fragment, null, /* @__PURE__ */ react.createElement(AlertActionLink, {
      onClick: resetErrorBoundary
    }, t4("retry")))
  }));
};

// build/App.js
var mainPageContentId = "kc-main-content-page-container";
var AppContexts = ({
  children: children2,
  adminClient
}) => /* @__PURE__ */ react.createElement(HashRouter, null, /* @__PURE__ */ react.createElement(AdminClient.Provider, {
  value: adminClient
}, /* @__PURE__ */ react.createElement(WhoAmIContextProvider, null, /* @__PURE__ */ react.createElement(RealmContextProvider, null, /* @__PURE__ */ react.createElement(AccessContextProvider, null, /* @__PURE__ */ react.createElement(Help, null, /* @__PURE__ */ react.createElement(AlertProvider, null, /* @__PURE__ */ react.createElement(ServerInfoProvider, null, /* @__PURE__ */ react.createElement(SubGroups, null, children2)))))))));
var SecuredRoute = ({route}) => {
  const {hasAccess} = useAccess();
  const accessAllowed = route.access instanceof Array ? hasAccess(...route.access) : hasAccess(route.access);
  if (accessAllowed)
    return /* @__PURE__ */ react.createElement(route.component, null);
  return /* @__PURE__ */ react.createElement(ForbiddenSection, null);
};
var App = ({adminClient}) => {
  return /* @__PURE__ */ react.createElement(AppContexts, {
    adminClient
  }, /* @__PURE__ */ react.createElement(Page, {
    header: /* @__PURE__ */ react.createElement(Header, null),
    isManagedSidebar: true,
    sidebar: /* @__PURE__ */ react.createElement(PageNav, null),
    breadcrumb: /* @__PURE__ */ react.createElement(PageBreadCrumbs, null),
    mainContainerId: mainPageContentId
  }, /* @__PURE__ */ react.createElement(ErrorBoundary, {
    FallbackComponent: ErrorRenderer,
    onReset: () => window.location.reload()
  }, /* @__PURE__ */ react.createElement(Switch2, null, routes14.map((route, i3) => /* @__PURE__ */ react.createElement(Route, {
    exact: route.matchOptions?.exact ?? true,
    key: i3,
    path: route.path,
    component: () => /* @__PURE__ */ react.createElement(SecuredRoute, {
      route
    })
  }))))));
};

// build/context/auth/keycloak.js
var import_keycloak_admin = require_keycloak_admin();
async function keycloak_default() {
  const kcAdminClient = new import_keycloak_admin.default();
  try {
    await kcAdminClient.init({onLoad: "check-sso", pkceMethod: "S256"}, {
      url: environment_default.authUrl,
      realm: environment_default.loginRealm,
      clientId: environment_default.isRunningAsTheme ? "security-admin-console" : "security-admin-console-v2"
    });
    kcAdminClient.setConfig({realmName: environment_default.loginRealm});
    kcAdminClient.baseUrl = environment_default.authUrl;
  } catch (error2) {
    alert("failed to initialize keycloak");
  }
  return kcAdminClient;
}

// build/index.js
import.meta.env = env_exports;
console.info("supported languages", ...i18n_default.languages);
keycloak_default().then((adminClient) => {
  reactDom.render(/* @__PURE__ */ react.createElement(StrictMode, null, /* @__PURE__ */ react.createElement(App, {
    adminClient
  })), document.getElementById("app"));
});
if (void 0) {
  (void 0).accept();
}
//# sourceMappingURL=index.js.map
